// Vaulter GitHub Action - https://github.com/forattini-dev/vaulter
// Force silent logging to avoid pino-pretty transport errors in bundled action
process.env.S3DB_LOG_LEVEL = 'silent';
process.env.S3DB_LOG_FORMAT = 'json';

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// stub-native:node:sqlite
var require_node_sqlite = __commonJS({
  "stub-native:node:sqlite"(exports2, module2) {
    module2.exports = {};
  }
});

// node_modules/.pnpm/@smithy+types@4.12.0/node_modules/@smithy/types/dist-cjs/index.js
var require_dist_cjs = __commonJS({
  "node_modules/.pnpm/@smithy+types@4.12.0/node_modules/@smithy/types/dist-cjs/index.js"(exports2) {
    "use strict";
    exports2.HttpAuthLocation = void 0;
    (function(HttpAuthLocation) {
      HttpAuthLocation["HEADER"] = "header";
      HttpAuthLocation["QUERY"] = "query";
    })(exports2.HttpAuthLocation || (exports2.HttpAuthLocation = {}));
    exports2.HttpApiKeyAuthLocation = void 0;
    (function(HttpApiKeyAuthLocation2) {
      HttpApiKeyAuthLocation2["HEADER"] = "header";
      HttpApiKeyAuthLocation2["QUERY"] = "query";
    })(exports2.HttpApiKeyAuthLocation || (exports2.HttpApiKeyAuthLocation = {}));
    exports2.EndpointURLScheme = void 0;
    (function(EndpointURLScheme) {
      EndpointURLScheme["HTTP"] = "http";
      EndpointURLScheme["HTTPS"] = "https";
    })(exports2.EndpointURLScheme || (exports2.EndpointURLScheme = {}));
    exports2.AlgorithmId = void 0;
    (function(AlgorithmId) {
      AlgorithmId["MD5"] = "md5";
      AlgorithmId["CRC32"] = "crc32";
      AlgorithmId["CRC32C"] = "crc32c";
      AlgorithmId["SHA1"] = "sha1";
      AlgorithmId["SHA256"] = "sha256";
    })(exports2.AlgorithmId || (exports2.AlgorithmId = {}));
    var getChecksumConfiguration = (runtimeConfig) => {
      const checksumAlgorithms = [];
      if (runtimeConfig.sha256 !== void 0) {
        checksumAlgorithms.push({
          algorithmId: () => exports2.AlgorithmId.SHA256,
          checksumConstructor: () => runtimeConfig.sha256
        });
      }
      if (runtimeConfig.md5 != void 0) {
        checksumAlgorithms.push({
          algorithmId: () => exports2.AlgorithmId.MD5,
          checksumConstructor: () => runtimeConfig.md5
        });
      }
      return {
        addChecksumAlgorithm(algo) {
          checksumAlgorithms.push(algo);
        },
        checksumAlgorithms() {
          return checksumAlgorithms;
        }
      };
    };
    var resolveChecksumRuntimeConfig = (clientConfig) => {
      const runtimeConfig = {};
      clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
        runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
      });
      return runtimeConfig;
    };
    var getDefaultClientConfiguration = (runtimeConfig) => {
      return getChecksumConfiguration(runtimeConfig);
    };
    var resolveDefaultRuntimeConfig4 = (config) => {
      return resolveChecksumRuntimeConfig(config);
    };
    exports2.FieldPosition = void 0;
    (function(FieldPosition) {
      FieldPosition[FieldPosition["HEADER"] = 0] = "HEADER";
      FieldPosition[FieldPosition["TRAILER"] = 1] = "TRAILER";
    })(exports2.FieldPosition || (exports2.FieldPosition = {}));
    var SMITHY_CONTEXT_KEY2 = "__smithy_context";
    exports2.IniSectionType = void 0;
    (function(IniSectionType) {
      IniSectionType["PROFILE"] = "profile";
      IniSectionType["SSO_SESSION"] = "sso-session";
      IniSectionType["SERVICES"] = "services";
    })(exports2.IniSectionType || (exports2.IniSectionType = {}));
    exports2.RequestHandlerProtocol = void 0;
    (function(RequestHandlerProtocol) {
      RequestHandlerProtocol["HTTP_0_9"] = "http/0.9";
      RequestHandlerProtocol["HTTP_1_0"] = "http/1.0";
      RequestHandlerProtocol["TDS_8_0"] = "tds/8.0";
    })(exports2.RequestHandlerProtocol || (exports2.RequestHandlerProtocol = {}));
    exports2.SMITHY_CONTEXT_KEY = SMITHY_CONTEXT_KEY2;
    exports2.getDefaultClientConfiguration = getDefaultClientConfiguration;
    exports2.resolveDefaultRuntimeConfig = resolveDefaultRuntimeConfig4;
  }
});

// node_modules/.pnpm/@smithy+protocol-http@5.3.8/node_modules/@smithy/protocol-http/dist-cjs/index.js
var require_dist_cjs2 = __commonJS({
  "node_modules/.pnpm/@smithy+protocol-http@5.3.8/node_modules/@smithy/protocol-http/dist-cjs/index.js"(exports2) {
    "use strict";
    var types = require_dist_cjs();
    var getHttpHandlerExtensionConfiguration4 = (runtimeConfig) => {
      return {
        setHttpHandler(handler) {
          runtimeConfig.httpHandler = handler;
        },
        httpHandler() {
          return runtimeConfig.httpHandler;
        },
        updateHttpClientConfig(key, value) {
          runtimeConfig.httpHandler?.updateHttpClientConfig(key, value);
        },
        httpHandlerConfigs() {
          return runtimeConfig.httpHandler.httpHandlerConfigs();
        }
      };
    };
    var resolveHttpHandlerRuntimeConfig4 = (httpHandlerExtensionConfiguration) => {
      return {
        httpHandler: httpHandlerExtensionConfiguration.httpHandler()
      };
    };
    var Field = class {
      name;
      kind;
      values;
      constructor({ name, kind = types.FieldPosition.HEADER, values = [] }) {
        this.name = name;
        this.kind = kind;
        this.values = values;
      }
      add(value) {
        this.values.push(value);
      }
      set(values) {
        this.values = values;
      }
      remove(value) {
        this.values = this.values.filter((v4) => v4 !== value);
      }
      toString() {
        return this.values.map((v4) => v4.includes(",") || v4.includes(" ") ? `"${v4}"` : v4).join(", ");
      }
      get() {
        return this.values;
      }
    };
    var Fields = class {
      entries = {};
      encoding;
      constructor({ fields = [], encoding: encoding2 = "utf-8" }) {
        fields.forEach(this.setField.bind(this));
        this.encoding = encoding2;
      }
      setField(field) {
        this.entries[field.name.toLowerCase()] = field;
      }
      getField(name) {
        return this.entries[name.toLowerCase()];
      }
      removeField(name) {
        delete this.entries[name.toLowerCase()];
      }
      getByType(kind) {
        return Object.values(this.entries).filter((field) => field.kind === kind);
      }
    };
    var HttpRequest11 = class _HttpRequest {
      method;
      protocol;
      hostname;
      port;
      path;
      query;
      headers;
      username;
      password;
      fragment;
      body;
      constructor(options) {
        this.method = options.method || "GET";
        this.hostname = options.hostname || "localhost";
        this.port = options.port;
        this.query = options.query || {};
        this.headers = options.headers || {};
        this.body = options.body;
        this.protocol = options.protocol ? options.protocol.slice(-1) !== ":" ? `${options.protocol}:` : options.protocol : "https:";
        this.path = options.path ? options.path.charAt(0) !== "/" ? `/${options.path}` : options.path : "/";
        this.username = options.username;
        this.password = options.password;
        this.fragment = options.fragment;
      }
      static clone(request2) {
        const cloned = new _HttpRequest({
          ...request2,
          headers: { ...request2.headers }
        });
        if (cloned.query) {
          cloned.query = cloneQuery(cloned.query);
        }
        return cloned;
      }
      static isInstance(request2) {
        if (!request2) {
          return false;
        }
        const req = request2;
        return "method" in req && "protocol" in req && "hostname" in req && "path" in req && typeof req["query"] === "object" && typeof req["headers"] === "object";
      }
      clone() {
        return _HttpRequest.clone(this);
      }
    };
    function cloneQuery(query) {
      return Object.keys(query).reduce((carry, paramName) => {
        const param = query[paramName];
        return {
          ...carry,
          [paramName]: Array.isArray(param) ? [...param] : param
        };
      }, {});
    }
    var HttpResponse5 = class {
      statusCode;
      reason;
      headers;
      body;
      constructor(options) {
        this.statusCode = options.statusCode;
        this.reason = options.reason;
        this.headers = options.headers || {};
        this.body = options.body;
      }
      static isInstance(response2) {
        if (!response2)
          return false;
        const resp = response2;
        return typeof resp.statusCode === "number" && typeof resp.headers === "object";
      }
    };
    function isValidHostname(hostname) {
      const hostPattern = /^[a-z0-9][a-z0-9\.\-]*[a-z0-9]$/;
      return hostPattern.test(hostname);
    }
    exports2.Field = Field;
    exports2.Fields = Fields;
    exports2.HttpRequest = HttpRequest11;
    exports2.HttpResponse = HttpResponse5;
    exports2.getHttpHandlerExtensionConfiguration = getHttpHandlerExtensionConfiguration4;
    exports2.isValidHostname = isValidHostname;
    exports2.resolveHttpHandlerRuntimeConfig = resolveHttpHandlerRuntimeConfig4;
  }
});

// node_modules/.pnpm/@aws-sdk+middleware-expect-continue@3.969.0/node_modules/@aws-sdk/middleware-expect-continue/dist-cjs/index.js
var require_dist_cjs3 = __commonJS({
  "node_modules/.pnpm/@aws-sdk+middleware-expect-continue@3.969.0/node_modules/@aws-sdk/middleware-expect-continue/dist-cjs/index.js"(exports2) {
    "use strict";
    var protocolHttp = require_dist_cjs2();
    function addExpectContinueMiddleware(options) {
      return (next) => async (args) => {
        const { request: request2 } = args;
        if (options.expectContinueHeader !== false && protocolHttp.HttpRequest.isInstance(request2) && request2.body && options.runtime === "node" && options.requestHandler?.constructor?.name !== "FetchHttpHandler") {
          let sendHeader = true;
          if (typeof options.expectContinueHeader === "number") {
            try {
              const bodyLength = Number(request2.headers?.["content-length"]) ?? options.bodyLengthChecker?.(request2.body) ?? Infinity;
              sendHeader = bodyLength >= options.expectContinueHeader;
            } catch (e4) {
            }
          } else {
            sendHeader = !!options.expectContinueHeader;
          }
          if (sendHeader) {
            request2.headers.Expect = "100-continue";
          }
        }
        return next({
          ...args,
          request: request2
        });
      };
    }
    var addExpectContinueMiddlewareOptions = {
      step: "build",
      tags: ["SET_EXPECT_HEADER", "EXPECT_HEADER"],
      name: "addExpectContinueMiddleware",
      override: true
    };
    var getAddExpectContinuePlugin = (options) => ({
      applyToStack: (clientStack) => {
        clientStack.add(addExpectContinueMiddleware(options), addExpectContinueMiddlewareOptions);
      }
    });
    exports2.addExpectContinueMiddleware = addExpectContinueMiddleware;
    exports2.addExpectContinueMiddlewareOptions = addExpectContinueMiddlewareOptions;
    exports2.getAddExpectContinuePlugin = getAddExpectContinuePlugin;
  }
});

// node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/client/emitWarningIfUnsupportedVersion.js
var state, emitWarningIfUnsupportedVersion;
var init_emitWarningIfUnsupportedVersion = __esm({
  "node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/client/emitWarningIfUnsupportedVersion.js"() {
    state = {
      warningEmitted: false
    };
    emitWarningIfUnsupportedVersion = (version) => {
      if (version && !state.warningEmitted && parseInt(version.substring(1, version.indexOf("."))) < 20) {
        state.warningEmitted = true;
        process.emitWarning(`NodeDeprecationWarning: The AWS SDK for JavaScript (v3) will
no longer support Node.js ${version} in January 2026.

To continue receiving updates to AWS services, bug fixes, and security
updates please upgrade to a supported Node.js LTS version.

More information can be found at: https://a.co/c895JFp`);
      }
    };
  }
});

// node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/client/setCredentialFeature.js
function setCredentialFeature(credentials, feature, value) {
  if (!credentials.$source) {
    credentials.$source = {};
  }
  credentials.$source[feature] = value;
  return credentials;
}
var init_setCredentialFeature = __esm({
  "node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/client/setCredentialFeature.js"() {
  }
});

// node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/client/setFeature.js
function setFeature(context, feature, value) {
  if (!context.__aws_sdk_context) {
    context.__aws_sdk_context = {
      features: {}
    };
  } else if (!context.__aws_sdk_context.features) {
    context.__aws_sdk_context.features = {};
  }
  context.__aws_sdk_context.features[feature] = value;
}
var init_setFeature = __esm({
  "node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/client/setFeature.js"() {
  }
});

// node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/client/setTokenFeature.js
function setTokenFeature(token, feature, value) {
  if (!token.$source) {
    token.$source = {};
  }
  token.$source[feature] = value;
  return token;
}
var init_setTokenFeature = __esm({
  "node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/client/setTokenFeature.js"() {
  }
});

// node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/client/index.js
var client_exports = {};
__export(client_exports, {
  emitWarningIfUnsupportedVersion: () => emitWarningIfUnsupportedVersion,
  setCredentialFeature: () => setCredentialFeature,
  setFeature: () => setFeature,
  setTokenFeature: () => setTokenFeature,
  state: () => state
});
var init_client = __esm({
  "node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/client/index.js"() {
    init_emitWarningIfUnsupportedVersion();
    init_setCredentialFeature();
    init_setFeature();
    init_setTokenFeature();
  }
});

// node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/getDateHeader.js
var import_protocol_http, getDateHeader;
var init_getDateHeader = __esm({
  "node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/getDateHeader.js"() {
    import_protocol_http = __toESM(require_dist_cjs2());
    getDateHeader = (response2) => import_protocol_http.HttpResponse.isInstance(response2) ? response2.headers?.date ?? response2.headers?.Date : void 0;
  }
});

// node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/getSkewCorrectedDate.js
var getSkewCorrectedDate;
var init_getSkewCorrectedDate = __esm({
  "node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/getSkewCorrectedDate.js"() {
    getSkewCorrectedDate = (systemClockOffset) => new Date(Date.now() + systemClockOffset);
  }
});

// node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/isClockSkewed.js
var isClockSkewed;
var init_isClockSkewed = __esm({
  "node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/isClockSkewed.js"() {
    init_getSkewCorrectedDate();
    isClockSkewed = (clockTime, systemClockOffset) => Math.abs(getSkewCorrectedDate(systemClockOffset).getTime() - clockTime) >= 3e5;
  }
});

// node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/getUpdatedSystemClockOffset.js
var getUpdatedSystemClockOffset;
var init_getUpdatedSystemClockOffset = __esm({
  "node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/getUpdatedSystemClockOffset.js"() {
    init_isClockSkewed();
    getUpdatedSystemClockOffset = (clockTime, currentSystemClockOffset) => {
      const clockTimeInMs = Date.parse(clockTime);
      if (isClockSkewed(clockTimeInMs, currentSystemClockOffset)) {
        return clockTimeInMs - Date.now();
      }
      return currentSystemClockOffset;
    };
  }
});

// node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/index.js
var init_utils = __esm({
  "node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/index.js"() {
    init_getDateHeader();
    init_getSkewCorrectedDate();
    init_getUpdatedSystemClockOffset();
  }
});

// node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/AwsSdkSigV4Signer.js
var import_protocol_http2, throwSigningPropertyError, validateSigningProperties, AwsSdkSigV4Signer, AWSSDKSigV4Signer;
var init_AwsSdkSigV4Signer = __esm({
  "node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/AwsSdkSigV4Signer.js"() {
    import_protocol_http2 = __toESM(require_dist_cjs2());
    init_utils();
    throwSigningPropertyError = (name, property) => {
      if (!property) {
        throw new Error(`Property \`${name}\` is not resolved for AWS SDK SigV4Auth`);
      }
      return property;
    };
    validateSigningProperties = async (signingProperties) => {
      const context = throwSigningPropertyError("context", signingProperties.context);
      const config = throwSigningPropertyError("config", signingProperties.config);
      const authScheme = context.endpointV2?.properties?.authSchemes?.[0];
      const signerFunction = throwSigningPropertyError("signer", config.signer);
      const signer = await signerFunction(authScheme);
      const signingRegion = signingProperties?.signingRegion;
      const signingRegionSet = signingProperties?.signingRegionSet;
      const signingName = signingProperties?.signingName;
      return {
        config,
        signer,
        signingRegion,
        signingRegionSet,
        signingName
      };
    };
    AwsSdkSigV4Signer = class {
      async sign(httpRequest, identity2, signingProperties) {
        if (!import_protocol_http2.HttpRequest.isInstance(httpRequest)) {
          throw new Error("The request is not an instance of `HttpRequest` and cannot be signed");
        }
        const validatedProps = await validateSigningProperties(signingProperties);
        const { config, signer } = validatedProps;
        let { signingRegion, signingName } = validatedProps;
        const handlerExecutionContext = signingProperties.context;
        if (handlerExecutionContext?.authSchemes?.length ?? 0 > 1) {
          const [first, second] = handlerExecutionContext.authSchemes;
          if (first?.name === "sigv4a" && second?.name === "sigv4") {
            signingRegion = second?.signingRegion ?? signingRegion;
            signingName = second?.signingName ?? signingName;
          }
        }
        const signedRequest = await signer.sign(httpRequest, {
          signingDate: getSkewCorrectedDate(config.systemClockOffset),
          signingRegion,
          signingService: signingName
        });
        return signedRequest;
      }
      errorHandler(signingProperties) {
        return (error2) => {
          const serverTime = error2.ServerTime ?? getDateHeader(error2.$response);
          if (serverTime) {
            const config = throwSigningPropertyError("config", signingProperties.config);
            const initialSystemClockOffset = config.systemClockOffset;
            config.systemClockOffset = getUpdatedSystemClockOffset(serverTime, config.systemClockOffset);
            const clockSkewCorrected = config.systemClockOffset !== initialSystemClockOffset;
            if (clockSkewCorrected && error2.$metadata) {
              error2.$metadata.clockSkewCorrected = true;
            }
          }
          throw error2;
        };
      }
      successHandler(httpResponse, signingProperties) {
        const dateHeader = getDateHeader(httpResponse);
        if (dateHeader) {
          const config = throwSigningPropertyError("config", signingProperties.config);
          config.systemClockOffset = getUpdatedSystemClockOffset(dateHeader, config.systemClockOffset);
        }
      }
    };
    AWSSDKSigV4Signer = AwsSdkSigV4Signer;
  }
});

// node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/AwsSdkSigV4ASigner.js
var import_protocol_http3, AwsSdkSigV4ASigner;
var init_AwsSdkSigV4ASigner = __esm({
  "node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/AwsSdkSigV4ASigner.js"() {
    import_protocol_http3 = __toESM(require_dist_cjs2());
    init_utils();
    init_AwsSdkSigV4Signer();
    AwsSdkSigV4ASigner = class extends AwsSdkSigV4Signer {
      async sign(httpRequest, identity2, signingProperties) {
        if (!import_protocol_http3.HttpRequest.isInstance(httpRequest)) {
          throw new Error("The request is not an instance of `HttpRequest` and cannot be signed");
        }
        const { config, signer, signingRegion, signingRegionSet, signingName } = await validateSigningProperties(signingProperties);
        const configResolvedSigningRegionSet = await config.sigv4aSigningRegionSet?.();
        const multiRegionOverride = (configResolvedSigningRegionSet ?? signingRegionSet ?? [signingRegion]).join(",");
        const signedRequest = await signer.sign(httpRequest, {
          signingDate: getSkewCorrectedDate(config.systemClockOffset),
          signingRegion: multiRegionOverride,
          signingService: signingName
        });
        return signedRequest;
      }
    };
  }
});

// node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/getArrayForCommaSeparatedString.js
var getArrayForCommaSeparatedString;
var init_getArrayForCommaSeparatedString = __esm({
  "node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/getArrayForCommaSeparatedString.js"() {
    getArrayForCommaSeparatedString = (str) => typeof str === "string" && str.length > 0 ? str.split(",").map((item) => item.trim()) : [];
  }
});

// node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/getBearerTokenEnvKey.js
var getBearerTokenEnvKey;
var init_getBearerTokenEnvKey = __esm({
  "node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/getBearerTokenEnvKey.js"() {
    getBearerTokenEnvKey = (signingName) => `AWS_BEARER_TOKEN_${signingName.replace(/[\s-]/g, "_").toUpperCase()}`;
  }
});

// node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/NODE_AUTH_SCHEME_PREFERENCE_OPTIONS.js
var NODE_AUTH_SCHEME_PREFERENCE_ENV_KEY, NODE_AUTH_SCHEME_PREFERENCE_CONFIG_KEY, NODE_AUTH_SCHEME_PREFERENCE_OPTIONS;
var init_NODE_AUTH_SCHEME_PREFERENCE_OPTIONS = __esm({
  "node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/NODE_AUTH_SCHEME_PREFERENCE_OPTIONS.js"() {
    init_getArrayForCommaSeparatedString();
    init_getBearerTokenEnvKey();
    NODE_AUTH_SCHEME_PREFERENCE_ENV_KEY = "AWS_AUTH_SCHEME_PREFERENCE";
    NODE_AUTH_SCHEME_PREFERENCE_CONFIG_KEY = "auth_scheme_preference";
    NODE_AUTH_SCHEME_PREFERENCE_OPTIONS = {
      environmentVariableSelector: (env, options) => {
        if (options?.signingName) {
          const bearerTokenKey = getBearerTokenEnvKey(options.signingName);
          if (bearerTokenKey in env)
            return ["httpBearerAuth"];
        }
        if (!(NODE_AUTH_SCHEME_PREFERENCE_ENV_KEY in env))
          return void 0;
        return getArrayForCommaSeparatedString(env[NODE_AUTH_SCHEME_PREFERENCE_ENV_KEY]);
      },
      configFileSelector: (profile) => {
        if (!(NODE_AUTH_SCHEME_PREFERENCE_CONFIG_KEY in profile))
          return void 0;
        return getArrayForCommaSeparatedString(profile[NODE_AUTH_SCHEME_PREFERENCE_CONFIG_KEY]);
      },
      default: []
    };
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/getSmithyContext.js
var import_types, getSmithyContext;
var init_getSmithyContext = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/getSmithyContext.js"() {
    import_types = __toESM(require_dist_cjs());
    getSmithyContext = (context) => context[import_types.SMITHY_CONTEXT_KEY] || (context[import_types.SMITHY_CONTEXT_KEY] = {});
  }
});

// node_modules/.pnpm/@smithy+util-middleware@4.2.8/node_modules/@smithy/util-middleware/dist-cjs/index.js
var require_dist_cjs4 = __commonJS({
  "node_modules/.pnpm/@smithy+util-middleware@4.2.8/node_modules/@smithy/util-middleware/dist-cjs/index.js"(exports2) {
    "use strict";
    var types = require_dist_cjs();
    var getSmithyContext10 = (context) => context[types.SMITHY_CONTEXT_KEY] || (context[types.SMITHY_CONTEXT_KEY] = {});
    var normalizeProvider5 = (input) => {
      if (typeof input === "function")
        return input;
      const promisified = Promise.resolve(input);
      return () => promisified;
    };
    exports2.getSmithyContext = getSmithyContext10;
    exports2.normalizeProvider = normalizeProvider5;
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/resolveAuthOptions.js
var resolveAuthOptions;
var init_resolveAuthOptions = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/resolveAuthOptions.js"() {
    resolveAuthOptions = (candidateAuthOptions, authSchemePreference) => {
      if (!authSchemePreference || authSchemePreference.length === 0) {
        return candidateAuthOptions;
      }
      const preferredAuthOptions = [];
      for (const preferredSchemeName of authSchemePreference) {
        for (const candidateAuthOption of candidateAuthOptions) {
          const candidateAuthSchemeName = candidateAuthOption.schemeId.split("#")[1];
          if (candidateAuthSchemeName === preferredSchemeName) {
            preferredAuthOptions.push(candidateAuthOption);
          }
        }
      }
      for (const candidateAuthOption of candidateAuthOptions) {
        if (!preferredAuthOptions.find(({ schemeId }) => schemeId === candidateAuthOption.schemeId)) {
          preferredAuthOptions.push(candidateAuthOption);
        }
      }
      return preferredAuthOptions;
    };
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/httpAuthSchemeMiddleware.js
function convertHttpAuthSchemesToMap(httpAuthSchemes) {
  const map2 = /* @__PURE__ */ new Map();
  for (const scheme of httpAuthSchemes) {
    map2.set(scheme.schemeId, scheme);
  }
  return map2;
}
var import_util_middleware, httpAuthSchemeMiddleware;
var init_httpAuthSchemeMiddleware = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/httpAuthSchemeMiddleware.js"() {
    import_util_middleware = __toESM(require_dist_cjs4());
    init_resolveAuthOptions();
    httpAuthSchemeMiddleware = (config, mwOptions) => (next, context) => async (args) => {
      const options = config.httpAuthSchemeProvider(await mwOptions.httpAuthSchemeParametersProvider(config, context, args.input));
      const authSchemePreference = config.authSchemePreference ? await config.authSchemePreference() : [];
      const resolvedOptions = resolveAuthOptions(options, authSchemePreference);
      const authSchemes = convertHttpAuthSchemesToMap(config.httpAuthSchemes);
      const smithyContext = (0, import_util_middleware.getSmithyContext)(context);
      const failureReasons = [];
      for (const option of resolvedOptions) {
        const scheme = authSchemes.get(option.schemeId);
        if (!scheme) {
          failureReasons.push(`HttpAuthScheme \`${option.schemeId}\` was not enabled for this service.`);
          continue;
        }
        const identityProvider = scheme.identityProvider(await mwOptions.identityProviderConfigProvider(config));
        if (!identityProvider) {
          failureReasons.push(`HttpAuthScheme \`${option.schemeId}\` did not have an IdentityProvider configured.`);
          continue;
        }
        const { identityProperties = {}, signingProperties = {} } = option.propertiesExtractor?.(config, context) || {};
        option.identityProperties = Object.assign(option.identityProperties || {}, identityProperties);
        option.signingProperties = Object.assign(option.signingProperties || {}, signingProperties);
        smithyContext.selectedHttpAuthScheme = {
          httpAuthOption: option,
          identity: await identityProvider(option.identityProperties),
          signer: scheme.signer
        };
        break;
      }
      if (!smithyContext.selectedHttpAuthScheme) {
        throw new Error(failureReasons.join("\n"));
      }
      return next(args);
    };
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/getHttpAuthSchemeEndpointRuleSetPlugin.js
var httpAuthSchemeEndpointRuleSetMiddlewareOptions, getHttpAuthSchemeEndpointRuleSetPlugin;
var init_getHttpAuthSchemeEndpointRuleSetPlugin = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/getHttpAuthSchemeEndpointRuleSetPlugin.js"() {
    init_httpAuthSchemeMiddleware();
    httpAuthSchemeEndpointRuleSetMiddlewareOptions = {
      step: "serialize",
      tags: ["HTTP_AUTH_SCHEME"],
      name: "httpAuthSchemeMiddleware",
      override: true,
      relation: "before",
      toMiddleware: "endpointV2Middleware"
    };
    getHttpAuthSchemeEndpointRuleSetPlugin = (config, { httpAuthSchemeParametersProvider, identityProviderConfigProvider }) => ({
      applyToStack: (clientStack) => {
        clientStack.addRelativeTo(httpAuthSchemeMiddleware(config, {
          httpAuthSchemeParametersProvider,
          identityProviderConfigProvider
        }), httpAuthSchemeEndpointRuleSetMiddlewareOptions);
      }
    });
  }
});

// node_modules/.pnpm/@smithy+middleware-serde@4.2.9/node_modules/@smithy/middleware-serde/dist-cjs/index.js
var require_dist_cjs5 = __commonJS({
  "node_modules/.pnpm/@smithy+middleware-serde@4.2.9/node_modules/@smithy/middleware-serde/dist-cjs/index.js"(exports2) {
    "use strict";
    var protocolHttp = require_dist_cjs2();
    var deserializerMiddleware = (options, deserializer) => (next, context) => async (args) => {
      const { response: response2 } = await next(args);
      try {
        const parsed = await deserializer(response2, options);
        return {
          response: response2,
          output: parsed
        };
      } catch (error2) {
        Object.defineProperty(error2, "$response", {
          value: response2,
          enumerable: false,
          writable: false,
          configurable: false
        });
        if (!("$metadata" in error2)) {
          const hint = `Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.`;
          try {
            error2.message += "\n  " + hint;
          } catch (e4) {
            if (!context.logger || context.logger?.constructor?.name === "NoOpLogger") {
              console.warn(hint);
            } else {
              context.logger?.warn?.(hint);
            }
          }
          if (typeof error2.$responseBodyText !== "undefined") {
            if (error2.$response) {
              error2.$response.body = error2.$responseBodyText;
            }
          }
          try {
            if (protocolHttp.HttpResponse.isInstance(response2)) {
              const { headers: headers2 = {} } = response2;
              const headerEntries = Object.entries(headers2);
              error2.$metadata = {
                httpStatusCode: response2.statusCode,
                requestId: findHeader2(/^x-[\w-]+-request-?id$/, headerEntries),
                extendedRequestId: findHeader2(/^x-[\w-]+-id-2$/, headerEntries),
                cfId: findHeader2(/^x-[\w-]+-cf-id$/, headerEntries)
              };
            }
          } catch (e4) {
          }
        }
        throw error2;
      }
    };
    var findHeader2 = (pattern, headers2) => {
      return (headers2.find(([k4]) => {
        return k4.match(pattern);
      }) || [void 0, void 0])[1];
    };
    var serializerMiddleware = (options, serializer) => (next, context) => async (args) => {
      const endpointConfig = options;
      const endpoint = context.endpointV2?.url && endpointConfig.urlParser ? async () => endpointConfig.urlParser(context.endpointV2.url) : endpointConfig.endpoint;
      if (!endpoint) {
        throw new Error("No valid endpoint provider available.");
      }
      const request2 = await serializer(args.input, { ...options, endpoint });
      return next({
        ...args,
        request: request2
      });
    };
    var deserializerMiddlewareOption2 = {
      name: "deserializerMiddleware",
      step: "deserialize",
      tags: ["DESERIALIZER"],
      override: true
    };
    var serializerMiddlewareOption3 = {
      name: "serializerMiddleware",
      step: "serialize",
      tags: ["SERIALIZER"],
      override: true
    };
    function getSerdePlugin(config, serializer, deserializer) {
      return {
        applyToStack: (commandStack) => {
          commandStack.add(deserializerMiddleware(config, deserializer), deserializerMiddlewareOption2);
          commandStack.add(serializerMiddleware(config, serializer), serializerMiddlewareOption3);
        }
      };
    }
    exports2.deserializerMiddleware = deserializerMiddleware;
    exports2.deserializerMiddlewareOption = deserializerMiddlewareOption2;
    exports2.getSerdePlugin = getSerdePlugin;
    exports2.serializerMiddleware = serializerMiddleware;
    exports2.serializerMiddlewareOption = serializerMiddlewareOption3;
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/getHttpAuthSchemePlugin.js
var import_middleware_serde, httpAuthSchemeMiddlewareOptions, getHttpAuthSchemePlugin;
var init_getHttpAuthSchemePlugin = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/getHttpAuthSchemePlugin.js"() {
    import_middleware_serde = __toESM(require_dist_cjs5());
    init_httpAuthSchemeMiddleware();
    httpAuthSchemeMiddlewareOptions = {
      step: "serialize",
      tags: ["HTTP_AUTH_SCHEME"],
      name: "httpAuthSchemeMiddleware",
      override: true,
      relation: "before",
      toMiddleware: import_middleware_serde.serializerMiddlewareOption.name
    };
    getHttpAuthSchemePlugin = (config, { httpAuthSchemeParametersProvider, identityProviderConfigProvider }) => ({
      applyToStack: (clientStack) => {
        clientStack.addRelativeTo(httpAuthSchemeMiddleware(config, {
          httpAuthSchemeParametersProvider,
          identityProviderConfigProvider
        }), httpAuthSchemeMiddlewareOptions);
      }
    });
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/index.js
var init_middleware_http_auth_scheme = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/index.js"() {
    init_httpAuthSchemeMiddleware();
    init_getHttpAuthSchemeEndpointRuleSetPlugin();
    init_getHttpAuthSchemePlugin();
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/middleware-http-signing/httpSigningMiddleware.js
var import_protocol_http4, import_util_middleware2, defaultErrorHandler, defaultSuccessHandler, httpSigningMiddleware;
var init_httpSigningMiddleware = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/middleware-http-signing/httpSigningMiddleware.js"() {
    import_protocol_http4 = __toESM(require_dist_cjs2());
    import_util_middleware2 = __toESM(require_dist_cjs4());
    defaultErrorHandler = (signingProperties) => (error2) => {
      throw error2;
    };
    defaultSuccessHandler = (httpResponse, signingProperties) => {
    };
    httpSigningMiddleware = (config) => (next, context) => async (args) => {
      if (!import_protocol_http4.HttpRequest.isInstance(args.request)) {
        return next(args);
      }
      const smithyContext = (0, import_util_middleware2.getSmithyContext)(context);
      const scheme = smithyContext.selectedHttpAuthScheme;
      if (!scheme) {
        throw new Error(`No HttpAuthScheme was selected: unable to sign request`);
      }
      const { httpAuthOption: { signingProperties = {} }, identity: identity2, signer } = scheme;
      const output = await next({
        ...args,
        request: await signer.sign(args.request, identity2, signingProperties)
      }).catch((signer.errorHandler || defaultErrorHandler)(signingProperties));
      (signer.successHandler || defaultSuccessHandler)(output.response, signingProperties);
      return output;
    };
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/middleware-http-signing/getHttpSigningMiddleware.js
var httpSigningMiddlewareOptions, getHttpSigningPlugin;
var init_getHttpSigningMiddleware = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/middleware-http-signing/getHttpSigningMiddleware.js"() {
    init_httpSigningMiddleware();
    httpSigningMiddlewareOptions = {
      step: "finalizeRequest",
      tags: ["HTTP_SIGNING"],
      name: "httpSigningMiddleware",
      aliases: ["apiKeyMiddleware", "tokenMiddleware", "awsAuthMiddleware"],
      override: true,
      relation: "after",
      toMiddleware: "retryMiddleware"
    };
    getHttpSigningPlugin = (config) => ({
      applyToStack: (clientStack) => {
        clientStack.addRelativeTo(httpSigningMiddleware(config), httpSigningMiddlewareOptions);
      }
    });
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/middleware-http-signing/index.js
var init_middleware_http_signing = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/middleware-http-signing/index.js"() {
    init_httpSigningMiddleware();
    init_getHttpSigningMiddleware();
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/normalizeProvider.js
var normalizeProvider;
var init_normalizeProvider = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/normalizeProvider.js"() {
    normalizeProvider = (input) => {
      if (typeof input === "function")
        return input;
      const promisified = Promise.resolve(input);
      return () => promisified;
    };
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/pagination/createPaginator.js
function createPaginator(ClientCtor, CommandCtor, inputTokenName, outputTokenName, pageSizeTokenName) {
  return async function* paginateOperation(config, input, ...additionalArguments) {
    const _input = input;
    let token = config.startingToken ?? _input[inputTokenName];
    let hasNext = true;
    let page;
    while (hasNext) {
      _input[inputTokenName] = token;
      if (pageSizeTokenName) {
        _input[pageSizeTokenName] = _input[pageSizeTokenName] ?? config.pageSize;
      }
      if (config.client instanceof ClientCtor) {
        page = await makePagedClientRequest(CommandCtor, config.client, input, config.withCommand, ...additionalArguments);
      } else {
        throw new Error(`Invalid client, expected instance of ${ClientCtor.name}`);
      }
      yield page;
      const prevToken = token;
      token = get2(page, outputTokenName);
      hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return void 0;
  };
}
var makePagedClientRequest, get2;
var init_createPaginator = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/pagination/createPaginator.js"() {
    makePagedClientRequest = async (CommandCtor, client2, input, withCommand = (_) => _, ...args) => {
      let command = new CommandCtor(input);
      command = withCommand(command) ?? command;
      return await client2.send(command, ...args);
    };
    get2 = (fromObject, path3) => {
      let cursor2 = fromObject;
      const pathComponents = path3.split(".");
      for (const step of pathComponents) {
        if (!cursor2 || typeof cursor2 !== "object") {
          return void 0;
        }
        cursor2 = cursor2[step];
      }
      return cursor2;
    };
  }
});

// node_modules/.pnpm/@smithy+is-array-buffer@4.2.0/node_modules/@smithy/is-array-buffer/dist-cjs/index.js
var require_dist_cjs6 = __commonJS({
  "node_modules/.pnpm/@smithy+is-array-buffer@4.2.0/node_modules/@smithy/is-array-buffer/dist-cjs/index.js"(exports2) {
    "use strict";
    var isArrayBuffer = (arg) => typeof ArrayBuffer === "function" && arg instanceof ArrayBuffer || Object.prototype.toString.call(arg) === "[object ArrayBuffer]";
    exports2.isArrayBuffer = isArrayBuffer;
  }
});

// node_modules/.pnpm/@smithy+util-buffer-from@4.2.0/node_modules/@smithy/util-buffer-from/dist-cjs/index.js
var require_dist_cjs7 = __commonJS({
  "node_modules/.pnpm/@smithy+util-buffer-from@4.2.0/node_modules/@smithy/util-buffer-from/dist-cjs/index.js"(exports2) {
    "use strict";
    var isArrayBuffer = require_dist_cjs6();
    var buffer = require("buffer");
    var fromArrayBuffer = (input, offset = 0, length = input.byteLength - offset) => {
      if (!isArrayBuffer.isArrayBuffer(input)) {
        throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof input} (${input})`);
      }
      return buffer.Buffer.from(input, offset, length);
    };
    var fromString = (input, encoding2) => {
      if (typeof input !== "string") {
        throw new TypeError(`The "input" argument must be of type string. Received type ${typeof input} (${input})`);
      }
      return encoding2 ? buffer.Buffer.from(input, encoding2) : buffer.Buffer.from(input);
    };
    exports2.fromArrayBuffer = fromArrayBuffer;
    exports2.fromString = fromString;
  }
});

// node_modules/.pnpm/@smithy+util-base64@4.3.0/node_modules/@smithy/util-base64/dist-cjs/fromBase64.js
var require_fromBase64 = __commonJS({
  "node_modules/.pnpm/@smithy+util-base64@4.3.0/node_modules/@smithy/util-base64/dist-cjs/fromBase64.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fromBase64 = void 0;
    var util_buffer_from_1 = require_dist_cjs7();
    var BASE64_REGEX = /^[A-Za-z0-9+/]*={0,2}$/;
    var fromBase648 = (input) => {
      if (input.length * 3 % 4 !== 0) {
        throw new TypeError(`Incorrect padding on base64 string.`);
      }
      if (!BASE64_REGEX.exec(input)) {
        throw new TypeError(`Invalid base64 string.`);
      }
      const buffer = (0, util_buffer_from_1.fromString)(input, "base64");
      return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    };
    exports2.fromBase64 = fromBase648;
  }
});

// node_modules/.pnpm/@smithy+util-utf8@4.2.0/node_modules/@smithy/util-utf8/dist-cjs/index.js
var require_dist_cjs8 = __commonJS({
  "node_modules/.pnpm/@smithy+util-utf8@4.2.0/node_modules/@smithy/util-utf8/dist-cjs/index.js"(exports2) {
    "use strict";
    var utilBufferFrom = require_dist_cjs7();
    var fromUtf87 = (input) => {
      const buf = utilBufferFrom.fromString(input, "utf8");
      return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    };
    var toUint8Array2 = (data2) => {
      if (typeof data2 === "string") {
        return fromUtf87(data2);
      }
      if (ArrayBuffer.isView(data2)) {
        return new Uint8Array(data2.buffer, data2.byteOffset, data2.byteLength / Uint8Array.BYTES_PER_ELEMENT);
      }
      return new Uint8Array(data2);
    };
    var toUtf810 = (input) => {
      if (typeof input === "string") {
        return input;
      }
      if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
        throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.");
      }
      return utilBufferFrom.fromArrayBuffer(input.buffer, input.byteOffset, input.byteLength).toString("utf8");
    };
    exports2.fromUtf8 = fromUtf87;
    exports2.toUint8Array = toUint8Array2;
    exports2.toUtf8 = toUtf810;
  }
});

// node_modules/.pnpm/@smithy+util-base64@4.3.0/node_modules/@smithy/util-base64/dist-cjs/toBase64.js
var require_toBase64 = __commonJS({
  "node_modules/.pnpm/@smithy+util-base64@4.3.0/node_modules/@smithy/util-base64/dist-cjs/toBase64.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toBase64 = void 0;
    var util_buffer_from_1 = require_dist_cjs7();
    var util_utf8_1 = require_dist_cjs8();
    var toBase648 = (_input) => {
      let input;
      if (typeof _input === "string") {
        input = (0, util_utf8_1.fromUtf8)(_input);
      } else {
        input = _input;
      }
      if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
        throw new Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.");
      }
      return (0, util_buffer_from_1.fromArrayBuffer)(input.buffer, input.byteOffset, input.byteLength).toString("base64");
    };
    exports2.toBase64 = toBase648;
  }
});

// node_modules/.pnpm/@smithy+util-base64@4.3.0/node_modules/@smithy/util-base64/dist-cjs/index.js
var require_dist_cjs9 = __commonJS({
  "node_modules/.pnpm/@smithy+util-base64@4.3.0/node_modules/@smithy/util-base64/dist-cjs/index.js"(exports2) {
    "use strict";
    var fromBase648 = require_fromBase64();
    var toBase648 = require_toBase64();
    Object.keys(fromBase648).forEach(function(k4) {
      if (k4 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, k4)) Object.defineProperty(exports2, k4, {
        enumerable: true,
        get: function() {
          return fromBase648[k4];
        }
      });
    });
    Object.keys(toBase648).forEach(function(k4) {
      if (k4 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, k4)) Object.defineProperty(exports2, k4, {
        enumerable: true,
        get: function() {
          return toBase648[k4];
        }
      });
    });
  }
});

// node_modules/.pnpm/@smithy+util-stream@4.5.10/node_modules/@smithy/util-stream/dist-cjs/checksum/ChecksumStream.js
var require_ChecksumStream = __commonJS({
  "node_modules/.pnpm/@smithy+util-stream@4.5.10/node_modules/@smithy/util-stream/dist-cjs/checksum/ChecksumStream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ChecksumStream = void 0;
    var util_base64_1 = require_dist_cjs9();
    var stream_1 = require("stream");
    var ChecksumStream = class extends stream_1.Duplex {
      expectedChecksum;
      checksumSourceLocation;
      checksum;
      source;
      base64Encoder;
      constructor({ expectedChecksum, checksum, source, checksumSourceLocation, base64Encoder }) {
        super();
        if (typeof source.pipe === "function") {
          this.source = source;
        } else {
          throw new Error(`@smithy/util-stream: unsupported source type ${source?.constructor?.name ?? source} in ChecksumStream.`);
        }
        this.base64Encoder = base64Encoder ?? util_base64_1.toBase64;
        this.expectedChecksum = expectedChecksum;
        this.checksum = checksum;
        this.checksumSourceLocation = checksumSourceLocation;
        this.source.pipe(this);
      }
      _read(size) {
      }
      _write(chunk2, encoding2, callback) {
        try {
          this.checksum.update(chunk2);
          this.push(chunk2);
        } catch (e4) {
          return callback(e4);
        }
        return callback();
      }
      async _final(callback) {
        try {
          const digest = await this.checksum.digest();
          const received = this.base64Encoder(digest);
          if (this.expectedChecksum !== received) {
            return callback(new Error(`Checksum mismatch: expected "${this.expectedChecksum}" but received "${received}" in response header "${this.checksumSourceLocation}".`));
          }
        } catch (e4) {
          return callback(e4);
        }
        this.push(null);
        return callback();
      }
    };
    exports2.ChecksumStream = ChecksumStream;
  }
});

// node_modules/.pnpm/@smithy+util-stream@4.5.10/node_modules/@smithy/util-stream/dist-cjs/stream-type-check.js
var require_stream_type_check = __commonJS({
  "node_modules/.pnpm/@smithy+util-stream@4.5.10/node_modules/@smithy/util-stream/dist-cjs/stream-type-check.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isBlob = exports2.isReadableStream = void 0;
    var isReadableStream2 = (stream) => typeof ReadableStream === "function" && (stream?.constructor?.name === ReadableStream.name || stream instanceof ReadableStream);
    exports2.isReadableStream = isReadableStream2;
    var isBlob = (blob) => {
      return typeof Blob === "function" && (blob?.constructor?.name === Blob.name || blob instanceof Blob);
    };
    exports2.isBlob = isBlob;
  }
});

// node_modules/.pnpm/@smithy+util-stream@4.5.10/node_modules/@smithy/util-stream/dist-cjs/checksum/ChecksumStream.browser.js
var require_ChecksumStream_browser = __commonJS({
  "node_modules/.pnpm/@smithy+util-stream@4.5.10/node_modules/@smithy/util-stream/dist-cjs/checksum/ChecksumStream.browser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ChecksumStream = void 0;
    var ReadableStreamRef = typeof ReadableStream === "function" ? ReadableStream : function() {
    };
    var ChecksumStream = class extends ReadableStreamRef {
    };
    exports2.ChecksumStream = ChecksumStream;
  }
});

// node_modules/.pnpm/@smithy+util-stream@4.5.10/node_modules/@smithy/util-stream/dist-cjs/checksum/createChecksumStream.browser.js
var require_createChecksumStream_browser = __commonJS({
  "node_modules/.pnpm/@smithy+util-stream@4.5.10/node_modules/@smithy/util-stream/dist-cjs/checksum/createChecksumStream.browser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createChecksumStream = void 0;
    var util_base64_1 = require_dist_cjs9();
    var stream_type_check_1 = require_stream_type_check();
    var ChecksumStream_browser_1 = require_ChecksumStream_browser();
    var createChecksumStream = ({ expectedChecksum, checksum, source, checksumSourceLocation, base64Encoder }) => {
      if (!(0, stream_type_check_1.isReadableStream)(source)) {
        throw new Error(`@smithy/util-stream: unsupported source type ${source?.constructor?.name ?? source} in ChecksumStream.`);
      }
      const encoder = base64Encoder ?? util_base64_1.toBase64;
      if (typeof TransformStream !== "function") {
        throw new Error("@smithy/util-stream: unable to instantiate ChecksumStream because API unavailable: ReadableStream/TransformStream.");
      }
      const transform = new TransformStream({
        start() {
        },
        async transform(chunk2, controller) {
          checksum.update(chunk2);
          controller.enqueue(chunk2);
        },
        async flush(controller) {
          const digest = await checksum.digest();
          const received = encoder(digest);
          if (expectedChecksum !== received) {
            const error2 = new Error(`Checksum mismatch: expected "${expectedChecksum}" but received "${received}" in response header "${checksumSourceLocation}".`);
            controller.error(error2);
          } else {
            controller.terminate();
          }
        }
      });
      source.pipeThrough(transform);
      const readable2 = transform.readable;
      Object.setPrototypeOf(readable2, ChecksumStream_browser_1.ChecksumStream.prototype);
      return readable2;
    };
    exports2.createChecksumStream = createChecksumStream;
  }
});

// node_modules/.pnpm/@smithy+util-stream@4.5.10/node_modules/@smithy/util-stream/dist-cjs/checksum/createChecksumStream.js
var require_createChecksumStream = __commonJS({
  "node_modules/.pnpm/@smithy+util-stream@4.5.10/node_modules/@smithy/util-stream/dist-cjs/checksum/createChecksumStream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createChecksumStream = createChecksumStream;
    var stream_type_check_1 = require_stream_type_check();
    var ChecksumStream_1 = require_ChecksumStream();
    var createChecksumStream_browser_1 = require_createChecksumStream_browser();
    function createChecksumStream(init) {
      if (typeof ReadableStream === "function" && (0, stream_type_check_1.isReadableStream)(init.source)) {
        return (0, createChecksumStream_browser_1.createChecksumStream)(init);
      }
      return new ChecksumStream_1.ChecksumStream(init);
    }
  }
});

// node_modules/.pnpm/@smithy+util-stream@4.5.10/node_modules/@smithy/util-stream/dist-cjs/ByteArrayCollector.js
var require_ByteArrayCollector = __commonJS({
  "node_modules/.pnpm/@smithy+util-stream@4.5.10/node_modules/@smithy/util-stream/dist-cjs/ByteArrayCollector.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ByteArrayCollector = void 0;
    var ByteArrayCollector = class {
      allocByteArray;
      byteLength = 0;
      byteArrays = [];
      constructor(allocByteArray) {
        this.allocByteArray = allocByteArray;
      }
      push(byteArray) {
        this.byteArrays.push(byteArray);
        this.byteLength += byteArray.byteLength;
      }
      flush() {
        if (this.byteArrays.length === 1) {
          const bytes = this.byteArrays[0];
          this.reset();
          return bytes;
        }
        const aggregation = this.allocByteArray(this.byteLength);
        let cursor2 = 0;
        for (let i4 = 0; i4 < this.byteArrays.length; ++i4) {
          const bytes = this.byteArrays[i4];
          aggregation.set(bytes, cursor2);
          cursor2 += bytes.byteLength;
        }
        this.reset();
        return aggregation;
      }
      reset() {
        this.byteArrays = [];
        this.byteLength = 0;
      }
    };
    exports2.ByteArrayCollector = ByteArrayCollector;
  }
});

// node_modules/.pnpm/@smithy+util-stream@4.5.10/node_modules/@smithy/util-stream/dist-cjs/createBufferedReadableStream.js
var require_createBufferedReadableStream = __commonJS({
  "node_modules/.pnpm/@smithy+util-stream@4.5.10/node_modules/@smithy/util-stream/dist-cjs/createBufferedReadableStream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createBufferedReadable = void 0;
    exports2.createBufferedReadableStream = createBufferedReadableStream;
    exports2.merge = merge2;
    exports2.flush = flush;
    exports2.sizeOf = sizeOf;
    exports2.modeOf = modeOf;
    var ByteArrayCollector_1 = require_ByteArrayCollector();
    function createBufferedReadableStream(upstream, size, logger3) {
      const reader = upstream.getReader();
      let streamBufferingLoggedWarning = false;
      let bytesSeen = 0;
      const buffers = ["", new ByteArrayCollector_1.ByteArrayCollector((size2) => new Uint8Array(size2))];
      let mode = -1;
      const pull = async (controller) => {
        const { value, done } = await reader.read();
        const chunk2 = value;
        if (done) {
          if (mode !== -1) {
            const remainder = flush(buffers, mode);
            if (sizeOf(remainder) > 0) {
              controller.enqueue(remainder);
            }
          }
          controller.close();
        } else {
          const chunkMode = modeOf(chunk2, false);
          if (mode !== chunkMode) {
            if (mode >= 0) {
              controller.enqueue(flush(buffers, mode));
            }
            mode = chunkMode;
          }
          if (mode === -1) {
            controller.enqueue(chunk2);
            return;
          }
          const chunkSize = sizeOf(chunk2);
          bytesSeen += chunkSize;
          const bufferSize = sizeOf(buffers[mode]);
          if (chunkSize >= size && bufferSize === 0) {
            controller.enqueue(chunk2);
          } else {
            const newSize = merge2(buffers, mode, chunk2);
            if (!streamBufferingLoggedWarning && bytesSeen > size * 2) {
              streamBufferingLoggedWarning = true;
              logger3?.warn(`@smithy/util-stream - stream chunk size ${chunkSize} is below threshold of ${size}, automatically buffering.`);
            }
            if (newSize >= size) {
              controller.enqueue(flush(buffers, mode));
            } else {
              await pull(controller);
            }
          }
        }
      };
      return new ReadableStream({
        pull
      });
    }
    exports2.createBufferedReadable = createBufferedReadableStream;
    function merge2(buffers, mode, chunk2) {
      switch (mode) {
        case 0:
          buffers[0] += chunk2;
          return sizeOf(buffers[0]);
        case 1:
        case 2:
          buffers[mode].push(chunk2);
          return sizeOf(buffers[mode]);
      }
    }
    function flush(buffers, mode) {
      switch (mode) {
        case 0:
          const s4 = buffers[0];
          buffers[0] = "";
          return s4;
        case 1:
        case 2:
          return buffers[mode].flush();
      }
      throw new Error(`@smithy/util-stream - invalid index ${mode} given to flush()`);
    }
    function sizeOf(chunk2) {
      return chunk2?.byteLength ?? chunk2?.length ?? 0;
    }
    function modeOf(chunk2, allowBuffer = true) {
      if (allowBuffer && typeof Buffer !== "undefined" && chunk2 instanceof Buffer) {
        return 2;
      }
      if (chunk2 instanceof Uint8Array) {
        return 1;
      }
      if (typeof chunk2 === "string") {
        return 0;
      }
      return -1;
    }
  }
});

// node_modules/.pnpm/@smithy+util-stream@4.5.10/node_modules/@smithy/util-stream/dist-cjs/createBufferedReadable.js
var require_createBufferedReadable = __commonJS({
  "node_modules/.pnpm/@smithy+util-stream@4.5.10/node_modules/@smithy/util-stream/dist-cjs/createBufferedReadable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createBufferedReadable = createBufferedReadable;
    var node_stream_1 = require("node:stream");
    var ByteArrayCollector_1 = require_ByteArrayCollector();
    var createBufferedReadableStream_1 = require_createBufferedReadableStream();
    var stream_type_check_1 = require_stream_type_check();
    function createBufferedReadable(upstream, size, logger3) {
      if ((0, stream_type_check_1.isReadableStream)(upstream)) {
        return (0, createBufferedReadableStream_1.createBufferedReadableStream)(upstream, size, logger3);
      }
      const downstream = new node_stream_1.Readable({ read() {
      } });
      let streamBufferingLoggedWarning = false;
      let bytesSeen = 0;
      const buffers = [
        "",
        new ByteArrayCollector_1.ByteArrayCollector((size2) => new Uint8Array(size2)),
        new ByteArrayCollector_1.ByteArrayCollector((size2) => Buffer.from(new Uint8Array(size2)))
      ];
      let mode = -1;
      upstream.on("data", (chunk2) => {
        const chunkMode = (0, createBufferedReadableStream_1.modeOf)(chunk2, true);
        if (mode !== chunkMode) {
          if (mode >= 0) {
            downstream.push((0, createBufferedReadableStream_1.flush)(buffers, mode));
          }
          mode = chunkMode;
        }
        if (mode === -1) {
          downstream.push(chunk2);
          return;
        }
        const chunkSize = (0, createBufferedReadableStream_1.sizeOf)(chunk2);
        bytesSeen += chunkSize;
        const bufferSize = (0, createBufferedReadableStream_1.sizeOf)(buffers[mode]);
        if (chunkSize >= size && bufferSize === 0) {
          downstream.push(chunk2);
        } else {
          const newSize = (0, createBufferedReadableStream_1.merge)(buffers, mode, chunk2);
          if (!streamBufferingLoggedWarning && bytesSeen > size * 2) {
            streamBufferingLoggedWarning = true;
            logger3?.warn(`@smithy/util-stream - stream chunk size ${chunkSize} is below threshold of ${size}, automatically buffering.`);
          }
          if (newSize >= size) {
            downstream.push((0, createBufferedReadableStream_1.flush)(buffers, mode));
          }
        }
      });
      upstream.on("end", () => {
        if (mode !== -1) {
          const remainder = (0, createBufferedReadableStream_1.flush)(buffers, mode);
          if ((0, createBufferedReadableStream_1.sizeOf)(remainder) > 0) {
            downstream.push(remainder);
          }
        }
        downstream.push(null);
      });
      return downstream;
    }
  }
});

// node_modules/.pnpm/@smithy+util-stream@4.5.10/node_modules/@smithy/util-stream/dist-cjs/getAwsChunkedEncodingStream.browser.js
var require_getAwsChunkedEncodingStream_browser = __commonJS({
  "node_modules/.pnpm/@smithy+util-stream@4.5.10/node_modules/@smithy/util-stream/dist-cjs/getAwsChunkedEncodingStream.browser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getAwsChunkedEncodingStream = void 0;
    var getAwsChunkedEncodingStream = (readableStream, options) => {
      const { base64Encoder, bodyLengthChecker, checksumAlgorithmFn, checksumLocationName, streamHasher } = options;
      const checksumRequired = base64Encoder !== void 0 && bodyLengthChecker !== void 0 && checksumAlgorithmFn !== void 0 && checksumLocationName !== void 0 && streamHasher !== void 0;
      const digest = checksumRequired ? streamHasher(checksumAlgorithmFn, readableStream) : void 0;
      const reader = readableStream.getReader();
      return new ReadableStream({
        async pull(controller) {
          const { value, done } = await reader.read();
          if (done) {
            controller.enqueue(`0\r
`);
            if (checksumRequired) {
              const checksum = base64Encoder(await digest);
              controller.enqueue(`${checksumLocationName}:${checksum}\r
`);
              controller.enqueue(`\r
`);
            }
            controller.close();
          } else {
            controller.enqueue(`${(bodyLengthChecker(value) || 0).toString(16)}\r
${value}\r
`);
          }
        }
      });
    };
    exports2.getAwsChunkedEncodingStream = getAwsChunkedEncodingStream;
  }
});

// node_modules/.pnpm/@smithy+util-stream@4.5.10/node_modules/@smithy/util-stream/dist-cjs/getAwsChunkedEncodingStream.js
var require_getAwsChunkedEncodingStream = __commonJS({
  "node_modules/.pnpm/@smithy+util-stream@4.5.10/node_modules/@smithy/util-stream/dist-cjs/getAwsChunkedEncodingStream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getAwsChunkedEncodingStream = getAwsChunkedEncodingStream;
    var node_stream_1 = require("node:stream");
    var getAwsChunkedEncodingStream_browser_1 = require_getAwsChunkedEncodingStream_browser();
    var stream_type_check_1 = require_stream_type_check();
    function getAwsChunkedEncodingStream(stream, options) {
      const readable2 = stream;
      const readableStream = stream;
      if ((0, stream_type_check_1.isReadableStream)(readableStream)) {
        return (0, getAwsChunkedEncodingStream_browser_1.getAwsChunkedEncodingStream)(readableStream, options);
      }
      const { base64Encoder, bodyLengthChecker, checksumAlgorithmFn, checksumLocationName, streamHasher } = options;
      const checksumRequired = base64Encoder !== void 0 && checksumAlgorithmFn !== void 0 && checksumLocationName !== void 0 && streamHasher !== void 0;
      const digest = checksumRequired ? streamHasher(checksumAlgorithmFn, readable2) : void 0;
      const awsChunkedEncodingStream = new node_stream_1.Readable({
        read: () => {
        }
      });
      readable2.on("data", (data2) => {
        const length = bodyLengthChecker(data2) || 0;
        if (length === 0) {
          return;
        }
        awsChunkedEncodingStream.push(`${length.toString(16)}\r
`);
        awsChunkedEncodingStream.push(data2);
        awsChunkedEncodingStream.push("\r\n");
      });
      readable2.on("end", async () => {
        awsChunkedEncodingStream.push(`0\r
`);
        if (checksumRequired) {
          const checksum = base64Encoder(await digest);
          awsChunkedEncodingStream.push(`${checksumLocationName}:${checksum}\r
`);
          awsChunkedEncodingStream.push(`\r
`);
        }
        awsChunkedEncodingStream.push(null);
      });
      return awsChunkedEncodingStream;
    }
  }
});

// node_modules/.pnpm/@smithy+util-stream@4.5.10/node_modules/@smithy/util-stream/dist-cjs/headStream.browser.js
var require_headStream_browser = __commonJS({
  "node_modules/.pnpm/@smithy+util-stream@4.5.10/node_modules/@smithy/util-stream/dist-cjs/headStream.browser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.headStream = headStream;
    async function headStream(stream, bytes) {
      let byteLengthCounter = 0;
      const chunks = [];
      const reader = stream.getReader();
      let isDone = false;
      while (!isDone) {
        const { done, value } = await reader.read();
        if (value) {
          chunks.push(value);
          byteLengthCounter += value?.byteLength ?? 0;
        }
        if (byteLengthCounter >= bytes) {
          break;
        }
        isDone = done;
      }
      reader.releaseLock();
      const collected = new Uint8Array(Math.min(bytes, byteLengthCounter));
      let offset = 0;
      for (const chunk2 of chunks) {
        if (chunk2.byteLength > collected.byteLength - offset) {
          collected.set(chunk2.subarray(0, collected.byteLength - offset), offset);
          break;
        } else {
          collected.set(chunk2, offset);
        }
        offset += chunk2.length;
      }
      return collected;
    }
  }
});

// node_modules/.pnpm/@smithy+util-stream@4.5.10/node_modules/@smithy/util-stream/dist-cjs/headStream.js
var require_headStream = __commonJS({
  "node_modules/.pnpm/@smithy+util-stream@4.5.10/node_modules/@smithy/util-stream/dist-cjs/headStream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.headStream = void 0;
    var stream_1 = require("stream");
    var headStream_browser_1 = require_headStream_browser();
    var stream_type_check_1 = require_stream_type_check();
    var headStream = (stream, bytes) => {
      if ((0, stream_type_check_1.isReadableStream)(stream)) {
        return (0, headStream_browser_1.headStream)(stream, bytes);
      }
      return new Promise((resolve, reject) => {
        const collector = new Collector();
        collector.limit = bytes;
        stream.pipe(collector);
        stream.on("error", (err) => {
          collector.end();
          reject(err);
        });
        collector.on("error", reject);
        collector.on("finish", function() {
          const bytes2 = new Uint8Array(Buffer.concat(this.buffers));
          resolve(bytes2);
        });
      });
    };
    exports2.headStream = headStream;
    var Collector = class extends stream_1.Writable {
      buffers = [];
      limit = Infinity;
      bytesBuffered = 0;
      _write(chunk2, encoding2, callback) {
        this.buffers.push(chunk2);
        this.bytesBuffered += chunk2.byteLength ?? 0;
        if (this.bytesBuffered >= this.limit) {
          const excess = this.bytesBuffered - this.limit;
          const tailBuffer = this.buffers[this.buffers.length - 1];
          this.buffers[this.buffers.length - 1] = tailBuffer.subarray(0, tailBuffer.byteLength - excess);
          this.emit("finish");
        }
        callback();
      }
    };
  }
});

// node_modules/.pnpm/@smithy+util-uri-escape@4.2.0/node_modules/@smithy/util-uri-escape/dist-cjs/index.js
var require_dist_cjs10 = __commonJS({
  "node_modules/.pnpm/@smithy+util-uri-escape@4.2.0/node_modules/@smithy/util-uri-escape/dist-cjs/index.js"(exports2) {
    "use strict";
    var escapeUri = (uri) => encodeURIComponent(uri).replace(/[!'()*]/g, hexEncode);
    var hexEncode = (c4) => `%${c4.charCodeAt(0).toString(16).toUpperCase()}`;
    var escapeUriPath = (uri) => uri.split("/").map(escapeUri).join("/");
    exports2.escapeUri = escapeUri;
    exports2.escapeUriPath = escapeUriPath;
  }
});

// node_modules/.pnpm/@smithy+querystring-builder@4.2.8/node_modules/@smithy/querystring-builder/dist-cjs/index.js
var require_dist_cjs11 = __commonJS({
  "node_modules/.pnpm/@smithy+querystring-builder@4.2.8/node_modules/@smithy/querystring-builder/dist-cjs/index.js"(exports2) {
    "use strict";
    var utilUriEscape = require_dist_cjs10();
    function buildQueryString(query) {
      const parts = [];
      for (let key of Object.keys(query).sort()) {
        const value = query[key];
        key = utilUriEscape.escapeUri(key);
        if (Array.isArray(value)) {
          for (let i4 = 0, iLen = value.length; i4 < iLen; i4++) {
            parts.push(`${key}=${utilUriEscape.escapeUri(value[i4])}`);
          }
        } else {
          let qsEntry = key;
          if (value || typeof value === "string") {
            qsEntry += `=${utilUriEscape.escapeUri(value)}`;
          }
          parts.push(qsEntry);
        }
      }
      return parts.join("&");
    }
    exports2.buildQueryString = buildQueryString;
  }
});

// node_modules/.pnpm/@smithy+node-http-handler@4.4.8/node_modules/@smithy/node-http-handler/dist-cjs/index.js
var require_dist_cjs12 = __commonJS({
  "node_modules/.pnpm/@smithy+node-http-handler@4.4.8/node_modules/@smithy/node-http-handler/dist-cjs/index.js"(exports2) {
    "use strict";
    var protocolHttp = require_dist_cjs2();
    var querystringBuilder = require_dist_cjs11();
    var http = require("http");
    var https = require("https");
    var stream = require("stream");
    var http2 = require("http2");
    var NODEJS_TIMEOUT_ERROR_CODES = ["ECONNRESET", "EPIPE", "ETIMEDOUT"];
    var getTransformedHeaders = (headers2) => {
      const transformedHeaders = {};
      for (const name of Object.keys(headers2)) {
        const headerValues = headers2[name];
        transformedHeaders[name] = Array.isArray(headerValues) ? headerValues.join(",") : headerValues;
      }
      return transformedHeaders;
    };
    var timing = {
      setTimeout: (cb, ms) => setTimeout(cb, ms),
      clearTimeout: (timeoutId) => clearTimeout(timeoutId)
    };
    var DEFER_EVENT_LISTENER_TIME$2 = 1e3;
    var setConnectionTimeout = (request2, reject, timeoutInMs = 0) => {
      if (!timeoutInMs) {
        return -1;
      }
      const registerTimeout = (offset) => {
        const timeoutId = timing.setTimeout(() => {
          request2.destroy();
          reject(Object.assign(new Error(`@smithy/node-http-handler - the request socket did not establish a connection with the server within the configured timeout of ${timeoutInMs} ms.`), {
            name: "TimeoutError"
          }));
        }, timeoutInMs - offset);
        const doWithSocket = (socket) => {
          if (socket?.connecting) {
            socket.on("connect", () => {
              timing.clearTimeout(timeoutId);
            });
          } else {
            timing.clearTimeout(timeoutId);
          }
        };
        if (request2.socket) {
          doWithSocket(request2.socket);
        } else {
          request2.on("socket", doWithSocket);
        }
      };
      if (timeoutInMs < 2e3) {
        registerTimeout(0);
        return 0;
      }
      return timing.setTimeout(registerTimeout.bind(null, DEFER_EVENT_LISTENER_TIME$2), DEFER_EVENT_LISTENER_TIME$2);
    };
    var setRequestTimeout = (req, reject, timeoutInMs = 0, throwOnRequestTimeout, logger3) => {
      if (timeoutInMs) {
        return timing.setTimeout(() => {
          let msg = `@smithy/node-http-handler - [${throwOnRequestTimeout ? "ERROR" : "WARN"}] a request has exceeded the configured ${timeoutInMs} ms requestTimeout.`;
          if (throwOnRequestTimeout) {
            const error2 = Object.assign(new Error(msg), {
              name: "TimeoutError",
              code: "ETIMEDOUT"
            });
            req.destroy(error2);
            reject(error2);
          } else {
            msg += ` Init client requestHandler with throwOnRequestTimeout=true to turn this into an error.`;
            logger3?.warn?.(msg);
          }
        }, timeoutInMs);
      }
      return -1;
    };
    var DEFER_EVENT_LISTENER_TIME$1 = 3e3;
    var setSocketKeepAlive = (request2, { keepAlive, keepAliveMsecs }, deferTimeMs = DEFER_EVENT_LISTENER_TIME$1) => {
      if (keepAlive !== true) {
        return -1;
      }
      const registerListener = () => {
        if (request2.socket) {
          request2.socket.setKeepAlive(keepAlive, keepAliveMsecs || 0);
        } else {
          request2.on("socket", (socket) => {
            socket.setKeepAlive(keepAlive, keepAliveMsecs || 0);
          });
        }
      };
      if (deferTimeMs === 0) {
        registerListener();
        return 0;
      }
      return timing.setTimeout(registerListener, deferTimeMs);
    };
    var DEFER_EVENT_LISTENER_TIME = 3e3;
    var setSocketTimeout = (request2, reject, timeoutInMs = 0) => {
      const registerTimeout = (offset) => {
        const timeout = timeoutInMs - offset;
        const onTimeout = () => {
          request2.destroy();
          reject(Object.assign(new Error(`@smithy/node-http-handler - the request socket timed out after ${timeoutInMs} ms of inactivity (configured by client requestHandler).`), { name: "TimeoutError" }));
        };
        if (request2.socket) {
          request2.socket.setTimeout(timeout, onTimeout);
          request2.on("close", () => request2.socket?.removeListener("timeout", onTimeout));
        } else {
          request2.setTimeout(timeout, onTimeout);
        }
      };
      if (0 < timeoutInMs && timeoutInMs < 6e3) {
        registerTimeout(0);
        return 0;
      }
      return timing.setTimeout(registerTimeout.bind(null, timeoutInMs === 0 ? 0 : DEFER_EVENT_LISTENER_TIME), DEFER_EVENT_LISTENER_TIME);
    };
    var MIN_WAIT_TIME = 6e3;
    async function writeRequestBody(httpRequest, request2, maxContinueTimeoutMs = MIN_WAIT_TIME, externalAgent = false) {
      const headers2 = request2.headers ?? {};
      const expect = headers2.Expect || headers2.expect;
      let timeoutId = -1;
      let sendBody = true;
      if (!externalAgent && expect === "100-continue") {
        sendBody = await Promise.race([
          new Promise((resolve) => {
            timeoutId = Number(timing.setTimeout(() => resolve(true), Math.max(MIN_WAIT_TIME, maxContinueTimeoutMs)));
          }),
          new Promise((resolve) => {
            httpRequest.on("continue", () => {
              timing.clearTimeout(timeoutId);
              resolve(true);
            });
            httpRequest.on("response", () => {
              timing.clearTimeout(timeoutId);
              resolve(false);
            });
            httpRequest.on("error", () => {
              timing.clearTimeout(timeoutId);
              resolve(false);
            });
          })
        ]);
      }
      if (sendBody) {
        writeBody(httpRequest, request2.body);
      }
    }
    function writeBody(httpRequest, body2) {
      if (body2 instanceof stream.Readable) {
        body2.pipe(httpRequest);
        return;
      }
      if (body2) {
        if (Buffer.isBuffer(body2) || typeof body2 === "string") {
          httpRequest.end(body2);
          return;
        }
        const uint8 = body2;
        if (typeof uint8 === "object" && uint8.buffer && typeof uint8.byteOffset === "number" && typeof uint8.byteLength === "number") {
          httpRequest.end(Buffer.from(uint8.buffer, uint8.byteOffset, uint8.byteLength));
          return;
        }
        httpRequest.end(Buffer.from(body2));
        return;
      }
      httpRequest.end();
    }
    var DEFAULT_REQUEST_TIMEOUT = 0;
    var NodeHttpHandler = class _NodeHttpHandler {
      config;
      configProvider;
      socketWarningTimestamp = 0;
      externalAgent = false;
      metadata = { handlerProtocol: "http/1.1" };
      static create(instanceOrOptions) {
        if (typeof instanceOrOptions?.handle === "function") {
          return instanceOrOptions;
        }
        return new _NodeHttpHandler(instanceOrOptions);
      }
      static checkSocketUsage(agent2, socketWarningTimestamp, logger3 = console) {
        const { sockets, requests, maxSockets } = agent2;
        if (typeof maxSockets !== "number" || maxSockets === Infinity) {
          return socketWarningTimestamp;
        }
        const interval = 15e3;
        if (Date.now() - interval < socketWarningTimestamp) {
          return socketWarningTimestamp;
        }
        if (sockets && requests) {
          for (const origin in sockets) {
            const socketsInUse = sockets[origin]?.length ?? 0;
            const requestsEnqueued = requests[origin]?.length ?? 0;
            if (socketsInUse >= maxSockets && requestsEnqueued >= 2 * maxSockets) {
              logger3?.warn?.(`@smithy/node-http-handler:WARN - socket usage at capacity=${socketsInUse} and ${requestsEnqueued} additional requests are enqueued.
See https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/node-configuring-maxsockets.html
or increase socketAcquisitionWarningTimeout=(millis) in the NodeHttpHandler config.`);
              return Date.now();
            }
          }
        }
        return socketWarningTimestamp;
      }
      constructor(options) {
        this.configProvider = new Promise((resolve, reject) => {
          if (typeof options === "function") {
            options().then((_options) => {
              resolve(this.resolveDefaultConfig(_options));
            }).catch(reject);
          } else {
            resolve(this.resolveDefaultConfig(options));
          }
        });
      }
      resolveDefaultConfig(options) {
        const { requestTimeout, connectionTimeout, socketTimeout, socketAcquisitionWarningTimeout, httpAgent, httpsAgent, throwOnRequestTimeout } = options || {};
        const keepAlive = true;
        const maxSockets = 50;
        return {
          connectionTimeout,
          requestTimeout,
          socketTimeout,
          socketAcquisitionWarningTimeout,
          throwOnRequestTimeout,
          httpAgent: (() => {
            if (httpAgent instanceof http.Agent || typeof httpAgent?.destroy === "function") {
              this.externalAgent = true;
              return httpAgent;
            }
            return new http.Agent({ keepAlive, maxSockets, ...httpAgent });
          })(),
          httpsAgent: (() => {
            if (httpsAgent instanceof https.Agent || typeof httpsAgent?.destroy === "function") {
              this.externalAgent = true;
              return httpsAgent;
            }
            return new https.Agent({ keepAlive, maxSockets, ...httpsAgent });
          })(),
          logger: console
        };
      }
      destroy() {
        this.config?.httpAgent?.destroy();
        this.config?.httpsAgent?.destroy();
      }
      async handle(request2, { abortSignal: abortSignal2, requestTimeout } = {}) {
        if (!this.config) {
          this.config = await this.configProvider;
        }
        return new Promise((_resolve, _reject) => {
          const config = this.config;
          let writeRequestBodyPromise = void 0;
          const timeouts = [];
          const resolve = async (arg) => {
            await writeRequestBodyPromise;
            timeouts.forEach(timing.clearTimeout);
            _resolve(arg);
          };
          const reject = async (arg) => {
            await writeRequestBodyPromise;
            timeouts.forEach(timing.clearTimeout);
            _reject(arg);
          };
          if (abortSignal2?.aborted) {
            const abortError = new Error("Request aborted");
            abortError.name = "AbortError";
            reject(abortError);
            return;
          }
          const isSSL = request2.protocol === "https:";
          const headers2 = request2.headers ?? {};
          const expectContinue = (headers2.Expect ?? headers2.expect) === "100-continue";
          let agent2 = isSSL ? config.httpsAgent : config.httpAgent;
          if (expectContinue && !this.externalAgent) {
            agent2 = new (isSSL ? https.Agent : http.Agent)({
              keepAlive: false,
              maxSockets: Infinity
            });
          }
          timeouts.push(timing.setTimeout(() => {
            this.socketWarningTimestamp = _NodeHttpHandler.checkSocketUsage(agent2, this.socketWarningTimestamp, config.logger);
          }, config.socketAcquisitionWarningTimeout ?? (config.requestTimeout ?? 2e3) + (config.connectionTimeout ?? 1e3)));
          const queryString = querystringBuilder.buildQueryString(request2.query || {});
          let auth = void 0;
          if (request2.username != null || request2.password != null) {
            const username = request2.username ?? "";
            const password = request2.password ?? "";
            auth = `${username}:${password}`;
          }
          let path3 = request2.path;
          if (queryString) {
            path3 += `?${queryString}`;
          }
          if (request2.fragment) {
            path3 += `#${request2.fragment}`;
          }
          let hostname = request2.hostname ?? "";
          if (hostname[0] === "[" && hostname.endsWith("]")) {
            hostname = request2.hostname.slice(1, -1);
          } else {
            hostname = request2.hostname;
          }
          const nodeHttpsOptions = {
            headers: request2.headers,
            host: hostname,
            method: request2.method,
            path: path3,
            port: request2.port,
            agent: agent2,
            auth
          };
          const requestFunc = isSSL ? https.request : http.request;
          const req = requestFunc(nodeHttpsOptions, (res) => {
            const httpResponse = new protocolHttp.HttpResponse({
              statusCode: res.statusCode || -1,
              reason: res.statusMessage,
              headers: getTransformedHeaders(res.headers),
              body: res
            });
            resolve({ response: httpResponse });
          });
          req.on("error", (err) => {
            if (NODEJS_TIMEOUT_ERROR_CODES.includes(err.code)) {
              reject(Object.assign(err, { name: "TimeoutError" }));
            } else {
              reject(err);
            }
          });
          if (abortSignal2) {
            const onAbort = () => {
              req.destroy();
              const abortError = new Error("Request aborted");
              abortError.name = "AbortError";
              reject(abortError);
            };
            if (typeof abortSignal2.addEventListener === "function") {
              const signal = abortSignal2;
              signal.addEventListener("abort", onAbort, { once: true });
              req.once("close", () => signal.removeEventListener("abort", onAbort));
            } else {
              abortSignal2.onabort = onAbort;
            }
          }
          const effectiveRequestTimeout = requestTimeout ?? config.requestTimeout;
          timeouts.push(setConnectionTimeout(req, reject, config.connectionTimeout));
          timeouts.push(setRequestTimeout(req, reject, effectiveRequestTimeout, config.throwOnRequestTimeout, config.logger ?? console));
          timeouts.push(setSocketTimeout(req, reject, config.socketTimeout));
          const httpAgent = nodeHttpsOptions.agent;
          if (typeof httpAgent === "object" && "keepAlive" in httpAgent) {
            timeouts.push(setSocketKeepAlive(req, {
              keepAlive: httpAgent.keepAlive,
              keepAliveMsecs: httpAgent.keepAliveMsecs
            }));
          }
          writeRequestBodyPromise = writeRequestBody(req, request2, effectiveRequestTimeout, this.externalAgent).catch((e4) => {
            timeouts.forEach(timing.clearTimeout);
            return _reject(e4);
          });
        });
      }
      updateHttpClientConfig(key, value) {
        this.config = void 0;
        this.configProvider = this.configProvider.then((config) => {
          return {
            ...config,
            [key]: value
          };
        });
      }
      httpHandlerConfigs() {
        return this.config ?? {};
      }
    };
    var NodeHttp2ConnectionPool = class {
      sessions = [];
      constructor(sessions) {
        this.sessions = sessions ?? [];
      }
      poll() {
        if (this.sessions.length > 0) {
          return this.sessions.shift();
        }
      }
      offerLast(session) {
        this.sessions.push(session);
      }
      contains(session) {
        return this.sessions.includes(session);
      }
      remove(session) {
        this.sessions = this.sessions.filter((s4) => s4 !== session);
      }
      [Symbol.iterator]() {
        return this.sessions[Symbol.iterator]();
      }
      destroy(connection2) {
        for (const session of this.sessions) {
          if (session === connection2) {
            if (!session.destroyed) {
              session.destroy();
            }
          }
        }
      }
    };
    var NodeHttp2ConnectionManager = class {
      constructor(config) {
        this.config = config;
        if (this.config.maxConcurrency && this.config.maxConcurrency <= 0) {
          throw new RangeError("maxConcurrency must be greater than zero.");
        }
      }
      config;
      sessionCache = /* @__PURE__ */ new Map();
      lease(requestContext, connectionConfiguration) {
        const url = this.getUrlString(requestContext);
        const existingPool = this.sessionCache.get(url);
        if (existingPool) {
          const existingSession = existingPool.poll();
          if (existingSession && !this.config.disableConcurrency) {
            return existingSession;
          }
        }
        const session = http2.connect(url);
        if (this.config.maxConcurrency) {
          session.settings({ maxConcurrentStreams: this.config.maxConcurrency }, (err) => {
            if (err) {
              throw new Error("Fail to set maxConcurrentStreams to " + this.config.maxConcurrency + "when creating new session for " + requestContext.destination.toString());
            }
          });
        }
        session.unref();
        const destroySessionCb = () => {
          session.destroy();
          this.deleteSession(url, session);
        };
        session.on("goaway", destroySessionCb);
        session.on("error", destroySessionCb);
        session.on("frameError", destroySessionCb);
        session.on("close", () => this.deleteSession(url, session));
        if (connectionConfiguration.requestTimeout) {
          session.setTimeout(connectionConfiguration.requestTimeout, destroySessionCb);
        }
        const connectionPool = this.sessionCache.get(url) || new NodeHttp2ConnectionPool();
        connectionPool.offerLast(session);
        this.sessionCache.set(url, connectionPool);
        return session;
      }
      deleteSession(authority, session) {
        const existingConnectionPool = this.sessionCache.get(authority);
        if (!existingConnectionPool) {
          return;
        }
        if (!existingConnectionPool.contains(session)) {
          return;
        }
        existingConnectionPool.remove(session);
        this.sessionCache.set(authority, existingConnectionPool);
      }
      release(requestContext, session) {
        const cacheKey = this.getUrlString(requestContext);
        this.sessionCache.get(cacheKey)?.offerLast(session);
      }
      destroy() {
        for (const [key, connectionPool] of this.sessionCache) {
          for (const session of connectionPool) {
            if (!session.destroyed) {
              session.destroy();
            }
            connectionPool.remove(session);
          }
          this.sessionCache.delete(key);
        }
      }
      setMaxConcurrentStreams(maxConcurrentStreams) {
        if (maxConcurrentStreams && maxConcurrentStreams <= 0) {
          throw new RangeError("maxConcurrentStreams must be greater than zero.");
        }
        this.config.maxConcurrency = maxConcurrentStreams;
      }
      setDisableConcurrentStreams(disableConcurrentStreams) {
        this.config.disableConcurrency = disableConcurrentStreams;
      }
      getUrlString(request2) {
        return request2.destination.toString();
      }
    };
    var NodeHttp2Handler = class _NodeHttp2Handler {
      config;
      configProvider;
      metadata = { handlerProtocol: "h2" };
      connectionManager = new NodeHttp2ConnectionManager({});
      static create(instanceOrOptions) {
        if (typeof instanceOrOptions?.handle === "function") {
          return instanceOrOptions;
        }
        return new _NodeHttp2Handler(instanceOrOptions);
      }
      constructor(options) {
        this.configProvider = new Promise((resolve, reject) => {
          if (typeof options === "function") {
            options().then((opts) => {
              resolve(opts || {});
            }).catch(reject);
          } else {
            resolve(options || {});
          }
        });
      }
      destroy() {
        this.connectionManager.destroy();
      }
      async handle(request2, { abortSignal: abortSignal2, requestTimeout } = {}) {
        if (!this.config) {
          this.config = await this.configProvider;
          this.connectionManager.setDisableConcurrentStreams(this.config.disableConcurrentStreams || false);
          if (this.config.maxConcurrentStreams) {
            this.connectionManager.setMaxConcurrentStreams(this.config.maxConcurrentStreams);
          }
        }
        const { requestTimeout: configRequestTimeout, disableConcurrentStreams } = this.config;
        const effectiveRequestTimeout = requestTimeout ?? configRequestTimeout;
        return new Promise((_resolve, _reject) => {
          let fulfilled = false;
          let writeRequestBodyPromise = void 0;
          const resolve = async (arg) => {
            await writeRequestBodyPromise;
            _resolve(arg);
          };
          const reject = async (arg) => {
            await writeRequestBodyPromise;
            _reject(arg);
          };
          if (abortSignal2?.aborted) {
            fulfilled = true;
            const abortError = new Error("Request aborted");
            abortError.name = "AbortError";
            reject(abortError);
            return;
          }
          const { hostname, method, port, protocol, query } = request2;
          let auth = "";
          if (request2.username != null || request2.password != null) {
            const username = request2.username ?? "";
            const password = request2.password ?? "";
            auth = `${username}:${password}@`;
          }
          const authority = `${protocol}//${auth}${hostname}${port ? `:${port}` : ""}`;
          const requestContext = { destination: new URL(authority) };
          const session = this.connectionManager.lease(requestContext, {
            requestTimeout: this.config?.sessionTimeout,
            disableConcurrentStreams: disableConcurrentStreams || false
          });
          const rejectWithDestroy = (err) => {
            if (disableConcurrentStreams) {
              this.destroySession(session);
            }
            fulfilled = true;
            reject(err);
          };
          const queryString = querystringBuilder.buildQueryString(query || {});
          let path3 = request2.path;
          if (queryString) {
            path3 += `?${queryString}`;
          }
          if (request2.fragment) {
            path3 += `#${request2.fragment}`;
          }
          const req = session.request({
            ...request2.headers,
            [http2.constants.HTTP2_HEADER_PATH]: path3,
            [http2.constants.HTTP2_HEADER_METHOD]: method
          });
          session.ref();
          req.on("response", (headers2) => {
            const httpResponse = new protocolHttp.HttpResponse({
              statusCode: headers2[":status"] || -1,
              headers: getTransformedHeaders(headers2),
              body: req
            });
            fulfilled = true;
            resolve({ response: httpResponse });
            if (disableConcurrentStreams) {
              session.close();
              this.connectionManager.deleteSession(authority, session);
            }
          });
          if (effectiveRequestTimeout) {
            req.setTimeout(effectiveRequestTimeout, () => {
              req.close();
              const timeoutError = new Error(`Stream timed out because of no activity for ${effectiveRequestTimeout} ms`);
              timeoutError.name = "TimeoutError";
              rejectWithDestroy(timeoutError);
            });
          }
          if (abortSignal2) {
            const onAbort = () => {
              req.close();
              const abortError = new Error("Request aborted");
              abortError.name = "AbortError";
              rejectWithDestroy(abortError);
            };
            if (typeof abortSignal2.addEventListener === "function") {
              const signal = abortSignal2;
              signal.addEventListener("abort", onAbort, { once: true });
              req.once("close", () => signal.removeEventListener("abort", onAbort));
            } else {
              abortSignal2.onabort = onAbort;
            }
          }
          req.on("frameError", (type, code, id2) => {
            rejectWithDestroy(new Error(`Frame type id ${type} in stream id ${id2} has failed with code ${code}.`));
          });
          req.on("error", rejectWithDestroy);
          req.on("aborted", () => {
            rejectWithDestroy(new Error(`HTTP/2 stream is abnormally aborted in mid-communication with result code ${req.rstCode}.`));
          });
          req.on("close", () => {
            session.unref();
            if (disableConcurrentStreams) {
              session.destroy();
            }
            if (!fulfilled) {
              rejectWithDestroy(new Error("Unexpected error: http2 request did not get a response"));
            }
          });
          writeRequestBodyPromise = writeRequestBody(req, request2, effectiveRequestTimeout);
        });
      }
      updateHttpClientConfig(key, value) {
        this.config = void 0;
        this.configProvider = this.configProvider.then((config) => {
          return {
            ...config,
            [key]: value
          };
        });
      }
      httpHandlerConfigs() {
        return this.config ?? {};
      }
      destroySession(session) {
        if (!session.destroyed) {
          session.destroy();
        }
      }
    };
    var Collector = class extends stream.Writable {
      bufferedBytes = [];
      _write(chunk2, encoding2, callback) {
        this.bufferedBytes.push(chunk2);
        callback();
      }
    };
    var streamCollector4 = (stream2) => {
      if (isReadableStreamInstance(stream2)) {
        return collectReadableStream(stream2);
      }
      return new Promise((resolve, reject) => {
        const collector = new Collector();
        stream2.pipe(collector);
        stream2.on("error", (err) => {
          collector.end();
          reject(err);
        });
        collector.on("error", reject);
        collector.on("finish", function() {
          const bytes = new Uint8Array(Buffer.concat(this.bufferedBytes));
          resolve(bytes);
        });
      });
    };
    var isReadableStreamInstance = (stream2) => typeof ReadableStream === "function" && stream2 instanceof ReadableStream;
    async function collectReadableStream(stream2) {
      const chunks = [];
      const reader = stream2.getReader();
      let isDone = false;
      let length = 0;
      while (!isDone) {
        const { done, value } = await reader.read();
        if (value) {
          chunks.push(value);
          length += value.length;
        }
        isDone = done;
      }
      const collected = new Uint8Array(length);
      let offset = 0;
      for (const chunk2 of chunks) {
        collected.set(chunk2, offset);
        offset += chunk2.length;
      }
      return collected;
    }
    exports2.DEFAULT_REQUEST_TIMEOUT = DEFAULT_REQUEST_TIMEOUT;
    exports2.NodeHttp2Handler = NodeHttp2Handler;
    exports2.NodeHttpHandler = NodeHttpHandler;
    exports2.streamCollector = streamCollector4;
  }
});

// node_modules/.pnpm/@smithy+fetch-http-handler@5.3.9/node_modules/@smithy/fetch-http-handler/dist-cjs/index.js
var require_dist_cjs13 = __commonJS({
  "node_modules/.pnpm/@smithy+fetch-http-handler@5.3.9/node_modules/@smithy/fetch-http-handler/dist-cjs/index.js"(exports2) {
    "use strict";
    var protocolHttp = require_dist_cjs2();
    var querystringBuilder = require_dist_cjs11();
    var utilBase64 = require_dist_cjs9();
    function createRequest(url, requestOptions) {
      return new Request(url, requestOptions);
    }
    function requestTimeout(timeoutInMs = 0) {
      return new Promise((resolve, reject) => {
        if (timeoutInMs) {
          setTimeout(() => {
            const timeoutError = new Error(`Request did not complete within ${timeoutInMs} ms`);
            timeoutError.name = "TimeoutError";
            reject(timeoutError);
          }, timeoutInMs);
        }
      });
    }
    var keepAliveSupport = {
      supported: void 0
    };
    var FetchHttpHandler = class _FetchHttpHandler {
      config;
      configProvider;
      static create(instanceOrOptions) {
        if (typeof instanceOrOptions?.handle === "function") {
          return instanceOrOptions;
        }
        return new _FetchHttpHandler(instanceOrOptions);
      }
      constructor(options) {
        if (typeof options === "function") {
          this.configProvider = options().then((opts) => opts || {});
        } else {
          this.config = options ?? {};
          this.configProvider = Promise.resolve(this.config);
        }
        if (keepAliveSupport.supported === void 0) {
          keepAliveSupport.supported = Boolean(typeof Request !== "undefined" && "keepalive" in createRequest("https://[::1]"));
        }
      }
      destroy() {
      }
      async handle(request2, { abortSignal: abortSignal2, requestTimeout: requestTimeout$1 } = {}) {
        if (!this.config) {
          this.config = await this.configProvider;
        }
        const requestTimeoutInMs = requestTimeout$1 ?? this.config.requestTimeout;
        const keepAlive = this.config.keepAlive === true;
        const credentials = this.config.credentials;
        if (abortSignal2?.aborted) {
          const abortError = new Error("Request aborted");
          abortError.name = "AbortError";
          return Promise.reject(abortError);
        }
        let path3 = request2.path;
        const queryString = querystringBuilder.buildQueryString(request2.query || {});
        if (queryString) {
          path3 += `?${queryString}`;
        }
        if (request2.fragment) {
          path3 += `#${request2.fragment}`;
        }
        let auth = "";
        if (request2.username != null || request2.password != null) {
          const username = request2.username ?? "";
          const password = request2.password ?? "";
          auth = `${username}:${password}@`;
        }
        const { port, method } = request2;
        const url = `${request2.protocol}//${auth}${request2.hostname}${port ? `:${port}` : ""}${path3}`;
        const body2 = method === "GET" || method === "HEAD" ? void 0 : request2.body;
        const requestOptions = {
          body: body2,
          headers: new Headers(request2.headers),
          method,
          credentials
        };
        if (this.config?.cache) {
          requestOptions.cache = this.config.cache;
        }
        if (body2) {
          requestOptions.duplex = "half";
        }
        if (typeof AbortController !== "undefined") {
          requestOptions.signal = abortSignal2;
        }
        if (keepAliveSupport.supported) {
          requestOptions.keepalive = keepAlive;
        }
        if (typeof this.config.requestInit === "function") {
          Object.assign(requestOptions, this.config.requestInit(request2));
        }
        let removeSignalEventListener = () => {
        };
        const fetchRequest = createRequest(url, requestOptions);
        const raceOfPromises = [
          fetch(fetchRequest).then((response2) => {
            const fetchHeaders = response2.headers;
            const transformedHeaders = {};
            for (const pair of fetchHeaders.entries()) {
              transformedHeaders[pair[0]] = pair[1];
            }
            const hasReadableStream = response2.body != void 0;
            if (!hasReadableStream) {
              return response2.blob().then((body3) => ({
                response: new protocolHttp.HttpResponse({
                  headers: transformedHeaders,
                  reason: response2.statusText,
                  statusCode: response2.status,
                  body: body3
                })
              }));
            }
            return {
              response: new protocolHttp.HttpResponse({
                headers: transformedHeaders,
                reason: response2.statusText,
                statusCode: response2.status,
                body: response2.body
              })
            };
          }),
          requestTimeout(requestTimeoutInMs)
        ];
        if (abortSignal2) {
          raceOfPromises.push(new Promise((resolve, reject) => {
            const onAbort = () => {
              const abortError = new Error("Request aborted");
              abortError.name = "AbortError";
              reject(abortError);
            };
            if (typeof abortSignal2.addEventListener === "function") {
              const signal = abortSignal2;
              signal.addEventListener("abort", onAbort, { once: true });
              removeSignalEventListener = () => signal.removeEventListener("abort", onAbort);
            } else {
              abortSignal2.onabort = onAbort;
            }
          }));
        }
        return Promise.race(raceOfPromises).finally(removeSignalEventListener);
      }
      updateHttpClientConfig(key, value) {
        this.config = void 0;
        this.configProvider = this.configProvider.then((config) => {
          config[key] = value;
          return config;
        });
      }
      httpHandlerConfigs() {
        return this.config ?? {};
      }
    };
    var streamCollector4 = async (stream) => {
      if (typeof Blob === "function" && stream instanceof Blob || stream.constructor?.name === "Blob") {
        if (Blob.prototype.arrayBuffer !== void 0) {
          return new Uint8Array(await stream.arrayBuffer());
        }
        return collectBlob(stream);
      }
      return collectStream(stream);
    };
    async function collectBlob(blob) {
      const base64 = await readToBase64(blob);
      const arrayBuffer = utilBase64.fromBase64(base64);
      return new Uint8Array(arrayBuffer);
    }
    async function collectStream(stream) {
      const chunks = [];
      const reader = stream.getReader();
      let isDone = false;
      let length = 0;
      while (!isDone) {
        const { done, value } = await reader.read();
        if (value) {
          chunks.push(value);
          length += value.length;
        }
        isDone = done;
      }
      const collected = new Uint8Array(length);
      let offset = 0;
      for (const chunk2 of chunks) {
        collected.set(chunk2, offset);
        offset += chunk2.length;
      }
      return collected;
    }
    function readToBase64(blob) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => {
          if (reader.readyState !== 2) {
            return reject(new Error("Reader aborted too early"));
          }
          const result = reader.result ?? "";
          const commaIndex = result.indexOf(",");
          const dataOffset = commaIndex > -1 ? commaIndex + 1 : result.length;
          resolve(result.substring(dataOffset));
        };
        reader.onabort = () => reject(new Error("Read aborted"));
        reader.onerror = () => reject(reader.error);
        reader.readAsDataURL(blob);
      });
    }
    exports2.FetchHttpHandler = FetchHttpHandler;
    exports2.keepAliveSupport = keepAliveSupport;
    exports2.streamCollector = streamCollector4;
  }
});

// node_modules/.pnpm/@smithy+util-hex-encoding@4.2.0/node_modules/@smithy/util-hex-encoding/dist-cjs/index.js
var require_dist_cjs14 = __commonJS({
  "node_modules/.pnpm/@smithy+util-hex-encoding@4.2.0/node_modules/@smithy/util-hex-encoding/dist-cjs/index.js"(exports2) {
    "use strict";
    var SHORT_TO_HEX = {};
    var HEX_TO_SHORT = {};
    for (let i4 = 0; i4 < 256; i4++) {
      let encodedByte = i4.toString(16).toLowerCase();
      if (encodedByte.length === 1) {
        encodedByte = `0${encodedByte}`;
      }
      SHORT_TO_HEX[i4] = encodedByte;
      HEX_TO_SHORT[encodedByte] = i4;
    }
    function fromHex(encoded) {
      if (encoded.length % 2 !== 0) {
        throw new Error("Hex encoded strings must have an even number length");
      }
      const out = new Uint8Array(encoded.length / 2);
      for (let i4 = 0; i4 < encoded.length; i4 += 2) {
        const encodedByte = encoded.slice(i4, i4 + 2).toLowerCase();
        if (encodedByte in HEX_TO_SHORT) {
          out[i4 / 2] = HEX_TO_SHORT[encodedByte];
        } else {
          throw new Error(`Cannot decode unrecognized sequence ${encodedByte} as hexadecimal`);
        }
      }
      return out;
    }
    function toHex(bytes) {
      let out = "";
      for (let i4 = 0; i4 < bytes.byteLength; i4++) {
        out += SHORT_TO_HEX[bytes[i4]];
      }
      return out;
    }
    exports2.fromHex = fromHex;
    exports2.toHex = toHex;
  }
});

// node_modules/.pnpm/@smithy+util-stream@4.5.10/node_modules/@smithy/util-stream/dist-cjs/sdk-stream-mixin.browser.js
var require_sdk_stream_mixin_browser = __commonJS({
  "node_modules/.pnpm/@smithy+util-stream@4.5.10/node_modules/@smithy/util-stream/dist-cjs/sdk-stream-mixin.browser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sdkStreamMixin = void 0;
    var fetch_http_handler_1 = require_dist_cjs13();
    var util_base64_1 = require_dist_cjs9();
    var util_hex_encoding_1 = require_dist_cjs14();
    var util_utf8_1 = require_dist_cjs8();
    var stream_type_check_1 = require_stream_type_check();
    var ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED = "The stream has already been transformed.";
    var sdkStreamMixin2 = (stream) => {
      if (!isBlobInstance(stream) && !(0, stream_type_check_1.isReadableStream)(stream)) {
        const name = stream?.__proto__?.constructor?.name || stream;
        throw new Error(`Unexpected stream implementation, expect Blob or ReadableStream, got ${name}`);
      }
      let transformed = false;
      const transformToByteArray = async () => {
        if (transformed) {
          throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
        }
        transformed = true;
        return await (0, fetch_http_handler_1.streamCollector)(stream);
      };
      const blobToWebStream = (blob) => {
        if (typeof blob.stream !== "function") {
          throw new Error("Cannot transform payload Blob to web stream. Please make sure the Blob.stream() is polyfilled.\nIf you are using React Native, this API is not yet supported, see: https://react-native.canny.io/feature-requests/p/fetch-streaming-body");
        }
        return blob.stream();
      };
      return Object.assign(stream, {
        transformToByteArray,
        transformToString: async (encoding2) => {
          const buf = await transformToByteArray();
          if (encoding2 === "base64") {
            return (0, util_base64_1.toBase64)(buf);
          } else if (encoding2 === "hex") {
            return (0, util_hex_encoding_1.toHex)(buf);
          } else if (encoding2 === void 0 || encoding2 === "utf8" || encoding2 === "utf-8") {
            return (0, util_utf8_1.toUtf8)(buf);
          } else if (typeof TextDecoder === "function") {
            return new TextDecoder(encoding2).decode(buf);
          } else {
            throw new Error("TextDecoder is not available, please make sure polyfill is provided.");
          }
        },
        transformToWebStream: () => {
          if (transformed) {
            throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
          }
          transformed = true;
          if (isBlobInstance(stream)) {
            return blobToWebStream(stream);
          } else if ((0, stream_type_check_1.isReadableStream)(stream)) {
            return stream;
          } else {
            throw new Error(`Cannot transform payload to web stream, got ${stream}`);
          }
        }
      });
    };
    exports2.sdkStreamMixin = sdkStreamMixin2;
    var isBlobInstance = (stream) => typeof Blob === "function" && stream instanceof Blob;
  }
});

// node_modules/.pnpm/@smithy+util-stream@4.5.10/node_modules/@smithy/util-stream/dist-cjs/sdk-stream-mixin.js
var require_sdk_stream_mixin = __commonJS({
  "node_modules/.pnpm/@smithy+util-stream@4.5.10/node_modules/@smithy/util-stream/dist-cjs/sdk-stream-mixin.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sdkStreamMixin = void 0;
    var node_http_handler_1 = require_dist_cjs12();
    var util_buffer_from_1 = require_dist_cjs7();
    var stream_1 = require("stream");
    var sdk_stream_mixin_browser_1 = require_sdk_stream_mixin_browser();
    var ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED = "The stream has already been transformed.";
    var sdkStreamMixin2 = (stream) => {
      if (!(stream instanceof stream_1.Readable)) {
        try {
          return (0, sdk_stream_mixin_browser_1.sdkStreamMixin)(stream);
        } catch (e4) {
          const name = stream?.__proto__?.constructor?.name || stream;
          throw new Error(`Unexpected stream implementation, expect Stream.Readable instance, got ${name}`);
        }
      }
      let transformed = false;
      const transformToByteArray = async () => {
        if (transformed) {
          throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
        }
        transformed = true;
        return await (0, node_http_handler_1.streamCollector)(stream);
      };
      return Object.assign(stream, {
        transformToByteArray,
        transformToString: async (encoding2) => {
          const buf = await transformToByteArray();
          if (encoding2 === void 0 || Buffer.isEncoding(encoding2)) {
            return (0, util_buffer_from_1.fromArrayBuffer)(buf.buffer, buf.byteOffset, buf.byteLength).toString(encoding2);
          } else {
            const decoder = new TextDecoder(encoding2);
            return decoder.decode(buf);
          }
        },
        transformToWebStream: () => {
          if (transformed) {
            throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
          }
          if (stream.readableFlowing !== null) {
            throw new Error("The stream has been consumed by other callbacks.");
          }
          if (typeof stream_1.Readable.toWeb !== "function") {
            throw new Error("Readable.toWeb() is not supported. Please ensure a polyfill is available.");
          }
          transformed = true;
          return stream_1.Readable.toWeb(stream);
        }
      });
    };
    exports2.sdkStreamMixin = sdkStreamMixin2;
  }
});

// node_modules/.pnpm/@smithy+util-stream@4.5.10/node_modules/@smithy/util-stream/dist-cjs/splitStream.browser.js
var require_splitStream_browser = __commonJS({
  "node_modules/.pnpm/@smithy+util-stream@4.5.10/node_modules/@smithy/util-stream/dist-cjs/splitStream.browser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.splitStream = splitStream;
    async function splitStream(stream) {
      if (typeof stream.stream === "function") {
        stream = stream.stream();
      }
      const readableStream = stream;
      return readableStream.tee();
    }
  }
});

// node_modules/.pnpm/@smithy+util-stream@4.5.10/node_modules/@smithy/util-stream/dist-cjs/splitStream.js
var require_splitStream = __commonJS({
  "node_modules/.pnpm/@smithy+util-stream@4.5.10/node_modules/@smithy/util-stream/dist-cjs/splitStream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.splitStream = splitStream;
    var stream_1 = require("stream");
    var splitStream_browser_1 = require_splitStream_browser();
    var stream_type_check_1 = require_stream_type_check();
    async function splitStream(stream) {
      if ((0, stream_type_check_1.isReadableStream)(stream) || (0, stream_type_check_1.isBlob)(stream)) {
        return (0, splitStream_browser_1.splitStream)(stream);
      }
      const stream1 = new stream_1.PassThrough();
      const stream2 = new stream_1.PassThrough();
      stream.pipe(stream1);
      stream.pipe(stream2);
      return [stream1, stream2];
    }
  }
});

// node_modules/.pnpm/@smithy+util-stream@4.5.10/node_modules/@smithy/util-stream/dist-cjs/index.js
var require_dist_cjs15 = __commonJS({
  "node_modules/.pnpm/@smithy+util-stream@4.5.10/node_modules/@smithy/util-stream/dist-cjs/index.js"(exports2) {
    "use strict";
    var utilBase64 = require_dist_cjs9();
    var utilUtf8 = require_dist_cjs8();
    var ChecksumStream = require_ChecksumStream();
    var createChecksumStream = require_createChecksumStream();
    var createBufferedReadable = require_createBufferedReadable();
    var getAwsChunkedEncodingStream = require_getAwsChunkedEncodingStream();
    var headStream = require_headStream();
    var sdkStreamMixin2 = require_sdk_stream_mixin();
    var splitStream = require_splitStream();
    var streamTypeCheck = require_stream_type_check();
    var Uint8ArrayBlobAdapter2 = class _Uint8ArrayBlobAdapter extends Uint8Array {
      static fromString(source, encoding2 = "utf-8") {
        if (typeof source === "string") {
          if (encoding2 === "base64") {
            return _Uint8ArrayBlobAdapter.mutate(utilBase64.fromBase64(source));
          }
          return _Uint8ArrayBlobAdapter.mutate(utilUtf8.fromUtf8(source));
        }
        throw new Error(`Unsupported conversion from ${typeof source} to Uint8ArrayBlobAdapter.`);
      }
      static mutate(source) {
        Object.setPrototypeOf(source, _Uint8ArrayBlobAdapter.prototype);
        return source;
      }
      transformToString(encoding2 = "utf-8") {
        if (encoding2 === "base64") {
          return utilBase64.toBase64(this);
        }
        return utilUtf8.toUtf8(this);
      }
    };
    Object.defineProperty(exports2, "isBlob", {
      enumerable: true,
      get: function() {
        return streamTypeCheck.isBlob;
      }
    });
    Object.defineProperty(exports2, "isReadableStream", {
      enumerable: true,
      get: function() {
        return streamTypeCheck.isReadableStream;
      }
    });
    exports2.Uint8ArrayBlobAdapter = Uint8ArrayBlobAdapter2;
    Object.keys(ChecksumStream).forEach(function(k4) {
      if (k4 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, k4)) Object.defineProperty(exports2, k4, {
        enumerable: true,
        get: function() {
          return ChecksumStream[k4];
        }
      });
    });
    Object.keys(createChecksumStream).forEach(function(k4) {
      if (k4 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, k4)) Object.defineProperty(exports2, k4, {
        enumerable: true,
        get: function() {
          return createChecksumStream[k4];
        }
      });
    });
    Object.keys(createBufferedReadable).forEach(function(k4) {
      if (k4 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, k4)) Object.defineProperty(exports2, k4, {
        enumerable: true,
        get: function() {
          return createBufferedReadable[k4];
        }
      });
    });
    Object.keys(getAwsChunkedEncodingStream).forEach(function(k4) {
      if (k4 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, k4)) Object.defineProperty(exports2, k4, {
        enumerable: true,
        get: function() {
          return getAwsChunkedEncodingStream[k4];
        }
      });
    });
    Object.keys(headStream).forEach(function(k4) {
      if (k4 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, k4)) Object.defineProperty(exports2, k4, {
        enumerable: true,
        get: function() {
          return headStream[k4];
        }
      });
    });
    Object.keys(sdkStreamMixin2).forEach(function(k4) {
      if (k4 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, k4)) Object.defineProperty(exports2, k4, {
        enumerable: true,
        get: function() {
          return sdkStreamMixin2[k4];
        }
      });
    });
    Object.keys(splitStream).forEach(function(k4) {
      if (k4 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, k4)) Object.defineProperty(exports2, k4, {
        enumerable: true,
        get: function() {
          return splitStream[k4];
        }
      });
    });
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/protocols/collect-stream-body.js
var import_util_stream, collectBody;
var init_collect_stream_body = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/protocols/collect-stream-body.js"() {
    import_util_stream = __toESM(require_dist_cjs15());
    collectBody = async (streamBody = new Uint8Array(), context) => {
      if (streamBody instanceof Uint8Array) {
        return import_util_stream.Uint8ArrayBlobAdapter.mutate(streamBody);
      }
      if (!streamBody) {
        return import_util_stream.Uint8ArrayBlobAdapter.mutate(new Uint8Array());
      }
      const fromContext = context.streamCollector(streamBody);
      return import_util_stream.Uint8ArrayBlobAdapter.mutate(await fromContext);
    };
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/protocols/extended-encode-uri-component.js
function extendedEncodeURIComponent(str) {
  return encodeURIComponent(str).replace(/[!'()*]/g, function(c4) {
    return "%" + c4.charCodeAt(0).toString(16).toUpperCase();
  });
}
var init_extended_encode_uri_component = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/protocols/extended-encode-uri-component.js"() {
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/schema/deref.js
var deref;
var init_deref = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/schema/deref.js"() {
    deref = (schemaRef) => {
      if (typeof schemaRef === "function") {
        return schemaRef();
      }
      return schemaRef;
    };
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/schema/schemas/operation.js
var operation;
var init_operation = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/schema/schemas/operation.js"() {
    operation = (namespace, name, traits, input, output) => ({
      name,
      namespace,
      traits,
      input,
      output
    });
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/schema/middleware/schemaDeserializationMiddleware.js
var import_protocol_http5, import_util_middleware3, schemaDeserializationMiddleware, findHeader;
var init_schemaDeserializationMiddleware = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/schema/middleware/schemaDeserializationMiddleware.js"() {
    import_protocol_http5 = __toESM(require_dist_cjs2());
    import_util_middleware3 = __toESM(require_dist_cjs4());
    init_operation();
    schemaDeserializationMiddleware = (config) => (next, context) => async (args) => {
      const { response: response2 } = await next(args);
      const { operationSchema } = (0, import_util_middleware3.getSmithyContext)(context);
      const [, ns, n4, t4, i4, o4] = operationSchema ?? [];
      try {
        const parsed = await config.protocol.deserializeResponse(operation(ns, n4, t4, i4, o4), {
          ...config,
          ...context
        }, response2);
        return {
          response: response2,
          output: parsed
        };
      } catch (error2) {
        Object.defineProperty(error2, "$response", {
          value: response2,
          enumerable: false,
          writable: false,
          configurable: false
        });
        if (!("$metadata" in error2)) {
          const hint = `Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.`;
          try {
            error2.message += "\n  " + hint;
          } catch (e4) {
            if (!context.logger || context.logger?.constructor?.name === "NoOpLogger") {
              console.warn(hint);
            } else {
              context.logger?.warn?.(hint);
            }
          }
          if (typeof error2.$responseBodyText !== "undefined") {
            if (error2.$response) {
              error2.$response.body = error2.$responseBodyText;
            }
          }
          try {
            if (import_protocol_http5.HttpResponse.isInstance(response2)) {
              const { headers: headers2 = {} } = response2;
              const headerEntries = Object.entries(headers2);
              error2.$metadata = {
                httpStatusCode: response2.statusCode,
                requestId: findHeader(/^x-[\w-]+-request-?id$/, headerEntries),
                extendedRequestId: findHeader(/^x-[\w-]+-id-2$/, headerEntries),
                cfId: findHeader(/^x-[\w-]+-cf-id$/, headerEntries)
              };
            }
          } catch (e4) {
          }
        }
        throw error2;
      }
    };
    findHeader = (pattern, headers2) => {
      return (headers2.find(([k4]) => {
        return k4.match(pattern);
      }) || [void 0, void 0])[1];
    };
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/schema/middleware/schemaSerializationMiddleware.js
var import_util_middleware4, schemaSerializationMiddleware;
var init_schemaSerializationMiddleware = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/schema/middleware/schemaSerializationMiddleware.js"() {
    import_util_middleware4 = __toESM(require_dist_cjs4());
    init_operation();
    schemaSerializationMiddleware = (config) => (next, context) => async (args) => {
      const { operationSchema } = (0, import_util_middleware4.getSmithyContext)(context);
      const [, ns, n4, t4, i4, o4] = operationSchema ?? [];
      const endpoint = context.endpointV2?.url && config.urlParser ? async () => config.urlParser(context.endpointV2.url) : config.endpoint;
      const request2 = await config.protocol.serializeRequest(operation(ns, n4, t4, i4, o4), args.input, {
        ...config,
        ...context,
        endpoint
      });
      return next({
        ...args,
        request: request2
      });
    };
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/schema/middleware/getSchemaSerdePlugin.js
function getSchemaSerdePlugin(config) {
  return {
    applyToStack: (commandStack) => {
      commandStack.add(schemaSerializationMiddleware(config), serializerMiddlewareOption2);
      commandStack.add(schemaDeserializationMiddleware(config), deserializerMiddlewareOption);
      config.protocol.setSerdeContext(config);
    }
  };
}
var deserializerMiddlewareOption, serializerMiddlewareOption2;
var init_getSchemaSerdePlugin = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/schema/middleware/getSchemaSerdePlugin.js"() {
    init_schemaDeserializationMiddleware();
    init_schemaSerializationMiddleware();
    deserializerMiddlewareOption = {
      name: "deserializerMiddleware",
      step: "deserialize",
      tags: ["DESERIALIZER"],
      override: true
    };
    serializerMiddlewareOption2 = {
      name: "serializerMiddleware",
      step: "serialize",
      tags: ["SERIALIZER"],
      override: true
    };
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/schema/schemas/Schema.js
var Schema;
var init_Schema = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/schema/schemas/Schema.js"() {
    Schema = class {
      name;
      namespace;
      traits;
      static assign(instance, values) {
        const schema = Object.assign(instance, values);
        return schema;
      }
      static [Symbol.hasInstance](lhs) {
        const isPrototype2 = this.prototype.isPrototypeOf(lhs);
        if (!isPrototype2 && typeof lhs === "object" && lhs !== null) {
          const list2 = lhs;
          return list2.symbol === this.symbol;
        }
        return isPrototype2;
      }
      getName() {
        return this.namespace + "#" + this.name;
      }
    };
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/schema/schemas/ListSchema.js
var ListSchema, list;
var init_ListSchema = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/schema/schemas/ListSchema.js"() {
    init_Schema();
    ListSchema = class _ListSchema extends Schema {
      static symbol = /* @__PURE__ */ Symbol.for("@smithy/lis");
      name;
      traits;
      valueSchema;
      symbol = _ListSchema.symbol;
    };
    list = (namespace, name, traits, valueSchema) => Schema.assign(new ListSchema(), {
      name,
      namespace,
      traits,
      valueSchema
    });
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/schema/schemas/MapSchema.js
var MapSchema, map;
var init_MapSchema = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/schema/schemas/MapSchema.js"() {
    init_Schema();
    MapSchema = class _MapSchema extends Schema {
      static symbol = /* @__PURE__ */ Symbol.for("@smithy/map");
      name;
      traits;
      keySchema;
      valueSchema;
      symbol = _MapSchema.symbol;
    };
    map = (namespace, name, traits, keySchema, valueSchema) => Schema.assign(new MapSchema(), {
      name,
      namespace,
      traits,
      keySchema,
      valueSchema
    });
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/schema/schemas/OperationSchema.js
var OperationSchema, op;
var init_OperationSchema = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/schema/schemas/OperationSchema.js"() {
    init_Schema();
    OperationSchema = class _OperationSchema extends Schema {
      static symbol = /* @__PURE__ */ Symbol.for("@smithy/ope");
      name;
      traits;
      input;
      output;
      symbol = _OperationSchema.symbol;
    };
    op = (namespace, name, traits, input, output) => Schema.assign(new OperationSchema(), {
      name,
      namespace,
      traits,
      input,
      output
    });
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/schema/schemas/StructureSchema.js
var StructureSchema, struct;
var init_StructureSchema = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/schema/schemas/StructureSchema.js"() {
    init_Schema();
    StructureSchema = class _StructureSchema extends Schema {
      static symbol = /* @__PURE__ */ Symbol.for("@smithy/str");
      name;
      traits;
      memberNames;
      memberList;
      symbol = _StructureSchema.symbol;
    };
    struct = (namespace, name, traits, memberNames, memberList) => Schema.assign(new StructureSchema(), {
      name,
      namespace,
      traits,
      memberNames,
      memberList
    });
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/schema/schemas/ErrorSchema.js
var ErrorSchema, error;
var init_ErrorSchema = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/schema/schemas/ErrorSchema.js"() {
    init_Schema();
    init_StructureSchema();
    ErrorSchema = class _ErrorSchema extends StructureSchema {
      static symbol = /* @__PURE__ */ Symbol.for("@smithy/err");
      ctor;
      symbol = _ErrorSchema.symbol;
    };
    error = (namespace, name, traits, memberNames, memberList, ctor) => Schema.assign(new ErrorSchema(), {
      name,
      namespace,
      traits,
      memberNames,
      memberList,
      ctor: null
    });
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/schema/schemas/translateTraits.js
function translateTraits(indicator) {
  if (typeof indicator === "object") {
    return indicator;
  }
  indicator = indicator | 0;
  const traits = {};
  let i4 = 0;
  for (const trait of [
    "httpLabel",
    "idempotent",
    "idempotencyToken",
    "sensitive",
    "httpPayload",
    "httpResponseCode",
    "httpQueryParams"
  ]) {
    if ((indicator >> i4++ & 1) === 1) {
      traits[trait] = 1;
    }
  }
  return traits;
}
var init_translateTraits = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/schema/schemas/translateTraits.js"() {
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/schema/schemas/NormalizedSchema.js
function member(memberSchema, memberName) {
  if (memberSchema instanceof NormalizedSchema) {
    return Object.assign(memberSchema, {
      memberName,
      _isMemberSchema: true
    });
  }
  const internalCtorAccess = NormalizedSchema;
  return new internalCtorAccess(memberSchema, memberName);
}
var NormalizedSchema, isMemberSchema, isStaticSchema;
var init_NormalizedSchema = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/schema/schemas/NormalizedSchema.js"() {
    init_deref();
    init_translateTraits();
    NormalizedSchema = class _NormalizedSchema {
      ref;
      memberName;
      static symbol = /* @__PURE__ */ Symbol.for("@smithy/nor");
      symbol = _NormalizedSchema.symbol;
      name;
      schema;
      _isMemberSchema;
      traits;
      memberTraits;
      normalizedTraits;
      constructor(ref, memberName) {
        this.ref = ref;
        this.memberName = memberName;
        const traitStack = [];
        let _ref = ref;
        let schema = ref;
        this._isMemberSchema = false;
        while (isMemberSchema(_ref)) {
          traitStack.push(_ref[1]);
          _ref = _ref[0];
          schema = deref(_ref);
          this._isMemberSchema = true;
        }
        if (traitStack.length > 0) {
          this.memberTraits = {};
          for (let i4 = traitStack.length - 1; i4 >= 0; --i4) {
            const traitSet = traitStack[i4];
            Object.assign(this.memberTraits, translateTraits(traitSet));
          }
        } else {
          this.memberTraits = 0;
        }
        if (schema instanceof _NormalizedSchema) {
          const computedMemberTraits = this.memberTraits;
          Object.assign(this, schema);
          this.memberTraits = Object.assign({}, computedMemberTraits, schema.getMemberTraits(), this.getMemberTraits());
          this.normalizedTraits = void 0;
          this.memberName = memberName ?? schema.memberName;
          return;
        }
        this.schema = deref(schema);
        if (isStaticSchema(this.schema)) {
          this.name = `${this.schema[1]}#${this.schema[2]}`;
          this.traits = this.schema[3];
        } else {
          this.name = this.memberName ?? String(schema);
          this.traits = 0;
        }
        if (this._isMemberSchema && !memberName) {
          throw new Error(`@smithy/core/schema - NormalizedSchema member init ${this.getName(true)} missing member name.`);
        }
      }
      static [Symbol.hasInstance](lhs) {
        const isPrototype2 = this.prototype.isPrototypeOf(lhs);
        if (!isPrototype2 && typeof lhs === "object" && lhs !== null) {
          const ns = lhs;
          return ns.symbol === this.symbol;
        }
        return isPrototype2;
      }
      static of(ref) {
        const sc = deref(ref);
        if (sc instanceof _NormalizedSchema) {
          return sc;
        }
        if (isMemberSchema(sc)) {
          const [ns, traits] = sc;
          if (ns instanceof _NormalizedSchema) {
            Object.assign(ns.getMergedTraits(), translateTraits(traits));
            return ns;
          }
          throw new Error(`@smithy/core/schema - may not init unwrapped member schema=${JSON.stringify(ref, null, 2)}.`);
        }
        return new _NormalizedSchema(sc);
      }
      getSchema() {
        const sc = this.schema;
        if (sc[0] === 0) {
          return sc[4];
        }
        return sc;
      }
      getName(withNamespace = false) {
        const { name } = this;
        const short = !withNamespace && name && name.includes("#");
        return short ? name.split("#")[1] : name || void 0;
      }
      getMemberName() {
        return this.memberName;
      }
      isMemberSchema() {
        return this._isMemberSchema;
      }
      isListSchema() {
        const sc = this.getSchema();
        return typeof sc === "number" ? sc >= 64 && sc < 128 : sc[0] === 1;
      }
      isMapSchema() {
        const sc = this.getSchema();
        return typeof sc === "number" ? sc >= 128 && sc <= 255 : sc[0] === 2;
      }
      isStructSchema() {
        const sc = this.getSchema();
        const id2 = sc[0];
        return id2 === 3 || id2 === -3 || id2 === 4;
      }
      isUnionSchema() {
        const sc = this.getSchema();
        return sc[0] === 4;
      }
      isBlobSchema() {
        const sc = this.getSchema();
        return sc === 21 || sc === 42;
      }
      isTimestampSchema() {
        const sc = this.getSchema();
        return typeof sc === "number" && sc >= 4 && sc <= 7;
      }
      isUnitSchema() {
        return this.getSchema() === "unit";
      }
      isDocumentSchema() {
        return this.getSchema() === 15;
      }
      isStringSchema() {
        return this.getSchema() === 0;
      }
      isBooleanSchema() {
        return this.getSchema() === 2;
      }
      isNumericSchema() {
        return this.getSchema() === 1;
      }
      isBigIntegerSchema() {
        return this.getSchema() === 17;
      }
      isBigDecimalSchema() {
        return this.getSchema() === 19;
      }
      isStreaming() {
        const { streaming } = this.getMergedTraits();
        return !!streaming || this.getSchema() === 42;
      }
      isIdempotencyToken() {
        const match = (traits2) => (traits2 & 4) === 4 || !!traits2?.idempotencyToken;
        const { normalizedTraits, traits, memberTraits } = this;
        return match(normalizedTraits) || match(traits) || match(memberTraits);
      }
      getMergedTraits() {
        return this.normalizedTraits ?? (this.normalizedTraits = {
          ...this.getOwnTraits(),
          ...this.getMemberTraits()
        });
      }
      getMemberTraits() {
        return translateTraits(this.memberTraits);
      }
      getOwnTraits() {
        return translateTraits(this.traits);
      }
      getKeySchema() {
        const [isDoc, isMap2] = [this.isDocumentSchema(), this.isMapSchema()];
        if (!isDoc && !isMap2) {
          throw new Error(`@smithy/core/schema - cannot get key for non-map: ${this.getName(true)}`);
        }
        const schema = this.getSchema();
        const memberSchema = isDoc ? 15 : schema[4] ?? 0;
        return member([memberSchema, 0], "key");
      }
      getValueSchema() {
        const sc = this.getSchema();
        const [isDoc, isMap2, isList] = [this.isDocumentSchema(), this.isMapSchema(), this.isListSchema()];
        const memberSchema = typeof sc === "number" ? 63 & sc : sc && typeof sc === "object" && (isMap2 || isList) ? sc[3 + sc[0]] : isDoc ? 15 : void 0;
        if (memberSchema != null) {
          return member([memberSchema, 0], isMap2 ? "value" : "member");
        }
        throw new Error(`@smithy/core/schema - ${this.getName(true)} has no value member.`);
      }
      getMemberSchema(memberName) {
        const struct2 = this.getSchema();
        if (this.isStructSchema() && struct2[4].includes(memberName)) {
          const i4 = struct2[4].indexOf(memberName);
          const memberSchema = struct2[5][i4];
          return member(isMemberSchema(memberSchema) ? memberSchema : [memberSchema, 0], memberName);
        }
        if (this.isDocumentSchema()) {
          return member([15, 0], memberName);
        }
        throw new Error(`@smithy/core/schema - ${this.getName(true)} has no no member=${memberName}.`);
      }
      getMemberSchemas() {
        const buffer = {};
        try {
          for (const [k4, v4] of this.structIterator()) {
            buffer[k4] = v4;
          }
        } catch (ignored) {
        }
        return buffer;
      }
      getEventStreamMember() {
        if (this.isStructSchema()) {
          for (const [memberName, memberSchema] of this.structIterator()) {
            if (memberSchema.isStreaming() && memberSchema.isStructSchema()) {
              return memberName;
            }
          }
        }
        return "";
      }
      *structIterator() {
        if (this.isUnitSchema()) {
          return;
        }
        if (!this.isStructSchema()) {
          throw new Error("@smithy/core/schema - cannot iterate non-struct schema.");
        }
        const struct2 = this.getSchema();
        for (let i4 = 0; i4 < struct2[4].length; ++i4) {
          yield [struct2[4][i4], member([struct2[5][i4], 0], struct2[4][i4])];
        }
      }
    };
    isMemberSchema = (sc) => Array.isArray(sc) && sc.length === 2;
    isStaticSchema = (sc) => Array.isArray(sc) && sc.length >= 5;
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/schema/schemas/SimpleSchema.js
var SimpleSchema, sim, simAdapter;
var init_SimpleSchema = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/schema/schemas/SimpleSchema.js"() {
    init_Schema();
    SimpleSchema = class _SimpleSchema extends Schema {
      static symbol = /* @__PURE__ */ Symbol.for("@smithy/sim");
      name;
      schemaRef;
      traits;
      symbol = _SimpleSchema.symbol;
    };
    sim = (namespace, name, schemaRef, traits) => Schema.assign(new SimpleSchema(), {
      name,
      namespace,
      traits,
      schemaRef
    });
    simAdapter = (namespace, name, traits, schemaRef) => Schema.assign(new SimpleSchema(), {
      name,
      namespace,
      traits,
      schemaRef
    });
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/schema/schemas/sentinels.js
var SCHEMA;
var init_sentinels = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/schema/schemas/sentinels.js"() {
    SCHEMA = {
      BLOB: 21,
      STREAMING_BLOB: 42,
      BOOLEAN: 2,
      STRING: 0,
      NUMERIC: 1,
      BIG_INTEGER: 17,
      BIG_DECIMAL: 19,
      DOCUMENT: 15,
      TIMESTAMP_DEFAULT: 4,
      TIMESTAMP_DATE_TIME: 5,
      TIMESTAMP_HTTP_DATE: 6,
      TIMESTAMP_EPOCH_SECONDS: 7,
      LIST_MODIFIER: 64,
      MAP_MODIFIER: 128
    };
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/schema/TypeRegistry.js
var TypeRegistry;
var init_TypeRegistry = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/schema/TypeRegistry.js"() {
    TypeRegistry = class _TypeRegistry {
      namespace;
      schemas;
      exceptions;
      static registries = /* @__PURE__ */ new Map();
      constructor(namespace, schemas = /* @__PURE__ */ new Map(), exceptions = /* @__PURE__ */ new Map()) {
        this.namespace = namespace;
        this.schemas = schemas;
        this.exceptions = exceptions;
      }
      static for(namespace) {
        if (!_TypeRegistry.registries.has(namespace)) {
          _TypeRegistry.registries.set(namespace, new _TypeRegistry(namespace));
        }
        return _TypeRegistry.registries.get(namespace);
      }
      register(shapeId, schema) {
        const qualifiedName = this.normalizeShapeId(shapeId);
        const registry = _TypeRegistry.for(qualifiedName.split("#")[0]);
        registry.schemas.set(qualifiedName, schema);
      }
      getSchema(shapeId) {
        const id2 = this.normalizeShapeId(shapeId);
        if (!this.schemas.has(id2)) {
          throw new Error(`@smithy/core/schema - schema not found for ${id2}`);
        }
        return this.schemas.get(id2);
      }
      registerError(es, ctor) {
        const $error = es;
        const registry = _TypeRegistry.for($error[1]);
        registry.schemas.set($error[1] + "#" + $error[2], $error);
        registry.exceptions.set($error, ctor);
      }
      getErrorCtor(es) {
        const $error = es;
        const registry = _TypeRegistry.for($error[1]);
        return registry.exceptions.get($error);
      }
      getBaseException() {
        for (const exceptionKey of this.exceptions.keys()) {
          if (Array.isArray(exceptionKey)) {
            const [, ns, name] = exceptionKey;
            const id2 = ns + "#" + name;
            if (id2.startsWith("smithy.ts.sdk.synthetic.") && id2.endsWith("ServiceException")) {
              return exceptionKey;
            }
          }
        }
        return void 0;
      }
      find(predicate) {
        return [...this.schemas.values()].find(predicate);
      }
      clear() {
        this.schemas.clear();
        this.exceptions.clear();
      }
      normalizeShapeId(shapeId) {
        if (shapeId.includes("#")) {
          return shapeId;
        }
        return this.namespace + "#" + shapeId;
      }
    };
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/schema/index.js
var schema_exports = {};
__export(schema_exports, {
  ErrorSchema: () => ErrorSchema,
  ListSchema: () => ListSchema,
  MapSchema: () => MapSchema,
  NormalizedSchema: () => NormalizedSchema,
  OperationSchema: () => OperationSchema,
  SCHEMA: () => SCHEMA,
  Schema: () => Schema,
  SimpleSchema: () => SimpleSchema,
  StructureSchema: () => StructureSchema,
  TypeRegistry: () => TypeRegistry,
  deref: () => deref,
  deserializerMiddlewareOption: () => deserializerMiddlewareOption,
  error: () => error,
  getSchemaSerdePlugin: () => getSchemaSerdePlugin,
  isStaticSchema: () => isStaticSchema,
  list: () => list,
  map: () => map,
  op: () => op,
  operation: () => operation,
  serializerMiddlewareOption: () => serializerMiddlewareOption2,
  sim: () => sim,
  simAdapter: () => simAdapter,
  struct: () => struct,
  translateTraits: () => translateTraits
});
var init_schema = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/schema/index.js"() {
    init_deref();
    init_getSchemaSerdePlugin();
    init_ListSchema();
    init_MapSchema();
    init_OperationSchema();
    init_operation();
    init_ErrorSchema();
    init_NormalizedSchema();
    init_Schema();
    init_SimpleSchema();
    init_StructureSchema();
    init_sentinels();
    init_translateTraits();
    init_TypeRegistry();
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/serde/copyDocumentWithTransform.js
var copyDocumentWithTransform;
var init_copyDocumentWithTransform = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/serde/copyDocumentWithTransform.js"() {
    copyDocumentWithTransform = (source, schemaRef, transform = (_) => _) => source;
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/serde/parse-utils.js
var parseBoolean, expectBoolean, expectNumber, MAX_FLOAT, expectFloat32, expectLong, expectInt, expectInt32, expectShort, expectByte, expectSizedInt, castInt, expectNonNull, expectObject, expectString, expectUnion, strictParseDouble, strictParseFloat, strictParseFloat32, NUMBER_REGEX, parseNumber, limitedParseDouble, handleFloat, limitedParseFloat, limitedParseFloat32, parseFloatString, strictParseLong, strictParseInt, strictParseInt32, strictParseShort, strictParseByte, stackTraceWarning, logger;
var init_parse_utils = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/serde/parse-utils.js"() {
    parseBoolean = (value) => {
      switch (value) {
        case "true":
          return true;
        case "false":
          return false;
        default:
          throw new Error(`Unable to parse boolean value "${value}"`);
      }
    };
    expectBoolean = (value) => {
      if (value === null || value === void 0) {
        return void 0;
      }
      if (typeof value === "number") {
        if (value === 0 || value === 1) {
          logger.warn(stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));
        }
        if (value === 0) {
          return false;
        }
        if (value === 1) {
          return true;
        }
      }
      if (typeof value === "string") {
        const lower = value.toLowerCase();
        if (lower === "false" || lower === "true") {
          logger.warn(stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));
        }
        if (lower === "false") {
          return false;
        }
        if (lower === "true") {
          return true;
        }
      }
      if (typeof value === "boolean") {
        return value;
      }
      throw new TypeError(`Expected boolean, got ${typeof value}: ${value}`);
    };
    expectNumber = (value) => {
      if (value === null || value === void 0) {
        return void 0;
      }
      if (typeof value === "string") {
        const parsed = parseFloat(value);
        if (!Number.isNaN(parsed)) {
          if (String(parsed) !== String(value)) {
            logger.warn(stackTraceWarning(`Expected number but observed string: ${value}`));
          }
          return parsed;
        }
      }
      if (typeof value === "number") {
        return value;
      }
      throw new TypeError(`Expected number, got ${typeof value}: ${value}`);
    };
    MAX_FLOAT = Math.ceil(2 ** 127 * (2 - 2 ** -23));
    expectFloat32 = (value) => {
      const expected = expectNumber(value);
      if (expected !== void 0 && !Number.isNaN(expected) && expected !== Infinity && expected !== -Infinity) {
        if (Math.abs(expected) > MAX_FLOAT) {
          throw new TypeError(`Expected 32-bit float, got ${value}`);
        }
      }
      return expected;
    };
    expectLong = (value) => {
      if (value === null || value === void 0) {
        return void 0;
      }
      if (Number.isInteger(value) && !Number.isNaN(value)) {
        return value;
      }
      throw new TypeError(`Expected integer, got ${typeof value}: ${value}`);
    };
    expectInt = expectLong;
    expectInt32 = (value) => expectSizedInt(value, 32);
    expectShort = (value) => expectSizedInt(value, 16);
    expectByte = (value) => expectSizedInt(value, 8);
    expectSizedInt = (value, size) => {
      const expected = expectLong(value);
      if (expected !== void 0 && castInt(expected, size) !== expected) {
        throw new TypeError(`Expected ${size}-bit integer, got ${value}`);
      }
      return expected;
    };
    castInt = (value, size) => {
      switch (size) {
        case 32:
          return Int32Array.of(value)[0];
        case 16:
          return Int16Array.of(value)[0];
        case 8:
          return Int8Array.of(value)[0];
      }
    };
    expectNonNull = (value, location) => {
      if (value === null || value === void 0) {
        if (location) {
          throw new TypeError(`Expected a non-null value for ${location}`);
        }
        throw new TypeError("Expected a non-null value");
      }
      return value;
    };
    expectObject = (value) => {
      if (value === null || value === void 0) {
        return void 0;
      }
      if (typeof value === "object" && !Array.isArray(value)) {
        return value;
      }
      const receivedType = Array.isArray(value) ? "array" : typeof value;
      throw new TypeError(`Expected object, got ${receivedType}: ${value}`);
    };
    expectString = (value) => {
      if (value === null || value === void 0) {
        return void 0;
      }
      if (typeof value === "string") {
        return value;
      }
      if (["boolean", "number", "bigint"].includes(typeof value)) {
        logger.warn(stackTraceWarning(`Expected string, got ${typeof value}: ${value}`));
        return String(value);
      }
      throw new TypeError(`Expected string, got ${typeof value}: ${value}`);
    };
    expectUnion = (value) => {
      if (value === null || value === void 0) {
        return void 0;
      }
      const asObject = expectObject(value);
      const setKeys = Object.entries(asObject).filter(([, v4]) => v4 != null).map(([k4]) => k4);
      if (setKeys.length === 0) {
        throw new TypeError(`Unions must have exactly one non-null member. None were found.`);
      }
      if (setKeys.length > 1) {
        throw new TypeError(`Unions must have exactly one non-null member. Keys ${setKeys} were not null.`);
      }
      return asObject;
    };
    strictParseDouble = (value) => {
      if (typeof value == "string") {
        return expectNumber(parseNumber(value));
      }
      return expectNumber(value);
    };
    strictParseFloat = strictParseDouble;
    strictParseFloat32 = (value) => {
      if (typeof value == "string") {
        return expectFloat32(parseNumber(value));
      }
      return expectFloat32(value);
    };
    NUMBER_REGEX = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g;
    parseNumber = (value) => {
      const matches = value.match(NUMBER_REGEX);
      if (matches === null || matches[0].length !== value.length) {
        throw new TypeError(`Expected real number, got implicit NaN`);
      }
      return parseFloat(value);
    };
    limitedParseDouble = (value) => {
      if (typeof value == "string") {
        return parseFloatString(value);
      }
      return expectNumber(value);
    };
    handleFloat = limitedParseDouble;
    limitedParseFloat = limitedParseDouble;
    limitedParseFloat32 = (value) => {
      if (typeof value == "string") {
        return parseFloatString(value);
      }
      return expectFloat32(value);
    };
    parseFloatString = (value) => {
      switch (value) {
        case "NaN":
          return NaN;
        case "Infinity":
          return Infinity;
        case "-Infinity":
          return -Infinity;
        default:
          throw new Error(`Unable to parse float value: ${value}`);
      }
    };
    strictParseLong = (value) => {
      if (typeof value === "string") {
        return expectLong(parseNumber(value));
      }
      return expectLong(value);
    };
    strictParseInt = strictParseLong;
    strictParseInt32 = (value) => {
      if (typeof value === "string") {
        return expectInt32(parseNumber(value));
      }
      return expectInt32(value);
    };
    strictParseShort = (value) => {
      if (typeof value === "string") {
        return expectShort(parseNumber(value));
      }
      return expectShort(value);
    };
    strictParseByte = (value) => {
      if (typeof value === "string") {
        return expectByte(parseNumber(value));
      }
      return expectByte(value);
    };
    stackTraceWarning = (message) => {
      return String(new TypeError(message).stack || message).split("\n").slice(0, 5).filter((s4) => !s4.includes("stackTraceWarning")).join("\n");
    };
    logger = {
      warn: console.warn
    };
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/serde/date-utils.js
function dateToUtcString(date3) {
  const year2 = date3.getUTCFullYear();
  const month = date3.getUTCMonth();
  const dayOfWeek = date3.getUTCDay();
  const dayOfMonthInt = date3.getUTCDate();
  const hoursInt = date3.getUTCHours();
  const minutesInt = date3.getUTCMinutes();
  const secondsInt = date3.getUTCSeconds();
  const dayOfMonthString = dayOfMonthInt < 10 ? `0${dayOfMonthInt}` : `${dayOfMonthInt}`;
  const hoursString = hoursInt < 10 ? `0${hoursInt}` : `${hoursInt}`;
  const minutesString = minutesInt < 10 ? `0${minutesInt}` : `${minutesInt}`;
  const secondsString = secondsInt < 10 ? `0${secondsInt}` : `${secondsInt}`;
  return `${DAYS[dayOfWeek]}, ${dayOfMonthString} ${MONTHS[month]} ${year2} ${hoursString}:${minutesString}:${secondsString} GMT`;
}
var DAYS, MONTHS, RFC3339, parseRfc3339DateTime, RFC3339_WITH_OFFSET, parseRfc3339DateTimeWithOffset, IMF_FIXDATE, RFC_850_DATE, ASC_TIME, parseRfc7231DateTime, parseEpochTimestamp, buildDate, parseTwoDigitYear, FIFTY_YEARS_IN_MILLIS, adjustRfc850Year, parseMonthByShortName, DAYS_IN_MONTH, validateDayOfMonth, isLeapYear, parseDateValue, parseMilliseconds, parseOffsetToMilliseconds, stripLeadingZeroes;
var init_date_utils = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/serde/date-utils.js"() {
    init_parse_utils();
    DAYS = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
    MONTHS = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    RFC3339 = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/);
    parseRfc3339DateTime = (value) => {
      if (value === null || value === void 0) {
        return void 0;
      }
      if (typeof value !== "string") {
        throw new TypeError("RFC-3339 date-times must be expressed as strings");
      }
      const match = RFC3339.exec(value);
      if (!match) {
        throw new TypeError("Invalid RFC-3339 date-time value");
      }
      const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds] = match;
      const year2 = strictParseShort(stripLeadingZeroes(yearStr));
      const month = parseDateValue(monthStr, "month", 1, 12);
      const day = parseDateValue(dayStr, "day", 1, 31);
      return buildDate(year2, month, day, { hours, minutes, seconds, fractionalMilliseconds });
    };
    RFC3339_WITH_OFFSET = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/);
    parseRfc3339DateTimeWithOffset = (value) => {
      if (value === null || value === void 0) {
        return void 0;
      }
      if (typeof value !== "string") {
        throw new TypeError("RFC-3339 date-times must be expressed as strings");
      }
      const match = RFC3339_WITH_OFFSET.exec(value);
      if (!match) {
        throw new TypeError("Invalid RFC-3339 date-time value");
      }
      const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, offsetStr] = match;
      const year2 = strictParseShort(stripLeadingZeroes(yearStr));
      const month = parseDateValue(monthStr, "month", 1, 12);
      const day = parseDateValue(dayStr, "day", 1, 31);
      const date3 = buildDate(year2, month, day, { hours, minutes, seconds, fractionalMilliseconds });
      if (offsetStr.toUpperCase() != "Z") {
        date3.setTime(date3.getTime() - parseOffsetToMilliseconds(offsetStr));
      }
      return date3;
    };
    IMF_FIXDATE = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
    RFC_850_DATE = new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
    ASC_TIME = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/);
    parseRfc7231DateTime = (value) => {
      if (value === null || value === void 0) {
        return void 0;
      }
      if (typeof value !== "string") {
        throw new TypeError("RFC-7231 date-times must be expressed as strings");
      }
      let match = IMF_FIXDATE.exec(value);
      if (match) {
        const [_, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
        return buildDate(strictParseShort(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr, "day", 1, 31), { hours, minutes, seconds, fractionalMilliseconds });
      }
      match = RFC_850_DATE.exec(value);
      if (match) {
        const [_, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
        return adjustRfc850Year(buildDate(parseTwoDigitYear(yearStr), parseMonthByShortName(monthStr), parseDateValue(dayStr, "day", 1, 31), {
          hours,
          minutes,
          seconds,
          fractionalMilliseconds
        }));
      }
      match = ASC_TIME.exec(value);
      if (match) {
        const [_, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, yearStr] = match;
        return buildDate(strictParseShort(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr.trimLeft(), "day", 1, 31), { hours, minutes, seconds, fractionalMilliseconds });
      }
      throw new TypeError("Invalid RFC-7231 date-time value");
    };
    parseEpochTimestamp = (value) => {
      if (value === null || value === void 0) {
        return void 0;
      }
      let valueAsDouble;
      if (typeof value === "number") {
        valueAsDouble = value;
      } else if (typeof value === "string") {
        valueAsDouble = strictParseDouble(value);
      } else if (typeof value === "object" && value.tag === 1) {
        valueAsDouble = value.value;
      } else {
        throw new TypeError("Epoch timestamps must be expressed as floating point numbers or their string representation");
      }
      if (Number.isNaN(valueAsDouble) || valueAsDouble === Infinity || valueAsDouble === -Infinity) {
        throw new TypeError("Epoch timestamps must be valid, non-Infinite, non-NaN numerics");
      }
      return new Date(Math.round(valueAsDouble * 1e3));
    };
    buildDate = (year2, month, day, time2) => {
      const adjustedMonth = month - 1;
      validateDayOfMonth(year2, adjustedMonth, day);
      return new Date(Date.UTC(year2, adjustedMonth, day, parseDateValue(time2.hours, "hour", 0, 23), parseDateValue(time2.minutes, "minute", 0, 59), parseDateValue(time2.seconds, "seconds", 0, 60), parseMilliseconds(time2.fractionalMilliseconds)));
    };
    parseTwoDigitYear = (value) => {
      const thisYear = (/* @__PURE__ */ new Date()).getUTCFullYear();
      const valueInThisCentury = Math.floor(thisYear / 100) * 100 + strictParseShort(stripLeadingZeroes(value));
      if (valueInThisCentury < thisYear) {
        return valueInThisCentury + 100;
      }
      return valueInThisCentury;
    };
    FIFTY_YEARS_IN_MILLIS = 50 * 365 * 24 * 60 * 60 * 1e3;
    adjustRfc850Year = (input) => {
      if (input.getTime() - (/* @__PURE__ */ new Date()).getTime() > FIFTY_YEARS_IN_MILLIS) {
        return new Date(Date.UTC(input.getUTCFullYear() - 100, input.getUTCMonth(), input.getUTCDate(), input.getUTCHours(), input.getUTCMinutes(), input.getUTCSeconds(), input.getUTCMilliseconds()));
      }
      return input;
    };
    parseMonthByShortName = (value) => {
      const monthIdx = MONTHS.indexOf(value);
      if (monthIdx < 0) {
        throw new TypeError(`Invalid month: ${value}`);
      }
      return monthIdx + 1;
    };
    DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    validateDayOfMonth = (year2, month, day) => {
      let maxDays = DAYS_IN_MONTH[month];
      if (month === 1 && isLeapYear(year2)) {
        maxDays = 29;
      }
      if (day > maxDays) {
        throw new TypeError(`Invalid day for ${MONTHS[month]} in ${year2}: ${day}`);
      }
    };
    isLeapYear = (year2) => {
      return year2 % 4 === 0 && (year2 % 100 !== 0 || year2 % 400 === 0);
    };
    parseDateValue = (value, type, lower, upper) => {
      const dateVal = strictParseByte(stripLeadingZeroes(value));
      if (dateVal < lower || dateVal > upper) {
        throw new TypeError(`${type} must be between ${lower} and ${upper}, inclusive`);
      }
      return dateVal;
    };
    parseMilliseconds = (value) => {
      if (value === null || value === void 0) {
        return 0;
      }
      return strictParseFloat32("0." + value) * 1e3;
    };
    parseOffsetToMilliseconds = (value) => {
      const directionStr = value[0];
      let direction = 1;
      if (directionStr == "+") {
        direction = 1;
      } else if (directionStr == "-") {
        direction = -1;
      } else {
        throw new TypeError(`Offset direction, ${directionStr}, must be "+" or "-"`);
      }
      const hour = Number(value.substring(1, 3));
      const minute = Number(value.substring(4, 6));
      return direction * (hour * 60 + minute) * 60 * 1e3;
    };
    stripLeadingZeroes = (value) => {
      let idx = 0;
      while (idx < value.length - 1 && value.charAt(idx) === "0") {
        idx++;
      }
      if (idx === 0) {
        return value;
      }
      return value.slice(idx);
    };
  }
});

// node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs
var tslib_es6_exports = {};
__export(tslib_es6_exports, {
  __addDisposableResource: () => __addDisposableResource,
  __assign: () => __assign,
  __asyncDelegator: () => __asyncDelegator,
  __asyncGenerator: () => __asyncGenerator,
  __asyncValues: () => __asyncValues,
  __await: () => __await,
  __awaiter: () => __awaiter,
  __classPrivateFieldGet: () => __classPrivateFieldGet,
  __classPrivateFieldIn: () => __classPrivateFieldIn,
  __classPrivateFieldSet: () => __classPrivateFieldSet,
  __createBinding: () => __createBinding,
  __decorate: () => __decorate,
  __disposeResources: () => __disposeResources,
  __esDecorate: () => __esDecorate,
  __exportStar: () => __exportStar,
  __extends: () => __extends,
  __generator: () => __generator,
  __importDefault: () => __importDefault,
  __importStar: () => __importStar,
  __makeTemplateObject: () => __makeTemplateObject,
  __metadata: () => __metadata,
  __param: () => __param,
  __propKey: () => __propKey,
  __read: () => __read,
  __rest: () => __rest,
  __rewriteRelativeImportExtension: () => __rewriteRelativeImportExtension,
  __runInitializers: () => __runInitializers,
  __setFunctionName: () => __setFunctionName,
  __spread: () => __spread,
  __spreadArray: () => __spreadArray,
  __spreadArrays: () => __spreadArrays,
  __values: () => __values,
  default: () => tslib_es6_default
});
function __extends(d4, b4) {
  if (typeof b4 !== "function" && b4 !== null)
    throw new TypeError("Class extends value " + String(b4) + " is not a constructor or null");
  extendStatics(d4, b4);
  function __() {
    this.constructor = d4;
  }
  d4.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
}
function __rest(s4, e4) {
  var t4 = {};
  for (var p4 in s4) if (Object.prototype.hasOwnProperty.call(s4, p4) && e4.indexOf(p4) < 0)
    t4[p4] = s4[p4];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i4 = 0, p4 = Object.getOwnPropertySymbols(s4); i4 < p4.length; i4++) {
      if (e4.indexOf(p4[i4]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p4[i4]))
        t4[p4[i4]] = s4[p4[i4]];
    }
  return t4;
}
function __decorate(decorators, target, key, desc) {
  var c4 = arguments.length, r4 = c4 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d4;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r4 = Reflect.decorate(decorators, target, key, desc);
  else for (var i4 = decorators.length - 1; i4 >= 0; i4--) if (d4 = decorators[i4]) r4 = (c4 < 3 ? d4(r4) : c4 > 3 ? d4(target, key, r4) : d4(target, key)) || r4;
  return c4 > 3 && r4 && Object.defineProperty(target, key, r4), r4;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f4) {
    if (f4 !== void 0 && typeof f4 !== "function") throw new TypeError("Function expected");
    return f4;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i4 = decorators.length - 1; i4 >= 0; i4--) {
    var context = {};
    for (var p4 in contextIn) context[p4] = p4 === "access" ? {} : contextIn[p4];
    for (var p4 in contextIn.access) context.access[p4] = contextIn.access[p4];
    context.addInitializer = function(f4) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f4 || null));
    };
    var result = (0, decorators[i4])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i4 = 0; i4 < initializers.length; i4++) {
    value = useValue ? initializers[i4].call(thisArg, value) : initializers[i4].call(thisArg);
  }
  return useValue ? value : void 0;
}
function __propKey(x4) {
  return typeof x4 === "symbol" ? x4 : "".concat(x4);
}
function __setFunctionName(f4, name, prefix) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f4, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e4) {
        reject(e4);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e4) {
        reject(e4);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body2) {
  var _ = { label: 0, sent: function() {
    if (t4[0] & 1) throw t4[1];
    return t4[1];
  }, trys: [], ops: [] }, f4, y2, t4, g4 = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g4.next = verb(0), g4["throw"] = verb(1), g4["return"] = verb(2), typeof Symbol === "function" && (g4[Symbol.iterator] = function() {
    return this;
  }), g4;
  function verb(n4) {
    return function(v4) {
      return step([n4, v4]);
    };
  }
  function step(op2) {
    if (f4) throw new TypeError("Generator is already executing.");
    while (g4 && (g4 = 0, op2[0] && (_ = 0)), _) try {
      if (f4 = 1, y2 && (t4 = op2[0] & 2 ? y2["return"] : op2[0] ? y2["throw"] || ((t4 = y2["return"]) && t4.call(y2), 0) : y2.next) && !(t4 = t4.call(y2, op2[1])).done) return t4;
      if (y2 = 0, t4) op2 = [op2[0] & 2, t4.value];
      switch (op2[0]) {
        case 0:
        case 1:
          t4 = op2;
          break;
        case 4:
          _.label++;
          return { value: op2[1], done: false };
        case 5:
          _.label++;
          y2 = op2[1];
          op2 = [0];
          continue;
        case 7:
          op2 = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t4 = _.trys, t4 = t4.length > 0 && t4[t4.length - 1]) && (op2[0] === 6 || op2[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op2[0] === 3 && (!t4 || op2[1] > t4[0] && op2[1] < t4[3])) {
            _.label = op2[1];
            break;
          }
          if (op2[0] === 6 && _.label < t4[1]) {
            _.label = t4[1];
            t4 = op2;
            break;
          }
          if (t4 && _.label < t4[2]) {
            _.label = t4[2];
            _.ops.push(op2);
            break;
          }
          if (t4[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op2 = body2.call(thisArg, _);
    } catch (e4) {
      op2 = [6, e4];
      y2 = 0;
    } finally {
      f4 = t4 = 0;
    }
    if (op2[0] & 5) throw op2[1];
    return { value: op2[0] ? op2[1] : void 0, done: true };
  }
}
function __exportStar(m4, o4) {
  for (var p4 in m4) if (p4 !== "default" && !Object.prototype.hasOwnProperty.call(o4, p4)) __createBinding(o4, m4, p4);
}
function __values(o4) {
  var s4 = typeof Symbol === "function" && Symbol.iterator, m4 = s4 && o4[s4], i4 = 0;
  if (m4) return m4.call(o4);
  if (o4 && typeof o4.length === "number") return {
    next: function() {
      if (o4 && i4 >= o4.length) o4 = void 0;
      return { value: o4 && o4[i4++], done: !o4 };
    }
  };
  throw new TypeError(s4 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o4, n4) {
  var m4 = typeof Symbol === "function" && o4[Symbol.iterator];
  if (!m4) return o4;
  var i4 = m4.call(o4), r4, ar = [], e4;
  try {
    while ((n4 === void 0 || n4-- > 0) && !(r4 = i4.next()).done) ar.push(r4.value);
  } catch (error2) {
    e4 = { error: error2 };
  } finally {
    try {
      if (r4 && !r4.done && (m4 = i4["return"])) m4.call(i4);
    } finally {
      if (e4) throw e4.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i4 = 0; i4 < arguments.length; i4++)
    ar = ar.concat(__read(arguments[i4]));
  return ar;
}
function __spreadArrays() {
  for (var s4 = 0, i4 = 0, il = arguments.length; i4 < il; i4++) s4 += arguments[i4].length;
  for (var r4 = Array(s4), k4 = 0, i4 = 0; i4 < il; i4++)
    for (var a4 = arguments[i4], j4 = 0, jl = a4.length; j4 < jl; j4++, k4++)
      r4[k4] = a4[j4];
  return r4;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i4 = 0, l4 = from.length, ar; i4 < l4; i4++) {
    if (ar || !(i4 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i4);
      ar[i4] = from[i4];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v4) {
  return this instanceof __await ? (this.v = v4, this) : new __await(v4);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g4 = generator.apply(thisArg, _arguments || []), i4, q4 = [];
  return i4 = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i4[Symbol.asyncIterator] = function() {
    return this;
  }, i4;
  function awaitReturn(f4) {
    return function(v4) {
      return Promise.resolve(v4).then(f4, reject);
    };
  }
  function verb(n4, f4) {
    if (g4[n4]) {
      i4[n4] = function(v4) {
        return new Promise(function(a4, b4) {
          q4.push([n4, v4, a4, b4]) > 1 || resume(n4, v4);
        });
      };
      if (f4) i4[n4] = f4(i4[n4]);
    }
  }
  function resume(n4, v4) {
    try {
      step(g4[n4](v4));
    } catch (e4) {
      settle(q4[0][3], e4);
    }
  }
  function step(r4) {
    r4.value instanceof __await ? Promise.resolve(r4.value.v).then(fulfill, reject) : settle(q4[0][2], r4);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f4, v4) {
    if (f4(v4), q4.shift(), q4.length) resume(q4[0][0], q4[0][1]);
  }
}
function __asyncDelegator(o4) {
  var i4, p4;
  return i4 = {}, verb("next"), verb("throw", function(e4) {
    throw e4;
  }), verb("return"), i4[Symbol.iterator] = function() {
    return this;
  }, i4;
  function verb(n4, f4) {
    i4[n4] = o4[n4] ? function(v4) {
      return (p4 = !p4) ? { value: __await(o4[n4](v4)), done: false } : f4 ? f4(v4) : v4;
    } : f4;
  }
}
function __asyncValues(o4) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m4 = o4[Symbol.asyncIterator], i4;
  return m4 ? m4.call(o4) : (o4 = typeof __values === "function" ? __values(o4) : o4[Symbol.iterator](), i4 = {}, verb("next"), verb("throw"), verb("return"), i4[Symbol.asyncIterator] = function() {
    return this;
  }, i4);
  function verb(n4) {
    i4[n4] = o4[n4] && function(v4) {
      return new Promise(function(resolve, reject) {
        v4 = o4[n4](v4), settle(resolve, reject, v4.done, v4.value);
      });
    };
  }
  function settle(resolve, reject, d4, v4) {
    Promise.resolve(v4).then(function(v5) {
      resolve({ value: v5, done: d4 });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k4 = ownKeys(mod), i4 = 0; i4 < k4.length; i4++) if (k4[i4] !== "default") __createBinding(result, mod, k4[i4]);
  }
  __setModuleDefault(result, mod);
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver2, state2, kind, f4) {
  if (kind === "a" && !f4) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state2 === "function" ? receiver2 !== state2 || !f4 : !state2.has(receiver2)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f4 : kind === "a" ? f4.call(receiver2) : f4 ? f4.value : state2.get(receiver2);
}
function __classPrivateFieldSet(receiver2, state2, value, kind, f4) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f4) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state2 === "function" ? receiver2 !== state2 || !f4 : !state2.has(receiver2)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f4.call(receiver2, value) : f4 ? f4.value = value : state2.set(receiver2, value), value;
}
function __classPrivateFieldIn(state2, receiver2) {
  if (receiver2 === null || typeof receiver2 !== "object" && typeof receiver2 !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state2 === "function" ? receiver2 === state2 : state2.has(receiver2);
}
function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() {
      try {
        inner.call(this);
      } catch (e4) {
        return Promise.reject(e4);
      }
    };
    env.stack.push({ value, dispose, async });
  } else if (async) {
    env.stack.push({ async: true });
  }
  return value;
}
function __disposeResources(env) {
  function fail(e4) {
    env.error = env.hasError ? new _SuppressedError(e4, env.error, "An error was suppressed during disposal.") : e4;
    env.hasError = true;
  }
  var r4, s4 = 0;
  function next() {
    while (r4 = env.stack.pop()) {
      try {
        if (!r4.async && s4 === 1) return s4 = 0, env.stack.push(r4), Promise.resolve().then(next);
        if (r4.dispose) {
          var result = r4.dispose.call(r4.value);
          if (r4.async) return s4 |= 2, Promise.resolve(result).then(next, function(e4) {
            fail(e4);
            return next();
          });
        } else s4 |= 1;
      } catch (e4) {
        fail(e4);
      }
    }
    if (s4 === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
    if (env.hasError) throw env.error;
  }
  return next();
}
function __rewriteRelativeImportExtension(path3, preserveJsx) {
  if (typeof path3 === "string" && /^\.\.?\//.test(path3)) {
    return path3.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m4, tsx, d4, ext, cm) {
      return tsx ? preserveJsx ? ".jsx" : ".js" : d4 && (!ext || !cm) ? m4 : d4 + ext + "." + cm.toLowerCase() + "js";
    });
  }
  return path3;
}
var extendStatics, __assign, __createBinding, __setModuleDefault, ownKeys, _SuppressedError, tslib_es6_default;
var init_tslib_es6 = __esm({
  "node_modules/.pnpm/tslib@2.8.1/node_modules/tslib/tslib.es6.mjs"() {
    extendStatics = function(d4, b4) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b5) {
        d5.__proto__ = b5;
      } || function(d5, b5) {
        for (var p4 in b5) if (Object.prototype.hasOwnProperty.call(b5, p4)) d5[p4] = b5[p4];
      };
      return extendStatics(d4, b4);
    };
    __assign = function() {
      __assign = Object.assign || function __assign2(t4) {
        for (var s4, i4 = 1, n4 = arguments.length; i4 < n4; i4++) {
          s4 = arguments[i4];
          for (var p4 in s4) if (Object.prototype.hasOwnProperty.call(s4, p4)) t4[p4] = s4[p4];
        }
        return t4;
      };
      return __assign.apply(this, arguments);
    };
    __createBinding = Object.create ? (function(o4, m4, k4, k22) {
      if (k22 === void 0) k22 = k4;
      var desc = Object.getOwnPropertyDescriptor(m4, k4);
      if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m4[k4];
        } };
      }
      Object.defineProperty(o4, k22, desc);
    }) : (function(o4, m4, k4, k22) {
      if (k22 === void 0) k22 = k4;
      o4[k22] = m4[k4];
    });
    __setModuleDefault = Object.create ? (function(o4, v4) {
      Object.defineProperty(o4, "default", { enumerable: true, value: v4 });
    }) : function(o4, v4) {
      o4["default"] = v4;
    };
    ownKeys = function(o4) {
      ownKeys = Object.getOwnPropertyNames || function(o5) {
        var ar = [];
        for (var k4 in o5) if (Object.prototype.hasOwnProperty.call(o5, k4)) ar[ar.length] = k4;
        return ar;
      };
      return ownKeys(o4);
    };
    _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error2, suppressed, message) {
      var e4 = new Error(message);
      return e4.name = "SuppressedError", e4.error = error2, e4.suppressed = suppressed, e4;
    };
    tslib_es6_default = {
      __extends,
      __assign,
      __rest,
      __decorate,
      __param,
      __esDecorate,
      __runInitializers,
      __propKey,
      __setFunctionName,
      __metadata,
      __awaiter,
      __generator,
      __createBinding,
      __exportStar,
      __values,
      __read,
      __spread,
      __spreadArrays,
      __spreadArray,
      __await,
      __asyncGenerator,
      __asyncDelegator,
      __asyncValues,
      __makeTemplateObject,
      __importStar,
      __importDefault,
      __classPrivateFieldGet,
      __classPrivateFieldSet,
      __classPrivateFieldIn,
      __addDisposableResource,
      __disposeResources,
      __rewriteRelativeImportExtension
    };
  }
});

// node_modules/.pnpm/@smithy+uuid@1.1.0/node_modules/@smithy/uuid/dist-cjs/randomUUID.js
var require_randomUUID = __commonJS({
  "node_modules/.pnpm/@smithy+uuid@1.1.0/node_modules/@smithy/uuid/dist-cjs/randomUUID.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.randomUUID = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var crypto_1 = tslib_1.__importDefault(require("crypto"));
    exports2.randomUUID = crypto_1.default.randomUUID.bind(crypto_1.default);
  }
});

// node_modules/.pnpm/@smithy+uuid@1.1.0/node_modules/@smithy/uuid/dist-cjs/index.js
var require_dist_cjs16 = __commonJS({
  "node_modules/.pnpm/@smithy+uuid@1.1.0/node_modules/@smithy/uuid/dist-cjs/index.js"(exports2) {
    "use strict";
    var randomUUID = require_randomUUID();
    var decimalToHex = Array.from({ length: 256 }, (_, i4) => i4.toString(16).padStart(2, "0"));
    var v4 = () => {
      if (randomUUID.randomUUID) {
        return randomUUID.randomUUID();
      }
      const rnds = new Uint8Array(16);
      crypto.getRandomValues(rnds);
      rnds[6] = rnds[6] & 15 | 64;
      rnds[8] = rnds[8] & 63 | 128;
      return decimalToHex[rnds[0]] + decimalToHex[rnds[1]] + decimalToHex[rnds[2]] + decimalToHex[rnds[3]] + "-" + decimalToHex[rnds[4]] + decimalToHex[rnds[5]] + "-" + decimalToHex[rnds[6]] + decimalToHex[rnds[7]] + "-" + decimalToHex[rnds[8]] + decimalToHex[rnds[9]] + "-" + decimalToHex[rnds[10]] + decimalToHex[rnds[11]] + decimalToHex[rnds[12]] + decimalToHex[rnds[13]] + decimalToHex[rnds[14]] + decimalToHex[rnds[15]];
    };
    exports2.v4 = v4;
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/serde/generateIdempotencyToken.js
var import_uuid;
var init_generateIdempotencyToken = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/serde/generateIdempotencyToken.js"() {
    import_uuid = __toESM(require_dist_cjs16());
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/serde/lazy-json.js
var LazyJsonString;
var init_lazy_json = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/serde/lazy-json.js"() {
    LazyJsonString = function LazyJsonString2(val) {
      const str = Object.assign(new String(val), {
        deserializeJSON() {
          return JSON.parse(String(val));
        },
        toString() {
          return String(val);
        },
        toJSON() {
          return String(val);
        }
      });
      return str;
    };
    LazyJsonString.from = (object) => {
      if (object && typeof object === "object" && (object instanceof LazyJsonString || "deserializeJSON" in object)) {
        return object;
      } else if (typeof object === "string" || Object.getPrototypeOf(object) === String.prototype) {
        return LazyJsonString(String(object));
      }
      return LazyJsonString(JSON.stringify(object));
    };
    LazyJsonString.fromObject = LazyJsonString.from;
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/serde/quote-header.js
function quoteHeader(part) {
  if (part.includes(",") || part.includes('"')) {
    part = `"${part.replace(/"/g, '\\"')}"`;
  }
  return part;
}
var init_quote_header = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/serde/quote-header.js"() {
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/serde/schema-serde-lib/schema-date-utils.js
function range(v4, min, max) {
  const _v = Number(v4);
  if (_v < min || _v > max) {
    throw new Error(`Value ${_v} out of range [${min}, ${max}]`);
  }
}
var ddd, mmm, time, date, year, RFC3339_WITH_OFFSET2, IMF_FIXDATE2, RFC_850_DATE2, ASC_TIME2, months, _parseEpochTimestamp, _parseRfc3339DateTimeWithOffset, _parseRfc7231DateTime;
var init_schema_date_utils = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/serde/schema-serde-lib/schema-date-utils.js"() {
    ddd = `(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun)(?:[ne|u?r]?s?day)?`;
    mmm = `(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)`;
    time = `(\\d?\\d):(\\d{2}):(\\d{2})(?:\\.(\\d+))?`;
    date = `(\\d?\\d)`;
    year = `(\\d{4})`;
    RFC3339_WITH_OFFSET2 = new RegExp(/^(\d{4})-(\d\d)-(\d\d)[tT](\d\d):(\d\d):(\d\d)(\.(\d+))?(([-+]\d\d:\d\d)|[zZ])$/);
    IMF_FIXDATE2 = new RegExp(`^${ddd}, ${date} ${mmm} ${year} ${time} GMT$`);
    RFC_850_DATE2 = new RegExp(`^${ddd}, ${date}-${mmm}-(\\d\\d) ${time} GMT$`);
    ASC_TIME2 = new RegExp(`^${ddd} ${mmm} ( [1-9]|\\d\\d) ${time} ${year}$`);
    months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    _parseEpochTimestamp = (value) => {
      if (value == null) {
        return void 0;
      }
      let num = NaN;
      if (typeof value === "number") {
        num = value;
      } else if (typeof value === "string") {
        if (!/^-?\d*\.?\d+$/.test(value)) {
          throw new TypeError(`parseEpochTimestamp - numeric string invalid.`);
        }
        num = Number.parseFloat(value);
      } else if (typeof value === "object" && value.tag === 1) {
        num = value.value;
      }
      if (isNaN(num) || Math.abs(num) === Infinity) {
        throw new TypeError("Epoch timestamps must be valid finite numbers.");
      }
      return new Date(Math.round(num * 1e3));
    };
    _parseRfc3339DateTimeWithOffset = (value) => {
      if (value == null) {
        return void 0;
      }
      if (typeof value !== "string") {
        throw new TypeError("RFC3339 timestamps must be strings");
      }
      const matches = RFC3339_WITH_OFFSET2.exec(value);
      if (!matches) {
        throw new TypeError(`Invalid RFC3339 timestamp format ${value}`);
      }
      const [, yearStr, monthStr, dayStr, hours, minutes, seconds, , ms, offsetStr] = matches;
      range(monthStr, 1, 12);
      range(dayStr, 1, 31);
      range(hours, 0, 23);
      range(minutes, 0, 59);
      range(seconds, 0, 60);
      const date3 = new Date(Date.UTC(Number(yearStr), Number(monthStr) - 1, Number(dayStr), Number(hours), Number(minutes), Number(seconds), Number(ms) ? Math.round(parseFloat(`0.${ms}`) * 1e3) : 0));
      date3.setUTCFullYear(Number(yearStr));
      if (offsetStr.toUpperCase() != "Z") {
        const [, sign, offsetH, offsetM] = /([+-])(\d\d):(\d\d)/.exec(offsetStr) || [void 0, "+", 0, 0];
        const scalar = sign === "-" ? 1 : -1;
        date3.setTime(date3.getTime() + scalar * (Number(offsetH) * 60 * 60 * 1e3 + Number(offsetM) * 60 * 1e3));
      }
      return date3;
    };
    _parseRfc7231DateTime = (value) => {
      if (value == null) {
        return void 0;
      }
      if (typeof value !== "string") {
        throw new TypeError("RFC7231 timestamps must be strings.");
      }
      let day;
      let month;
      let year2;
      let hour;
      let minute;
      let second;
      let fraction;
      let matches;
      if (matches = IMF_FIXDATE2.exec(value)) {
        [, day, month, year2, hour, minute, second, fraction] = matches;
      } else if (matches = RFC_850_DATE2.exec(value)) {
        [, day, month, year2, hour, minute, second, fraction] = matches;
        year2 = (Number(year2) + 1900).toString();
      } else if (matches = ASC_TIME2.exec(value)) {
        [, month, day, hour, minute, second, fraction, year2] = matches;
      }
      if (year2 && second) {
        const timestamp = Date.UTC(Number(year2), months.indexOf(month), Number(day), Number(hour), Number(minute), Number(second), fraction ? Math.round(parseFloat(`0.${fraction}`) * 1e3) : 0);
        range(day, 1, 31);
        range(hour, 0, 23);
        range(minute, 0, 59);
        range(second, 0, 60);
        const date3 = new Date(timestamp);
        date3.setUTCFullYear(Number(year2));
        return date3;
      }
      throw new TypeError(`Invalid RFC7231 date-time value ${value}.`);
    };
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/serde/split-every.js
function splitEvery(value, delimiter, numDelimiters) {
  if (numDelimiters <= 0 || !Number.isInteger(numDelimiters)) {
    throw new Error("Invalid number of delimiters (" + numDelimiters + ") for splitEvery.");
  }
  const segments = value.split(delimiter);
  if (numDelimiters === 1) {
    return segments;
  }
  const compoundSegments = [];
  let currentSegment = "";
  for (let i4 = 0; i4 < segments.length; i4++) {
    if (currentSegment === "") {
      currentSegment = segments[i4];
    } else {
      currentSegment += delimiter + segments[i4];
    }
    if ((i4 + 1) % numDelimiters === 0) {
      compoundSegments.push(currentSegment);
      currentSegment = "";
    }
  }
  if (currentSegment !== "") {
    compoundSegments.push(currentSegment);
  }
  return compoundSegments;
}
var init_split_every = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/serde/split-every.js"() {
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/serde/split-header.js
var splitHeader;
var init_split_header = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/serde/split-header.js"() {
    splitHeader = (value) => {
      const z2 = value.length;
      const values = [];
      let withinQuotes = false;
      let prevChar = void 0;
      let anchor = 0;
      for (let i4 = 0; i4 < z2; ++i4) {
        const char = value[i4];
        switch (char) {
          case `"`:
            if (prevChar !== "\\") {
              withinQuotes = !withinQuotes;
            }
            break;
          case ",":
            if (!withinQuotes) {
              values.push(value.slice(anchor, i4));
              anchor = i4 + 1;
            }
            break;
          default:
        }
        prevChar = char;
      }
      values.push(value.slice(anchor));
      return values.map((v4) => {
        v4 = v4.trim();
        const z3 = v4.length;
        if (z3 < 2) {
          return v4;
        }
        if (v4[0] === `"` && v4[z3 - 1] === `"`) {
          v4 = v4.slice(1, z3 - 1);
        }
        return v4.replace(/\\"/g, '"');
      });
    };
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/serde/value/NumericValue.js
function nv(input) {
  return new NumericValue(String(input), "bigDecimal");
}
var format, NumericValue;
var init_NumericValue = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/serde/value/NumericValue.js"() {
    format = /^-?\d*(\.\d+)?$/;
    NumericValue = class _NumericValue {
      string;
      type;
      constructor(string, type) {
        this.string = string;
        this.type = type;
        if (!format.test(string)) {
          throw new Error(`@smithy/core/serde - NumericValue must only contain [0-9], at most one decimal point ".", and an optional negation prefix "-".`);
        }
      }
      toString() {
        return this.string;
      }
      static [Symbol.hasInstance](object) {
        if (!object || typeof object !== "object") {
          return false;
        }
        const _nv = object;
        return _NumericValue.prototype.isPrototypeOf(object) || _nv.type === "bigDecimal" && format.test(_nv.string);
      }
    };
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/serde/index.js
var serde_exports = {};
__export(serde_exports, {
  LazyJsonString: () => LazyJsonString,
  NumericValue: () => NumericValue,
  _parseEpochTimestamp: () => _parseEpochTimestamp,
  _parseRfc3339DateTimeWithOffset: () => _parseRfc3339DateTimeWithOffset,
  _parseRfc7231DateTime: () => _parseRfc7231DateTime,
  copyDocumentWithTransform: () => copyDocumentWithTransform,
  dateToUtcString: () => dateToUtcString,
  expectBoolean: () => expectBoolean,
  expectByte: () => expectByte,
  expectFloat32: () => expectFloat32,
  expectInt: () => expectInt,
  expectInt32: () => expectInt32,
  expectLong: () => expectLong,
  expectNonNull: () => expectNonNull,
  expectNumber: () => expectNumber,
  expectObject: () => expectObject,
  expectShort: () => expectShort,
  expectString: () => expectString,
  expectUnion: () => expectUnion,
  generateIdempotencyToken: () => import_uuid.v4,
  handleFloat: () => handleFloat,
  limitedParseDouble: () => limitedParseDouble,
  limitedParseFloat: () => limitedParseFloat,
  limitedParseFloat32: () => limitedParseFloat32,
  logger: () => logger,
  nv: () => nv,
  parseBoolean: () => parseBoolean,
  parseEpochTimestamp: () => parseEpochTimestamp,
  parseRfc3339DateTime: () => parseRfc3339DateTime,
  parseRfc3339DateTimeWithOffset: () => parseRfc3339DateTimeWithOffset,
  parseRfc7231DateTime: () => parseRfc7231DateTime,
  quoteHeader: () => quoteHeader,
  splitEvery: () => splitEvery,
  splitHeader: () => splitHeader,
  strictParseByte: () => strictParseByte,
  strictParseDouble: () => strictParseDouble,
  strictParseFloat: () => strictParseFloat,
  strictParseFloat32: () => strictParseFloat32,
  strictParseInt: () => strictParseInt,
  strictParseInt32: () => strictParseInt32,
  strictParseLong: () => strictParseLong,
  strictParseShort: () => strictParseShort
});
var init_serde = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/serde/index.js"() {
    init_copyDocumentWithTransform();
    init_date_utils();
    init_generateIdempotencyToken();
    init_lazy_json();
    init_parse_utils();
    init_quote_header();
    init_schema_date_utils();
    init_split_every();
    init_split_header();
    init_NumericValue();
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/protocols/SerdeContext.js
var SerdeContext;
var init_SerdeContext = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/protocols/SerdeContext.js"() {
    SerdeContext = class {
      serdeContext;
      setSerdeContext(serdeContext) {
        this.serdeContext = serdeContext;
      }
    };
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/event-streams/EventStreamSerde.js
var import_util_utf8, EventStreamSerde;
var init_EventStreamSerde = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/event-streams/EventStreamSerde.js"() {
    import_util_utf8 = __toESM(require_dist_cjs8());
    EventStreamSerde = class {
      marshaller;
      serializer;
      deserializer;
      serdeContext;
      defaultContentType;
      constructor({ marshaller, serializer, deserializer, serdeContext, defaultContentType }) {
        this.marshaller = marshaller;
        this.serializer = serializer;
        this.deserializer = deserializer;
        this.serdeContext = serdeContext;
        this.defaultContentType = defaultContentType;
      }
      async serializeEventStream({ eventStream, requestSchema, initialRequest }) {
        const marshaller = this.marshaller;
        const eventStreamMember = requestSchema.getEventStreamMember();
        const unionSchema = requestSchema.getMemberSchema(eventStreamMember);
        const serializer = this.serializer;
        const defaultContentType = this.defaultContentType;
        const initialRequestMarker = /* @__PURE__ */ Symbol("initialRequestMarker");
        const eventStreamIterable = {
          async *[Symbol.asyncIterator]() {
            if (initialRequest) {
              const headers2 = {
                ":event-type": { type: "string", value: "initial-request" },
                ":message-type": { type: "string", value: "event" },
                ":content-type": { type: "string", value: defaultContentType }
              };
              serializer.write(requestSchema, initialRequest);
              const body2 = serializer.flush();
              yield {
                [initialRequestMarker]: true,
                headers: headers2,
                body: body2
              };
            }
            for await (const page of eventStream) {
              yield page;
            }
          }
        };
        return marshaller.serialize(eventStreamIterable, (event) => {
          if (event[initialRequestMarker]) {
            return {
              headers: event.headers,
              body: event.body
            };
          }
          const unionMember = Object.keys(event).find((key) => {
            return key !== "__type";
          }) ?? "";
          const { additionalHeaders, body: body2, eventType, explicitPayloadContentType } = this.writeEventBody(unionMember, unionSchema, event);
          const headers2 = {
            ":event-type": { type: "string", value: eventType },
            ":message-type": { type: "string", value: "event" },
            ":content-type": { type: "string", value: explicitPayloadContentType ?? defaultContentType },
            ...additionalHeaders
          };
          return {
            headers: headers2,
            body: body2
          };
        });
      }
      async deserializeEventStream({ response: response2, responseSchema, initialResponseContainer }) {
        const marshaller = this.marshaller;
        const eventStreamMember = responseSchema.getEventStreamMember();
        const unionSchema = responseSchema.getMemberSchema(eventStreamMember);
        const memberSchemas = unionSchema.getMemberSchemas();
        const initialResponseMarker = /* @__PURE__ */ Symbol("initialResponseMarker");
        const asyncIterable = marshaller.deserialize(response2.body, async (event) => {
          const unionMember = Object.keys(event).find((key) => {
            return key !== "__type";
          }) ?? "";
          const body2 = event[unionMember].body;
          if (unionMember === "initial-response") {
            const dataObject = await this.deserializer.read(responseSchema, body2);
            delete dataObject[eventStreamMember];
            return {
              [initialResponseMarker]: true,
              ...dataObject
            };
          } else if (unionMember in memberSchemas) {
            const eventStreamSchema = memberSchemas[unionMember];
            if (eventStreamSchema.isStructSchema()) {
              const out = {};
              let hasBindings = false;
              for (const [name, member2] of eventStreamSchema.structIterator()) {
                const { eventHeader, eventPayload } = member2.getMergedTraits();
                hasBindings = hasBindings || Boolean(eventHeader || eventPayload);
                if (eventPayload) {
                  if (member2.isBlobSchema()) {
                    out[name] = body2;
                  } else if (member2.isStringSchema()) {
                    out[name] = (this.serdeContext?.utf8Encoder ?? import_util_utf8.toUtf8)(body2);
                  } else if (member2.isStructSchema()) {
                    out[name] = await this.deserializer.read(member2, body2);
                  }
                } else if (eventHeader) {
                  const value = event[unionMember].headers[name]?.value;
                  if (value != null) {
                    if (member2.isNumericSchema()) {
                      if (value && typeof value === "object" && "bytes" in value) {
                        out[name] = BigInt(value.toString());
                      } else {
                        out[name] = Number(value);
                      }
                    } else {
                      out[name] = value;
                    }
                  }
                }
              }
              if (hasBindings) {
                return {
                  [unionMember]: out
                };
              }
            }
            return {
              [unionMember]: await this.deserializer.read(eventStreamSchema, body2)
            };
          } else {
            return {
              $unknown: event
            };
          }
        });
        const asyncIterator = asyncIterable[Symbol.asyncIterator]();
        const firstEvent = await asyncIterator.next();
        if (firstEvent.done) {
          return asyncIterable;
        }
        if (firstEvent.value?.[initialResponseMarker]) {
          if (!responseSchema) {
            throw new Error("@smithy::core/protocols - initial-response event encountered in event stream but no response schema given.");
          }
          for (const [key, value] of Object.entries(firstEvent.value)) {
            initialResponseContainer[key] = value;
          }
        }
        return {
          async *[Symbol.asyncIterator]() {
            if (!firstEvent?.value?.[initialResponseMarker]) {
              yield firstEvent.value;
            }
            while (true) {
              const { done, value } = await asyncIterator.next();
              if (done) {
                break;
              }
              yield value;
            }
          }
        };
      }
      writeEventBody(unionMember, unionSchema, event) {
        const serializer = this.serializer;
        let eventType = unionMember;
        let explicitPayloadMember = null;
        let explicitPayloadContentType;
        const isKnownSchema = (() => {
          const struct2 = unionSchema.getSchema();
          return struct2[4].includes(unionMember);
        })();
        const additionalHeaders = {};
        if (!isKnownSchema) {
          const [type, value] = event[unionMember];
          eventType = type;
          serializer.write(15, value);
        } else {
          const eventSchema = unionSchema.getMemberSchema(unionMember);
          if (eventSchema.isStructSchema()) {
            for (const [memberName, memberSchema] of eventSchema.structIterator()) {
              const { eventHeader, eventPayload } = memberSchema.getMergedTraits();
              if (eventPayload) {
                explicitPayloadMember = memberName;
              } else if (eventHeader) {
                const value = event[unionMember][memberName];
                let type = "binary";
                if (memberSchema.isNumericSchema()) {
                  if ((-2) ** 31 <= value && value <= 2 ** 31 - 1) {
                    type = "integer";
                  } else {
                    type = "long";
                  }
                } else if (memberSchema.isTimestampSchema()) {
                  type = "timestamp";
                } else if (memberSchema.isStringSchema()) {
                  type = "string";
                } else if (memberSchema.isBooleanSchema()) {
                  type = "boolean";
                }
                if (value != null) {
                  additionalHeaders[memberName] = {
                    type,
                    value
                  };
                  delete event[unionMember][memberName];
                }
              }
            }
            if (explicitPayloadMember !== null) {
              const payloadSchema = eventSchema.getMemberSchema(explicitPayloadMember);
              if (payloadSchema.isBlobSchema()) {
                explicitPayloadContentType = "application/octet-stream";
              } else if (payloadSchema.isStringSchema()) {
                explicitPayloadContentType = "text/plain";
              }
              serializer.write(payloadSchema, event[unionMember][explicitPayloadMember]);
            } else {
              serializer.write(eventSchema, event[unionMember]);
            }
          } else {
            throw new Error("@smithy/core/event-streams - non-struct member not supported in event stream union.");
          }
        }
        const messageSerialization = serializer.flush();
        const body2 = typeof messageSerialization === "string" ? (this.serdeContext?.utf8Decoder ?? import_util_utf8.fromUtf8)(messageSerialization) : messageSerialization;
        return {
          body: body2,
          eventType,
          explicitPayloadContentType,
          additionalHeaders
        };
      }
    };
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/event-streams/index.js
var event_streams_exports = {};
__export(event_streams_exports, {
  EventStreamSerde: () => EventStreamSerde
});
var init_event_streams = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/event-streams/index.js"() {
    init_EventStreamSerde();
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/protocols/HttpProtocol.js
var import_protocol_http6, HttpProtocol;
var init_HttpProtocol = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/protocols/HttpProtocol.js"() {
    init_schema();
    import_protocol_http6 = __toESM(require_dist_cjs2());
    init_SerdeContext();
    HttpProtocol = class extends SerdeContext {
      options;
      constructor(options) {
        super();
        this.options = options;
      }
      getRequestType() {
        return import_protocol_http6.HttpRequest;
      }
      getResponseType() {
        return import_protocol_http6.HttpResponse;
      }
      setSerdeContext(serdeContext) {
        this.serdeContext = serdeContext;
        this.serializer.setSerdeContext(serdeContext);
        this.deserializer.setSerdeContext(serdeContext);
        if (this.getPayloadCodec()) {
          this.getPayloadCodec().setSerdeContext(serdeContext);
        }
      }
      updateServiceEndpoint(request2, endpoint) {
        if ("url" in endpoint) {
          request2.protocol = endpoint.url.protocol;
          request2.hostname = endpoint.url.hostname;
          request2.port = endpoint.url.port ? Number(endpoint.url.port) : void 0;
          request2.path = endpoint.url.pathname;
          request2.fragment = endpoint.url.hash || void 0;
          request2.username = endpoint.url.username || void 0;
          request2.password = endpoint.url.password || void 0;
          if (!request2.query) {
            request2.query = {};
          }
          for (const [k4, v4] of endpoint.url.searchParams.entries()) {
            request2.query[k4] = v4;
          }
          return request2;
        } else {
          request2.protocol = endpoint.protocol;
          request2.hostname = endpoint.hostname;
          request2.port = endpoint.port ? Number(endpoint.port) : void 0;
          request2.path = endpoint.path;
          request2.query = {
            ...endpoint.query
          };
          return request2;
        }
      }
      setHostPrefix(request2, operationSchema, input) {
        if (this.serdeContext?.disableHostPrefix) {
          return;
        }
        const inputNs = NormalizedSchema.of(operationSchema.input);
        const opTraits = translateTraits(operationSchema.traits ?? {});
        if (opTraits.endpoint) {
          let hostPrefix = opTraits.endpoint?.[0];
          if (typeof hostPrefix === "string") {
            const hostLabelInputs = [...inputNs.structIterator()].filter(([, member2]) => member2.getMergedTraits().hostLabel);
            for (const [name] of hostLabelInputs) {
              const replacement = input[name];
              if (typeof replacement !== "string") {
                throw new Error(`@smithy/core/schema - ${name} in input must be a string as hostLabel.`);
              }
              hostPrefix = hostPrefix.replace(`{${name}}`, replacement);
            }
            request2.hostname = hostPrefix + request2.hostname;
          }
        }
      }
      deserializeMetadata(output) {
        return {
          httpStatusCode: output.statusCode,
          requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
          extendedRequestId: output.headers["x-amz-id-2"],
          cfId: output.headers["x-amz-cf-id"]
        };
      }
      async serializeEventStream({ eventStream, requestSchema, initialRequest }) {
        const eventStreamSerde = await this.loadEventStreamCapability();
        return eventStreamSerde.serializeEventStream({
          eventStream,
          requestSchema,
          initialRequest
        });
      }
      async deserializeEventStream({ response: response2, responseSchema, initialResponseContainer }) {
        const eventStreamSerde = await this.loadEventStreamCapability();
        return eventStreamSerde.deserializeEventStream({
          response: response2,
          responseSchema,
          initialResponseContainer
        });
      }
      async loadEventStreamCapability() {
        const { EventStreamSerde: EventStreamSerde2 } = await Promise.resolve().then(() => (init_event_streams(), event_streams_exports));
        return new EventStreamSerde2({
          marshaller: this.getEventStreamMarshaller(),
          serializer: this.serializer,
          deserializer: this.deserializer,
          serdeContext: this.serdeContext,
          defaultContentType: this.getDefaultContentType()
        });
      }
      getDefaultContentType() {
        throw new Error(`@smithy/core/protocols - ${this.constructor.name} getDefaultContentType() implementation missing.`);
      }
      async deserializeHttpMessage(schema, context, response2, arg4, arg5) {
        void schema;
        void context;
        void response2;
        void arg4;
        void arg5;
        return [];
      }
      getEventStreamMarshaller() {
        const context = this.serdeContext;
        if (!context.eventStreamMarshaller) {
          throw new Error("@smithy/core - HttpProtocol: eventStreamMarshaller missing in serdeContext.");
        }
        return context.eventStreamMarshaller;
      }
    };
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/protocols/HttpBindingProtocol.js
var import_protocol_http7, import_util_stream2, HttpBindingProtocol;
var init_HttpBindingProtocol = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/protocols/HttpBindingProtocol.js"() {
    init_schema();
    init_serde();
    import_protocol_http7 = __toESM(require_dist_cjs2());
    import_util_stream2 = __toESM(require_dist_cjs15());
    init_collect_stream_body();
    init_extended_encode_uri_component();
    init_HttpProtocol();
    HttpBindingProtocol = class extends HttpProtocol {
      async serializeRequest(operationSchema, _input, context) {
        const input = {
          ..._input ?? {}
        };
        const serializer = this.serializer;
        const query = {};
        const headers2 = {};
        const endpoint = await context.endpoint();
        const ns = NormalizedSchema.of(operationSchema?.input);
        const schema = ns.getSchema();
        let hasNonHttpBindingMember = false;
        let payload2;
        const request2 = new import_protocol_http7.HttpRequest({
          protocol: "",
          hostname: "",
          port: void 0,
          path: "",
          fragment: void 0,
          query,
          headers: headers2,
          body: void 0
        });
        if (endpoint) {
          this.updateServiceEndpoint(request2, endpoint);
          this.setHostPrefix(request2, operationSchema, input);
          const opTraits = translateTraits(operationSchema.traits);
          if (opTraits.http) {
            request2.method = opTraits.http[0];
            const [path3, search] = opTraits.http[1].split("?");
            if (request2.path == "/") {
              request2.path = path3;
            } else {
              request2.path += path3;
            }
            const traitSearchParams = new URLSearchParams(search ?? "");
            Object.assign(query, Object.fromEntries(traitSearchParams));
          }
        }
        for (const [memberName, memberNs] of ns.structIterator()) {
          const memberTraits = memberNs.getMergedTraits() ?? {};
          const inputMemberValue = input[memberName];
          if (inputMemberValue == null && !memberNs.isIdempotencyToken()) {
            continue;
          }
          if (memberTraits.httpPayload) {
            const isStreaming = memberNs.isStreaming();
            if (isStreaming) {
              const isEventStream = memberNs.isStructSchema();
              if (isEventStream) {
                if (input[memberName]) {
                  payload2 = await this.serializeEventStream({
                    eventStream: input[memberName],
                    requestSchema: ns
                  });
                }
              } else {
                payload2 = inputMemberValue;
              }
            } else {
              serializer.write(memberNs, inputMemberValue);
              payload2 = serializer.flush();
            }
            delete input[memberName];
          } else if (memberTraits.httpLabel) {
            serializer.write(memberNs, inputMemberValue);
            const replacement = serializer.flush();
            if (request2.path.includes(`{${memberName}+}`)) {
              request2.path = request2.path.replace(`{${memberName}+}`, replacement.split("/").map(extendedEncodeURIComponent).join("/"));
            } else if (request2.path.includes(`{${memberName}}`)) {
              request2.path = request2.path.replace(`{${memberName}}`, extendedEncodeURIComponent(replacement));
            }
            delete input[memberName];
          } else if (memberTraits.httpHeader) {
            serializer.write(memberNs, inputMemberValue);
            headers2[memberTraits.httpHeader.toLowerCase()] = String(serializer.flush());
            delete input[memberName];
          } else if (typeof memberTraits.httpPrefixHeaders === "string") {
            for (const [key, val] of Object.entries(inputMemberValue)) {
              const amalgam = memberTraits.httpPrefixHeaders + key;
              serializer.write([memberNs.getValueSchema(), { httpHeader: amalgam }], val);
              headers2[amalgam.toLowerCase()] = serializer.flush();
            }
            delete input[memberName];
          } else if (memberTraits.httpQuery || memberTraits.httpQueryParams) {
            this.serializeQuery(memberNs, inputMemberValue, query);
            delete input[memberName];
          } else {
            hasNonHttpBindingMember = true;
          }
        }
        if (hasNonHttpBindingMember && input) {
          serializer.write(schema, input);
          payload2 = serializer.flush();
        }
        request2.headers = headers2;
        request2.query = query;
        request2.body = payload2;
        return request2;
      }
      serializeQuery(ns, data2, query) {
        const serializer = this.serializer;
        const traits = ns.getMergedTraits();
        if (traits.httpQueryParams) {
          for (const [key, val] of Object.entries(data2)) {
            if (!(key in query)) {
              const valueSchema = ns.getValueSchema();
              Object.assign(valueSchema.getMergedTraits(), {
                ...traits,
                httpQuery: key,
                httpQueryParams: void 0
              });
              this.serializeQuery(valueSchema, val, query);
            }
          }
          return;
        }
        if (ns.isListSchema()) {
          const sparse = !!ns.getMergedTraits().sparse;
          const buffer = [];
          for (const item of data2) {
            serializer.write([ns.getValueSchema(), traits], item);
            const serializable = serializer.flush();
            if (sparse || serializable !== void 0) {
              buffer.push(serializable);
            }
          }
          query[traits.httpQuery] = buffer;
        } else {
          serializer.write([ns, traits], data2);
          query[traits.httpQuery] = serializer.flush();
        }
      }
      async deserializeResponse(operationSchema, context, response2) {
        const deserializer = this.deserializer;
        const ns = NormalizedSchema.of(operationSchema.output);
        const dataObject = {};
        if (response2.statusCode >= 300) {
          const bytes = await collectBody(response2.body, context);
          if (bytes.byteLength > 0) {
            Object.assign(dataObject, await deserializer.read(15, bytes));
          }
          await this.handleError(operationSchema, context, response2, dataObject, this.deserializeMetadata(response2));
          throw new Error("@smithy/core/protocols - HTTP Protocol error handler failed to throw.");
        }
        for (const header in response2.headers) {
          const value = response2.headers[header];
          delete response2.headers[header];
          response2.headers[header.toLowerCase()] = value;
        }
        const nonHttpBindingMembers = await this.deserializeHttpMessage(ns, context, response2, dataObject);
        if (nonHttpBindingMembers.length) {
          const bytes = await collectBody(response2.body, context);
          if (bytes.byteLength > 0) {
            const dataFromBody = await deserializer.read(ns, bytes);
            for (const member2 of nonHttpBindingMembers) {
              dataObject[member2] = dataFromBody[member2];
            }
          }
        } else if (nonHttpBindingMembers.discardResponseBody) {
          await collectBody(response2.body, context);
        }
        dataObject.$metadata = this.deserializeMetadata(response2);
        return dataObject;
      }
      async deserializeHttpMessage(schema, context, response2, arg4, arg5) {
        let dataObject;
        if (arg4 instanceof Set) {
          dataObject = arg5;
        } else {
          dataObject = arg4;
        }
        let discardResponseBody = true;
        const deserializer = this.deserializer;
        const ns = NormalizedSchema.of(schema);
        const nonHttpBindingMembers = [];
        for (const [memberName, memberSchema] of ns.structIterator()) {
          const memberTraits = memberSchema.getMemberTraits();
          if (memberTraits.httpPayload) {
            discardResponseBody = false;
            const isStreaming = memberSchema.isStreaming();
            if (isStreaming) {
              const isEventStream = memberSchema.isStructSchema();
              if (isEventStream) {
                dataObject[memberName] = await this.deserializeEventStream({
                  response: response2,
                  responseSchema: ns
                });
              } else {
                dataObject[memberName] = (0, import_util_stream2.sdkStreamMixin)(response2.body);
              }
            } else if (response2.body) {
              const bytes = await collectBody(response2.body, context);
              if (bytes.byteLength > 0) {
                dataObject[memberName] = await deserializer.read(memberSchema, bytes);
              }
            }
          } else if (memberTraits.httpHeader) {
            const key = String(memberTraits.httpHeader).toLowerCase();
            const value = response2.headers[key];
            if (null != value) {
              if (memberSchema.isListSchema()) {
                const headerListValueSchema = memberSchema.getValueSchema();
                headerListValueSchema.getMergedTraits().httpHeader = key;
                let sections;
                if (headerListValueSchema.isTimestampSchema() && headerListValueSchema.getSchema() === 4) {
                  sections = splitEvery(value, ",", 2);
                } else {
                  sections = splitHeader(value);
                }
                const list2 = [];
                for (const section of sections) {
                  list2.push(await deserializer.read(headerListValueSchema, section.trim()));
                }
                dataObject[memberName] = list2;
              } else {
                dataObject[memberName] = await deserializer.read(memberSchema, value);
              }
            }
          } else if (memberTraits.httpPrefixHeaders !== void 0) {
            dataObject[memberName] = {};
            for (const [header, value] of Object.entries(response2.headers)) {
              if (header.startsWith(memberTraits.httpPrefixHeaders)) {
                const valueSchema = memberSchema.getValueSchema();
                valueSchema.getMergedTraits().httpHeader = header;
                dataObject[memberName][header.slice(memberTraits.httpPrefixHeaders.length)] = await deserializer.read(valueSchema, value);
              }
            }
          } else if (memberTraits.httpResponseCode) {
            dataObject[memberName] = response2.statusCode;
          } else {
            nonHttpBindingMembers.push(memberName);
          }
        }
        nonHttpBindingMembers.discardResponseBody = discardResponseBody;
        return nonHttpBindingMembers;
      }
    };
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/protocols/RpcProtocol.js
var import_protocol_http8, RpcProtocol;
var init_RpcProtocol = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/protocols/RpcProtocol.js"() {
    init_schema();
    import_protocol_http8 = __toESM(require_dist_cjs2());
    init_collect_stream_body();
    init_HttpProtocol();
    RpcProtocol = class extends HttpProtocol {
      async serializeRequest(operationSchema, input, context) {
        const serializer = this.serializer;
        const query = {};
        const headers2 = {};
        const endpoint = await context.endpoint();
        const ns = NormalizedSchema.of(operationSchema?.input);
        const schema = ns.getSchema();
        let payload2;
        const request2 = new import_protocol_http8.HttpRequest({
          protocol: "",
          hostname: "",
          port: void 0,
          path: "/",
          fragment: void 0,
          query,
          headers: headers2,
          body: void 0
        });
        if (endpoint) {
          this.updateServiceEndpoint(request2, endpoint);
          this.setHostPrefix(request2, operationSchema, input);
        }
        const _input = {
          ...input
        };
        if (input) {
          const eventStreamMember = ns.getEventStreamMember();
          if (eventStreamMember) {
            if (_input[eventStreamMember]) {
              const initialRequest = {};
              for (const [memberName, memberSchema] of ns.structIterator()) {
                if (memberName !== eventStreamMember && _input[memberName]) {
                  serializer.write(memberSchema, _input[memberName]);
                  initialRequest[memberName] = serializer.flush();
                }
              }
              payload2 = await this.serializeEventStream({
                eventStream: _input[eventStreamMember],
                requestSchema: ns,
                initialRequest
              });
            }
          } else {
            serializer.write(schema, _input);
            payload2 = serializer.flush();
          }
        }
        request2.headers = headers2;
        request2.query = query;
        request2.body = payload2;
        request2.method = "POST";
        return request2;
      }
      async deserializeResponse(operationSchema, context, response2) {
        const deserializer = this.deserializer;
        const ns = NormalizedSchema.of(operationSchema.output);
        const dataObject = {};
        if (response2.statusCode >= 300) {
          const bytes = await collectBody(response2.body, context);
          if (bytes.byteLength > 0) {
            Object.assign(dataObject, await deserializer.read(15, bytes));
          }
          await this.handleError(operationSchema, context, response2, dataObject, this.deserializeMetadata(response2));
          throw new Error("@smithy/core/protocols - RPC Protocol error handler failed to throw.");
        }
        for (const header in response2.headers) {
          const value = response2.headers[header];
          delete response2.headers[header];
          response2.headers[header.toLowerCase()] = value;
        }
        const eventStreamMember = ns.getEventStreamMember();
        if (eventStreamMember) {
          dataObject[eventStreamMember] = await this.deserializeEventStream({
            response: response2,
            responseSchema: ns,
            initialResponseContainer: dataObject
          });
        } else {
          const bytes = await collectBody(response2.body, context);
          if (bytes.byteLength > 0) {
            Object.assign(dataObject, await deserializer.read(ns, bytes));
          }
        }
        dataObject.$metadata = this.deserializeMetadata(response2);
        return dataObject;
      }
    };
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/protocols/resolve-path.js
var resolvedPath;
var init_resolve_path = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/protocols/resolve-path.js"() {
    init_extended_encode_uri_component();
    resolvedPath = (resolvedPath2, input, memberName, labelValueProvider, uriLabel, isGreedyLabel) => {
      if (input != null && input[memberName] !== void 0) {
        const labelValue = labelValueProvider();
        if (labelValue.length <= 0) {
          throw new Error("Empty value provided for input HTTP label: " + memberName + ".");
        }
        resolvedPath2 = resolvedPath2.replace(uriLabel, isGreedyLabel ? labelValue.split("/").map((segment) => extendedEncodeURIComponent(segment)).join("/") : extendedEncodeURIComponent(labelValue));
      } else {
        throw new Error("No value provided for input HTTP label: " + memberName + ".");
      }
      return resolvedPath2;
    };
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/protocols/requestBuilder.js
function requestBuilder(input, context) {
  return new RequestBuilder(input, context);
}
var import_protocol_http9, RequestBuilder;
var init_requestBuilder = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/protocols/requestBuilder.js"() {
    import_protocol_http9 = __toESM(require_dist_cjs2());
    init_resolve_path();
    RequestBuilder = class {
      input;
      context;
      query = {};
      method = "";
      headers = {};
      path = "";
      body = null;
      hostname = "";
      resolvePathStack = [];
      constructor(input, context) {
        this.input = input;
        this.context = context;
      }
      async build() {
        const { hostname, protocol = "https", port, path: basePath } = await this.context.endpoint();
        this.path = basePath;
        for (const resolvePath of this.resolvePathStack) {
          resolvePath(this.path);
        }
        return new import_protocol_http9.HttpRequest({
          protocol,
          hostname: this.hostname || hostname,
          port,
          method: this.method,
          path: this.path,
          query: this.query,
          body: this.body,
          headers: this.headers
        });
      }
      hn(hostname) {
        this.hostname = hostname;
        return this;
      }
      bp(uriLabel) {
        this.resolvePathStack.push((basePath) => {
          this.path = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + uriLabel;
        });
        return this;
      }
      p(memberName, labelValueProvider, uriLabel, isGreedyLabel) {
        this.resolvePathStack.push((path3) => {
          this.path = resolvedPath(path3, this.input, memberName, labelValueProvider, uriLabel, isGreedyLabel);
        });
        return this;
      }
      h(headers2) {
        this.headers = headers2;
        return this;
      }
      q(query) {
        this.query = query;
        return this;
      }
      b(body2) {
        this.body = body2;
        return this;
      }
      m(method) {
        this.method = method;
        return this;
      }
    };
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/protocols/serde/determineTimestampFormat.js
function determineTimestampFormat(ns, settings) {
  if (settings.timestampFormat.useTrait) {
    if (ns.isTimestampSchema() && (ns.getSchema() === 5 || ns.getSchema() === 6 || ns.getSchema() === 7)) {
      return ns.getSchema();
    }
  }
  const { httpLabel, httpPrefixHeaders, httpHeader, httpQuery } = ns.getMergedTraits();
  const bindingFormat = settings.httpBindings ? typeof httpPrefixHeaders === "string" || Boolean(httpHeader) ? 6 : Boolean(httpQuery) || Boolean(httpLabel) ? 5 : void 0 : void 0;
  return bindingFormat ?? settings.timestampFormat.default;
}
var init_determineTimestampFormat = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/protocols/serde/determineTimestampFormat.js"() {
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/protocols/serde/FromStringShapeDeserializer.js
var import_util_base64, import_util_utf82, FromStringShapeDeserializer;
var init_FromStringShapeDeserializer = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/protocols/serde/FromStringShapeDeserializer.js"() {
    init_schema();
    init_serde();
    import_util_base64 = __toESM(require_dist_cjs9());
    import_util_utf82 = __toESM(require_dist_cjs8());
    init_SerdeContext();
    init_determineTimestampFormat();
    FromStringShapeDeserializer = class extends SerdeContext {
      settings;
      constructor(settings) {
        super();
        this.settings = settings;
      }
      read(_schema, data2) {
        const ns = NormalizedSchema.of(_schema);
        if (ns.isListSchema()) {
          return splitHeader(data2).map((item) => this.read(ns.getValueSchema(), item));
        }
        if (ns.isBlobSchema()) {
          return (this.serdeContext?.base64Decoder ?? import_util_base64.fromBase64)(data2);
        }
        if (ns.isTimestampSchema()) {
          const format2 = determineTimestampFormat(ns, this.settings);
          switch (format2) {
            case 5:
              return _parseRfc3339DateTimeWithOffset(data2);
            case 6:
              return _parseRfc7231DateTime(data2);
            case 7:
              return _parseEpochTimestamp(data2);
            default:
              console.warn("Missing timestamp format, parsing value with Date constructor:", data2);
              return new Date(data2);
          }
        }
        if (ns.isStringSchema()) {
          const mediaType = ns.getMergedTraits().mediaType;
          let intermediateValue = data2;
          if (mediaType) {
            if (ns.getMergedTraits().httpHeader) {
              intermediateValue = this.base64ToUtf8(intermediateValue);
            }
            const isJson = mediaType === "application/json" || mediaType.endsWith("+json");
            if (isJson) {
              intermediateValue = LazyJsonString.from(intermediateValue);
            }
            return intermediateValue;
          }
        }
        if (ns.isNumericSchema()) {
          return Number(data2);
        }
        if (ns.isBigIntegerSchema()) {
          return BigInt(data2);
        }
        if (ns.isBigDecimalSchema()) {
          return new NumericValue(data2, "bigDecimal");
        }
        if (ns.isBooleanSchema()) {
          return String(data2).toLowerCase() === "true";
        }
        return data2;
      }
      base64ToUtf8(base64String) {
        return (this.serdeContext?.utf8Encoder ?? import_util_utf82.toUtf8)((this.serdeContext?.base64Decoder ?? import_util_base64.fromBase64)(base64String));
      }
    };
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/protocols/serde/HttpInterceptingShapeDeserializer.js
var import_util_utf83, HttpInterceptingShapeDeserializer;
var init_HttpInterceptingShapeDeserializer = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/protocols/serde/HttpInterceptingShapeDeserializer.js"() {
    init_schema();
    import_util_utf83 = __toESM(require_dist_cjs8());
    init_SerdeContext();
    init_FromStringShapeDeserializer();
    HttpInterceptingShapeDeserializer = class extends SerdeContext {
      codecDeserializer;
      stringDeserializer;
      constructor(codecDeserializer, codecSettings) {
        super();
        this.codecDeserializer = codecDeserializer;
        this.stringDeserializer = new FromStringShapeDeserializer(codecSettings);
      }
      setSerdeContext(serdeContext) {
        this.stringDeserializer.setSerdeContext(serdeContext);
        this.codecDeserializer.setSerdeContext(serdeContext);
        this.serdeContext = serdeContext;
      }
      read(schema, data2) {
        const ns = NormalizedSchema.of(schema);
        const traits = ns.getMergedTraits();
        const toString2 = this.serdeContext?.utf8Encoder ?? import_util_utf83.toUtf8;
        if (traits.httpHeader || traits.httpResponseCode) {
          return this.stringDeserializer.read(ns, toString2(data2));
        }
        if (traits.httpPayload) {
          if (ns.isBlobSchema()) {
            const toBytes2 = this.serdeContext?.utf8Decoder ?? import_util_utf83.fromUtf8;
            if (typeof data2 === "string") {
              return toBytes2(data2);
            }
            return data2;
          } else if (ns.isStringSchema()) {
            if ("byteLength" in data2) {
              return toString2(data2);
            }
            return data2;
          }
        }
        return this.codecDeserializer.read(ns, data2);
      }
    };
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/protocols/serde/ToStringShapeSerializer.js
var import_util_base642, ToStringShapeSerializer;
var init_ToStringShapeSerializer = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/protocols/serde/ToStringShapeSerializer.js"() {
    init_schema();
    init_serde();
    import_util_base642 = __toESM(require_dist_cjs9());
    init_SerdeContext();
    init_determineTimestampFormat();
    ToStringShapeSerializer = class extends SerdeContext {
      settings;
      stringBuffer = "";
      constructor(settings) {
        super();
        this.settings = settings;
      }
      write(schema, value) {
        const ns = NormalizedSchema.of(schema);
        switch (typeof value) {
          case "object":
            if (value === null) {
              this.stringBuffer = "null";
              return;
            }
            if (ns.isTimestampSchema()) {
              if (!(value instanceof Date)) {
                throw new Error(`@smithy/core/protocols - received non-Date value ${value} when schema expected Date in ${ns.getName(true)}`);
              }
              const format2 = determineTimestampFormat(ns, this.settings);
              switch (format2) {
                case 5:
                  this.stringBuffer = value.toISOString().replace(".000Z", "Z");
                  break;
                case 6:
                  this.stringBuffer = dateToUtcString(value);
                  break;
                case 7:
                  this.stringBuffer = String(value.getTime() / 1e3);
                  break;
                default:
                  console.warn("Missing timestamp format, using epoch seconds", value);
                  this.stringBuffer = String(value.getTime() / 1e3);
              }
              return;
            }
            if (ns.isBlobSchema() && "byteLength" in value) {
              this.stringBuffer = (this.serdeContext?.base64Encoder ?? import_util_base642.toBase64)(value);
              return;
            }
            if (ns.isListSchema() && Array.isArray(value)) {
              let buffer = "";
              for (const item of value) {
                this.write([ns.getValueSchema(), ns.getMergedTraits()], item);
                const headerItem = this.flush();
                const serialized = ns.getValueSchema().isTimestampSchema() ? headerItem : quoteHeader(headerItem);
                if (buffer !== "") {
                  buffer += ", ";
                }
                buffer += serialized;
              }
              this.stringBuffer = buffer;
              return;
            }
            this.stringBuffer = JSON.stringify(value, null, 2);
            break;
          case "string":
            const mediaType = ns.getMergedTraits().mediaType;
            let intermediateValue = value;
            if (mediaType) {
              const isJson = mediaType === "application/json" || mediaType.endsWith("+json");
              if (isJson) {
                intermediateValue = LazyJsonString.from(intermediateValue);
              }
              if (ns.getMergedTraits().httpHeader) {
                this.stringBuffer = (this.serdeContext?.base64Encoder ?? import_util_base642.toBase64)(intermediateValue.toString());
                return;
              }
            }
            this.stringBuffer = value;
            break;
          default:
            if (ns.isIdempotencyToken()) {
              this.stringBuffer = (0, import_uuid.v4)();
            } else {
              this.stringBuffer = String(value);
            }
        }
      }
      flush() {
        const buffer = this.stringBuffer;
        this.stringBuffer = "";
        return buffer;
      }
    };
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/protocols/serde/HttpInterceptingShapeSerializer.js
var HttpInterceptingShapeSerializer;
var init_HttpInterceptingShapeSerializer = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/protocols/serde/HttpInterceptingShapeSerializer.js"() {
    init_schema();
    init_ToStringShapeSerializer();
    HttpInterceptingShapeSerializer = class {
      codecSerializer;
      stringSerializer;
      buffer;
      constructor(codecSerializer, codecSettings, stringSerializer = new ToStringShapeSerializer(codecSettings)) {
        this.codecSerializer = codecSerializer;
        this.stringSerializer = stringSerializer;
      }
      setSerdeContext(serdeContext) {
        this.codecSerializer.setSerdeContext(serdeContext);
        this.stringSerializer.setSerdeContext(serdeContext);
      }
      write(schema, value) {
        const ns = NormalizedSchema.of(schema);
        const traits = ns.getMergedTraits();
        if (traits.httpHeader || traits.httpLabel || traits.httpQuery) {
          this.stringSerializer.write(ns, value);
          this.buffer = this.stringSerializer.flush();
          return;
        }
        return this.codecSerializer.write(ns, value);
      }
      flush() {
        if (this.buffer !== void 0) {
          const buffer = this.buffer;
          this.buffer = void 0;
          return buffer;
        }
        return this.codecSerializer.flush();
      }
    };
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/protocols/index.js
var protocols_exports = {};
__export(protocols_exports, {
  FromStringShapeDeserializer: () => FromStringShapeDeserializer,
  HttpBindingProtocol: () => HttpBindingProtocol,
  HttpInterceptingShapeDeserializer: () => HttpInterceptingShapeDeserializer,
  HttpInterceptingShapeSerializer: () => HttpInterceptingShapeSerializer,
  HttpProtocol: () => HttpProtocol,
  RequestBuilder: () => RequestBuilder,
  RpcProtocol: () => RpcProtocol,
  SerdeContext: () => SerdeContext,
  ToStringShapeSerializer: () => ToStringShapeSerializer,
  collectBody: () => collectBody,
  determineTimestampFormat: () => determineTimestampFormat,
  extendedEncodeURIComponent: () => extendedEncodeURIComponent,
  requestBuilder: () => requestBuilder,
  resolvedPath: () => resolvedPath
});
var init_protocols = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/protocols/index.js"() {
    init_collect_stream_body();
    init_extended_encode_uri_component();
    init_HttpBindingProtocol();
    init_HttpProtocol();
    init_RpcProtocol();
    init_requestBuilder();
    init_resolve_path();
    init_FromStringShapeDeserializer();
    init_HttpInterceptingShapeDeserializer();
    init_HttpInterceptingShapeSerializer();
    init_ToStringShapeSerializer();
    init_determineTimestampFormat();
    init_SerdeContext();
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/request-builder/requestBuilder.js
var init_requestBuilder2 = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/request-builder/requestBuilder.js"() {
    init_protocols();
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/setFeature.js
function setFeature2(context, feature, value) {
  if (!context.__smithy_context) {
    context.__smithy_context = {
      features: {}
    };
  } else if (!context.__smithy_context.features) {
    context.__smithy_context.features = {};
  }
  context.__smithy_context.features[feature] = value;
}
var init_setFeature2 = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/setFeature.js"() {
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/util-identity-and-auth/DefaultIdentityProviderConfig.js
var DefaultIdentityProviderConfig;
var init_DefaultIdentityProviderConfig = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/util-identity-and-auth/DefaultIdentityProviderConfig.js"() {
    DefaultIdentityProviderConfig = class {
      authSchemes = /* @__PURE__ */ new Map();
      constructor(config) {
        for (const [key, value] of Object.entries(config)) {
          if (value !== void 0) {
            this.authSchemes.set(key, value);
          }
        }
      }
      getIdentityProvider(schemeId) {
        return this.authSchemes.get(schemeId);
      }
    };
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/httpApiKeyAuth.js
var import_protocol_http10, import_types2, HttpApiKeyAuthSigner;
var init_httpApiKeyAuth = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/httpApiKeyAuth.js"() {
    import_protocol_http10 = __toESM(require_dist_cjs2());
    import_types2 = __toESM(require_dist_cjs());
    HttpApiKeyAuthSigner = class {
      async sign(httpRequest, identity2, signingProperties) {
        if (!signingProperties) {
          throw new Error("request could not be signed with `apiKey` since the `name` and `in` signer properties are missing");
        }
        if (!signingProperties.name) {
          throw new Error("request could not be signed with `apiKey` since the `name` signer property is missing");
        }
        if (!signingProperties.in) {
          throw new Error("request could not be signed with `apiKey` since the `in` signer property is missing");
        }
        if (!identity2.apiKey) {
          throw new Error("request could not be signed with `apiKey` since the `apiKey` is not defined");
        }
        const clonedRequest = import_protocol_http10.HttpRequest.clone(httpRequest);
        if (signingProperties.in === import_types2.HttpApiKeyAuthLocation.QUERY) {
          clonedRequest.query[signingProperties.name] = identity2.apiKey;
        } else if (signingProperties.in === import_types2.HttpApiKeyAuthLocation.HEADER) {
          clonedRequest.headers[signingProperties.name] = signingProperties.scheme ? `${signingProperties.scheme} ${identity2.apiKey}` : identity2.apiKey;
        } else {
          throw new Error("request can only be signed with `apiKey` locations `query` or `header`, but found: `" + signingProperties.in + "`");
        }
        return clonedRequest;
      }
    };
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/httpBearerAuth.js
var import_protocol_http11, HttpBearerAuthSigner;
var init_httpBearerAuth = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/httpBearerAuth.js"() {
    import_protocol_http11 = __toESM(require_dist_cjs2());
    HttpBearerAuthSigner = class {
      async sign(httpRequest, identity2, signingProperties) {
        const clonedRequest = import_protocol_http11.HttpRequest.clone(httpRequest);
        if (!identity2.token) {
          throw new Error("request could not be signed with `token` since the `token` is not defined");
        }
        clonedRequest.headers["Authorization"] = `Bearer ${identity2.token}`;
        return clonedRequest;
      }
    };
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/noAuth.js
var NoAuthSigner;
var init_noAuth = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/noAuth.js"() {
    NoAuthSigner = class {
      async sign(httpRequest, identity2, signingProperties) {
        return httpRequest;
      }
    };
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/index.js
var init_httpAuthSchemes = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/index.js"() {
    init_httpApiKeyAuth();
    init_httpBearerAuth();
    init_noAuth();
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/util-identity-and-auth/memoizeIdentityProvider.js
var createIsIdentityExpiredFunction, EXPIRATION_MS, isIdentityExpired, doesIdentityRequireRefresh, memoizeIdentityProvider;
var init_memoizeIdentityProvider = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/util-identity-and-auth/memoizeIdentityProvider.js"() {
    createIsIdentityExpiredFunction = (expirationMs) => function isIdentityExpired2(identity2) {
      return doesIdentityRequireRefresh(identity2) && identity2.expiration.getTime() - Date.now() < expirationMs;
    };
    EXPIRATION_MS = 3e5;
    isIdentityExpired = createIsIdentityExpiredFunction(EXPIRATION_MS);
    doesIdentityRequireRefresh = (identity2) => identity2.expiration !== void 0;
    memoizeIdentityProvider = (provider, isExpired, requiresRefresh) => {
      if (provider === void 0) {
        return void 0;
      }
      const normalizedProvider = typeof provider !== "function" ? async () => Promise.resolve(provider) : provider;
      let resolved;
      let pending;
      let hasResult;
      let isConstant = false;
      const coalesceProvider = async (options) => {
        if (!pending) {
          pending = normalizedProvider(options);
        }
        try {
          resolved = await pending;
          hasResult = true;
          isConstant = false;
        } finally {
          pending = void 0;
        }
        return resolved;
      };
      if (isExpired === void 0) {
        return async (options) => {
          if (!hasResult || options?.forceRefresh) {
            resolved = await coalesceProvider(options);
          }
          return resolved;
        };
      }
      return async (options) => {
        if (!hasResult || options?.forceRefresh) {
          resolved = await coalesceProvider(options);
        }
        if (isConstant) {
          return resolved;
        }
        if (!requiresRefresh(resolved)) {
          isConstant = true;
          return resolved;
        }
        if (isExpired(resolved)) {
          await coalesceProvider(options);
          return resolved;
        }
        return resolved;
      };
    };
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/util-identity-and-auth/index.js
var init_util_identity_and_auth = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/util-identity-and-auth/index.js"() {
    init_DefaultIdentityProviderConfig();
    init_httpAuthSchemes();
    init_memoizeIdentityProvider();
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/index.js
var dist_es_exports = {};
__export(dist_es_exports, {
  DefaultIdentityProviderConfig: () => DefaultIdentityProviderConfig,
  EXPIRATION_MS: () => EXPIRATION_MS,
  HttpApiKeyAuthSigner: () => HttpApiKeyAuthSigner,
  HttpBearerAuthSigner: () => HttpBearerAuthSigner,
  NoAuthSigner: () => NoAuthSigner,
  createIsIdentityExpiredFunction: () => createIsIdentityExpiredFunction,
  createPaginator: () => createPaginator,
  doesIdentityRequireRefresh: () => doesIdentityRequireRefresh,
  getHttpAuthSchemeEndpointRuleSetPlugin: () => getHttpAuthSchemeEndpointRuleSetPlugin,
  getHttpAuthSchemePlugin: () => getHttpAuthSchemePlugin,
  getHttpSigningPlugin: () => getHttpSigningPlugin,
  getSmithyContext: () => getSmithyContext,
  httpAuthSchemeEndpointRuleSetMiddlewareOptions: () => httpAuthSchemeEndpointRuleSetMiddlewareOptions,
  httpAuthSchemeMiddleware: () => httpAuthSchemeMiddleware,
  httpAuthSchemeMiddlewareOptions: () => httpAuthSchemeMiddlewareOptions,
  httpSigningMiddleware: () => httpSigningMiddleware,
  httpSigningMiddlewareOptions: () => httpSigningMiddlewareOptions,
  isIdentityExpired: () => isIdentityExpired,
  memoizeIdentityProvider: () => memoizeIdentityProvider,
  normalizeProvider: () => normalizeProvider,
  requestBuilder: () => requestBuilder,
  setFeature: () => setFeature2
});
var init_dist_es = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/index.js"() {
    init_getSmithyContext();
    init_middleware_http_auth_scheme();
    init_middleware_http_signing();
    init_normalizeProvider();
    init_createPaginator();
    init_requestBuilder2();
    init_setFeature2();
    init_util_identity_and_auth();
  }
});

// node_modules/.pnpm/@smithy+property-provider@4.2.8/node_modules/@smithy/property-provider/dist-cjs/index.js
var require_dist_cjs17 = __commonJS({
  "node_modules/.pnpm/@smithy+property-provider@4.2.8/node_modules/@smithy/property-provider/dist-cjs/index.js"(exports2) {
    "use strict";
    var ProviderError2 = class _ProviderError extends Error {
      name = "ProviderError";
      tryNextLink;
      constructor(message, options = true) {
        let logger3;
        let tryNextLink = true;
        if (typeof options === "boolean") {
          logger3 = void 0;
          tryNextLink = options;
        } else if (options != null && typeof options === "object") {
          logger3 = options.logger;
          tryNextLink = options.tryNextLink ?? true;
        }
        super(message);
        this.tryNextLink = tryNextLink;
        Object.setPrototypeOf(this, _ProviderError.prototype);
        logger3?.debug?.(`@smithy/property-provider ${tryNextLink ? "->" : "(!)"} ${message}`);
      }
      static from(error2, options = true) {
        return Object.assign(new this(error2.message, options), error2);
      }
    };
    var CredentialsProviderError = class _CredentialsProviderError extends ProviderError2 {
      name = "CredentialsProviderError";
      constructor(message, options = true) {
        super(message, options);
        Object.setPrototypeOf(this, _CredentialsProviderError.prototype);
      }
    };
    var TokenProviderError = class _TokenProviderError extends ProviderError2 {
      name = "TokenProviderError";
      constructor(message, options = true) {
        super(message, options);
        Object.setPrototypeOf(this, _TokenProviderError.prototype);
      }
    };
    var chain = (...providers) => async () => {
      if (providers.length === 0) {
        throw new ProviderError2("No providers in chain");
      }
      let lastProviderError;
      for (const provider of providers) {
        try {
          const credentials = await provider();
          return credentials;
        } catch (err) {
          lastProviderError = err;
          if (err?.tryNextLink) {
            continue;
          }
          throw err;
        }
      }
      throw lastProviderError;
    };
    var fromStatic = (staticValue) => () => Promise.resolve(staticValue);
    var memoize2 = (provider, isExpired, requiresRefresh) => {
      let resolved;
      let pending;
      let hasResult;
      let isConstant = false;
      const coalesceProvider = async () => {
        if (!pending) {
          pending = provider();
        }
        try {
          resolved = await pending;
          hasResult = true;
          isConstant = false;
        } finally {
          pending = void 0;
        }
        return resolved;
      };
      if (isExpired === void 0) {
        return async (options) => {
          if (!hasResult || options?.forceRefresh) {
            resolved = await coalesceProvider();
          }
          return resolved;
        };
      }
      return async (options) => {
        if (!hasResult || options?.forceRefresh) {
          resolved = await coalesceProvider();
        }
        if (isConstant) {
          return resolved;
        }
        if (requiresRefresh && !requiresRefresh(resolved)) {
          isConstant = true;
          return resolved;
        }
        if (isExpired(resolved)) {
          await coalesceProvider();
          return resolved;
        }
        return resolved;
      };
    };
    exports2.CredentialsProviderError = CredentialsProviderError;
    exports2.ProviderError = ProviderError2;
    exports2.TokenProviderError = TokenProviderError;
    exports2.chain = chain;
    exports2.fromStatic = fromStatic;
    exports2.memoize = memoize2;
  }
});

// node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/resolveAwsSdkSigV4AConfig.js
var import_property_provider, resolveAwsSdkSigV4AConfig, NODE_SIGV4A_CONFIG_OPTIONS;
var init_resolveAwsSdkSigV4AConfig = __esm({
  "node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/resolveAwsSdkSigV4AConfig.js"() {
    init_dist_es();
    import_property_provider = __toESM(require_dist_cjs17());
    resolveAwsSdkSigV4AConfig = (config) => {
      config.sigv4aSigningRegionSet = normalizeProvider(config.sigv4aSigningRegionSet);
      return config;
    };
    NODE_SIGV4A_CONFIG_OPTIONS = {
      environmentVariableSelector(env) {
        if (env.AWS_SIGV4A_SIGNING_REGION_SET) {
          return env.AWS_SIGV4A_SIGNING_REGION_SET.split(",").map((_) => _.trim());
        }
        throw new import_property_provider.ProviderError("AWS_SIGV4A_SIGNING_REGION_SET not set in env.", {
          tryNextLink: true
        });
      },
      configFileSelector(profile) {
        if (profile.sigv4a_signing_region_set) {
          return (profile.sigv4a_signing_region_set ?? "").split(",").map((_) => _.trim());
        }
        throw new import_property_provider.ProviderError("sigv4a_signing_region_set not set in profile.", {
          tryNextLink: true
        });
      },
      default: void 0
    };
  }
});

// node_modules/.pnpm/@smithy+signature-v4@5.3.8/node_modules/@smithy/signature-v4/dist-cjs/index.js
var require_dist_cjs18 = __commonJS({
  "node_modules/.pnpm/@smithy+signature-v4@5.3.8/node_modules/@smithy/signature-v4/dist-cjs/index.js"(exports2) {
    "use strict";
    var utilHexEncoding = require_dist_cjs14();
    var utilUtf8 = require_dist_cjs8();
    var isArrayBuffer = require_dist_cjs6();
    var protocolHttp = require_dist_cjs2();
    var utilMiddleware = require_dist_cjs4();
    var utilUriEscape = require_dist_cjs10();
    var ALGORITHM_QUERY_PARAM = "X-Amz-Algorithm";
    var CREDENTIAL_QUERY_PARAM = "X-Amz-Credential";
    var AMZ_DATE_QUERY_PARAM = "X-Amz-Date";
    var SIGNED_HEADERS_QUERY_PARAM = "X-Amz-SignedHeaders";
    var EXPIRES_QUERY_PARAM = "X-Amz-Expires";
    var SIGNATURE_QUERY_PARAM = "X-Amz-Signature";
    var TOKEN_QUERY_PARAM = "X-Amz-Security-Token";
    var REGION_SET_PARAM = "X-Amz-Region-Set";
    var AUTH_HEADER = "authorization";
    var AMZ_DATE_HEADER = AMZ_DATE_QUERY_PARAM.toLowerCase();
    var DATE_HEADER = "date";
    var GENERATED_HEADERS = [AUTH_HEADER, AMZ_DATE_HEADER, DATE_HEADER];
    var SIGNATURE_HEADER = SIGNATURE_QUERY_PARAM.toLowerCase();
    var SHA256_HEADER = "x-amz-content-sha256";
    var TOKEN_HEADER = TOKEN_QUERY_PARAM.toLowerCase();
    var HOST_HEADER = "host";
    var ALWAYS_UNSIGNABLE_HEADERS = {
      authorization: true,
      "cache-control": true,
      connection: true,
      expect: true,
      from: true,
      "keep-alive": true,
      "max-forwards": true,
      pragma: true,
      referer: true,
      te: true,
      trailer: true,
      "transfer-encoding": true,
      upgrade: true,
      "user-agent": true,
      "x-amzn-trace-id": true
    };
    var PROXY_HEADER_PATTERN = /^proxy-/;
    var SEC_HEADER_PATTERN = /^sec-/;
    var UNSIGNABLE_PATTERNS = [/^proxy-/i, /^sec-/i];
    var ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256";
    var ALGORITHM_IDENTIFIER_V4A = "AWS4-ECDSA-P256-SHA256";
    var EVENT_ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256-PAYLOAD";
    var UNSIGNED_PAYLOAD = "UNSIGNED-PAYLOAD";
    var MAX_CACHE_SIZE2 = 50;
    var KEY_TYPE_IDENTIFIER = "aws4_request";
    var MAX_PRESIGNED_TTL = 60 * 60 * 24 * 7;
    var signingKeyCache = {};
    var cacheQueue = [];
    var createScope = (shortDate, region, service) => `${shortDate}/${region}/${service}/${KEY_TYPE_IDENTIFIER}`;
    var getSigningKey = async (sha256Constructor, credentials, shortDate, region, service) => {
      const credsHash = await hmac(sha256Constructor, credentials.secretAccessKey, credentials.accessKeyId);
      const cacheKey = `${shortDate}:${region}:${service}:${utilHexEncoding.toHex(credsHash)}:${credentials.sessionToken}`;
      if (cacheKey in signingKeyCache) {
        return signingKeyCache[cacheKey];
      }
      cacheQueue.push(cacheKey);
      while (cacheQueue.length > MAX_CACHE_SIZE2) {
        delete signingKeyCache[cacheQueue.shift()];
      }
      let key = `AWS4${credentials.secretAccessKey}`;
      for (const signable of [shortDate, region, service, KEY_TYPE_IDENTIFIER]) {
        key = await hmac(sha256Constructor, key, signable);
      }
      return signingKeyCache[cacheKey] = key;
    };
    var clearCredentialCache = () => {
      cacheQueue.length = 0;
      Object.keys(signingKeyCache).forEach((cacheKey) => {
        delete signingKeyCache[cacheKey];
      });
    };
    var hmac = (ctor, secret, data2) => {
      const hash = new ctor(secret);
      hash.update(utilUtf8.toUint8Array(data2));
      return hash.digest();
    };
    var getCanonicalHeaders = ({ headers: headers2 }, unsignableHeaders, signableHeaders) => {
      const canonical = {};
      for (const headerName of Object.keys(headers2).sort()) {
        if (headers2[headerName] == void 0) {
          continue;
        }
        const canonicalHeaderName = headerName.toLowerCase();
        if (canonicalHeaderName in ALWAYS_UNSIGNABLE_HEADERS || unsignableHeaders?.has(canonicalHeaderName) || PROXY_HEADER_PATTERN.test(canonicalHeaderName) || SEC_HEADER_PATTERN.test(canonicalHeaderName)) {
          if (!signableHeaders || signableHeaders && !signableHeaders.has(canonicalHeaderName)) {
            continue;
          }
        }
        canonical[canonicalHeaderName] = headers2[headerName].trim().replace(/\s+/g, " ");
      }
      return canonical;
    };
    var getPayloadHash = async ({ headers: headers2, body: body2 }, hashConstructor) => {
      for (const headerName of Object.keys(headers2)) {
        if (headerName.toLowerCase() === SHA256_HEADER) {
          return headers2[headerName];
        }
      }
      if (body2 == void 0) {
        return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
      } else if (typeof body2 === "string" || ArrayBuffer.isView(body2) || isArrayBuffer.isArrayBuffer(body2)) {
        const hashCtor = new hashConstructor();
        hashCtor.update(utilUtf8.toUint8Array(body2));
        return utilHexEncoding.toHex(await hashCtor.digest());
      }
      return UNSIGNED_PAYLOAD;
    };
    var HeaderFormatter = class {
      format(headers2) {
        const chunks = [];
        for (const headerName of Object.keys(headers2)) {
          const bytes = utilUtf8.fromUtf8(headerName);
          chunks.push(Uint8Array.from([bytes.byteLength]), bytes, this.formatHeaderValue(headers2[headerName]));
        }
        const out = new Uint8Array(chunks.reduce((carry, bytes) => carry + bytes.byteLength, 0));
        let position = 0;
        for (const chunk2 of chunks) {
          out.set(chunk2, position);
          position += chunk2.byteLength;
        }
        return out;
      }
      formatHeaderValue(header) {
        switch (header.type) {
          case "boolean":
            return Uint8Array.from([header.value ? 0 : 1]);
          case "byte":
            return Uint8Array.from([2, header.value]);
          case "short":
            const shortView = new DataView(new ArrayBuffer(3));
            shortView.setUint8(0, 3);
            shortView.setInt16(1, header.value, false);
            return new Uint8Array(shortView.buffer);
          case "integer":
            const intView = new DataView(new ArrayBuffer(5));
            intView.setUint8(0, 4);
            intView.setInt32(1, header.value, false);
            return new Uint8Array(intView.buffer);
          case "long":
            const longBytes = new Uint8Array(9);
            longBytes[0] = 5;
            longBytes.set(header.value.bytes, 1);
            return longBytes;
          case "binary":
            const binView = new DataView(new ArrayBuffer(3 + header.value.byteLength));
            binView.setUint8(0, 6);
            binView.setUint16(1, header.value.byteLength, false);
            const binBytes = new Uint8Array(binView.buffer);
            binBytes.set(header.value, 3);
            return binBytes;
          case "string":
            const utf8Bytes = utilUtf8.fromUtf8(header.value);
            const strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));
            strView.setUint8(0, 7);
            strView.setUint16(1, utf8Bytes.byteLength, false);
            const strBytes = new Uint8Array(strView.buffer);
            strBytes.set(utf8Bytes, 3);
            return strBytes;
          case "timestamp":
            const tsBytes = new Uint8Array(9);
            tsBytes[0] = 8;
            tsBytes.set(Int64.fromNumber(header.value.valueOf()).bytes, 1);
            return tsBytes;
          case "uuid":
            if (!UUID_PATTERN.test(header.value)) {
              throw new Error(`Invalid UUID received: ${header.value}`);
            }
            const uuidBytes = new Uint8Array(17);
            uuidBytes[0] = 9;
            uuidBytes.set(utilHexEncoding.fromHex(header.value.replace(/\-/g, "")), 1);
            return uuidBytes;
        }
      }
    };
    var UUID_PATTERN = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
    var Int64 = class _Int64 {
      bytes;
      constructor(bytes) {
        this.bytes = bytes;
        if (bytes.byteLength !== 8) {
          throw new Error("Int64 buffers must be exactly 8 bytes");
        }
      }
      static fromNumber(number) {
        if (number > 9223372036854776e3 || number < -9223372036854776e3) {
          throw new Error(`${number} is too large (or, if negative, too small) to represent as an Int64`);
        }
        const bytes = new Uint8Array(8);
        for (let i4 = 7, remaining = Math.abs(Math.round(number)); i4 > -1 && remaining > 0; i4--, remaining /= 256) {
          bytes[i4] = remaining;
        }
        if (number < 0) {
          negate(bytes);
        }
        return new _Int64(bytes);
      }
      valueOf() {
        const bytes = this.bytes.slice(0);
        const negative = bytes[0] & 128;
        if (negative) {
          negate(bytes);
        }
        return parseInt(utilHexEncoding.toHex(bytes), 16) * (negative ? -1 : 1);
      }
      toString() {
        return String(this.valueOf());
      }
    };
    function negate(bytes) {
      for (let i4 = 0; i4 < 8; i4++) {
        bytes[i4] ^= 255;
      }
      for (let i4 = 7; i4 > -1; i4--) {
        bytes[i4]++;
        if (bytes[i4] !== 0)
          break;
      }
    }
    var hasHeader = (soughtHeader, headers2) => {
      soughtHeader = soughtHeader.toLowerCase();
      for (const headerName of Object.keys(headers2)) {
        if (soughtHeader === headerName.toLowerCase()) {
          return true;
        }
      }
      return false;
    };
    var moveHeadersToQuery = (request2, options = {}) => {
      const { headers: headers2, query = {} } = protocolHttp.HttpRequest.clone(request2);
      for (const name of Object.keys(headers2)) {
        const lname = name.toLowerCase();
        if (lname.slice(0, 6) === "x-amz-" && !options.unhoistableHeaders?.has(lname) || options.hoistableHeaders?.has(lname)) {
          query[name] = headers2[name];
          delete headers2[name];
        }
      }
      return {
        ...request2,
        headers: headers2,
        query
      };
    };
    var prepareRequest = (request2) => {
      request2 = protocolHttp.HttpRequest.clone(request2);
      for (const headerName of Object.keys(request2.headers)) {
        if (GENERATED_HEADERS.indexOf(headerName.toLowerCase()) > -1) {
          delete request2.headers[headerName];
        }
      }
      return request2;
    };
    var getCanonicalQuery = ({ query = {} }) => {
      const keys2 = [];
      const serialized = {};
      for (const key of Object.keys(query)) {
        if (key.toLowerCase() === SIGNATURE_HEADER) {
          continue;
        }
        const encodedKey = utilUriEscape.escapeUri(key);
        keys2.push(encodedKey);
        const value = query[key];
        if (typeof value === "string") {
          serialized[encodedKey] = `${encodedKey}=${utilUriEscape.escapeUri(value)}`;
        } else if (Array.isArray(value)) {
          serialized[encodedKey] = value.slice(0).reduce((encoded, value2) => encoded.concat([`${encodedKey}=${utilUriEscape.escapeUri(value2)}`]), []).sort().join("&");
        }
      }
      return keys2.sort().map((key) => serialized[key]).filter((serialized2) => serialized2).join("&");
    };
    var iso8601 = (time2) => toDate(time2).toISOString().replace(/\.\d{3}Z$/, "Z");
    var toDate = (time2) => {
      if (typeof time2 === "number") {
        return new Date(time2 * 1e3);
      }
      if (typeof time2 === "string") {
        if (Number(time2)) {
          return new Date(Number(time2) * 1e3);
        }
        return new Date(time2);
      }
      return time2;
    };
    var SignatureV4Base = class {
      service;
      regionProvider;
      credentialProvider;
      sha256;
      uriEscapePath;
      applyChecksum;
      constructor({ applyChecksum, credentials, region, service, sha256, uriEscapePath = true }) {
        this.service = service;
        this.sha256 = sha256;
        this.uriEscapePath = uriEscapePath;
        this.applyChecksum = typeof applyChecksum === "boolean" ? applyChecksum : true;
        this.regionProvider = utilMiddleware.normalizeProvider(region);
        this.credentialProvider = utilMiddleware.normalizeProvider(credentials);
      }
      createCanonicalRequest(request2, canonicalHeaders, payloadHash) {
        const sortedHeaders = Object.keys(canonicalHeaders).sort();
        return `${request2.method}
${this.getCanonicalPath(request2)}
${getCanonicalQuery(request2)}
${sortedHeaders.map((name) => `${name}:${canonicalHeaders[name]}`).join("\n")}

${sortedHeaders.join(";")}
${payloadHash}`;
      }
      async createStringToSign(longDate, credentialScope, canonicalRequest, algorithmIdentifier) {
        const hash = new this.sha256();
        hash.update(utilUtf8.toUint8Array(canonicalRequest));
        const hashedRequest = await hash.digest();
        return `${algorithmIdentifier}
${longDate}
${credentialScope}
${utilHexEncoding.toHex(hashedRequest)}`;
      }
      getCanonicalPath({ path: path3 }) {
        if (this.uriEscapePath) {
          const normalizedPathSegments = [];
          for (const pathSegment of path3.split("/")) {
            if (pathSegment?.length === 0)
              continue;
            if (pathSegment === ".")
              continue;
            if (pathSegment === "..") {
              normalizedPathSegments.pop();
            } else {
              normalizedPathSegments.push(pathSegment);
            }
          }
          const normalizedPath = `${path3?.startsWith("/") ? "/" : ""}${normalizedPathSegments.join("/")}${normalizedPathSegments.length > 0 && path3?.endsWith("/") ? "/" : ""}`;
          const doubleEncoded = utilUriEscape.escapeUri(normalizedPath);
          return doubleEncoded.replace(/%2F/g, "/");
        }
        return path3;
      }
      validateResolvedCredentials(credentials) {
        if (typeof credentials !== "object" || typeof credentials.accessKeyId !== "string" || typeof credentials.secretAccessKey !== "string") {
          throw new Error("Resolved credential object is not valid");
        }
      }
      formatDate(now) {
        const longDate = iso8601(now).replace(/[\-:]/g, "");
        return {
          longDate,
          shortDate: longDate.slice(0, 8)
        };
      }
      getCanonicalHeaderList(headers2) {
        return Object.keys(headers2).sort().join(";");
      }
    };
    var SignatureV42 = class extends SignatureV4Base {
      headerFormatter = new HeaderFormatter();
      constructor({ applyChecksum, credentials, region, service, sha256, uriEscapePath = true }) {
        super({
          applyChecksum,
          credentials,
          region,
          service,
          sha256,
          uriEscapePath
        });
      }
      async presign(originalRequest, options = {}) {
        const { signingDate = /* @__PURE__ */ new Date(), expiresIn = 3600, unsignableHeaders, unhoistableHeaders, signableHeaders, hoistableHeaders, signingRegion, signingService } = options;
        const credentials = await this.credentialProvider();
        this.validateResolvedCredentials(credentials);
        const region = signingRegion ?? await this.regionProvider();
        const { longDate, shortDate } = this.formatDate(signingDate);
        if (expiresIn > MAX_PRESIGNED_TTL) {
          return Promise.reject("Signature version 4 presigned URLs must have an expiration date less than one week in the future");
        }
        const scope = createScope(shortDate, region, signingService ?? this.service);
        const request2 = moveHeadersToQuery(prepareRequest(originalRequest), { unhoistableHeaders, hoistableHeaders });
        if (credentials.sessionToken) {
          request2.query[TOKEN_QUERY_PARAM] = credentials.sessionToken;
        }
        request2.query[ALGORITHM_QUERY_PARAM] = ALGORITHM_IDENTIFIER;
        request2.query[CREDENTIAL_QUERY_PARAM] = `${credentials.accessKeyId}/${scope}`;
        request2.query[AMZ_DATE_QUERY_PARAM] = longDate;
        request2.query[EXPIRES_QUERY_PARAM] = expiresIn.toString(10);
        const canonicalHeaders = getCanonicalHeaders(request2, unsignableHeaders, signableHeaders);
        request2.query[SIGNED_HEADERS_QUERY_PARAM] = this.getCanonicalHeaderList(canonicalHeaders);
        request2.query[SIGNATURE_QUERY_PARAM] = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request2, canonicalHeaders, await getPayloadHash(originalRequest, this.sha256)));
        return request2;
      }
      async sign(toSign, options) {
        if (typeof toSign === "string") {
          return this.signString(toSign, options);
        } else if (toSign.headers && toSign.payload) {
          return this.signEvent(toSign, options);
        } else if (toSign.message) {
          return this.signMessage(toSign, options);
        } else {
          return this.signRequest(toSign, options);
        }
      }
      async signEvent({ headers: headers2, payload: payload2 }, { signingDate = /* @__PURE__ */ new Date(), priorSignature, signingRegion, signingService }) {
        const region = signingRegion ?? await this.regionProvider();
        const { shortDate, longDate } = this.formatDate(signingDate);
        const scope = createScope(shortDate, region, signingService ?? this.service);
        const hashedPayload = await getPayloadHash({ headers: {}, body: payload2 }, this.sha256);
        const hash = new this.sha256();
        hash.update(headers2);
        const hashedHeaders = utilHexEncoding.toHex(await hash.digest());
        const stringToSign = [
          EVENT_ALGORITHM_IDENTIFIER,
          longDate,
          scope,
          priorSignature,
          hashedHeaders,
          hashedPayload
        ].join("\n");
        return this.signString(stringToSign, { signingDate, signingRegion: region, signingService });
      }
      async signMessage(signableMessage, { signingDate = /* @__PURE__ */ new Date(), signingRegion, signingService }) {
        const promise2 = this.signEvent({
          headers: this.headerFormatter.format(signableMessage.message.headers),
          payload: signableMessage.message.body
        }, {
          signingDate,
          signingRegion,
          signingService,
          priorSignature: signableMessage.priorSignature
        });
        return promise2.then((signature) => {
          return { message: signableMessage.message, signature };
        });
      }
      async signString(stringToSign, { signingDate = /* @__PURE__ */ new Date(), signingRegion, signingService } = {}) {
        const credentials = await this.credentialProvider();
        this.validateResolvedCredentials(credentials);
        const region = signingRegion ?? await this.regionProvider();
        const { shortDate } = this.formatDate(signingDate);
        const hash = new this.sha256(await this.getSigningKey(credentials, region, shortDate, signingService));
        hash.update(utilUtf8.toUint8Array(stringToSign));
        return utilHexEncoding.toHex(await hash.digest());
      }
      async signRequest(requestToSign, { signingDate = /* @__PURE__ */ new Date(), signableHeaders, unsignableHeaders, signingRegion, signingService } = {}) {
        const credentials = await this.credentialProvider();
        this.validateResolvedCredentials(credentials);
        const region = signingRegion ?? await this.regionProvider();
        const request2 = prepareRequest(requestToSign);
        const { longDate, shortDate } = this.formatDate(signingDate);
        const scope = createScope(shortDate, region, signingService ?? this.service);
        request2.headers[AMZ_DATE_HEADER] = longDate;
        if (credentials.sessionToken) {
          request2.headers[TOKEN_HEADER] = credentials.sessionToken;
        }
        const payloadHash = await getPayloadHash(request2, this.sha256);
        if (!hasHeader(SHA256_HEADER, request2.headers) && this.applyChecksum) {
          request2.headers[SHA256_HEADER] = payloadHash;
        }
        const canonicalHeaders = getCanonicalHeaders(request2, unsignableHeaders, signableHeaders);
        const signature = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request2, canonicalHeaders, payloadHash));
        request2.headers[AUTH_HEADER] = `${ALGORITHM_IDENTIFIER} Credential=${credentials.accessKeyId}/${scope}, SignedHeaders=${this.getCanonicalHeaderList(canonicalHeaders)}, Signature=${signature}`;
        return request2;
      }
      async getSignature(longDate, credentialScope, keyPromise, canonicalRequest) {
        const stringToSign = await this.createStringToSign(longDate, credentialScope, canonicalRequest, ALGORITHM_IDENTIFIER);
        const hash = new this.sha256(await keyPromise);
        hash.update(utilUtf8.toUint8Array(stringToSign));
        return utilHexEncoding.toHex(await hash.digest());
      }
      getSigningKey(credentials, region, shortDate, service) {
        return getSigningKey(this.sha256, credentials, shortDate, region, service || this.service);
      }
    };
    var signatureV4aContainer = {
      SignatureV4a: null
    };
    exports2.ALGORITHM_IDENTIFIER = ALGORITHM_IDENTIFIER;
    exports2.ALGORITHM_IDENTIFIER_V4A = ALGORITHM_IDENTIFIER_V4A;
    exports2.ALGORITHM_QUERY_PARAM = ALGORITHM_QUERY_PARAM;
    exports2.ALWAYS_UNSIGNABLE_HEADERS = ALWAYS_UNSIGNABLE_HEADERS;
    exports2.AMZ_DATE_HEADER = AMZ_DATE_HEADER;
    exports2.AMZ_DATE_QUERY_PARAM = AMZ_DATE_QUERY_PARAM;
    exports2.AUTH_HEADER = AUTH_HEADER;
    exports2.CREDENTIAL_QUERY_PARAM = CREDENTIAL_QUERY_PARAM;
    exports2.DATE_HEADER = DATE_HEADER;
    exports2.EVENT_ALGORITHM_IDENTIFIER = EVENT_ALGORITHM_IDENTIFIER;
    exports2.EXPIRES_QUERY_PARAM = EXPIRES_QUERY_PARAM;
    exports2.GENERATED_HEADERS = GENERATED_HEADERS;
    exports2.HOST_HEADER = HOST_HEADER;
    exports2.KEY_TYPE_IDENTIFIER = KEY_TYPE_IDENTIFIER;
    exports2.MAX_CACHE_SIZE = MAX_CACHE_SIZE2;
    exports2.MAX_PRESIGNED_TTL = MAX_PRESIGNED_TTL;
    exports2.PROXY_HEADER_PATTERN = PROXY_HEADER_PATTERN;
    exports2.REGION_SET_PARAM = REGION_SET_PARAM;
    exports2.SEC_HEADER_PATTERN = SEC_HEADER_PATTERN;
    exports2.SHA256_HEADER = SHA256_HEADER;
    exports2.SIGNATURE_HEADER = SIGNATURE_HEADER;
    exports2.SIGNATURE_QUERY_PARAM = SIGNATURE_QUERY_PARAM;
    exports2.SIGNED_HEADERS_QUERY_PARAM = SIGNED_HEADERS_QUERY_PARAM;
    exports2.SignatureV4 = SignatureV42;
    exports2.SignatureV4Base = SignatureV4Base;
    exports2.TOKEN_HEADER = TOKEN_HEADER;
    exports2.TOKEN_QUERY_PARAM = TOKEN_QUERY_PARAM;
    exports2.UNSIGNABLE_PATTERNS = UNSIGNABLE_PATTERNS;
    exports2.UNSIGNED_PAYLOAD = UNSIGNED_PAYLOAD;
    exports2.clearCredentialCache = clearCredentialCache;
    exports2.createScope = createScope;
    exports2.getCanonicalHeaders = getCanonicalHeaders;
    exports2.getCanonicalQuery = getCanonicalQuery;
    exports2.getPayloadHash = getPayloadHash;
    exports2.getSigningKey = getSigningKey;
    exports2.hasHeader = hasHeader;
    exports2.moveHeadersToQuery = moveHeadersToQuery;
    exports2.prepareRequest = prepareRequest;
    exports2.signatureV4aContainer = signatureV4aContainer;
  }
});

// node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/resolveAwsSdkSigV4Config.js
function normalizeCredentialProvider(config, { credentials, credentialDefaultProvider }) {
  let credentialsProvider;
  if (credentials) {
    if (!credentials?.memoized) {
      credentialsProvider = memoizeIdentityProvider(credentials, isIdentityExpired, doesIdentityRequireRefresh);
    } else {
      credentialsProvider = credentials;
    }
  } else {
    if (credentialDefaultProvider) {
      credentialsProvider = normalizeProvider(credentialDefaultProvider(Object.assign({}, config, {
        parentClientConfig: config
      })));
    } else {
      credentialsProvider = async () => {
        throw new Error("@aws-sdk/core::resolveAwsSdkSigV4Config - `credentials` not provided and no credentialDefaultProvider was configured.");
      };
    }
  }
  credentialsProvider.memoized = true;
  return credentialsProvider;
}
function bindCallerConfig(config, credentialsProvider) {
  if (credentialsProvider.configBound) {
    return credentialsProvider;
  }
  const fn = async (options) => credentialsProvider({ ...options, callerClientConfig: config });
  fn.memoized = credentialsProvider.memoized;
  fn.configBound = true;
  return fn;
}
var import_signature_v4, resolveAwsSdkSigV4Config, resolveAWSSDKSigV4Config;
var init_resolveAwsSdkSigV4Config = __esm({
  "node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/resolveAwsSdkSigV4Config.js"() {
    init_client();
    init_dist_es();
    import_signature_v4 = __toESM(require_dist_cjs18());
    resolveAwsSdkSigV4Config = (config) => {
      let inputCredentials = config.credentials;
      let isUserSupplied = !!config.credentials;
      let resolvedCredentials = void 0;
      Object.defineProperty(config, "credentials", {
        set(credentials) {
          if (credentials && credentials !== inputCredentials && credentials !== resolvedCredentials) {
            isUserSupplied = true;
          }
          inputCredentials = credentials;
          const memoizedProvider = normalizeCredentialProvider(config, {
            credentials: inputCredentials,
            credentialDefaultProvider: config.credentialDefaultProvider
          });
          const boundProvider = bindCallerConfig(config, memoizedProvider);
          if (isUserSupplied && !boundProvider.attributed) {
            const isCredentialObject = typeof inputCredentials === "object" && inputCredentials !== null;
            resolvedCredentials = async (options) => {
              const creds = await boundProvider(options);
              const attributedCreds = creds;
              if (isCredentialObject && (!attributedCreds.$source || Object.keys(attributedCreds.$source).length === 0)) {
                return setCredentialFeature(attributedCreds, "CREDENTIALS_CODE", "e");
              }
              return attributedCreds;
            };
            resolvedCredentials.memoized = boundProvider.memoized;
            resolvedCredentials.configBound = boundProvider.configBound;
            resolvedCredentials.attributed = true;
          } else {
            resolvedCredentials = boundProvider;
          }
        },
        get() {
          return resolvedCredentials;
        },
        enumerable: true,
        configurable: true
      });
      config.credentials = inputCredentials;
      const { signingEscapePath = true, systemClockOffset = config.systemClockOffset || 0, sha256 } = config;
      let signer;
      if (config.signer) {
        signer = normalizeProvider(config.signer);
      } else if (config.regionInfoProvider) {
        signer = () => normalizeProvider(config.region)().then(async (region) => [
          await config.regionInfoProvider(region, {
            useFipsEndpoint: await config.useFipsEndpoint(),
            useDualstackEndpoint: await config.useDualstackEndpoint()
          }) || {},
          region
        ]).then(([regionInfo, region]) => {
          const { signingRegion, signingService } = regionInfo;
          config.signingRegion = config.signingRegion || signingRegion || region;
          config.signingName = config.signingName || signingService || config.serviceId;
          const params = {
            ...config,
            credentials: config.credentials,
            region: config.signingRegion,
            service: config.signingName,
            sha256,
            uriEscapePath: signingEscapePath
          };
          const SignerCtor = config.signerConstructor || import_signature_v4.SignatureV4;
          return new SignerCtor(params);
        });
      } else {
        signer = async (authScheme) => {
          authScheme = Object.assign({}, {
            name: "sigv4",
            signingName: config.signingName || config.defaultSigningName,
            signingRegion: await normalizeProvider(config.region)(),
            properties: {}
          }, authScheme);
          const signingRegion = authScheme.signingRegion;
          const signingService = authScheme.signingName;
          config.signingRegion = config.signingRegion || signingRegion;
          config.signingName = config.signingName || signingService || config.serviceId;
          const params = {
            ...config,
            credentials: config.credentials,
            region: config.signingRegion,
            service: config.signingName,
            sha256,
            uriEscapePath: signingEscapePath
          };
          const SignerCtor = config.signerConstructor || import_signature_v4.SignatureV4;
          return new SignerCtor(params);
        };
      }
      const resolvedConfig = Object.assign(config, {
        systemClockOffset,
        signingEscapePath,
        signer
      });
      return resolvedConfig;
    };
    resolveAWSSDKSigV4Config = resolveAwsSdkSigV4Config;
  }
});

// node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/index.js
var init_aws_sdk = __esm({
  "node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/index.js"() {
    init_AwsSdkSigV4Signer();
    init_AwsSdkSigV4ASigner();
    init_NODE_AUTH_SCHEME_PREFERENCE_OPTIONS();
    init_resolveAwsSdkSigV4AConfig();
    init_resolveAwsSdkSigV4Config();
  }
});

// node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/index.js
var httpAuthSchemes_exports = {};
__export(httpAuthSchemes_exports, {
  AWSSDKSigV4Signer: () => AWSSDKSigV4Signer,
  AwsSdkSigV4ASigner: () => AwsSdkSigV4ASigner,
  AwsSdkSigV4Signer: () => AwsSdkSigV4Signer,
  NODE_AUTH_SCHEME_PREFERENCE_OPTIONS: () => NODE_AUTH_SCHEME_PREFERENCE_OPTIONS,
  NODE_SIGV4A_CONFIG_OPTIONS: () => NODE_SIGV4A_CONFIG_OPTIONS,
  getBearerTokenEnvKey: () => getBearerTokenEnvKey,
  resolveAWSSDKSigV4Config: () => resolveAWSSDKSigV4Config,
  resolveAwsSdkSigV4AConfig: () => resolveAwsSdkSigV4AConfig,
  resolveAwsSdkSigV4Config: () => resolveAwsSdkSigV4Config,
  validateSigningProperties: () => validateSigningProperties
});
var init_httpAuthSchemes2 = __esm({
  "node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/index.js"() {
    init_aws_sdk();
    init_getBearerTokenEnvKey();
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/cbor/cbor-types.js
function alloc(size) {
  return typeof Buffer !== "undefined" ? Buffer.alloc(size) : new Uint8Array(size);
}
function tag(data2) {
  data2[tagSymbol] = true;
  return data2;
}
var majorUint64, majorNegativeInt64, majorUnstructuredByteString, majorUtf8String, majorList, majorMap, majorTag, majorSpecial, specialFalse, specialTrue, specialNull, specialUndefined, extendedOneByte, extendedFloat16, extendedFloat32, extendedFloat64, minorIndefinite, tagSymbol;
var init_cbor_types = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/cbor/cbor-types.js"() {
    majorUint64 = 0;
    majorNegativeInt64 = 1;
    majorUnstructuredByteString = 2;
    majorUtf8String = 3;
    majorList = 4;
    majorMap = 5;
    majorTag = 6;
    majorSpecial = 7;
    specialFalse = 20;
    specialTrue = 21;
    specialNull = 22;
    specialUndefined = 23;
    extendedOneByte = 24;
    extendedFloat16 = 25;
    extendedFloat32 = 26;
    extendedFloat64 = 27;
    minorIndefinite = 31;
    tagSymbol = /* @__PURE__ */ Symbol("@smithy/core/cbor::tagSymbol");
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/cbor/cbor-decode.js
function setPayload(bytes) {
  payload = bytes;
  dataView = new DataView(payload.buffer, payload.byteOffset, payload.byteLength);
}
function decode(at, to) {
  if (at >= to) {
    throw new Error("unexpected end of (decode) payload.");
  }
  const major = (payload[at] & 224) >> 5;
  const minor = payload[at] & 31;
  switch (major) {
    case majorUint64:
    case majorNegativeInt64:
    case majorTag:
      let unsignedInt;
      let offset;
      if (minor < 24) {
        unsignedInt = minor;
        offset = 1;
      } else {
        switch (minor) {
          case extendedOneByte:
          case extendedFloat16:
          case extendedFloat32:
          case extendedFloat64:
            const countLength = minorValueToArgumentLength[minor];
            const countOffset = countLength + 1;
            offset = countOffset;
            if (to - at < countOffset) {
              throw new Error(`countLength ${countLength} greater than remaining buf len.`);
            }
            const countIndex = at + 1;
            if (countLength === 1) {
              unsignedInt = payload[countIndex];
            } else if (countLength === 2) {
              unsignedInt = dataView.getUint16(countIndex);
            } else if (countLength === 4) {
              unsignedInt = dataView.getUint32(countIndex);
            } else {
              unsignedInt = dataView.getBigUint64(countIndex);
            }
            break;
          default:
            throw new Error(`unexpected minor value ${minor}.`);
        }
      }
      if (major === majorUint64) {
        _offset = offset;
        return castBigInt(unsignedInt);
      } else if (major === majorNegativeInt64) {
        let negativeInt;
        if (typeof unsignedInt === "bigint") {
          negativeInt = BigInt(-1) - unsignedInt;
        } else {
          negativeInt = -1 - unsignedInt;
        }
        _offset = offset;
        return castBigInt(negativeInt);
      } else {
        if (minor === 2 || minor === 3) {
          const length = decodeCount(at + offset, to);
          let b4 = BigInt(0);
          const start = at + offset + _offset;
          for (let i4 = start; i4 < start + length; ++i4) {
            b4 = b4 << BigInt(8) | BigInt(payload[i4]);
          }
          _offset = offset + _offset + length;
          return minor === 3 ? -b4 - BigInt(1) : b4;
        } else if (minor === 4) {
          const decimalFraction = decode(at + offset, to);
          const [exponent, mantissa] = decimalFraction;
          const normalizer = mantissa < 0 ? -1 : 1;
          const mantissaStr = "0".repeat(Math.abs(exponent) + 1) + String(BigInt(normalizer) * BigInt(mantissa));
          let numericString;
          const sign = mantissa < 0 ? "-" : "";
          numericString = exponent === 0 ? mantissaStr : mantissaStr.slice(0, mantissaStr.length + exponent) + "." + mantissaStr.slice(exponent);
          numericString = numericString.replace(/^0+/g, "");
          if (numericString === "") {
            numericString = "0";
          }
          if (numericString[0] === ".") {
            numericString = "0" + numericString;
          }
          numericString = sign + numericString;
          _offset = offset + _offset;
          return nv(numericString);
        } else {
          const value = decode(at + offset, to);
          const valueOffset = _offset;
          _offset = offset + valueOffset;
          return tag({ tag: castBigInt(unsignedInt), value });
        }
      }
    case majorUtf8String:
    case majorMap:
    case majorList:
    case majorUnstructuredByteString:
      if (minor === minorIndefinite) {
        switch (major) {
          case majorUtf8String:
            return decodeUtf8StringIndefinite(at, to);
          case majorMap:
            return decodeMapIndefinite(at, to);
          case majorList:
            return decodeListIndefinite(at, to);
          case majorUnstructuredByteString:
            return decodeUnstructuredByteStringIndefinite(at, to);
        }
      } else {
        switch (major) {
          case majorUtf8String:
            return decodeUtf8String(at, to);
          case majorMap:
            return decodeMap(at, to);
          case majorList:
            return decodeList(at, to);
          case majorUnstructuredByteString:
            return decodeUnstructuredByteString(at, to);
        }
      }
    default:
      return decodeSpecial(at, to);
  }
}
function bytesToUtf8(bytes, at, to) {
  if (USE_BUFFER && bytes.constructor?.name === "Buffer") {
    return bytes.toString("utf-8", at, to);
  }
  if (textDecoder) {
    return textDecoder.decode(bytes.subarray(at, to));
  }
  return (0, import_util_utf84.toUtf8)(bytes.subarray(at, to));
}
function demote(bigInteger) {
  const num = Number(bigInteger);
  if (num < Number.MIN_SAFE_INTEGER || Number.MAX_SAFE_INTEGER < num) {
    console.warn(new Error(`@smithy/core/cbor - truncating BigInt(${bigInteger}) to ${num} with loss of precision.`));
  }
  return num;
}
function bytesToFloat16(a4, b4) {
  const sign = a4 >> 7;
  const exponent = (a4 & 124) >> 2;
  const fraction = (a4 & 3) << 8 | b4;
  const scalar = sign === 0 ? 1 : -1;
  let exponentComponent;
  let summation;
  if (exponent === 0) {
    if (fraction === 0) {
      return 0;
    } else {
      exponentComponent = Math.pow(2, 1 - 15);
      summation = 0;
    }
  } else if (exponent === 31) {
    if (fraction === 0) {
      return scalar * Infinity;
    } else {
      return NaN;
    }
  } else {
    exponentComponent = Math.pow(2, exponent - 15);
    summation = 1;
  }
  summation += fraction / 1024;
  return scalar * (exponentComponent * summation);
}
function decodeCount(at, to) {
  const minor = payload[at] & 31;
  if (minor < 24) {
    _offset = 1;
    return minor;
  }
  if (minor === extendedOneByte || minor === extendedFloat16 || minor === extendedFloat32 || minor === extendedFloat64) {
    const countLength = minorValueToArgumentLength[minor];
    _offset = countLength + 1;
    if (to - at < _offset) {
      throw new Error(`countLength ${countLength} greater than remaining buf len.`);
    }
    const countIndex = at + 1;
    if (countLength === 1) {
      return payload[countIndex];
    } else if (countLength === 2) {
      return dataView.getUint16(countIndex);
    } else if (countLength === 4) {
      return dataView.getUint32(countIndex);
    }
    return demote(dataView.getBigUint64(countIndex));
  }
  throw new Error(`unexpected minor value ${minor}.`);
}
function decodeUtf8String(at, to) {
  const length = decodeCount(at, to);
  const offset = _offset;
  at += offset;
  if (to - at < length) {
    throw new Error(`string len ${length} greater than remaining buf len.`);
  }
  const value = bytesToUtf8(payload, at, at + length);
  _offset = offset + length;
  return value;
}
function decodeUtf8StringIndefinite(at, to) {
  at += 1;
  const vector = [];
  for (const base2 = at; at < to; ) {
    if (payload[at] === 255) {
      const data2 = alloc(vector.length);
      data2.set(vector, 0);
      _offset = at - base2 + 2;
      return bytesToUtf8(data2, 0, data2.length);
    }
    const major = (payload[at] & 224) >> 5;
    const minor = payload[at] & 31;
    if (major !== majorUtf8String) {
      throw new Error(`unexpected major type ${major} in indefinite string.`);
    }
    if (minor === minorIndefinite) {
      throw new Error("nested indefinite string.");
    }
    const bytes = decodeUnstructuredByteString(at, to);
    const length = _offset;
    at += length;
    for (let i4 = 0; i4 < bytes.length; ++i4) {
      vector.push(bytes[i4]);
    }
  }
  throw new Error("expected break marker.");
}
function decodeUnstructuredByteString(at, to) {
  const length = decodeCount(at, to);
  const offset = _offset;
  at += offset;
  if (to - at < length) {
    throw new Error(`unstructured byte string len ${length} greater than remaining buf len.`);
  }
  const value = payload.subarray(at, at + length);
  _offset = offset + length;
  return value;
}
function decodeUnstructuredByteStringIndefinite(at, to) {
  at += 1;
  const vector = [];
  for (const base2 = at; at < to; ) {
    if (payload[at] === 255) {
      const data2 = alloc(vector.length);
      data2.set(vector, 0);
      _offset = at - base2 + 2;
      return data2;
    }
    const major = (payload[at] & 224) >> 5;
    const minor = payload[at] & 31;
    if (major !== majorUnstructuredByteString) {
      throw new Error(`unexpected major type ${major} in indefinite string.`);
    }
    if (minor === minorIndefinite) {
      throw new Error("nested indefinite string.");
    }
    const bytes = decodeUnstructuredByteString(at, to);
    const length = _offset;
    at += length;
    for (let i4 = 0; i4 < bytes.length; ++i4) {
      vector.push(bytes[i4]);
    }
  }
  throw new Error("expected break marker.");
}
function decodeList(at, to) {
  const listDataLength = decodeCount(at, to);
  const offset = _offset;
  at += offset;
  const base2 = at;
  const list2 = Array(listDataLength);
  for (let i4 = 0; i4 < listDataLength; ++i4) {
    const item = decode(at, to);
    const itemOffset = _offset;
    list2[i4] = item;
    at += itemOffset;
  }
  _offset = offset + (at - base2);
  return list2;
}
function decodeListIndefinite(at, to) {
  at += 1;
  const list2 = [];
  for (const base2 = at; at < to; ) {
    if (payload[at] === 255) {
      _offset = at - base2 + 2;
      return list2;
    }
    const item = decode(at, to);
    const n4 = _offset;
    at += n4;
    list2.push(item);
  }
  throw new Error("expected break marker.");
}
function decodeMap(at, to) {
  const mapDataLength = decodeCount(at, to);
  const offset = _offset;
  at += offset;
  const base2 = at;
  const map2 = {};
  for (let i4 = 0; i4 < mapDataLength; ++i4) {
    if (at >= to) {
      throw new Error("unexpected end of map payload.");
    }
    const major = (payload[at] & 224) >> 5;
    if (major !== majorUtf8String) {
      throw new Error(`unexpected major type ${major} for map key at index ${at}.`);
    }
    const key = decode(at, to);
    at += _offset;
    const value = decode(at, to);
    at += _offset;
    map2[key] = value;
  }
  _offset = offset + (at - base2);
  return map2;
}
function decodeMapIndefinite(at, to) {
  at += 1;
  const base2 = at;
  const map2 = {};
  for (; at < to; ) {
    if (at >= to) {
      throw new Error("unexpected end of map payload.");
    }
    if (payload[at] === 255) {
      _offset = at - base2 + 2;
      return map2;
    }
    const major = (payload[at] & 224) >> 5;
    if (major !== majorUtf8String) {
      throw new Error(`unexpected major type ${major} for map key.`);
    }
    const key = decode(at, to);
    at += _offset;
    const value = decode(at, to);
    at += _offset;
    map2[key] = value;
  }
  throw new Error("expected break marker.");
}
function decodeSpecial(at, to) {
  const minor = payload[at] & 31;
  switch (minor) {
    case specialTrue:
    case specialFalse:
      _offset = 1;
      return minor === specialTrue;
    case specialNull:
      _offset = 1;
      return null;
    case specialUndefined:
      _offset = 1;
      return null;
    case extendedFloat16:
      if (to - at < 3) {
        throw new Error("incomplete float16 at end of buf.");
      }
      _offset = 3;
      return bytesToFloat16(payload[at + 1], payload[at + 2]);
    case extendedFloat32:
      if (to - at < 5) {
        throw new Error("incomplete float32 at end of buf.");
      }
      _offset = 5;
      return dataView.getFloat32(at + 1);
    case extendedFloat64:
      if (to - at < 9) {
        throw new Error("incomplete float64 at end of buf.");
      }
      _offset = 9;
      return dataView.getFloat64(at + 1);
    default:
      throw new Error(`unexpected minor value ${minor}.`);
  }
}
function castBigInt(bigInt) {
  if (typeof bigInt === "number") {
    return bigInt;
  }
  const num = Number(bigInt);
  if (Number.MIN_SAFE_INTEGER <= num && num <= Number.MAX_SAFE_INTEGER) {
    return num;
  }
  return bigInt;
}
var import_util_utf84, USE_TEXT_DECODER, USE_BUFFER, payload, dataView, textDecoder, _offset, minorValueToArgumentLength;
var init_cbor_decode = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/cbor/cbor-decode.js"() {
    init_serde();
    import_util_utf84 = __toESM(require_dist_cjs8());
    init_cbor_types();
    USE_TEXT_DECODER = typeof TextDecoder !== "undefined";
    USE_BUFFER = typeof Buffer !== "undefined";
    payload = alloc(0);
    dataView = new DataView(payload.buffer, payload.byteOffset, payload.byteLength);
    textDecoder = USE_TEXT_DECODER ? new TextDecoder() : null;
    _offset = 0;
    minorValueToArgumentLength = {
      [extendedOneByte]: 1,
      [extendedFloat16]: 2,
      [extendedFloat32]: 4,
      [extendedFloat64]: 8
    };
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/cbor/cbor-encode.js
function ensureSpace(bytes) {
  const remaining = data.byteLength - cursor;
  if (remaining < bytes) {
    if (cursor < 16e6) {
      resize(Math.max(data.byteLength * 4, data.byteLength + bytes));
    } else {
      resize(data.byteLength + bytes + 16e6);
    }
  }
}
function toUint8Array() {
  const out = alloc(cursor);
  out.set(data.subarray(0, cursor), 0);
  cursor = 0;
  return out;
}
function resize(size) {
  const old = data;
  data = alloc(size);
  if (old) {
    if (old.copy) {
      old.copy(data, 0, 0, old.byteLength);
    } else {
      data.set(old, 0);
    }
  }
  dataView2 = new DataView(data.buffer, data.byteOffset, data.byteLength);
}
function encodeHeader(major, value) {
  if (value < 24) {
    data[cursor++] = major << 5 | value;
  } else if (value < 1 << 8) {
    data[cursor++] = major << 5 | 24;
    data[cursor++] = value;
  } else if (value < 1 << 16) {
    data[cursor++] = major << 5 | extendedFloat16;
    dataView2.setUint16(cursor, value);
    cursor += 2;
  } else if (value < 2 ** 32) {
    data[cursor++] = major << 5 | extendedFloat32;
    dataView2.setUint32(cursor, value);
    cursor += 4;
  } else {
    data[cursor++] = major << 5 | extendedFloat64;
    dataView2.setBigUint64(cursor, typeof value === "bigint" ? value : BigInt(value));
    cursor += 8;
  }
}
function encode(_input) {
  const encodeStack = [_input];
  while (encodeStack.length) {
    const input = encodeStack.pop();
    ensureSpace(typeof input === "string" ? input.length * 4 : 64);
    if (typeof input === "string") {
      if (USE_BUFFER2) {
        encodeHeader(majorUtf8String, Buffer.byteLength(input));
        cursor += data.write(input, cursor);
      } else {
        const bytes = (0, import_util_utf85.fromUtf8)(input);
        encodeHeader(majorUtf8String, bytes.byteLength);
        data.set(bytes, cursor);
        cursor += bytes.byteLength;
      }
      continue;
    } else if (typeof input === "number") {
      if (Number.isInteger(input)) {
        const nonNegative = input >= 0;
        const major = nonNegative ? majorUint64 : majorNegativeInt64;
        const value = nonNegative ? input : -input - 1;
        if (value < 24) {
          data[cursor++] = major << 5 | value;
        } else if (value < 256) {
          data[cursor++] = major << 5 | 24;
          data[cursor++] = value;
        } else if (value < 65536) {
          data[cursor++] = major << 5 | extendedFloat16;
          data[cursor++] = value >> 8;
          data[cursor++] = value;
        } else if (value < 4294967296) {
          data[cursor++] = major << 5 | extendedFloat32;
          dataView2.setUint32(cursor, value);
          cursor += 4;
        } else {
          data[cursor++] = major << 5 | extendedFloat64;
          dataView2.setBigUint64(cursor, BigInt(value));
          cursor += 8;
        }
        continue;
      }
      data[cursor++] = majorSpecial << 5 | extendedFloat64;
      dataView2.setFloat64(cursor, input);
      cursor += 8;
      continue;
    } else if (typeof input === "bigint") {
      const nonNegative = input >= 0;
      const major = nonNegative ? majorUint64 : majorNegativeInt64;
      const value = nonNegative ? input : -input - BigInt(1);
      const n4 = Number(value);
      if (n4 < 24) {
        data[cursor++] = major << 5 | n4;
      } else if (n4 < 256) {
        data[cursor++] = major << 5 | 24;
        data[cursor++] = n4;
      } else if (n4 < 65536) {
        data[cursor++] = major << 5 | extendedFloat16;
        data[cursor++] = n4 >> 8;
        data[cursor++] = n4 & 255;
      } else if (n4 < 4294967296) {
        data[cursor++] = major << 5 | extendedFloat32;
        dataView2.setUint32(cursor, n4);
        cursor += 4;
      } else if (value < BigInt("18446744073709551616")) {
        data[cursor++] = major << 5 | extendedFloat64;
        dataView2.setBigUint64(cursor, value);
        cursor += 8;
      } else {
        const binaryBigInt = value.toString(2);
        const bigIntBytes = new Uint8Array(Math.ceil(binaryBigInt.length / 8));
        let b4 = value;
        let i4 = 0;
        while (bigIntBytes.byteLength - ++i4 >= 0) {
          bigIntBytes[bigIntBytes.byteLength - i4] = Number(b4 & BigInt(255));
          b4 >>= BigInt(8);
        }
        ensureSpace(bigIntBytes.byteLength * 2);
        data[cursor++] = nonNegative ? 194 : 195;
        if (USE_BUFFER2) {
          encodeHeader(majorUnstructuredByteString, Buffer.byteLength(bigIntBytes));
        } else {
          encodeHeader(majorUnstructuredByteString, bigIntBytes.byteLength);
        }
        data.set(bigIntBytes, cursor);
        cursor += bigIntBytes.byteLength;
      }
      continue;
    } else if (input === null) {
      data[cursor++] = majorSpecial << 5 | specialNull;
      continue;
    } else if (typeof input === "boolean") {
      data[cursor++] = majorSpecial << 5 | (input ? specialTrue : specialFalse);
      continue;
    } else if (typeof input === "undefined") {
      throw new Error("@smithy/core/cbor: client may not serialize undefined value.");
    } else if (Array.isArray(input)) {
      for (let i4 = input.length - 1; i4 >= 0; --i4) {
        encodeStack.push(input[i4]);
      }
      encodeHeader(majorList, input.length);
      continue;
    } else if (typeof input.byteLength === "number") {
      ensureSpace(input.length * 2);
      encodeHeader(majorUnstructuredByteString, input.length);
      data.set(input, cursor);
      cursor += input.byteLength;
      continue;
    } else if (typeof input === "object") {
      if (input instanceof NumericValue) {
        const decimalIndex = input.string.indexOf(".");
        const exponent = decimalIndex === -1 ? 0 : decimalIndex - input.string.length + 1;
        const mantissa = BigInt(input.string.replace(".", ""));
        data[cursor++] = 196;
        encodeStack.push(mantissa);
        encodeStack.push(exponent);
        encodeHeader(majorList, 2);
        continue;
      }
      if (input[tagSymbol]) {
        if ("tag" in input && "value" in input) {
          encodeStack.push(input.value);
          encodeHeader(majorTag, input.tag);
          continue;
        } else {
          throw new Error("tag encountered with missing fields, need 'tag' and 'value', found: " + JSON.stringify(input));
        }
      }
      const keys2 = Object.keys(input);
      for (let i4 = keys2.length - 1; i4 >= 0; --i4) {
        const key = keys2[i4];
        encodeStack.push(input[key]);
        encodeStack.push(key);
      }
      encodeHeader(majorMap, keys2.length);
      continue;
    }
    throw new Error(`data type ${input?.constructor?.name ?? typeof input} not compatible for encoding.`);
  }
}
var import_util_utf85, USE_BUFFER2, initialSize, data, dataView2, cursor;
var init_cbor_encode = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/cbor/cbor-encode.js"() {
    init_serde();
    import_util_utf85 = __toESM(require_dist_cjs8());
    init_cbor_types();
    USE_BUFFER2 = typeof Buffer !== "undefined";
    initialSize = 2048;
    data = alloc(initialSize);
    dataView2 = new DataView(data.buffer, data.byteOffset, data.byteLength);
    cursor = 0;
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/cbor/cbor.js
var cbor;
var init_cbor = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/cbor/cbor.js"() {
    init_cbor_decode();
    init_cbor_encode();
    cbor = {
      deserialize(payload2) {
        setPayload(payload2);
        return decode(0, payload2.length);
      },
      serialize(input) {
        try {
          encode(input);
          return toUint8Array();
        } catch (e4) {
          toUint8Array();
          throw e4;
        }
      },
      resizeEncodingBuffer(size) {
        resize(size);
      }
    };
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/cbor/parseCborBody.js
var dateToTag, loadSmithyRpcV2CborErrorCode;
var init_parseCborBody = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/cbor/parseCborBody.js"() {
    init_cbor_types();
    dateToTag = (date3) => {
      return tag({
        tag: 1,
        value: date3.getTime() / 1e3
      });
    };
    loadSmithyRpcV2CborErrorCode = (output, data2) => {
      const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
          cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
          cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
          cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
          cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
      };
      if (data2["__type"] !== void 0) {
        return sanitizeErrorCode(data2["__type"]);
      }
      const codeKey = Object.keys(data2).find((key) => key.toLowerCase() === "code");
      if (codeKey && data2[codeKey] !== void 0) {
        return sanitizeErrorCode(data2[codeKey]);
      }
    };
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/cbor/CborCodec.js
var import_util_base643, CborCodec, CborShapeSerializer, CborShapeDeserializer;
var init_CborCodec = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/cbor/CborCodec.js"() {
    init_protocols();
    init_schema();
    init_serde();
    init_serde();
    import_util_base643 = __toESM(require_dist_cjs9());
    init_cbor();
    init_parseCborBody();
    CborCodec = class extends SerdeContext {
      createSerializer() {
        const serializer = new CborShapeSerializer();
        serializer.setSerdeContext(this.serdeContext);
        return serializer;
      }
      createDeserializer() {
        const deserializer = new CborShapeDeserializer();
        deserializer.setSerdeContext(this.serdeContext);
        return deserializer;
      }
    };
    CborShapeSerializer = class extends SerdeContext {
      value;
      write(schema, value) {
        this.value = this.serialize(schema, value);
      }
      serialize(schema, source) {
        const ns = NormalizedSchema.of(schema);
        if (source == null) {
          if (ns.isIdempotencyToken()) {
            return (0, import_uuid.v4)();
          }
          return source;
        }
        if (ns.isBlobSchema()) {
          if (typeof source === "string") {
            return (this.serdeContext?.base64Decoder ?? import_util_base643.fromBase64)(source);
          }
          return source;
        }
        if (ns.isTimestampSchema()) {
          if (typeof source === "number" || typeof source === "bigint") {
            return dateToTag(new Date(Number(source) / 1e3 | 0));
          }
          return dateToTag(source);
        }
        if (typeof source === "function" || typeof source === "object") {
          const sourceObject = source;
          if (ns.isListSchema() && Array.isArray(sourceObject)) {
            const sparse = !!ns.getMergedTraits().sparse;
            const newArray = [];
            let i4 = 0;
            for (const item of sourceObject) {
              const value = this.serialize(ns.getValueSchema(), item);
              if (value != null || sparse) {
                newArray[i4++] = value;
              }
            }
            return newArray;
          }
          if (sourceObject instanceof Date) {
            return dateToTag(sourceObject);
          }
          const newObject = {};
          if (ns.isMapSchema()) {
            const sparse = !!ns.getMergedTraits().sparse;
            for (const key of Object.keys(sourceObject)) {
              const value = this.serialize(ns.getValueSchema(), sourceObject[key]);
              if (value != null || sparse) {
                newObject[key] = value;
              }
            }
          } else if (ns.isStructSchema()) {
            for (const [key, memberSchema] of ns.structIterator()) {
              const value = this.serialize(memberSchema, sourceObject[key]);
              if (value != null) {
                newObject[key] = value;
              }
            }
            const isUnion = ns.isUnionSchema();
            if (isUnion && Array.isArray(sourceObject.$unknown)) {
              const [k4, v4] = sourceObject.$unknown;
              newObject[k4] = v4;
            } else if (typeof sourceObject.__type === "string") {
              for (const [k4, v4] of Object.entries(sourceObject)) {
                if (!(k4 in newObject)) {
                  newObject[k4] = this.serialize(15, v4);
                }
              }
            }
          } else if (ns.isDocumentSchema()) {
            for (const key of Object.keys(sourceObject)) {
              newObject[key] = this.serialize(ns.getValueSchema(), sourceObject[key]);
            }
          } else if (ns.isBigDecimalSchema()) {
            return sourceObject;
          }
          return newObject;
        }
        return source;
      }
      flush() {
        const buffer = cbor.serialize(this.value);
        this.value = void 0;
        return buffer;
      }
    };
    CborShapeDeserializer = class extends SerdeContext {
      read(schema, bytes) {
        const data2 = cbor.deserialize(bytes);
        return this.readValue(schema, data2);
      }
      readValue(_schema, value) {
        const ns = NormalizedSchema.of(_schema);
        if (ns.isTimestampSchema()) {
          if (typeof value === "number") {
            return _parseEpochTimestamp(value);
          }
          if (typeof value === "object") {
            if (value.tag === 1 && "value" in value) {
              return _parseEpochTimestamp(value.value);
            }
          }
        }
        if (ns.isBlobSchema()) {
          if (typeof value === "string") {
            return (this.serdeContext?.base64Decoder ?? import_util_base643.fromBase64)(value);
          }
          return value;
        }
        if (typeof value === "undefined" || typeof value === "boolean" || typeof value === "number" || typeof value === "string" || typeof value === "bigint" || typeof value === "symbol") {
          return value;
        } else if (typeof value === "object") {
          if (value === null) {
            return null;
          }
          if ("byteLength" in value) {
            return value;
          }
          if (value instanceof Date) {
            return value;
          }
          if (ns.isDocumentSchema()) {
            return value;
          }
          if (ns.isListSchema()) {
            const newArray = [];
            const memberSchema = ns.getValueSchema();
            const sparse = !!ns.getMergedTraits().sparse;
            for (const item of value) {
              const itemValue = this.readValue(memberSchema, item);
              if (itemValue != null || sparse) {
                newArray.push(itemValue);
              }
            }
            return newArray;
          }
          const newObject = {};
          if (ns.isMapSchema()) {
            const sparse = !!ns.getMergedTraits().sparse;
            const targetSchema = ns.getValueSchema();
            for (const key of Object.keys(value)) {
              const itemValue = this.readValue(targetSchema, value[key]);
              if (itemValue != null || sparse) {
                newObject[key] = itemValue;
              }
            }
          } else if (ns.isStructSchema()) {
            const isUnion = ns.isUnionSchema();
            let keys2;
            if (isUnion) {
              keys2 = new Set(Object.keys(value).filter((k4) => k4 !== "__type"));
            }
            for (const [key, memberSchema] of ns.structIterator()) {
              if (isUnion) {
                keys2.delete(key);
              }
              if (value[key] != null) {
                newObject[key] = this.readValue(memberSchema, value[key]);
              }
            }
            if (isUnion && keys2?.size === 1 && Object.keys(newObject).length === 0) {
              const k4 = keys2.values().next().value;
              newObject.$unknown = [k4, value[k4]];
            } else if (typeof value.__type === "string") {
              for (const [k4, v4] of Object.entries(value)) {
                if (!(k4 in newObject)) {
                  newObject[k4] = v4;
                }
              }
            }
          } else if (value instanceof NumericValue) {
            return value;
          }
          return newObject;
        } else {
          return value;
        }
      }
    };
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/cbor/SmithyRpcV2CborProtocol.js
var import_util_middleware5, SmithyRpcV2CborProtocol;
var init_SmithyRpcV2CborProtocol = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/cbor/SmithyRpcV2CborProtocol.js"() {
    init_protocols();
    init_schema();
    import_util_middleware5 = __toESM(require_dist_cjs4());
    init_CborCodec();
    init_parseCborBody();
    SmithyRpcV2CborProtocol = class extends RpcProtocol {
      codec = new CborCodec();
      serializer = this.codec.createSerializer();
      deserializer = this.codec.createDeserializer();
      constructor({ defaultNamespace }) {
        super({ defaultNamespace });
      }
      getShapeId() {
        return "smithy.protocols#rpcv2Cbor";
      }
      getPayloadCodec() {
        return this.codec;
      }
      async serializeRequest(operationSchema, input, context) {
        const request2 = await super.serializeRequest(operationSchema, input, context);
        Object.assign(request2.headers, {
          "content-type": this.getDefaultContentType(),
          "smithy-protocol": "rpc-v2-cbor",
          accept: this.getDefaultContentType()
        });
        if (deref(operationSchema.input) === "unit") {
          delete request2.body;
          delete request2.headers["content-type"];
        } else {
          if (!request2.body) {
            this.serializer.write(15, {});
            request2.body = this.serializer.flush();
          }
          try {
            request2.headers["content-length"] = String(request2.body.byteLength);
          } catch (e4) {
          }
        }
        const { service, operation: operation2 } = (0, import_util_middleware5.getSmithyContext)(context);
        const path3 = `/service/${service}/operation/${operation2}`;
        if (request2.path.endsWith("/")) {
          request2.path += path3.slice(1);
        } else {
          request2.path += path3;
        }
        return request2;
      }
      async deserializeResponse(operationSchema, context, response2) {
        return super.deserializeResponse(operationSchema, context, response2);
      }
      async handleError(operationSchema, context, response2, dataObject, metadata) {
        const errorName = loadSmithyRpcV2CborErrorCode(response2, dataObject) ?? "Unknown";
        let namespace = this.options.defaultNamespace;
        if (errorName.includes("#")) {
          [namespace] = errorName.split("#");
        }
        const errorMetadata = {
          $metadata: metadata,
          $fault: response2.statusCode <= 500 ? "client" : "server"
        };
        const registry = TypeRegistry.for(namespace);
        let errorSchema;
        try {
          errorSchema = registry.getSchema(errorName);
        } catch (e4) {
          if (dataObject.Message) {
            dataObject.message = dataObject.Message;
          }
          const synthetic = TypeRegistry.for("smithy.ts.sdk.synthetic." + namespace);
          const baseExceptionSchema = synthetic.getBaseException();
          if (baseExceptionSchema) {
            const ErrorCtor2 = synthetic.getErrorCtor(baseExceptionSchema);
            throw Object.assign(new ErrorCtor2({ name: errorName }), errorMetadata, dataObject);
          }
          throw Object.assign(new Error(errorName), errorMetadata, dataObject);
        }
        const ns = NormalizedSchema.of(errorSchema);
        const ErrorCtor = registry.getErrorCtor(errorSchema);
        const message = dataObject.message ?? dataObject.Message ?? "Unknown";
        const exception = new ErrorCtor(message);
        const output = {};
        for (const [name, member2] of ns.structIterator()) {
          output[name] = this.deserializer.readValue(member2, dataObject[name]);
        }
        throw Object.assign(exception, errorMetadata, {
          $fault: ns.getMergedTraits().error,
          message
        }, output);
      }
      getDefaultContentType() {
        return "application/cbor";
      }
    };
  }
});

// node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/cbor/index.js
var init_cbor2 = __esm({
  "node_modules/.pnpm/@smithy+core@3.20.6/node_modules/@smithy/core/dist-es/submodules/cbor/index.js"() {
    init_parseCborBody();
    init_SmithyRpcV2CborProtocol();
    init_CborCodec();
  }
});

// node_modules/.pnpm/@smithy+middleware-stack@4.2.8/node_modules/@smithy/middleware-stack/dist-cjs/index.js
var require_dist_cjs19 = __commonJS({
  "node_modules/.pnpm/@smithy+middleware-stack@4.2.8/node_modules/@smithy/middleware-stack/dist-cjs/index.js"(exports2) {
    "use strict";
    var getAllAliases = (name, aliases2) => {
      const _aliases = [];
      if (name) {
        _aliases.push(name);
      }
      if (aliases2) {
        for (const alias of aliases2) {
          _aliases.push(alias);
        }
      }
      return _aliases;
    };
    var getMiddlewareNameWithAliases = (name, aliases2) => {
      return `${name || "anonymous"}${aliases2 && aliases2.length > 0 ? ` (a.k.a. ${aliases2.join(",")})` : ""}`;
    };
    var constructStack = () => {
      let absoluteEntries = [];
      let relativeEntries = [];
      let identifyOnResolve = false;
      const entriesNameSet = /* @__PURE__ */ new Set();
      const sort = (entries) => entries.sort((a4, b4) => stepWeights[b4.step] - stepWeights[a4.step] || priorityWeights[b4.priority || "normal"] - priorityWeights[a4.priority || "normal"]);
      const removeByName = (toRemove) => {
        let isRemoved = false;
        const filterCb = (entry) => {
          const aliases2 = getAllAliases(entry.name, entry.aliases);
          if (aliases2.includes(toRemove)) {
            isRemoved = true;
            for (const alias of aliases2) {
              entriesNameSet.delete(alias);
            }
            return false;
          }
          return true;
        };
        absoluteEntries = absoluteEntries.filter(filterCb);
        relativeEntries = relativeEntries.filter(filterCb);
        return isRemoved;
      };
      const removeByReference = (toRemove) => {
        let isRemoved = false;
        const filterCb = (entry) => {
          if (entry.middleware === toRemove) {
            isRemoved = true;
            for (const alias of getAllAliases(entry.name, entry.aliases)) {
              entriesNameSet.delete(alias);
            }
            return false;
          }
          return true;
        };
        absoluteEntries = absoluteEntries.filter(filterCb);
        relativeEntries = relativeEntries.filter(filterCb);
        return isRemoved;
      };
      const cloneTo = (toStack) => {
        absoluteEntries.forEach((entry) => {
          toStack.add(entry.middleware, { ...entry });
        });
        relativeEntries.forEach((entry) => {
          toStack.addRelativeTo(entry.middleware, { ...entry });
        });
        toStack.identifyOnResolve?.(stack.identifyOnResolve());
        return toStack;
      };
      const expandRelativeMiddlewareList = (from) => {
        const expandedMiddlewareList = [];
        from.before.forEach((entry) => {
          if (entry.before.length === 0 && entry.after.length === 0) {
            expandedMiddlewareList.push(entry);
          } else {
            expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
          }
        });
        expandedMiddlewareList.push(from);
        from.after.reverse().forEach((entry) => {
          if (entry.before.length === 0 && entry.after.length === 0) {
            expandedMiddlewareList.push(entry);
          } else {
            expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
          }
        });
        return expandedMiddlewareList;
      };
      const getMiddlewareList = (debug = false) => {
        const normalizedAbsoluteEntries = [];
        const normalizedRelativeEntries = [];
        const normalizedEntriesNameMap = {};
        absoluteEntries.forEach((entry) => {
          const normalizedEntry = {
            ...entry,
            before: [],
            after: []
          };
          for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
            normalizedEntriesNameMap[alias] = normalizedEntry;
          }
          normalizedAbsoluteEntries.push(normalizedEntry);
        });
        relativeEntries.forEach((entry) => {
          const normalizedEntry = {
            ...entry,
            before: [],
            after: []
          };
          for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
            normalizedEntriesNameMap[alias] = normalizedEntry;
          }
          normalizedRelativeEntries.push(normalizedEntry);
        });
        normalizedRelativeEntries.forEach((entry) => {
          if (entry.toMiddleware) {
            const toMiddleware = normalizedEntriesNameMap[entry.toMiddleware];
            if (toMiddleware === void 0) {
              if (debug) {
                return;
              }
              throw new Error(`${entry.toMiddleware} is not found when adding ${getMiddlewareNameWithAliases(entry.name, entry.aliases)} middleware ${entry.relation} ${entry.toMiddleware}`);
            }
            if (entry.relation === "after") {
              toMiddleware.after.push(entry);
            }
            if (entry.relation === "before") {
              toMiddleware.before.push(entry);
            }
          }
        });
        const mainChain = sort(normalizedAbsoluteEntries).map(expandRelativeMiddlewareList).reduce((wholeList, expandedMiddlewareList) => {
          wholeList.push(...expandedMiddlewareList);
          return wholeList;
        }, []);
        return mainChain;
      };
      const stack = {
        add: (middleware, options = {}) => {
          const { name, override, aliases: _aliases } = options;
          const entry = {
            step: "initialize",
            priority: "normal",
            middleware,
            ...options
          };
          const aliases2 = getAllAliases(name, _aliases);
          if (aliases2.length > 0) {
            if (aliases2.some((alias) => entriesNameSet.has(alias))) {
              if (!override)
                throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
              for (const alias of aliases2) {
                const toOverrideIndex = absoluteEntries.findIndex((entry2) => entry2.name === alias || entry2.aliases?.some((a4) => a4 === alias));
                if (toOverrideIndex === -1) {
                  continue;
                }
                const toOverride = absoluteEntries[toOverrideIndex];
                if (toOverride.step !== entry.step || entry.priority !== toOverride.priority) {
                  throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware with ${toOverride.priority} priority in ${toOverride.step} step cannot be overridden by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware with ${entry.priority} priority in ${entry.step} step.`);
                }
                absoluteEntries.splice(toOverrideIndex, 1);
              }
            }
            for (const alias of aliases2) {
              entriesNameSet.add(alias);
            }
          }
          absoluteEntries.push(entry);
        },
        addRelativeTo: (middleware, options) => {
          const { name, override, aliases: _aliases } = options;
          const entry = {
            middleware,
            ...options
          };
          const aliases2 = getAllAliases(name, _aliases);
          if (aliases2.length > 0) {
            if (aliases2.some((alias) => entriesNameSet.has(alias))) {
              if (!override)
                throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
              for (const alias of aliases2) {
                const toOverrideIndex = relativeEntries.findIndex((entry2) => entry2.name === alias || entry2.aliases?.some((a4) => a4 === alias));
                if (toOverrideIndex === -1) {
                  continue;
                }
                const toOverride = relativeEntries[toOverrideIndex];
                if (toOverride.toMiddleware !== entry.toMiddleware || toOverride.relation !== entry.relation) {
                  throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware ${toOverride.relation} "${toOverride.toMiddleware}" middleware cannot be overridden by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware ${entry.relation} "${entry.toMiddleware}" middleware.`);
                }
                relativeEntries.splice(toOverrideIndex, 1);
              }
            }
            for (const alias of aliases2) {
              entriesNameSet.add(alias);
            }
          }
          relativeEntries.push(entry);
        },
        clone: () => cloneTo(constructStack()),
        use: (plugin) => {
          plugin.applyToStack(stack);
        },
        remove: (toRemove) => {
          if (typeof toRemove === "string")
            return removeByName(toRemove);
          else
            return removeByReference(toRemove);
        },
        removeByTag: (toRemove) => {
          let isRemoved = false;
          const filterCb = (entry) => {
            const { tags, name, aliases: _aliases } = entry;
            if (tags && tags.includes(toRemove)) {
              const aliases2 = getAllAliases(name, _aliases);
              for (const alias of aliases2) {
                entriesNameSet.delete(alias);
              }
              isRemoved = true;
              return false;
            }
            return true;
          };
          absoluteEntries = absoluteEntries.filter(filterCb);
          relativeEntries = relativeEntries.filter(filterCb);
          return isRemoved;
        },
        concat: (from) => {
          const cloned = cloneTo(constructStack());
          cloned.use(from);
          cloned.identifyOnResolve(identifyOnResolve || cloned.identifyOnResolve() || (from.identifyOnResolve?.() ?? false));
          return cloned;
        },
        applyToStack: cloneTo,
        identify: () => {
          return getMiddlewareList(true).map((mw) => {
            const step = mw.step ?? mw.relation + " " + mw.toMiddleware;
            return getMiddlewareNameWithAliases(mw.name, mw.aliases) + " - " + step;
          });
        },
        identifyOnResolve(toggle) {
          if (typeof toggle === "boolean")
            identifyOnResolve = toggle;
          return identifyOnResolve;
        },
        resolve: (handler, context) => {
          for (const middleware of getMiddlewareList().map((entry) => entry.middleware).reverse()) {
            handler = middleware(handler, context);
          }
          if (identifyOnResolve) {
            console.log(stack.identify());
          }
          return handler;
        }
      };
      return stack;
    };
    var stepWeights = {
      initialize: 5,
      serialize: 4,
      build: 3,
      finalizeRequest: 2,
      deserialize: 1
    };
    var priorityWeights = {
      high: 3,
      normal: 2,
      low: 1
    };
    exports2.constructStack = constructStack;
  }
});

// node_modules/.pnpm/@smithy+smithy-client@4.10.8/node_modules/@smithy/smithy-client/dist-cjs/index.js
var require_dist_cjs20 = __commonJS({
  "node_modules/.pnpm/@smithy+smithy-client@4.10.8/node_modules/@smithy/smithy-client/dist-cjs/index.js"(exports2) {
    "use strict";
    var middlewareStack = require_dist_cjs19();
    var protocols = (init_protocols(), __toCommonJS(protocols_exports));
    var types = require_dist_cjs();
    var schema = (init_schema(), __toCommonJS(schema_exports));
    var serde = (init_serde(), __toCommonJS(serde_exports));
    var Client2 = class {
      config;
      middlewareStack = middlewareStack.constructStack();
      initConfig;
      handlers;
      constructor(config) {
        this.config = config;
        const { protocol, protocolSettings } = config;
        if (protocolSettings) {
          if (typeof protocol === "function") {
            config.protocol = new protocol(protocolSettings);
          }
        }
      }
      send(command, optionsOrCb, cb) {
        const options = typeof optionsOrCb !== "function" ? optionsOrCb : void 0;
        const callback = typeof optionsOrCb === "function" ? optionsOrCb : cb;
        const useHandlerCache = options === void 0 && this.config.cacheMiddleware === true;
        let handler;
        if (useHandlerCache) {
          if (!this.handlers) {
            this.handlers = /* @__PURE__ */ new WeakMap();
          }
          const handlers = this.handlers;
          if (handlers.has(command.constructor)) {
            handler = handlers.get(command.constructor);
          } else {
            handler = command.resolveMiddleware(this.middlewareStack, this.config, options);
            handlers.set(command.constructor, handler);
          }
        } else {
          delete this.handlers;
          handler = command.resolveMiddleware(this.middlewareStack, this.config, options);
        }
        if (callback) {
          handler(command).then((result) => callback(null, result.output), (err) => callback(err)).catch(() => {
          });
        } else {
          return handler(command).then((result) => result.output);
        }
      }
      destroy() {
        this.config?.requestHandler?.destroy?.();
        delete this.handlers;
      }
    };
    var SENSITIVE_STRING$1 = "***SensitiveInformation***";
    function schemaLogFilter(schema$1, data2) {
      if (data2 == null) {
        return data2;
      }
      const ns = schema.NormalizedSchema.of(schema$1);
      if (ns.getMergedTraits().sensitive) {
        return SENSITIVE_STRING$1;
      }
      if (ns.isListSchema()) {
        const isSensitive = !!ns.getValueSchema().getMergedTraits().sensitive;
        if (isSensitive) {
          return SENSITIVE_STRING$1;
        }
      } else if (ns.isMapSchema()) {
        const isSensitive = !!ns.getKeySchema().getMergedTraits().sensitive || !!ns.getValueSchema().getMergedTraits().sensitive;
        if (isSensitive) {
          return SENSITIVE_STRING$1;
        }
      } else if (ns.isStructSchema() && typeof data2 === "object") {
        const object = data2;
        const newObject = {};
        for (const [member2, memberNs] of ns.structIterator()) {
          if (object[member2] != null) {
            newObject[member2] = schemaLogFilter(memberNs, object[member2]);
          }
        }
        return newObject;
      }
      return data2;
    }
    var Command = class {
      middlewareStack = middlewareStack.constructStack();
      schema;
      static classBuilder() {
        return new ClassBuilder();
      }
      resolveMiddlewareWithContext(clientStack, configuration, options, { middlewareFn, clientName, commandName, inputFilterSensitiveLog, outputFilterSensitiveLog, smithyContext, additionalContext, CommandCtor }) {
        for (const mw of middlewareFn.bind(this)(CommandCtor, clientStack, configuration, options)) {
          this.middlewareStack.use(mw);
        }
        const stack = clientStack.concat(this.middlewareStack);
        const { logger: logger3 } = configuration;
        const handlerExecutionContext = {
          logger: logger3,
          clientName,
          commandName,
          inputFilterSensitiveLog,
          outputFilterSensitiveLog,
          [types.SMITHY_CONTEXT_KEY]: {
            commandInstance: this,
            ...smithyContext
          },
          ...additionalContext
        };
        const { requestHandler } = configuration;
        return stack.resolve((request2) => requestHandler.handle(request2.request, options || {}), handlerExecutionContext);
      }
    };
    var ClassBuilder = class {
      _init = () => {
      };
      _ep = {};
      _middlewareFn = () => [];
      _commandName = "";
      _clientName = "";
      _additionalContext = {};
      _smithyContext = {};
      _inputFilterSensitiveLog = void 0;
      _outputFilterSensitiveLog = void 0;
      _serializer = null;
      _deserializer = null;
      _operationSchema;
      init(cb) {
        this._init = cb;
      }
      ep(endpointParameterInstructions) {
        this._ep = endpointParameterInstructions;
        return this;
      }
      m(middlewareSupplier) {
        this._middlewareFn = middlewareSupplier;
        return this;
      }
      s(service, operation2, smithyContext = {}) {
        this._smithyContext = {
          service,
          operation: operation2,
          ...smithyContext
        };
        return this;
      }
      c(additionalContext = {}) {
        this._additionalContext = additionalContext;
        return this;
      }
      n(clientName, commandName) {
        this._clientName = clientName;
        this._commandName = commandName;
        return this;
      }
      f(inputFilter = (_) => _, outputFilter = (_) => _) {
        this._inputFilterSensitiveLog = inputFilter;
        this._outputFilterSensitiveLog = outputFilter;
        return this;
      }
      ser(serializer) {
        this._serializer = serializer;
        return this;
      }
      de(deserializer) {
        this._deserializer = deserializer;
        return this;
      }
      sc(operation2) {
        this._operationSchema = operation2;
        this._smithyContext.operationSchema = operation2;
        return this;
      }
      build() {
        const closure = this;
        let CommandRef;
        return CommandRef = class extends Command {
          input;
          static getEndpointParameterInstructions() {
            return closure._ep;
          }
          constructor(...[input]) {
            super();
            this.input = input ?? {};
            closure._init(this);
            this.schema = closure._operationSchema;
          }
          resolveMiddleware(stack, configuration, options) {
            const op2 = closure._operationSchema;
            const input = op2?.[4] ?? op2?.input;
            const output = op2?.[5] ?? op2?.output;
            return this.resolveMiddlewareWithContext(stack, configuration, options, {
              CommandCtor: CommandRef,
              middlewareFn: closure._middlewareFn,
              clientName: closure._clientName,
              commandName: closure._commandName,
              inputFilterSensitiveLog: closure._inputFilterSensitiveLog ?? (op2 ? schemaLogFilter.bind(null, input) : (_) => _),
              outputFilterSensitiveLog: closure._outputFilterSensitiveLog ?? (op2 ? schemaLogFilter.bind(null, output) : (_) => _),
              smithyContext: closure._smithyContext,
              additionalContext: closure._additionalContext
            });
          }
          serialize = closure._serializer;
          deserialize = closure._deserializer;
        };
      }
    };
    var SENSITIVE_STRING = "***SensitiveInformation***";
    var createAggregatedClient4 = (commands4, Client3) => {
      for (const command of Object.keys(commands4)) {
        const CommandCtor = commands4[command];
        const methodImpl = async function(args, optionsOrCb, cb) {
          const command2 = new CommandCtor(args);
          if (typeof optionsOrCb === "function") {
            this.send(command2, optionsOrCb);
          } else if (typeof cb === "function") {
            if (typeof optionsOrCb !== "object")
              throw new Error(`Expected http options but got ${typeof optionsOrCb}`);
            this.send(command2, optionsOrCb || {}, cb);
          } else {
            return this.send(command2, optionsOrCb);
          }
        };
        const methodName = (command[0].toLowerCase() + command.slice(1)).replace(/Command$/, "");
        Client3.prototype[methodName] = methodImpl;
      }
    };
    var ServiceException = class _ServiceException extends Error {
      $fault;
      $response;
      $retryable;
      $metadata;
      constructor(options) {
        super(options.message);
        Object.setPrototypeOf(this, Object.getPrototypeOf(this).constructor.prototype);
        this.name = options.name;
        this.$fault = options.$fault;
        this.$metadata = options.$metadata;
      }
      static isInstance(value) {
        if (!value)
          return false;
        const candidate = value;
        return _ServiceException.prototype.isPrototypeOf(candidate) || Boolean(candidate.$fault) && Boolean(candidate.$metadata) && (candidate.$fault === "client" || candidate.$fault === "server");
      }
      static [Symbol.hasInstance](instance) {
        if (!instance)
          return false;
        const candidate = instance;
        if (this === _ServiceException) {
          return _ServiceException.isInstance(instance);
        }
        if (_ServiceException.isInstance(instance)) {
          if (candidate.name && this.name) {
            return this.prototype.isPrototypeOf(instance) || candidate.name === this.name;
          }
          return this.prototype.isPrototypeOf(instance);
        }
        return false;
      }
    };
    var decorateServiceException2 = (exception, additions = {}) => {
      Object.entries(additions).filter(([, v4]) => v4 !== void 0).forEach(([k4, v4]) => {
        if (exception[k4] == void 0 || exception[k4] === "") {
          exception[k4] = v4;
        }
      });
      const message = exception.message || exception.Message || "UnknownError";
      exception.message = message;
      delete exception.Message;
      return exception;
    };
    var throwDefaultError = ({ output, parsedBody, exceptionCtor, errorCode }) => {
      const $metadata = deserializeMetadata(output);
      const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : void 0;
      const response2 = new exceptionCtor({
        name: parsedBody?.code || parsedBody?.Code || errorCode || statusCode || "UnknownError",
        $fault: "client",
        $metadata
      });
      throw decorateServiceException2(response2, parsedBody);
    };
    var withBaseException = (ExceptionCtor) => {
      return ({ output, parsedBody, errorCode }) => {
        throwDefaultError({ output, parsedBody, exceptionCtor: ExceptionCtor, errorCode });
      };
    };
    var deserializeMetadata = (output) => ({
      httpStatusCode: output.statusCode,
      requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
      extendedRequestId: output.headers["x-amz-id-2"],
      cfId: output.headers["x-amz-cf-id"]
    });
    var loadConfigsForDefaultMode4 = (mode) => {
      switch (mode) {
        case "standard":
          return {
            retryMode: "standard",
            connectionTimeout: 3100
          };
        case "in-region":
          return {
            retryMode: "standard",
            connectionTimeout: 1100
          };
        case "cross-region":
          return {
            retryMode: "standard",
            connectionTimeout: 3100
          };
        case "mobile":
          return {
            retryMode: "standard",
            connectionTimeout: 3e4
          };
        default:
          return {};
      }
    };
    var warningEmitted = false;
    var emitWarningIfUnsupportedVersion5 = (version) => {
      if (version && !warningEmitted && parseInt(version.substring(1, version.indexOf("."))) < 16) {
        warningEmitted = true;
      }
    };
    var getChecksumConfiguration = (runtimeConfig) => {
      const checksumAlgorithms = [];
      for (const id2 in types.AlgorithmId) {
        const algorithmId = types.AlgorithmId[id2];
        if (runtimeConfig[algorithmId] === void 0) {
          continue;
        }
        checksumAlgorithms.push({
          algorithmId: () => algorithmId,
          checksumConstructor: () => runtimeConfig[algorithmId]
        });
      }
      return {
        addChecksumAlgorithm(algo) {
          checksumAlgorithms.push(algo);
        },
        checksumAlgorithms() {
          return checksumAlgorithms;
        }
      };
    };
    var resolveChecksumRuntimeConfig = (clientConfig) => {
      const runtimeConfig = {};
      clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
        runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
      });
      return runtimeConfig;
    };
    var getRetryConfiguration = (runtimeConfig) => {
      return {
        setRetryStrategy(retryStrategy) {
          runtimeConfig.retryStrategy = retryStrategy;
        },
        retryStrategy() {
          return runtimeConfig.retryStrategy;
        }
      };
    };
    var resolveRetryRuntimeConfig = (retryStrategyConfiguration) => {
      const runtimeConfig = {};
      runtimeConfig.retryStrategy = retryStrategyConfiguration.retryStrategy();
      return runtimeConfig;
    };
    var getDefaultExtensionConfiguration4 = (runtimeConfig) => {
      return Object.assign(getChecksumConfiguration(runtimeConfig), getRetryConfiguration(runtimeConfig));
    };
    var getDefaultClientConfiguration = getDefaultExtensionConfiguration4;
    var resolveDefaultRuntimeConfig4 = (config) => {
      return Object.assign(resolveChecksumRuntimeConfig(config), resolveRetryRuntimeConfig(config));
    };
    var getArrayIfSingleItem = (mayBeArray) => Array.isArray(mayBeArray) ? mayBeArray : [mayBeArray];
    var getValueFromTextNode3 = (obj) => {
      const textNodeName = "#text";
      for (const key in obj) {
        if (obj.hasOwnProperty(key) && obj[key][textNodeName] !== void 0) {
          obj[key] = obj[key][textNodeName];
        } else if (typeof obj[key] === "object" && obj[key] !== null) {
          obj[key] = getValueFromTextNode3(obj[key]);
        }
      }
      return obj;
    };
    var isSerializableHeaderValue = (value) => {
      return value != null;
    };
    var NoOpLogger4 = class {
      trace() {
      }
      debug() {
      }
      info() {
      }
      warn() {
      }
      error() {
      }
    };
    function map2(arg0, arg1, arg2) {
      let target;
      let filter2;
      let instructions;
      if (typeof arg1 === "undefined" && typeof arg2 === "undefined") {
        target = {};
        instructions = arg0;
      } else {
        target = arg0;
        if (typeof arg1 === "function") {
          filter2 = arg1;
          instructions = arg2;
          return mapWithFilter(target, filter2, instructions);
        } else {
          instructions = arg1;
        }
      }
      for (const key of Object.keys(instructions)) {
        if (!Array.isArray(instructions[key])) {
          target[key] = instructions[key];
          continue;
        }
        applyInstruction(target, null, instructions, key);
      }
      return target;
    }
    var convertMap = (target) => {
      const output = {};
      for (const [k4, v4] of Object.entries(target || {})) {
        output[k4] = [, v4];
      }
      return output;
    };
    var take = (source, instructions) => {
      const out = {};
      for (const key in instructions) {
        applyInstruction(out, source, instructions, key);
      }
      return out;
    };
    var mapWithFilter = (target, filter2, instructions) => {
      return map2(target, Object.entries(instructions).reduce((_instructions, [key, value]) => {
        if (Array.isArray(value)) {
          _instructions[key] = value;
        } else {
          if (typeof value === "function") {
            _instructions[key] = [filter2, value()];
          } else {
            _instructions[key] = [filter2, value];
          }
        }
        return _instructions;
      }, {}));
    };
    var applyInstruction = (target, source, instructions, targetKey) => {
      if (source !== null) {
        let instruction = instructions[targetKey];
        if (typeof instruction === "function") {
          instruction = [, instruction];
        }
        const [filter3 = nonNullish, valueFn = pass, sourceKey = targetKey] = instruction;
        if (typeof filter3 === "function" && filter3(source[sourceKey]) || typeof filter3 !== "function" && !!filter3) {
          target[targetKey] = valueFn(source[sourceKey]);
        }
        return;
      }
      let [filter2, value] = instructions[targetKey];
      if (typeof value === "function") {
        let _value;
        const defaultFilterPassed = filter2 === void 0 && (_value = value()) != null;
        const customFilterPassed = typeof filter2 === "function" && !!filter2(void 0) || typeof filter2 !== "function" && !!filter2;
        if (defaultFilterPassed) {
          target[targetKey] = _value;
        } else if (customFilterPassed) {
          target[targetKey] = value();
        }
      } else {
        const defaultFilterPassed = filter2 === void 0 && value != null;
        const customFilterPassed = typeof filter2 === "function" && !!filter2(value) || typeof filter2 !== "function" && !!filter2;
        if (defaultFilterPassed || customFilterPassed) {
          target[targetKey] = value;
        }
      }
    };
    var nonNullish = (_) => _ != null;
    var pass = (_) => _;
    var serializeFloat = (value) => {
      if (value !== value) {
        return "NaN";
      }
      switch (value) {
        case Infinity:
          return "Infinity";
        case -Infinity:
          return "-Infinity";
        default:
          return value;
      }
    };
    var serializeDateTime = (date3) => date3.toISOString().replace(".000Z", "Z");
    var _json = (obj) => {
      if (obj == null) {
        return {};
      }
      if (Array.isArray(obj)) {
        return obj.filter((_) => _ != null).map(_json);
      }
      if (typeof obj === "object") {
        const target = {};
        for (const key of Object.keys(obj)) {
          if (obj[key] == null) {
            continue;
          }
          target[key] = _json(obj[key]);
        }
        return target;
      }
      return obj;
    };
    Object.defineProperty(exports2, "collectBody", {
      enumerable: true,
      get: function() {
        return protocols.collectBody;
      }
    });
    Object.defineProperty(exports2, "extendedEncodeURIComponent", {
      enumerable: true,
      get: function() {
        return protocols.extendedEncodeURIComponent;
      }
    });
    Object.defineProperty(exports2, "resolvedPath", {
      enumerable: true,
      get: function() {
        return protocols.resolvedPath;
      }
    });
    exports2.Client = Client2;
    exports2.Command = Command;
    exports2.NoOpLogger = NoOpLogger4;
    exports2.SENSITIVE_STRING = SENSITIVE_STRING;
    exports2.ServiceException = ServiceException;
    exports2._json = _json;
    exports2.convertMap = convertMap;
    exports2.createAggregatedClient = createAggregatedClient4;
    exports2.decorateServiceException = decorateServiceException2;
    exports2.emitWarningIfUnsupportedVersion = emitWarningIfUnsupportedVersion5;
    exports2.getArrayIfSingleItem = getArrayIfSingleItem;
    exports2.getDefaultClientConfiguration = getDefaultClientConfiguration;
    exports2.getDefaultExtensionConfiguration = getDefaultExtensionConfiguration4;
    exports2.getValueFromTextNode = getValueFromTextNode3;
    exports2.isSerializableHeaderValue = isSerializableHeaderValue;
    exports2.loadConfigsForDefaultMode = loadConfigsForDefaultMode4;
    exports2.map = map2;
    exports2.resolveDefaultRuntimeConfig = resolveDefaultRuntimeConfig4;
    exports2.serializeDateTime = serializeDateTime;
    exports2.serializeFloat = serializeFloat;
    exports2.take = take;
    exports2.throwDefaultError = throwDefaultError;
    exports2.withBaseException = withBaseException;
    Object.keys(serde).forEach(function(k4) {
      if (k4 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, k4)) Object.defineProperty(exports2, k4, {
        enumerable: true,
        get: function() {
          return serde[k4];
        }
      });
    });
  }
});

// node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/ProtocolLib.js
var import_smithy_client, ProtocolLib;
var init_ProtocolLib = __esm({
  "node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/ProtocolLib.js"() {
    init_schema();
    import_smithy_client = __toESM(require_dist_cjs20());
    ProtocolLib = class {
      queryCompat;
      constructor(queryCompat = false) {
        this.queryCompat = queryCompat;
      }
      resolveRestContentType(defaultContentType, inputSchema) {
        const members = inputSchema.getMemberSchemas();
        const httpPayloadMember = Object.values(members).find((m4) => {
          return !!m4.getMergedTraits().httpPayload;
        });
        if (httpPayloadMember) {
          const mediaType = httpPayloadMember.getMergedTraits().mediaType;
          if (mediaType) {
            return mediaType;
          } else if (httpPayloadMember.isStringSchema()) {
            return "text/plain";
          } else if (httpPayloadMember.isBlobSchema()) {
            return "application/octet-stream";
          } else {
            return defaultContentType;
          }
        } else if (!inputSchema.isUnitSchema()) {
          const hasBody = Object.values(members).find((m4) => {
            const { httpQuery, httpQueryParams, httpHeader, httpLabel, httpPrefixHeaders } = m4.getMergedTraits();
            const noPrefixHeaders = httpPrefixHeaders === void 0;
            return !httpQuery && !httpQueryParams && !httpHeader && !httpLabel && noPrefixHeaders;
          });
          if (hasBody) {
            return defaultContentType;
          }
        }
      }
      async getErrorSchemaOrThrowBaseException(errorIdentifier, defaultNamespace, response2, dataObject, metadata, getErrorSchema) {
        let namespace = defaultNamespace;
        let errorName = errorIdentifier;
        if (errorIdentifier.includes("#")) {
          [namespace, errorName] = errorIdentifier.split("#");
        }
        const errorMetadata = {
          $metadata: metadata,
          $fault: response2.statusCode < 500 ? "client" : "server"
        };
        const registry = TypeRegistry.for(namespace);
        try {
          const errorSchema = getErrorSchema?.(registry, errorName) ?? registry.getSchema(errorIdentifier);
          return { errorSchema, errorMetadata };
        } catch (e4) {
          dataObject.message = dataObject.message ?? dataObject.Message ?? "UnknownError";
          const synthetic = TypeRegistry.for("smithy.ts.sdk.synthetic." + namespace);
          const baseExceptionSchema = synthetic.getBaseException();
          if (baseExceptionSchema) {
            const ErrorCtor = synthetic.getErrorCtor(baseExceptionSchema) ?? Error;
            throw this.decorateServiceException(Object.assign(new ErrorCtor({ name: errorName }), errorMetadata), dataObject);
          }
          throw this.decorateServiceException(Object.assign(new Error(errorName), errorMetadata), dataObject);
        }
      }
      decorateServiceException(exception, additions = {}) {
        if (this.queryCompat) {
          const msg = exception.Message ?? additions.Message;
          const error2 = (0, import_smithy_client.decorateServiceException)(exception, additions);
          if (msg) {
            error2.message = msg;
          }
          error2.Error = {
            ...error2.Error,
            Type: error2.Error.Type,
            Code: error2.Error.Code,
            Message: error2.Error.message ?? error2.Error.Message ?? msg
          };
          const reqId = error2.$metadata.requestId;
          if (reqId) {
            error2.RequestId = reqId;
          }
          return error2;
        }
        return (0, import_smithy_client.decorateServiceException)(exception, additions);
      }
      setQueryCompatError(output, response2) {
        const queryErrorHeader = response2.headers?.["x-amzn-query-error"];
        if (output !== void 0 && queryErrorHeader != null) {
          const [Code, Type] = queryErrorHeader.split(";");
          const entries = Object.entries(output);
          const Error2 = {
            Code,
            Type
          };
          Object.assign(output, Error2);
          for (const [k4, v4] of entries) {
            Error2[k4 === "message" ? "Message" : k4] = v4;
          }
          delete Error2.__type;
          output.Error = Error2;
        }
      }
      queryCompatOutput(queryCompatErrorData, errorData) {
        if (queryCompatErrorData.Error) {
          errorData.Error = queryCompatErrorData.Error;
        }
        if (queryCompatErrorData.Type) {
          errorData.Type = queryCompatErrorData.Type;
        }
        if (queryCompatErrorData.Code) {
          errorData.Code = queryCompatErrorData.Code;
        }
      }
      findQueryCompatibleError(registry, errorName) {
        try {
          return registry.getSchema(errorName);
        } catch (e4) {
          return registry.find((schema) => NormalizedSchema.of(schema).getMergedTraits().awsQueryError?.[0] === errorName);
        }
      }
    };
  }
});

// node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/cbor/AwsSmithyRpcV2CborProtocol.js
var AwsSmithyRpcV2CborProtocol;
var init_AwsSmithyRpcV2CborProtocol = __esm({
  "node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/cbor/AwsSmithyRpcV2CborProtocol.js"() {
    init_cbor2();
    init_schema();
    init_ProtocolLib();
    AwsSmithyRpcV2CborProtocol = class extends SmithyRpcV2CborProtocol {
      awsQueryCompatible;
      mixin;
      constructor({ defaultNamespace, awsQueryCompatible }) {
        super({ defaultNamespace });
        this.awsQueryCompatible = !!awsQueryCompatible;
        this.mixin = new ProtocolLib(this.awsQueryCompatible);
      }
      async serializeRequest(operationSchema, input, context) {
        const request2 = await super.serializeRequest(operationSchema, input, context);
        if (this.awsQueryCompatible) {
          request2.headers["x-amzn-query-mode"] = "true";
        }
        return request2;
      }
      async handleError(operationSchema, context, response2, dataObject, metadata) {
        if (this.awsQueryCompatible) {
          this.mixin.setQueryCompatError(dataObject, response2);
        }
        const errorName = (() => {
          const compatHeader = response2.headers["x-amzn-query-error"];
          if (compatHeader && this.awsQueryCompatible) {
            return compatHeader.split(";")[0];
          }
          return loadSmithyRpcV2CborErrorCode(response2, dataObject) ?? "Unknown";
        })();
        const { errorSchema, errorMetadata } = await this.mixin.getErrorSchemaOrThrowBaseException(errorName, this.options.defaultNamespace, response2, dataObject, metadata, this.awsQueryCompatible ? this.mixin.findQueryCompatibleError : void 0);
        const ns = NormalizedSchema.of(errorSchema);
        const message = dataObject.message ?? dataObject.Message ?? "Unknown";
        const ErrorCtor = TypeRegistry.for(errorSchema[1]).getErrorCtor(errorSchema) ?? Error;
        const exception = new ErrorCtor(message);
        const output = {};
        for (const [name, member2] of ns.structIterator()) {
          if (dataObject[name] != null) {
            output[name] = this.deserializer.readValue(member2, dataObject[name]);
          }
        }
        if (this.awsQueryCompatible) {
          this.mixin.queryCompatOutput(dataObject, output);
        }
        throw this.mixin.decorateServiceException(Object.assign(exception, errorMetadata, {
          $fault: ns.getMergedTraits().error,
          message
        }, output), dataObject);
      }
    };
  }
});

// node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/coercing-serializers.js
var _toStr, _toBool, _toNum;
var init_coercing_serializers = __esm({
  "node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/coercing-serializers.js"() {
    _toStr = (val) => {
      if (val == null) {
        return val;
      }
      if (typeof val === "number" || typeof val === "bigint") {
        const warning2 = new Error(`Received number ${val} where a string was expected.`);
        warning2.name = "Warning";
        console.warn(warning2);
        return String(val);
      }
      if (typeof val === "boolean") {
        const warning2 = new Error(`Received boolean ${val} where a string was expected.`);
        warning2.name = "Warning";
        console.warn(warning2);
        return String(val);
      }
      return val;
    };
    _toBool = (val) => {
      if (val == null) {
        return val;
      }
      if (typeof val === "number") {
      }
      if (typeof val === "string") {
        const lowercase = val.toLowerCase();
        if (val !== "" && lowercase !== "false" && lowercase !== "true") {
          const warning2 = new Error(`Received string "${val}" where a boolean was expected.`);
          warning2.name = "Warning";
          console.warn(warning2);
        }
        return val !== "" && lowercase !== "false";
      }
      return val;
    };
    _toNum = (val) => {
      if (val == null) {
        return val;
      }
      if (typeof val === "boolean") {
      }
      if (typeof val === "string") {
        const num = Number(val);
        if (num.toString() !== val) {
          const warning2 = new Error(`Received string "${val}" where a number was expected.`);
          warning2.name = "Warning";
          console.warn(warning2);
          return val;
        }
        return num;
      }
      return val;
    };
  }
});

// node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/ConfigurableSerdeContext.js
var SerdeContextConfig;
var init_ConfigurableSerdeContext = __esm({
  "node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/ConfigurableSerdeContext.js"() {
    SerdeContextConfig = class {
      serdeContext;
      setSerdeContext(serdeContext) {
        this.serdeContext = serdeContext;
      }
    };
  }
});

// node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/structIterator.js
function* serializingStructIterator(ns, sourceObject) {
  if (ns.isUnitSchema()) {
    return;
  }
  const struct2 = ns.getSchema();
  for (let i4 = 0; i4 < struct2[4].length; ++i4) {
    const key = struct2[4][i4];
    const memberSchema = struct2[5][i4];
    const memberNs = new NormalizedSchema([memberSchema, 0], key);
    if (!(key in sourceObject) && !memberNs.isIdempotencyToken()) {
      continue;
    }
    yield [key, memberNs];
  }
}
function* deserializingStructIterator(ns, sourceObject, nameTrait) {
  if (ns.isUnitSchema()) {
    return;
  }
  const struct2 = ns.getSchema();
  let keysRemaining = Object.keys(sourceObject).filter((k4) => k4 !== "__type").length;
  for (let i4 = 0; i4 < struct2[4].length; ++i4) {
    if (keysRemaining === 0) {
      break;
    }
    const key = struct2[4][i4];
    const memberSchema = struct2[5][i4];
    const memberNs = new NormalizedSchema([memberSchema, 0], key);
    let serializationKey = key;
    if (nameTrait) {
      serializationKey = memberNs.getMergedTraits()[nameTrait] ?? key;
    }
    if (!(serializationKey in sourceObject)) {
      continue;
    }
    yield [key, memberNs];
    keysRemaining -= 1;
  }
}
var init_structIterator = __esm({
  "node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/structIterator.js"() {
    init_schema();
  }
});

// node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/UnionSerde.js
var UnionSerde;
var init_UnionSerde = __esm({
  "node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/UnionSerde.js"() {
    UnionSerde = class {
      from;
      to;
      keys;
      constructor(from, to) {
        this.from = from;
        this.to = to;
        this.keys = new Set(Object.keys(this.from).filter((k4) => k4 !== "__type"));
      }
      mark(key) {
        this.keys.delete(key);
      }
      hasUnknown() {
        return this.keys.size === 1 && Object.keys(this.to).length === 0;
      }
      writeUnknown() {
        if (this.hasUnknown()) {
          const k4 = this.keys.values().next().value;
          const v4 = this.from[k4];
          this.to.$unknown = [k4, v4];
        }
      }
    };
  }
});

// node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/jsonReviver.js
function jsonReviver(key, value, context) {
  if (context?.source) {
    const numericString = context.source;
    if (typeof value === "number") {
      if (value > Number.MAX_SAFE_INTEGER || value < Number.MIN_SAFE_INTEGER || numericString !== String(value)) {
        const isFractional = numericString.includes(".");
        if (isFractional) {
          return new NumericValue(numericString, "bigDecimal");
        } else {
          return BigInt(numericString);
        }
      }
    }
  }
  return value;
}
var init_jsonReviver = __esm({
  "node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/jsonReviver.js"() {
    init_serde();
  }
});

// node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/common.js
var import_smithy_client2, import_util_utf86, collectBodyString;
var init_common = __esm({
  "node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/common.js"() {
    import_smithy_client2 = __toESM(require_dist_cjs20());
    import_util_utf86 = __toESM(require_dist_cjs8());
    collectBodyString = (streamBody, context) => (0, import_smithy_client2.collectBody)(streamBody, context).then((body2) => (context?.utf8Encoder ?? import_util_utf86.toUtf8)(body2));
  }
});

// node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/parseJsonBody.js
var parseJsonBody, parseJsonErrorBody, loadRestJsonErrorCode;
var init_parseJsonBody = __esm({
  "node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/parseJsonBody.js"() {
    init_common();
    parseJsonBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
      if (encoded.length) {
        try {
          return JSON.parse(encoded);
        } catch (e4) {
          if (e4?.name === "SyntaxError") {
            Object.defineProperty(e4, "$responseBodyText", {
              value: encoded
            });
          }
          throw e4;
        }
      }
      return {};
    });
    parseJsonErrorBody = async (errorBody, context) => {
      const value = await parseJsonBody(errorBody, context);
      value.message = value.message ?? value.Message;
      return value;
    };
    loadRestJsonErrorCode = (output, data2) => {
      const findKey = (object, key) => Object.keys(object).find((k4) => k4.toLowerCase() === key.toLowerCase());
      const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
          cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
          cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
          cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
          cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
      };
      const headerKey = findKey(output.headers, "x-amzn-errortype");
      if (headerKey !== void 0) {
        return sanitizeErrorCode(output.headers[headerKey]);
      }
      if (data2 && typeof data2 === "object") {
        const codeKey = findKey(data2, "code");
        if (codeKey && data2[codeKey] !== void 0) {
          return sanitizeErrorCode(data2[codeKey]);
        }
        if (data2["__type"] !== void 0) {
          return sanitizeErrorCode(data2["__type"]);
        }
      }
    };
  }
});

// node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/JsonShapeDeserializer.js
var import_util_base644, JsonShapeDeserializer;
var init_JsonShapeDeserializer = __esm({
  "node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/JsonShapeDeserializer.js"() {
    init_protocols();
    init_schema();
    init_serde();
    import_util_base644 = __toESM(require_dist_cjs9());
    init_ConfigurableSerdeContext();
    init_structIterator();
    init_UnionSerde();
    init_jsonReviver();
    init_parseJsonBody();
    JsonShapeDeserializer = class extends SerdeContextConfig {
      settings;
      constructor(settings) {
        super();
        this.settings = settings;
      }
      async read(schema, data2) {
        return this._read(schema, typeof data2 === "string" ? JSON.parse(data2, jsonReviver) : await parseJsonBody(data2, this.serdeContext));
      }
      readObject(schema, data2) {
        return this._read(schema, data2);
      }
      _read(schema, value) {
        const isObject2 = value !== null && typeof value === "object";
        const ns = NormalizedSchema.of(schema);
        if (isObject2) {
          if (ns.isStructSchema()) {
            const record = value;
            const union = ns.isUnionSchema();
            const out = {};
            let nameMap = void 0;
            const { jsonName } = this.settings;
            if (jsonName) {
              nameMap = {};
            }
            let unionSerde;
            if (union) {
              unionSerde = new UnionSerde(record, out);
            }
            for (const [memberName, memberSchema] of deserializingStructIterator(ns, record, jsonName ? "jsonName" : false)) {
              let fromKey = memberName;
              if (jsonName) {
                fromKey = memberSchema.getMergedTraits().jsonName ?? fromKey;
                nameMap[fromKey] = memberName;
              }
              if (union) {
                unionSerde.mark(fromKey);
              }
              if (record[fromKey] != null) {
                out[memberName] = this._read(memberSchema, record[fromKey]);
              }
            }
            if (union) {
              unionSerde.writeUnknown();
            } else if (typeof record.__type === "string") {
              for (const [k4, v4] of Object.entries(record)) {
                const t4 = jsonName ? nameMap[k4] ?? k4 : k4;
                if (!(t4 in out)) {
                  out[t4] = v4;
                }
              }
            }
            return out;
          }
          if (Array.isArray(value) && ns.isListSchema()) {
            const listMember = ns.getValueSchema();
            const out = [];
            const sparse = !!ns.getMergedTraits().sparse;
            for (const item of value) {
              if (sparse || item != null) {
                out.push(this._read(listMember, item));
              }
            }
            return out;
          }
          if (ns.isMapSchema()) {
            const mapMember = ns.getValueSchema();
            const out = {};
            const sparse = !!ns.getMergedTraits().sparse;
            for (const [_k, _v] of Object.entries(value)) {
              if (sparse || _v != null) {
                out[_k] = this._read(mapMember, _v);
              }
            }
            return out;
          }
        }
        if (ns.isBlobSchema() && typeof value === "string") {
          return (0, import_util_base644.fromBase64)(value);
        }
        const mediaType = ns.getMergedTraits().mediaType;
        if (ns.isStringSchema() && typeof value === "string" && mediaType) {
          const isJson = mediaType === "application/json" || mediaType.endsWith("+json");
          if (isJson) {
            return LazyJsonString.from(value);
          }
          return value;
        }
        if (ns.isTimestampSchema() && value != null) {
          const format2 = determineTimestampFormat(ns, this.settings);
          switch (format2) {
            case 5:
              return parseRfc3339DateTimeWithOffset(value);
            case 6:
              return parseRfc7231DateTime(value);
            case 7:
              return parseEpochTimestamp(value);
            default:
              console.warn("Missing timestamp format, parsing value with Date constructor:", value);
              return new Date(value);
          }
        }
        if (ns.isBigIntegerSchema() && (typeof value === "number" || typeof value === "string")) {
          return BigInt(value);
        }
        if (ns.isBigDecimalSchema() && value != void 0) {
          if (value instanceof NumericValue) {
            return value;
          }
          const untyped = value;
          if (untyped.type === "bigDecimal" && "string" in untyped) {
            return new NumericValue(untyped.string, untyped.type);
          }
          return new NumericValue(String(value), "bigDecimal");
        }
        if (ns.isNumericSchema() && typeof value === "string") {
          switch (value) {
            case "Infinity":
              return Infinity;
            case "-Infinity":
              return -Infinity;
            case "NaN":
              return NaN;
          }
          return value;
        }
        if (ns.isDocumentSchema()) {
          if (isObject2) {
            const out = Array.isArray(value) ? [] : {};
            for (const [k4, v4] of Object.entries(value)) {
              if (v4 instanceof NumericValue) {
                out[k4] = v4;
              } else {
                out[k4] = this._read(ns, v4);
              }
            }
            return out;
          } else {
            return structuredClone(value);
          }
        }
        return value;
      }
    };
  }
});

// node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/jsonReplacer.js
var NUMERIC_CONTROL_CHAR, JsonReplacer;
var init_jsonReplacer = __esm({
  "node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/jsonReplacer.js"() {
    init_serde();
    NUMERIC_CONTROL_CHAR = String.fromCharCode(925);
    JsonReplacer = class {
      values = /* @__PURE__ */ new Map();
      counter = 0;
      stage = 0;
      createReplacer() {
        if (this.stage === 1) {
          throw new Error("@aws-sdk/core/protocols - JsonReplacer already created.");
        }
        if (this.stage === 2) {
          throw new Error("@aws-sdk/core/protocols - JsonReplacer exhausted.");
        }
        this.stage = 1;
        return (key, value) => {
          if (value instanceof NumericValue) {
            const v4 = `${NUMERIC_CONTROL_CHAR + "nv" + this.counter++}_` + value.string;
            this.values.set(`"${v4}"`, value.string);
            return v4;
          }
          if (typeof value === "bigint") {
            const s4 = value.toString();
            const v4 = `${NUMERIC_CONTROL_CHAR + "b" + this.counter++}_` + s4;
            this.values.set(`"${v4}"`, s4);
            return v4;
          }
          return value;
        };
      }
      replaceInJson(json) {
        if (this.stage === 0) {
          throw new Error("@aws-sdk/core/protocols - JsonReplacer not created yet.");
        }
        if (this.stage === 2) {
          throw new Error("@aws-sdk/core/protocols - JsonReplacer exhausted.");
        }
        this.stage = 2;
        if (this.counter === 0) {
          return json;
        }
        for (const [key, value] of this.values) {
          json = json.replace(key, value);
        }
        return json;
      }
    };
  }
});

// node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/JsonShapeSerializer.js
var import_util_base645, JsonShapeSerializer;
var init_JsonShapeSerializer = __esm({
  "node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/JsonShapeSerializer.js"() {
    init_protocols();
    init_schema();
    init_serde();
    import_util_base645 = __toESM(require_dist_cjs9());
    init_ConfigurableSerdeContext();
    init_structIterator();
    init_jsonReplacer();
    JsonShapeSerializer = class extends SerdeContextConfig {
      settings;
      buffer;
      useReplacer = false;
      rootSchema;
      constructor(settings) {
        super();
        this.settings = settings;
      }
      write(schema, value) {
        this.rootSchema = NormalizedSchema.of(schema);
        this.buffer = this._write(this.rootSchema, value);
      }
      writeDiscriminatedDocument(schema, value) {
        this.write(schema, value);
        if (typeof this.buffer === "object") {
          this.buffer.__type = NormalizedSchema.of(schema).getName(true);
        }
      }
      flush() {
        const { rootSchema, useReplacer } = this;
        this.rootSchema = void 0;
        this.useReplacer = false;
        if (rootSchema?.isStructSchema() || rootSchema?.isDocumentSchema()) {
          if (!useReplacer) {
            return JSON.stringify(this.buffer);
          }
          const replacer = new JsonReplacer();
          return replacer.replaceInJson(JSON.stringify(this.buffer, replacer.createReplacer(), 0));
        }
        return this.buffer;
      }
      _write(schema, value, container) {
        const isObject2 = value !== null && typeof value === "object";
        const ns = NormalizedSchema.of(schema);
        if (isObject2) {
          if (ns.isStructSchema()) {
            const record = value;
            const out = {};
            const { jsonName } = this.settings;
            let nameMap = void 0;
            if (jsonName) {
              nameMap = {};
            }
            for (const [memberName, memberSchema] of serializingStructIterator(ns, record)) {
              const serializableValue = this._write(memberSchema, record[memberName], ns);
              if (serializableValue !== void 0) {
                let targetKey = memberName;
                if (jsonName) {
                  targetKey = memberSchema.getMergedTraits().jsonName ?? memberName;
                  nameMap[memberName] = targetKey;
                }
                out[targetKey] = serializableValue;
              }
            }
            if (ns.isUnionSchema() && Object.keys(out).length === 0) {
              const { $unknown } = record;
              if (Array.isArray($unknown)) {
                const [k4, v4] = $unknown;
                out[k4] = this._write(15, v4);
              }
            } else if (typeof record.__type === "string") {
              for (const [k4, v4] of Object.entries(record)) {
                const targetKey = jsonName ? nameMap[k4] ?? k4 : k4;
                if (!(targetKey in out)) {
                  out[targetKey] = this._write(15, v4);
                }
              }
            }
            return out;
          }
          if (Array.isArray(value) && ns.isListSchema()) {
            const listMember = ns.getValueSchema();
            const out = [];
            const sparse = !!ns.getMergedTraits().sparse;
            for (const item of value) {
              if (sparse || item != null) {
                out.push(this._write(listMember, item));
              }
            }
            return out;
          }
          if (ns.isMapSchema()) {
            const mapMember = ns.getValueSchema();
            const out = {};
            const sparse = !!ns.getMergedTraits().sparse;
            for (const [_k, _v] of Object.entries(value)) {
              if (sparse || _v != null) {
                out[_k] = this._write(mapMember, _v);
              }
            }
            return out;
          }
          if (value instanceof Uint8Array && (ns.isBlobSchema() || ns.isDocumentSchema())) {
            if (ns === this.rootSchema) {
              return value;
            }
            return (this.serdeContext?.base64Encoder ?? import_util_base645.toBase64)(value);
          }
          if (value instanceof Date && (ns.isTimestampSchema() || ns.isDocumentSchema())) {
            const format2 = determineTimestampFormat(ns, this.settings);
            switch (format2) {
              case 5:
                return value.toISOString().replace(".000Z", "Z");
              case 6:
                return dateToUtcString(value);
              case 7:
                return value.getTime() / 1e3;
              default:
                console.warn("Missing timestamp format, using epoch seconds", value);
                return value.getTime() / 1e3;
            }
          }
          if (value instanceof NumericValue) {
            this.useReplacer = true;
          }
        }
        if (value === null && container?.isStructSchema()) {
          return void 0;
        }
        if (ns.isStringSchema()) {
          if (typeof value === "undefined" && ns.isIdempotencyToken()) {
            return (0, import_uuid.v4)();
          }
          const mediaType = ns.getMergedTraits().mediaType;
          if (value != null && mediaType) {
            const isJson = mediaType === "application/json" || mediaType.endsWith("+json");
            if (isJson) {
              return LazyJsonString.from(value);
            }
          }
          return value;
        }
        if (typeof value === "number" && ns.isNumericSchema()) {
          if (Math.abs(value) === Infinity || isNaN(value)) {
            return String(value);
          }
          return value;
        }
        if (typeof value === "string" && ns.isBlobSchema()) {
          if (ns === this.rootSchema) {
            return value;
          }
          return (this.serdeContext?.base64Encoder ?? import_util_base645.toBase64)(value);
        }
        if (typeof value === "bigint") {
          this.useReplacer = true;
        }
        if (ns.isDocumentSchema()) {
          if (isObject2) {
            const out = Array.isArray(value) ? [] : {};
            for (const [k4, v4] of Object.entries(value)) {
              if (v4 instanceof NumericValue) {
                this.useReplacer = true;
                out[k4] = v4;
              } else {
                out[k4] = this._write(ns, v4);
              }
            }
            return out;
          } else {
            return structuredClone(value);
          }
        }
        return value;
      }
    };
  }
});

// node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/JsonCodec.js
var JsonCodec;
var init_JsonCodec = __esm({
  "node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/JsonCodec.js"() {
    init_ConfigurableSerdeContext();
    init_JsonShapeDeserializer();
    init_JsonShapeSerializer();
    JsonCodec = class extends SerdeContextConfig {
      settings;
      constructor(settings) {
        super();
        this.settings = settings;
      }
      createSerializer() {
        const serializer = new JsonShapeSerializer(this.settings);
        serializer.setSerdeContext(this.serdeContext);
        return serializer;
      }
      createDeserializer() {
        const deserializer = new JsonShapeDeserializer(this.settings);
        deserializer.setSerdeContext(this.serdeContext);
        return deserializer;
      }
    };
  }
});

// node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/AwsJsonRpcProtocol.js
var AwsJsonRpcProtocol;
var init_AwsJsonRpcProtocol = __esm({
  "node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/AwsJsonRpcProtocol.js"() {
    init_protocols();
    init_schema();
    init_ProtocolLib();
    init_JsonCodec();
    init_parseJsonBody();
    AwsJsonRpcProtocol = class extends RpcProtocol {
      serializer;
      deserializer;
      serviceTarget;
      codec;
      mixin;
      awsQueryCompatible;
      constructor({ defaultNamespace, serviceTarget, awsQueryCompatible, jsonCodec }) {
        super({
          defaultNamespace
        });
        this.serviceTarget = serviceTarget;
        this.codec = jsonCodec ?? new JsonCodec({
          timestampFormat: {
            useTrait: true,
            default: 7
          },
          jsonName: false
        });
        this.serializer = this.codec.createSerializer();
        this.deserializer = this.codec.createDeserializer();
        this.awsQueryCompatible = !!awsQueryCompatible;
        this.mixin = new ProtocolLib(this.awsQueryCompatible);
      }
      async serializeRequest(operationSchema, input, context) {
        const request2 = await super.serializeRequest(operationSchema, input, context);
        if (!request2.path.endsWith("/")) {
          request2.path += "/";
        }
        Object.assign(request2.headers, {
          "content-type": `application/x-amz-json-${this.getJsonRpcVersion()}`,
          "x-amz-target": `${this.serviceTarget}.${operationSchema.name}`
        });
        if (this.awsQueryCompatible) {
          request2.headers["x-amzn-query-mode"] = "true";
        }
        if (deref(operationSchema.input) === "unit" || !request2.body) {
          request2.body = "{}";
        }
        return request2;
      }
      getPayloadCodec() {
        return this.codec;
      }
      async handleError(operationSchema, context, response2, dataObject, metadata) {
        if (this.awsQueryCompatible) {
          this.mixin.setQueryCompatError(dataObject, response2);
        }
        const errorIdentifier = loadRestJsonErrorCode(response2, dataObject) ?? "Unknown";
        const { errorSchema, errorMetadata } = await this.mixin.getErrorSchemaOrThrowBaseException(errorIdentifier, this.options.defaultNamespace, response2, dataObject, metadata, this.awsQueryCompatible ? this.mixin.findQueryCompatibleError : void 0);
        const ns = NormalizedSchema.of(errorSchema);
        const message = dataObject.message ?? dataObject.Message ?? "Unknown";
        const ErrorCtor = TypeRegistry.for(errorSchema[1]).getErrorCtor(errorSchema) ?? Error;
        const exception = new ErrorCtor(message);
        const output = {};
        for (const [name, member2] of ns.structIterator()) {
          if (dataObject[name] != null) {
            output[name] = this.codec.createDeserializer().readObject(member2, dataObject[name]);
          }
        }
        if (this.awsQueryCompatible) {
          this.mixin.queryCompatOutput(dataObject, output);
        }
        throw this.mixin.decorateServiceException(Object.assign(exception, errorMetadata, {
          $fault: ns.getMergedTraits().error,
          message
        }, output), dataObject);
      }
    };
  }
});

// node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/AwsJson1_0Protocol.js
var AwsJson1_0Protocol;
var init_AwsJson1_0Protocol = __esm({
  "node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/AwsJson1_0Protocol.js"() {
    init_AwsJsonRpcProtocol();
    AwsJson1_0Protocol = class extends AwsJsonRpcProtocol {
      constructor({ defaultNamespace, serviceTarget, awsQueryCompatible, jsonCodec }) {
        super({
          defaultNamespace,
          serviceTarget,
          awsQueryCompatible,
          jsonCodec
        });
      }
      getShapeId() {
        return "aws.protocols#awsJson1_0";
      }
      getJsonRpcVersion() {
        return "1.0";
      }
      getDefaultContentType() {
        return "application/x-amz-json-1.0";
      }
    };
  }
});

// node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/AwsJson1_1Protocol.js
var AwsJson1_1Protocol;
var init_AwsJson1_1Protocol = __esm({
  "node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/AwsJson1_1Protocol.js"() {
    init_AwsJsonRpcProtocol();
    AwsJson1_1Protocol = class extends AwsJsonRpcProtocol {
      constructor({ defaultNamespace, serviceTarget, awsQueryCompatible, jsonCodec }) {
        super({
          defaultNamespace,
          serviceTarget,
          awsQueryCompatible,
          jsonCodec
        });
      }
      getShapeId() {
        return "aws.protocols#awsJson1_1";
      }
      getJsonRpcVersion() {
        return "1.1";
      }
      getDefaultContentType() {
        return "application/x-amz-json-1.1";
      }
    };
  }
});

// node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/AwsRestJsonProtocol.js
var AwsRestJsonProtocol;
var init_AwsRestJsonProtocol = __esm({
  "node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/AwsRestJsonProtocol.js"() {
    init_protocols();
    init_schema();
    init_ProtocolLib();
    init_JsonCodec();
    init_parseJsonBody();
    AwsRestJsonProtocol = class extends HttpBindingProtocol {
      serializer;
      deserializer;
      codec;
      mixin = new ProtocolLib();
      constructor({ defaultNamespace }) {
        super({
          defaultNamespace
        });
        const settings = {
          timestampFormat: {
            useTrait: true,
            default: 7
          },
          httpBindings: true,
          jsonName: true
        };
        this.codec = new JsonCodec(settings);
        this.serializer = new HttpInterceptingShapeSerializer(this.codec.createSerializer(), settings);
        this.deserializer = new HttpInterceptingShapeDeserializer(this.codec.createDeserializer(), settings);
      }
      getShapeId() {
        return "aws.protocols#restJson1";
      }
      getPayloadCodec() {
        return this.codec;
      }
      setSerdeContext(serdeContext) {
        this.codec.setSerdeContext(serdeContext);
        super.setSerdeContext(serdeContext);
      }
      async serializeRequest(operationSchema, input, context) {
        const request2 = await super.serializeRequest(operationSchema, input, context);
        const inputSchema = NormalizedSchema.of(operationSchema.input);
        if (!request2.headers["content-type"]) {
          const contentType = this.mixin.resolveRestContentType(this.getDefaultContentType(), inputSchema);
          if (contentType) {
            request2.headers["content-type"] = contentType;
          }
        }
        if (request2.body == null && request2.headers["content-type"] === this.getDefaultContentType()) {
          request2.body = "{}";
        }
        return request2;
      }
      async deserializeResponse(operationSchema, context, response2) {
        const output = await super.deserializeResponse(operationSchema, context, response2);
        const outputSchema = NormalizedSchema.of(operationSchema.output);
        for (const [name, member2] of outputSchema.structIterator()) {
          if (member2.getMemberTraits().httpPayload && !(name in output)) {
            output[name] = null;
          }
        }
        return output;
      }
      async handleError(operationSchema, context, response2, dataObject, metadata) {
        const errorIdentifier = loadRestJsonErrorCode(response2, dataObject) ?? "Unknown";
        const { errorSchema, errorMetadata } = await this.mixin.getErrorSchemaOrThrowBaseException(errorIdentifier, this.options.defaultNamespace, response2, dataObject, metadata);
        const ns = NormalizedSchema.of(errorSchema);
        const message = dataObject.message ?? dataObject.Message ?? "Unknown";
        const ErrorCtor = TypeRegistry.for(errorSchema[1]).getErrorCtor(errorSchema) ?? Error;
        const exception = new ErrorCtor(message);
        await this.deserializeHttpMessage(errorSchema, context, response2, dataObject);
        const output = {};
        for (const [name, member2] of ns.structIterator()) {
          const target = member2.getMergedTraits().jsonName ?? name;
          output[name] = this.codec.createDeserializer().readObject(member2, dataObject[target]);
        }
        throw this.mixin.decorateServiceException(Object.assign(exception, errorMetadata, {
          $fault: ns.getMergedTraits().error,
          message
        }, output), dataObject);
      }
      getDefaultContentType() {
        return "application/json";
      }
    };
  }
});

// node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/awsExpectUnion.js
var import_smithy_client3, awsExpectUnion;
var init_awsExpectUnion = __esm({
  "node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/awsExpectUnion.js"() {
    import_smithy_client3 = __toESM(require_dist_cjs20());
    awsExpectUnion = (value) => {
      if (value == null) {
        return void 0;
      }
      if (typeof value === "object" && "__type" in value) {
        delete value.__type;
      }
      return (0, import_smithy_client3.expectUnion)(value);
    };
  }
});

// node_modules/.pnpm/fast-xml-parser@5.2.5/node_modules/fast-xml-parser/lib/fxp.cjs
var require_fxp = __commonJS({
  "node_modules/.pnpm/fast-xml-parser@5.2.5/node_modules/fast-xml-parser/lib/fxp.cjs"(exports2, module2) {
    (() => {
      "use strict";
      var t4 = { d: (e5, n5) => {
        for (var i5 in n5) t4.o(n5, i5) && !t4.o(e5, i5) && Object.defineProperty(e5, i5, { enumerable: true, get: n5[i5] });
      }, o: (t5, e5) => Object.prototype.hasOwnProperty.call(t5, e5), r: (t5) => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t5, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t5, "__esModule", { value: true });
      } }, e4 = {};
      t4.r(e4), t4.d(e4, { XMLBuilder: () => ft, XMLParser: () => st, XMLValidator: () => mt });
      const n4 = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", i4 = new RegExp("^[" + n4 + "][" + n4 + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$");
      function s4(t5, e5) {
        const n5 = [];
        let i5 = e5.exec(t5);
        for (; i5; ) {
          const s5 = [];
          s5.startIndex = e5.lastIndex - i5[0].length;
          const r5 = i5.length;
          for (let t6 = 0; t6 < r5; t6++) s5.push(i5[t6]);
          n5.push(s5), i5 = e5.exec(t5);
        }
        return n5;
      }
      const r4 = function(t5) {
        return !(null == i4.exec(t5));
      }, o4 = { allowBooleanAttributes: false, unpairedTags: [] };
      function a4(t5, e5) {
        e5 = Object.assign({}, o4, e5);
        const n5 = [];
        let i5 = false, s5 = false;
        "\uFEFF" === t5[0] && (t5 = t5.substr(1));
        for (let o5 = 0; o5 < t5.length; o5++) if ("<" === t5[o5] && "?" === t5[o5 + 1]) {
          if (o5 += 2, o5 = u4(t5, o5), o5.err) return o5;
        } else {
          if ("<" !== t5[o5]) {
            if (l4(t5[o5])) continue;
            return x4("InvalidChar", "char '" + t5[o5] + "' is not expected.", N(t5, o5));
          }
          {
            let a5 = o5;
            if (o5++, "!" === t5[o5]) {
              o5 = h4(t5, o5);
              continue;
            }
            {
              let d5 = false;
              "/" === t5[o5] && (d5 = true, o5++);
              let f5 = "";
              for (; o5 < t5.length && ">" !== t5[o5] && " " !== t5[o5] && "	" !== t5[o5] && "\n" !== t5[o5] && "\r" !== t5[o5]; o5++) f5 += t5[o5];
              if (f5 = f5.trim(), "/" === f5[f5.length - 1] && (f5 = f5.substring(0, f5.length - 1), o5--), !r4(f5)) {
                let e6;
                return e6 = 0 === f5.trim().length ? "Invalid space after '<'." : "Tag '" + f5 + "' is an invalid name.", x4("InvalidTag", e6, N(t5, o5));
              }
              const p5 = c4(t5, o5);
              if (false === p5) return x4("InvalidAttr", "Attributes for '" + f5 + "' have open quote.", N(t5, o5));
              let b5 = p5.value;
              if (o5 = p5.index, "/" === b5[b5.length - 1]) {
                const n6 = o5 - b5.length;
                b5 = b5.substring(0, b5.length - 1);
                const s6 = g4(b5, e5);
                if (true !== s6) return x4(s6.err.code, s6.err.msg, N(t5, n6 + s6.err.line));
                i5 = true;
              } else if (d5) {
                if (!p5.tagClosed) return x4("InvalidTag", "Closing tag '" + f5 + "' doesn't have proper closing.", N(t5, o5));
                if (b5.trim().length > 0) return x4("InvalidTag", "Closing tag '" + f5 + "' can't have attributes or invalid starting.", N(t5, a5));
                if (0 === n5.length) return x4("InvalidTag", "Closing tag '" + f5 + "' has not been opened.", N(t5, a5));
                {
                  const e6 = n5.pop();
                  if (f5 !== e6.tagName) {
                    let n6 = N(t5, e6.tagStartPos);
                    return x4("InvalidTag", "Expected closing tag '" + e6.tagName + "' (opened in line " + n6.line + ", col " + n6.col + ") instead of closing tag '" + f5 + "'.", N(t5, a5));
                  }
                  0 == n5.length && (s5 = true);
                }
              } else {
                const r5 = g4(b5, e5);
                if (true !== r5) return x4(r5.err.code, r5.err.msg, N(t5, o5 - b5.length + r5.err.line));
                if (true === s5) return x4("InvalidXml", "Multiple possible root nodes found.", N(t5, o5));
                -1 !== e5.unpairedTags.indexOf(f5) || n5.push({ tagName: f5, tagStartPos: a5 }), i5 = true;
              }
              for (o5++; o5 < t5.length; o5++) if ("<" === t5[o5]) {
                if ("!" === t5[o5 + 1]) {
                  o5++, o5 = h4(t5, o5);
                  continue;
                }
                if ("?" !== t5[o5 + 1]) break;
                if (o5 = u4(t5, ++o5), o5.err) return o5;
              } else if ("&" === t5[o5]) {
                const e6 = m4(t5, o5);
                if (-1 == e6) return x4("InvalidChar", "char '&' is not expected.", N(t5, o5));
                o5 = e6;
              } else if (true === s5 && !l4(t5[o5])) return x4("InvalidXml", "Extra text at the end", N(t5, o5));
              "<" === t5[o5] && o5--;
            }
          }
        }
        return i5 ? 1 == n5.length ? x4("InvalidTag", "Unclosed tag '" + n5[0].tagName + "'.", N(t5, n5[0].tagStartPos)) : !(n5.length > 0) || x4("InvalidXml", "Invalid '" + JSON.stringify(n5.map(((t6) => t6.tagName)), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 }) : x4("InvalidXml", "Start tag expected.", 1);
      }
      function l4(t5) {
        return " " === t5 || "	" === t5 || "\n" === t5 || "\r" === t5;
      }
      function u4(t5, e5) {
        const n5 = e5;
        for (; e5 < t5.length; e5++) if ("?" != t5[e5] && " " != t5[e5]) ;
        else {
          const i5 = t5.substr(n5, e5 - n5);
          if (e5 > 5 && "xml" === i5) return x4("InvalidXml", "XML declaration allowed only at the start of the document.", N(t5, e5));
          if ("?" == t5[e5] && ">" == t5[e5 + 1]) {
            e5++;
            break;
          }
        }
        return e5;
      }
      function h4(t5, e5) {
        if (t5.length > e5 + 5 && "-" === t5[e5 + 1] && "-" === t5[e5 + 2]) {
          for (e5 += 3; e5 < t5.length; e5++) if ("-" === t5[e5] && "-" === t5[e5 + 1] && ">" === t5[e5 + 2]) {
            e5 += 2;
            break;
          }
        } else if (t5.length > e5 + 8 && "D" === t5[e5 + 1] && "O" === t5[e5 + 2] && "C" === t5[e5 + 3] && "T" === t5[e5 + 4] && "Y" === t5[e5 + 5] && "P" === t5[e5 + 6] && "E" === t5[e5 + 7]) {
          let n5 = 1;
          for (e5 += 8; e5 < t5.length; e5++) if ("<" === t5[e5]) n5++;
          else if (">" === t5[e5] && (n5--, 0 === n5)) break;
        } else if (t5.length > e5 + 9 && "[" === t5[e5 + 1] && "C" === t5[e5 + 2] && "D" === t5[e5 + 3] && "A" === t5[e5 + 4] && "T" === t5[e5 + 5] && "A" === t5[e5 + 6] && "[" === t5[e5 + 7]) {
          for (e5 += 8; e5 < t5.length; e5++) if ("]" === t5[e5] && "]" === t5[e5 + 1] && ">" === t5[e5 + 2]) {
            e5 += 2;
            break;
          }
        }
        return e5;
      }
      const d4 = '"', f4 = "'";
      function c4(t5, e5) {
        let n5 = "", i5 = "", s5 = false;
        for (; e5 < t5.length; e5++) {
          if (t5[e5] === d4 || t5[e5] === f4) "" === i5 ? i5 = t5[e5] : i5 !== t5[e5] || (i5 = "");
          else if (">" === t5[e5] && "" === i5) {
            s5 = true;
            break;
          }
          n5 += t5[e5];
        }
        return "" === i5 && { value: n5, index: e5, tagClosed: s5 };
      }
      const p4 = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
      function g4(t5, e5) {
        const n5 = s4(t5, p4), i5 = {};
        for (let t6 = 0; t6 < n5.length; t6++) {
          if (0 === n5[t6][1].length) return x4("InvalidAttr", "Attribute '" + n5[t6][2] + "' has no space in starting.", E2(n5[t6]));
          if (void 0 !== n5[t6][3] && void 0 === n5[t6][4]) return x4("InvalidAttr", "Attribute '" + n5[t6][2] + "' is without value.", E2(n5[t6]));
          if (void 0 === n5[t6][3] && !e5.allowBooleanAttributes) return x4("InvalidAttr", "boolean attribute '" + n5[t6][2] + "' is not allowed.", E2(n5[t6]));
          const s5 = n5[t6][2];
          if (!b4(s5)) return x4("InvalidAttr", "Attribute '" + s5 + "' is an invalid name.", E2(n5[t6]));
          if (i5.hasOwnProperty(s5)) return x4("InvalidAttr", "Attribute '" + s5 + "' is repeated.", E2(n5[t6]));
          i5[s5] = 1;
        }
        return true;
      }
      function m4(t5, e5) {
        if (";" === t5[++e5]) return -1;
        if ("#" === t5[e5]) return (function(t6, e6) {
          let n6 = /\d/;
          for ("x" === t6[e6] && (e6++, n6 = /[\da-fA-F]/); e6 < t6.length; e6++) {
            if (";" === t6[e6]) return e6;
            if (!t6[e6].match(n6)) break;
          }
          return -1;
        })(t5, ++e5);
        let n5 = 0;
        for (; e5 < t5.length; e5++, n5++) if (!(t5[e5].match(/\w/) && n5 < 20)) {
          if (";" === t5[e5]) break;
          return -1;
        }
        return e5;
      }
      function x4(t5, e5, n5) {
        return { err: { code: t5, msg: e5, line: n5.line || n5, col: n5.col } };
      }
      function b4(t5) {
        return r4(t5);
      }
      function N(t5, e5) {
        const n5 = t5.substring(0, e5).split(/\r?\n/);
        return { line: n5.length, col: n5[n5.length - 1].length + 1 };
      }
      function E2(t5) {
        return t5.startIndex + t5[1].length;
      }
      const v4 = { preserveOrder: false, attributeNamePrefix: "@_", attributesGroupName: false, textNodeName: "#text", ignoreAttributes: true, removeNSPrefix: false, allowBooleanAttributes: false, parseTagValue: true, parseAttributeValue: false, trimValues: true, cdataPropName: false, numberParseOptions: { hex: true, leadingZeros: true, eNotation: true }, tagValueProcessor: function(t5, e5) {
        return e5;
      }, attributeValueProcessor: function(t5, e5) {
        return e5;
      }, stopNodes: [], alwaysCreateTextNode: false, isArray: () => false, commentPropName: false, unpairedTags: [], processEntities: true, htmlEntities: false, ignoreDeclaration: false, ignorePiTags: false, transformTagName: false, transformAttributeName: false, updateTag: function(t5, e5, n5) {
        return t5;
      }, captureMetaData: false };
      let y2;
      y2 = "function" != typeof Symbol ? "@@xmlMetadata" : /* @__PURE__ */ Symbol("XML Node Metadata");
      class T {
        constructor(t5) {
          this.tagname = t5, this.child = [], this[":@"] = {};
        }
        add(t5, e5) {
          "__proto__" === t5 && (t5 = "#__proto__"), this.child.push({ [t5]: e5 });
        }
        addChild(t5, e5) {
          "__proto__" === t5.tagname && (t5.tagname = "#__proto__"), t5[":@"] && Object.keys(t5[":@"]).length > 0 ? this.child.push({ [t5.tagname]: t5.child, ":@": t5[":@"] }) : this.child.push({ [t5.tagname]: t5.child }), void 0 !== e5 && (this.child[this.child.length - 1][y2] = { startIndex: e5 });
        }
        static getMetaDataSymbol() {
          return y2;
        }
      }
      function w4(t5, e5) {
        const n5 = {};
        if ("O" !== t5[e5 + 3] || "C" !== t5[e5 + 4] || "T" !== t5[e5 + 5] || "Y" !== t5[e5 + 6] || "P" !== t5[e5 + 7] || "E" !== t5[e5 + 8]) throw new Error("Invalid Tag instead of DOCTYPE");
        {
          e5 += 9;
          let i5 = 1, s5 = false, r5 = false, o5 = "";
          for (; e5 < t5.length; e5++) if ("<" !== t5[e5] || r5) if (">" === t5[e5]) {
            if (r5 ? "-" === t5[e5 - 1] && "-" === t5[e5 - 2] && (r5 = false, i5--) : i5--, 0 === i5) break;
          } else "[" === t5[e5] ? s5 = true : o5 += t5[e5];
          else {
            if (s5 && C2(t5, "!ENTITY", e5)) {
              let i6, s6;
              e5 += 7, [i6, s6, e5] = O(t5, e5 + 1), -1 === s6.indexOf("&") && (n5[i6] = { regx: RegExp(`&${i6};`, "g"), val: s6 });
            } else if (s5 && C2(t5, "!ELEMENT", e5)) {
              e5 += 8;
              const { index: n6 } = S(t5, e5 + 1);
              e5 = n6;
            } else if (s5 && C2(t5, "!ATTLIST", e5)) e5 += 8;
            else if (s5 && C2(t5, "!NOTATION", e5)) {
              e5 += 9;
              const { index: n6 } = A2(t5, e5 + 1);
              e5 = n6;
            } else {
              if (!C2(t5, "!--", e5)) throw new Error("Invalid DOCTYPE");
              r5 = true;
            }
            i5++, o5 = "";
          }
          if (0 !== i5) throw new Error("Unclosed DOCTYPE");
        }
        return { entities: n5, i: e5 };
      }
      const P = (t5, e5) => {
        for (; e5 < t5.length && /\s/.test(t5[e5]); ) e5++;
        return e5;
      };
      function O(t5, e5) {
        e5 = P(t5, e5);
        let n5 = "";
        for (; e5 < t5.length && !/\s/.test(t5[e5]) && '"' !== t5[e5] && "'" !== t5[e5]; ) n5 += t5[e5], e5++;
        if ($(n5), e5 = P(t5, e5), "SYSTEM" === t5.substring(e5, e5 + 6).toUpperCase()) throw new Error("External entities are not supported");
        if ("%" === t5[e5]) throw new Error("Parameter entities are not supported");
        let i5 = "";
        return [e5, i5] = I2(t5, e5, "entity"), [n5, i5, --e5];
      }
      function A2(t5, e5) {
        e5 = P(t5, e5);
        let n5 = "";
        for (; e5 < t5.length && !/\s/.test(t5[e5]); ) n5 += t5[e5], e5++;
        $(n5), e5 = P(t5, e5);
        const i5 = t5.substring(e5, e5 + 6).toUpperCase();
        if ("SYSTEM" !== i5 && "PUBLIC" !== i5) throw new Error(`Expected SYSTEM or PUBLIC, found "${i5}"`);
        e5 += i5.length, e5 = P(t5, e5);
        let s5 = null, r5 = null;
        if ("PUBLIC" === i5) [e5, s5] = I2(t5, e5, "publicIdentifier"), '"' !== t5[e5 = P(t5, e5)] && "'" !== t5[e5] || ([e5, r5] = I2(t5, e5, "systemIdentifier"));
        else if ("SYSTEM" === i5 && ([e5, r5] = I2(t5, e5, "systemIdentifier"), !r5)) throw new Error("Missing mandatory system identifier for SYSTEM notation");
        return { notationName: n5, publicIdentifier: s5, systemIdentifier: r5, index: --e5 };
      }
      function I2(t5, e5, n5) {
        let i5 = "";
        const s5 = t5[e5];
        if ('"' !== s5 && "'" !== s5) throw new Error(`Expected quoted string, found "${s5}"`);
        for (e5++; e5 < t5.length && t5[e5] !== s5; ) i5 += t5[e5], e5++;
        if (t5[e5] !== s5) throw new Error(`Unterminated ${n5} value`);
        return [++e5, i5];
      }
      function S(t5, e5) {
        e5 = P(t5, e5);
        let n5 = "";
        for (; e5 < t5.length && !/\s/.test(t5[e5]); ) n5 += t5[e5], e5++;
        if (!$(n5)) throw new Error(`Invalid element name: "${n5}"`);
        let i5 = "";
        if ("E" === t5[e5 = P(t5, e5)] && C2(t5, "MPTY", e5)) e5 += 4;
        else if ("A" === t5[e5] && C2(t5, "NY", e5)) e5 += 2;
        else {
          if ("(" !== t5[e5]) throw new Error(`Invalid Element Expression, found "${t5[e5]}"`);
          for (e5++; e5 < t5.length && ")" !== t5[e5]; ) i5 += t5[e5], e5++;
          if (")" !== t5[e5]) throw new Error("Unterminated content model");
        }
        return { elementName: n5, contentModel: i5.trim(), index: e5 };
      }
      function C2(t5, e5, n5) {
        for (let i5 = 0; i5 < e5.length; i5++) if (e5[i5] !== t5[n5 + i5 + 1]) return false;
        return true;
      }
      function $(t5) {
        if (r4(t5)) return t5;
        throw new Error(`Invalid entity name ${t5}`);
      }
      const j4 = /^[-+]?0x[a-fA-F0-9]+$/, D2 = /^([\-\+])?(0*)([0-9]*(\.[0-9]*)?)$/, V = { hex: true, leadingZeros: true, decimalPoint: ".", eNotation: true };
      const M = /^([-+])?(0*)(\d*(\.\d*)?[eE][-\+]?\d+)$/;
      function _(t5) {
        return "function" == typeof t5 ? t5 : Array.isArray(t5) ? (e5) => {
          for (const n5 of t5) {
            if ("string" == typeof n5 && e5 === n5) return true;
            if (n5 instanceof RegExp && n5.test(e5)) return true;
          }
        } : () => false;
      }
      class k4 {
        constructor(t5) {
          this.options = t5, this.currentNode = null, this.tagsNodeStack = [], this.docTypeEntities = {}, this.lastEntities = { apos: { regex: /&(apos|#39|#x27);/g, val: "'" }, gt: { regex: /&(gt|#62|#x3E);/g, val: ">" }, lt: { regex: /&(lt|#60|#x3C);/g, val: "<" }, quot: { regex: /&(quot|#34|#x22);/g, val: '"' } }, this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" }, this.htmlEntities = { space: { regex: /&(nbsp|#160);/g, val: " " }, cent: { regex: /&(cent|#162);/g, val: "\xA2" }, pound: { regex: /&(pound|#163);/g, val: "\xA3" }, yen: { regex: /&(yen|#165);/g, val: "\xA5" }, euro: { regex: /&(euro|#8364);/g, val: "\u20AC" }, copyright: { regex: /&(copy|#169);/g, val: "\xA9" }, reg: { regex: /&(reg|#174);/g, val: "\xAE" }, inr: { regex: /&(inr|#8377);/g, val: "\u20B9" }, num_dec: { regex: /&#([0-9]{1,7});/g, val: (t6, e5) => String.fromCodePoint(Number.parseInt(e5, 10)) }, num_hex: { regex: /&#x([0-9a-fA-F]{1,6});/g, val: (t6, e5) => String.fromCodePoint(Number.parseInt(e5, 16)) } }, this.addExternalEntities = F2, this.parseXml = X, this.parseTextData = L, this.resolveNameSpace = B2, this.buildAttributesMap = G2, this.isItStopNode = Z, this.replaceEntitiesValue = R, this.readStopNodeData = J2, this.saveTextToParentTag = q4, this.addChild = Y, this.ignoreAttributesFn = _(this.options.ignoreAttributes);
        }
      }
      function F2(t5) {
        const e5 = Object.keys(t5);
        for (let n5 = 0; n5 < e5.length; n5++) {
          const i5 = e5[n5];
          this.lastEntities[i5] = { regex: new RegExp("&" + i5 + ";", "g"), val: t5[i5] };
        }
      }
      function L(t5, e5, n5, i5, s5, r5, o5) {
        if (void 0 !== t5 && (this.options.trimValues && !i5 && (t5 = t5.trim()), t5.length > 0)) {
          o5 || (t5 = this.replaceEntitiesValue(t5));
          const i6 = this.options.tagValueProcessor(e5, t5, n5, s5, r5);
          return null == i6 ? t5 : typeof i6 != typeof t5 || i6 !== t5 ? i6 : this.options.trimValues || t5.trim() === t5 ? H2(t5, this.options.parseTagValue, this.options.numberParseOptions) : t5;
        }
      }
      function B2(t5) {
        if (this.options.removeNSPrefix) {
          const e5 = t5.split(":"), n5 = "/" === t5.charAt(0) ? "/" : "";
          if ("xmlns" === e5[0]) return "";
          2 === e5.length && (t5 = n5 + e5[1]);
        }
        return t5;
      }
      const U = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
      function G2(t5, e5, n5) {
        if (true !== this.options.ignoreAttributes && "string" == typeof t5) {
          const n6 = s4(t5, U), i5 = n6.length, r5 = {};
          for (let t6 = 0; t6 < i5; t6++) {
            const i6 = this.resolveNameSpace(n6[t6][1]);
            if (this.ignoreAttributesFn(i6, e5)) continue;
            let s5 = n6[t6][4], o5 = this.options.attributeNamePrefix + i6;
            if (i6.length) if (this.options.transformAttributeName && (o5 = this.options.transformAttributeName(o5)), "__proto__" === o5 && (o5 = "#__proto__"), void 0 !== s5) {
              this.options.trimValues && (s5 = s5.trim()), s5 = this.replaceEntitiesValue(s5);
              const t7 = this.options.attributeValueProcessor(i6, s5, e5);
              r5[o5] = null == t7 ? s5 : typeof t7 != typeof s5 || t7 !== s5 ? t7 : H2(s5, this.options.parseAttributeValue, this.options.numberParseOptions);
            } else this.options.allowBooleanAttributes && (r5[o5] = true);
          }
          if (!Object.keys(r5).length) return;
          if (this.options.attributesGroupName) {
            const t6 = {};
            return t6[this.options.attributesGroupName] = r5, t6;
          }
          return r5;
        }
      }
      const X = function(t5) {
        t5 = t5.replace(/\r\n?/g, "\n");
        const e5 = new T("!xml");
        let n5 = e5, i5 = "", s5 = "";
        for (let r5 = 0; r5 < t5.length; r5++) if ("<" === t5[r5]) if ("/" === t5[r5 + 1]) {
          const e6 = W(t5, ">", r5, "Closing Tag is not closed.");
          let o5 = t5.substring(r5 + 2, e6).trim();
          if (this.options.removeNSPrefix) {
            const t6 = o5.indexOf(":");
            -1 !== t6 && (o5 = o5.substr(t6 + 1));
          }
          this.options.transformTagName && (o5 = this.options.transformTagName(o5)), n5 && (i5 = this.saveTextToParentTag(i5, n5, s5));
          const a5 = s5.substring(s5.lastIndexOf(".") + 1);
          if (o5 && -1 !== this.options.unpairedTags.indexOf(o5)) throw new Error(`Unpaired tag can not be used as closing tag: </${o5}>`);
          let l5 = 0;
          a5 && -1 !== this.options.unpairedTags.indexOf(a5) ? (l5 = s5.lastIndexOf(".", s5.lastIndexOf(".") - 1), this.tagsNodeStack.pop()) : l5 = s5.lastIndexOf("."), s5 = s5.substring(0, l5), n5 = this.tagsNodeStack.pop(), i5 = "", r5 = e6;
        } else if ("?" === t5[r5 + 1]) {
          let e6 = z2(t5, r5, false, "?>");
          if (!e6) throw new Error("Pi Tag is not closed.");
          if (i5 = this.saveTextToParentTag(i5, n5, s5), this.options.ignoreDeclaration && "?xml" === e6.tagName || this.options.ignorePiTags) ;
          else {
            const t6 = new T(e6.tagName);
            t6.add(this.options.textNodeName, ""), e6.tagName !== e6.tagExp && e6.attrExpPresent && (t6[":@"] = this.buildAttributesMap(e6.tagExp, s5, e6.tagName)), this.addChild(n5, t6, s5, r5);
          }
          r5 = e6.closeIndex + 1;
        } else if ("!--" === t5.substr(r5 + 1, 3)) {
          const e6 = W(t5, "-->", r5 + 4, "Comment is not closed.");
          if (this.options.commentPropName) {
            const o5 = t5.substring(r5 + 4, e6 - 2);
            i5 = this.saveTextToParentTag(i5, n5, s5), n5.add(this.options.commentPropName, [{ [this.options.textNodeName]: o5 }]);
          }
          r5 = e6;
        } else if ("!D" === t5.substr(r5 + 1, 2)) {
          const e6 = w4(t5, r5);
          this.docTypeEntities = e6.entities, r5 = e6.i;
        } else if ("![" === t5.substr(r5 + 1, 2)) {
          const e6 = W(t5, "]]>", r5, "CDATA is not closed.") - 2, o5 = t5.substring(r5 + 9, e6);
          i5 = this.saveTextToParentTag(i5, n5, s5);
          let a5 = this.parseTextData(o5, n5.tagname, s5, true, false, true, true);
          null == a5 && (a5 = ""), this.options.cdataPropName ? n5.add(this.options.cdataPropName, [{ [this.options.textNodeName]: o5 }]) : n5.add(this.options.textNodeName, a5), r5 = e6 + 2;
        } else {
          let o5 = z2(t5, r5, this.options.removeNSPrefix), a5 = o5.tagName;
          const l5 = o5.rawTagName;
          let u5 = o5.tagExp, h5 = o5.attrExpPresent, d5 = o5.closeIndex;
          this.options.transformTagName && (a5 = this.options.transformTagName(a5)), n5 && i5 && "!xml" !== n5.tagname && (i5 = this.saveTextToParentTag(i5, n5, s5, false));
          const f5 = n5;
          f5 && -1 !== this.options.unpairedTags.indexOf(f5.tagname) && (n5 = this.tagsNodeStack.pop(), s5 = s5.substring(0, s5.lastIndexOf("."))), a5 !== e5.tagname && (s5 += s5 ? "." + a5 : a5);
          const c5 = r5;
          if (this.isItStopNode(this.options.stopNodes, s5, a5)) {
            let e6 = "";
            if (u5.length > 0 && u5.lastIndexOf("/") === u5.length - 1) "/" === a5[a5.length - 1] ? (a5 = a5.substr(0, a5.length - 1), s5 = s5.substr(0, s5.length - 1), u5 = a5) : u5 = u5.substr(0, u5.length - 1), r5 = o5.closeIndex;
            else if (-1 !== this.options.unpairedTags.indexOf(a5)) r5 = o5.closeIndex;
            else {
              const n6 = this.readStopNodeData(t5, l5, d5 + 1);
              if (!n6) throw new Error(`Unexpected end of ${l5}`);
              r5 = n6.i, e6 = n6.tagContent;
            }
            const i6 = new T(a5);
            a5 !== u5 && h5 && (i6[":@"] = this.buildAttributesMap(u5, s5, a5)), e6 && (e6 = this.parseTextData(e6, a5, s5, true, h5, true, true)), s5 = s5.substr(0, s5.lastIndexOf(".")), i6.add(this.options.textNodeName, e6), this.addChild(n5, i6, s5, c5);
          } else {
            if (u5.length > 0 && u5.lastIndexOf("/") === u5.length - 1) {
              "/" === a5[a5.length - 1] ? (a5 = a5.substr(0, a5.length - 1), s5 = s5.substr(0, s5.length - 1), u5 = a5) : u5 = u5.substr(0, u5.length - 1), this.options.transformTagName && (a5 = this.options.transformTagName(a5));
              const t6 = new T(a5);
              a5 !== u5 && h5 && (t6[":@"] = this.buildAttributesMap(u5, s5, a5)), this.addChild(n5, t6, s5, c5), s5 = s5.substr(0, s5.lastIndexOf("."));
            } else {
              const t6 = new T(a5);
              this.tagsNodeStack.push(n5), a5 !== u5 && h5 && (t6[":@"] = this.buildAttributesMap(u5, s5, a5)), this.addChild(n5, t6, s5, c5), n5 = t6;
            }
            i5 = "", r5 = d5;
          }
        }
        else i5 += t5[r5];
        return e5.child;
      };
      function Y(t5, e5, n5, i5) {
        this.options.captureMetaData || (i5 = void 0);
        const s5 = this.options.updateTag(e5.tagname, n5, e5[":@"]);
        false === s5 || ("string" == typeof s5 ? (e5.tagname = s5, t5.addChild(e5, i5)) : t5.addChild(e5, i5));
      }
      const R = function(t5) {
        if (this.options.processEntities) {
          for (let e5 in this.docTypeEntities) {
            const n5 = this.docTypeEntities[e5];
            t5 = t5.replace(n5.regx, n5.val);
          }
          for (let e5 in this.lastEntities) {
            const n5 = this.lastEntities[e5];
            t5 = t5.replace(n5.regex, n5.val);
          }
          if (this.options.htmlEntities) for (let e5 in this.htmlEntities) {
            const n5 = this.htmlEntities[e5];
            t5 = t5.replace(n5.regex, n5.val);
          }
          t5 = t5.replace(this.ampEntity.regex, this.ampEntity.val);
        }
        return t5;
      };
      function q4(t5, e5, n5, i5) {
        return t5 && (void 0 === i5 && (i5 = 0 === e5.child.length), void 0 !== (t5 = this.parseTextData(t5, e5.tagname, n5, false, !!e5[":@"] && 0 !== Object.keys(e5[":@"]).length, i5)) && "" !== t5 && e5.add(this.options.textNodeName, t5), t5 = ""), t5;
      }
      function Z(t5, e5, n5) {
        const i5 = "*." + n5;
        for (const n6 in t5) {
          const s5 = t5[n6];
          if (i5 === s5 || e5 === s5) return true;
        }
        return false;
      }
      function W(t5, e5, n5, i5) {
        const s5 = t5.indexOf(e5, n5);
        if (-1 === s5) throw new Error(i5);
        return s5 + e5.length - 1;
      }
      function z2(t5, e5, n5, i5 = ">") {
        const s5 = (function(t6, e6, n6 = ">") {
          let i6, s6 = "";
          for (let r6 = e6; r6 < t6.length; r6++) {
            let e7 = t6[r6];
            if (i6) e7 === i6 && (i6 = "");
            else if ('"' === e7 || "'" === e7) i6 = e7;
            else if (e7 === n6[0]) {
              if (!n6[1]) return { data: s6, index: r6 };
              if (t6[r6 + 1] === n6[1]) return { data: s6, index: r6 };
            } else "	" === e7 && (e7 = " ");
            s6 += e7;
          }
        })(t5, e5 + 1, i5);
        if (!s5) return;
        let r5 = s5.data;
        const o5 = s5.index, a5 = r5.search(/\s/);
        let l5 = r5, u5 = true;
        -1 !== a5 && (l5 = r5.substring(0, a5), r5 = r5.substring(a5 + 1).trimStart());
        const h5 = l5;
        if (n5) {
          const t6 = l5.indexOf(":");
          -1 !== t6 && (l5 = l5.substr(t6 + 1), u5 = l5 !== s5.data.substr(t6 + 1));
        }
        return { tagName: l5, tagExp: r5, closeIndex: o5, attrExpPresent: u5, rawTagName: h5 };
      }
      function J2(t5, e5, n5) {
        const i5 = n5;
        let s5 = 1;
        for (; n5 < t5.length; n5++) if ("<" === t5[n5]) if ("/" === t5[n5 + 1]) {
          const r5 = W(t5, ">", n5, `${e5} is not closed`);
          if (t5.substring(n5 + 2, r5).trim() === e5 && (s5--, 0 === s5)) return { tagContent: t5.substring(i5, n5), i: r5 };
          n5 = r5;
        } else if ("?" === t5[n5 + 1]) n5 = W(t5, "?>", n5 + 1, "StopNode is not closed.");
        else if ("!--" === t5.substr(n5 + 1, 3)) n5 = W(t5, "-->", n5 + 3, "StopNode is not closed.");
        else if ("![" === t5.substr(n5 + 1, 2)) n5 = W(t5, "]]>", n5, "StopNode is not closed.") - 2;
        else {
          const i6 = z2(t5, n5, ">");
          i6 && ((i6 && i6.tagName) === e5 && "/" !== i6.tagExp[i6.tagExp.length - 1] && s5++, n5 = i6.closeIndex);
        }
      }
      function H2(t5, e5, n5) {
        if (e5 && "string" == typeof t5) {
          const e6 = t5.trim();
          return "true" === e6 || "false" !== e6 && (function(t6, e7 = {}) {
            if (e7 = Object.assign({}, V, e7), !t6 || "string" != typeof t6) return t6;
            let n6 = t6.trim();
            if (void 0 !== e7.skipLike && e7.skipLike.test(n6)) return t6;
            if ("0" === t6) return 0;
            if (e7.hex && j4.test(n6)) return (function(t7) {
              if (parseInt) return parseInt(t7, 16);
              if (Number.parseInt) return Number.parseInt(t7, 16);
              if (window && window.parseInt) return window.parseInt(t7, 16);
              throw new Error("parseInt, Number.parseInt, window.parseInt are not supported");
            })(n6);
            if (-1 !== n6.search(/.+[eE].+/)) return (function(t7, e8, n7) {
              if (!n7.eNotation) return t7;
              const i6 = e8.match(M);
              if (i6) {
                let s5 = i6[1] || "";
                const r5 = -1 === i6[3].indexOf("e") ? "E" : "e", o5 = i6[2], a5 = s5 ? t7[o5.length + 1] === r5 : t7[o5.length] === r5;
                return o5.length > 1 && a5 ? t7 : 1 !== o5.length || !i6[3].startsWith(`.${r5}`) && i6[3][0] !== r5 ? n7.leadingZeros && !a5 ? (e8 = (i6[1] || "") + i6[3], Number(e8)) : t7 : Number(e8);
              }
              return t7;
            })(t6, n6, e7);
            {
              const s5 = D2.exec(n6);
              if (s5) {
                const r5 = s5[1] || "", o5 = s5[2];
                let a5 = (i5 = s5[3]) && -1 !== i5.indexOf(".") ? ("." === (i5 = i5.replace(/0+$/, "")) ? i5 = "0" : "." === i5[0] ? i5 = "0" + i5 : "." === i5[i5.length - 1] && (i5 = i5.substring(0, i5.length - 1)), i5) : i5;
                const l5 = r5 ? "." === t6[o5.length + 1] : "." === t6[o5.length];
                if (!e7.leadingZeros && (o5.length > 1 || 1 === o5.length && !l5)) return t6;
                {
                  const i6 = Number(n6), s6 = String(i6);
                  if (0 === i6 || -0 === i6) return i6;
                  if (-1 !== s6.search(/[eE]/)) return e7.eNotation ? i6 : t6;
                  if (-1 !== n6.indexOf(".")) return "0" === s6 || s6 === a5 || s6 === `${r5}${a5}` ? i6 : t6;
                  let l6 = o5 ? a5 : n6;
                  return o5 ? l6 === s6 || r5 + l6 === s6 ? i6 : t6 : l6 === s6 || l6 === r5 + s6 ? i6 : t6;
                }
              }
              return t6;
            }
            var i5;
          })(t5, n5);
        }
        return void 0 !== t5 ? t5 : "";
      }
      const K = T.getMetaDataSymbol();
      function Q(t5, e5) {
        return tt(t5, e5);
      }
      function tt(t5, e5, n5) {
        let i5;
        const s5 = {};
        for (let r5 = 0; r5 < t5.length; r5++) {
          const o5 = t5[r5], a5 = et(o5);
          let l5 = "";
          if (l5 = void 0 === n5 ? a5 : n5 + "." + a5, a5 === e5.textNodeName) void 0 === i5 ? i5 = o5[a5] : i5 += "" + o5[a5];
          else {
            if (void 0 === a5) continue;
            if (o5[a5]) {
              let t6 = tt(o5[a5], e5, l5);
              const n6 = it(t6, e5);
              void 0 !== o5[K] && (t6[K] = o5[K]), o5[":@"] ? nt(t6, o5[":@"], l5, e5) : 1 !== Object.keys(t6).length || void 0 === t6[e5.textNodeName] || e5.alwaysCreateTextNode ? 0 === Object.keys(t6).length && (e5.alwaysCreateTextNode ? t6[e5.textNodeName] = "" : t6 = "") : t6 = t6[e5.textNodeName], void 0 !== s5[a5] && s5.hasOwnProperty(a5) ? (Array.isArray(s5[a5]) || (s5[a5] = [s5[a5]]), s5[a5].push(t6)) : e5.isArray(a5, l5, n6) ? s5[a5] = [t6] : s5[a5] = t6;
            }
          }
        }
        return "string" == typeof i5 ? i5.length > 0 && (s5[e5.textNodeName] = i5) : void 0 !== i5 && (s5[e5.textNodeName] = i5), s5;
      }
      function et(t5) {
        const e5 = Object.keys(t5);
        for (let t6 = 0; t6 < e5.length; t6++) {
          const n5 = e5[t6];
          if (":@" !== n5) return n5;
        }
      }
      function nt(t5, e5, n5, i5) {
        if (e5) {
          const s5 = Object.keys(e5), r5 = s5.length;
          for (let o5 = 0; o5 < r5; o5++) {
            const r6 = s5[o5];
            i5.isArray(r6, n5 + "." + r6, true, true) ? t5[r6] = [e5[r6]] : t5[r6] = e5[r6];
          }
        }
      }
      function it(t5, e5) {
        const { textNodeName: n5 } = e5, i5 = Object.keys(t5).length;
        return 0 === i5 || !(1 !== i5 || !t5[n5] && "boolean" != typeof t5[n5] && 0 !== t5[n5]);
      }
      class st {
        constructor(t5) {
          this.externalEntities = {}, this.options = (function(t6) {
            return Object.assign({}, v4, t6);
          })(t5);
        }
        parse(t5, e5) {
          if ("string" == typeof t5) ;
          else {
            if (!t5.toString) throw new Error("XML data is accepted in String or Bytes[] form.");
            t5 = t5.toString();
          }
          if (e5) {
            true === e5 && (e5 = {});
            const n6 = a4(t5, e5);
            if (true !== n6) throw Error(`${n6.err.msg}:${n6.err.line}:${n6.err.col}`);
          }
          const n5 = new k4(this.options);
          n5.addExternalEntities(this.externalEntities);
          const i5 = n5.parseXml(t5);
          return this.options.preserveOrder || void 0 === i5 ? i5 : Q(i5, this.options);
        }
        addEntity(t5, e5) {
          if (-1 !== e5.indexOf("&")) throw new Error("Entity value can't have '&'");
          if (-1 !== t5.indexOf("&") || -1 !== t5.indexOf(";")) throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
          if ("&" === e5) throw new Error("An entity with value '&' is not permitted");
          this.externalEntities[t5] = e5;
        }
        static getMetaDataSymbol() {
          return T.getMetaDataSymbol();
        }
      }
      function rt(t5, e5) {
        let n5 = "";
        return e5.format && e5.indentBy.length > 0 && (n5 = "\n"), ot(t5, e5, "", n5);
      }
      function ot(t5, e5, n5, i5) {
        let s5 = "", r5 = false;
        for (let o5 = 0; o5 < t5.length; o5++) {
          const a5 = t5[o5], l5 = at(a5);
          if (void 0 === l5) continue;
          let u5 = "";
          if (u5 = 0 === n5.length ? l5 : `${n5}.${l5}`, l5 === e5.textNodeName) {
            let t6 = a5[l5];
            ut(u5, e5) || (t6 = e5.tagValueProcessor(l5, t6), t6 = ht(t6, e5)), r5 && (s5 += i5), s5 += t6, r5 = false;
            continue;
          }
          if (l5 === e5.cdataPropName) {
            r5 && (s5 += i5), s5 += `<![CDATA[${a5[l5][0][e5.textNodeName]}]]>`, r5 = false;
            continue;
          }
          if (l5 === e5.commentPropName) {
            s5 += i5 + `<!--${a5[l5][0][e5.textNodeName]}-->`, r5 = true;
            continue;
          }
          if ("?" === l5[0]) {
            const t6 = lt(a5[":@"], e5), n6 = "?xml" === l5 ? "" : i5;
            let o6 = a5[l5][0][e5.textNodeName];
            o6 = 0 !== o6.length ? " " + o6 : "", s5 += n6 + `<${l5}${o6}${t6}?>`, r5 = true;
            continue;
          }
          let h5 = i5;
          "" !== h5 && (h5 += e5.indentBy);
          const d5 = i5 + `<${l5}${lt(a5[":@"], e5)}`, f5 = ot(a5[l5], e5, u5, h5);
          -1 !== e5.unpairedTags.indexOf(l5) ? e5.suppressUnpairedNode ? s5 += d5 + ">" : s5 += d5 + "/>" : f5 && 0 !== f5.length || !e5.suppressEmptyNode ? f5 && f5.endsWith(">") ? s5 += d5 + `>${f5}${i5}</${l5}>` : (s5 += d5 + ">", f5 && "" !== i5 && (f5.includes("/>") || f5.includes("</")) ? s5 += i5 + e5.indentBy + f5 + i5 : s5 += f5, s5 += `</${l5}>`) : s5 += d5 + "/>", r5 = true;
        }
        return s5;
      }
      function at(t5) {
        const e5 = Object.keys(t5);
        for (let n5 = 0; n5 < e5.length; n5++) {
          const i5 = e5[n5];
          if (t5.hasOwnProperty(i5) && ":@" !== i5) return i5;
        }
      }
      function lt(t5, e5) {
        let n5 = "";
        if (t5 && !e5.ignoreAttributes) for (let i5 in t5) {
          if (!t5.hasOwnProperty(i5)) continue;
          let s5 = e5.attributeValueProcessor(i5, t5[i5]);
          s5 = ht(s5, e5), true === s5 && e5.suppressBooleanAttributes ? n5 += ` ${i5.substr(e5.attributeNamePrefix.length)}` : n5 += ` ${i5.substr(e5.attributeNamePrefix.length)}="${s5}"`;
        }
        return n5;
      }
      function ut(t5, e5) {
        let n5 = (t5 = t5.substr(0, t5.length - e5.textNodeName.length - 1)).substr(t5.lastIndexOf(".") + 1);
        for (let i5 in e5.stopNodes) if (e5.stopNodes[i5] === t5 || e5.stopNodes[i5] === "*." + n5) return true;
        return false;
      }
      function ht(t5, e5) {
        if (t5 && t5.length > 0 && e5.processEntities) for (let n5 = 0; n5 < e5.entities.length; n5++) {
          const i5 = e5.entities[n5];
          t5 = t5.replace(i5.regex, i5.val);
        }
        return t5;
      }
      const dt = { attributeNamePrefix: "@_", attributesGroupName: false, textNodeName: "#text", ignoreAttributes: true, cdataPropName: false, format: false, indentBy: "  ", suppressEmptyNode: false, suppressUnpairedNode: true, suppressBooleanAttributes: true, tagValueProcessor: function(t5, e5) {
        return e5;
      }, attributeValueProcessor: function(t5, e5) {
        return e5;
      }, preserveOrder: false, commentPropName: false, unpairedTags: [], entities: [{ regex: new RegExp("&", "g"), val: "&amp;" }, { regex: new RegExp(">", "g"), val: "&gt;" }, { regex: new RegExp("<", "g"), val: "&lt;" }, { regex: new RegExp("'", "g"), val: "&apos;" }, { regex: new RegExp('"', "g"), val: "&quot;" }], processEntities: true, stopNodes: [], oneListGroup: false };
      function ft(t5) {
        this.options = Object.assign({}, dt, t5), true === this.options.ignoreAttributes || this.options.attributesGroupName ? this.isAttribute = function() {
          return false;
        } : (this.ignoreAttributesFn = _(this.options.ignoreAttributes), this.attrPrefixLen = this.options.attributeNamePrefix.length, this.isAttribute = gt), this.processTextOrObjNode = ct, this.options.format ? (this.indentate = pt, this.tagEndChar = ">\n", this.newLine = "\n") : (this.indentate = function() {
          return "";
        }, this.tagEndChar = ">", this.newLine = "");
      }
      function ct(t5, e5, n5, i5) {
        const s5 = this.j2x(t5, n5 + 1, i5.concat(e5));
        return void 0 !== t5[this.options.textNodeName] && 1 === Object.keys(t5).length ? this.buildTextValNode(t5[this.options.textNodeName], e5, s5.attrStr, n5) : this.buildObjectNode(s5.val, e5, s5.attrStr, n5);
      }
      function pt(t5) {
        return this.options.indentBy.repeat(t5);
      }
      function gt(t5) {
        return !(!t5.startsWith(this.options.attributeNamePrefix) || t5 === this.options.textNodeName) && t5.substr(this.attrPrefixLen);
      }
      ft.prototype.build = function(t5) {
        return this.options.preserveOrder ? rt(t5, this.options) : (Array.isArray(t5) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1 && (t5 = { [this.options.arrayNodeName]: t5 }), this.j2x(t5, 0, []).val);
      }, ft.prototype.j2x = function(t5, e5, n5) {
        let i5 = "", s5 = "";
        const r5 = n5.join(".");
        for (let o5 in t5) if (Object.prototype.hasOwnProperty.call(t5, o5)) if (void 0 === t5[o5]) this.isAttribute(o5) && (s5 += "");
        else if (null === t5[o5]) this.isAttribute(o5) || o5 === this.options.cdataPropName ? s5 += "" : "?" === o5[0] ? s5 += this.indentate(e5) + "<" + o5 + "?" + this.tagEndChar : s5 += this.indentate(e5) + "<" + o5 + "/" + this.tagEndChar;
        else if (t5[o5] instanceof Date) s5 += this.buildTextValNode(t5[o5], o5, "", e5);
        else if ("object" != typeof t5[o5]) {
          const n6 = this.isAttribute(o5);
          if (n6 && !this.ignoreAttributesFn(n6, r5)) i5 += this.buildAttrPairStr(n6, "" + t5[o5]);
          else if (!n6) if (o5 === this.options.textNodeName) {
            let e6 = this.options.tagValueProcessor(o5, "" + t5[o5]);
            s5 += this.replaceEntitiesValue(e6);
          } else s5 += this.buildTextValNode(t5[o5], o5, "", e5);
        } else if (Array.isArray(t5[o5])) {
          const i6 = t5[o5].length;
          let r6 = "", a5 = "";
          for (let l5 = 0; l5 < i6; l5++) {
            const i7 = t5[o5][l5];
            if (void 0 === i7) ;
            else if (null === i7) "?" === o5[0] ? s5 += this.indentate(e5) + "<" + o5 + "?" + this.tagEndChar : s5 += this.indentate(e5) + "<" + o5 + "/" + this.tagEndChar;
            else if ("object" == typeof i7) if (this.options.oneListGroup) {
              const t6 = this.j2x(i7, e5 + 1, n5.concat(o5));
              r6 += t6.val, this.options.attributesGroupName && i7.hasOwnProperty(this.options.attributesGroupName) && (a5 += t6.attrStr);
            } else r6 += this.processTextOrObjNode(i7, o5, e5, n5);
            else if (this.options.oneListGroup) {
              let t6 = this.options.tagValueProcessor(o5, i7);
              t6 = this.replaceEntitiesValue(t6), r6 += t6;
            } else r6 += this.buildTextValNode(i7, o5, "", e5);
          }
          this.options.oneListGroup && (r6 = this.buildObjectNode(r6, o5, a5, e5)), s5 += r6;
        } else if (this.options.attributesGroupName && o5 === this.options.attributesGroupName) {
          const e6 = Object.keys(t5[o5]), n6 = e6.length;
          for (let s6 = 0; s6 < n6; s6++) i5 += this.buildAttrPairStr(e6[s6], "" + t5[o5][e6[s6]]);
        } else s5 += this.processTextOrObjNode(t5[o5], o5, e5, n5);
        return { attrStr: i5, val: s5 };
      }, ft.prototype.buildAttrPairStr = function(t5, e5) {
        return e5 = this.options.attributeValueProcessor(t5, "" + e5), e5 = this.replaceEntitiesValue(e5), this.options.suppressBooleanAttributes && "true" === e5 ? " " + t5 : " " + t5 + '="' + e5 + '"';
      }, ft.prototype.buildObjectNode = function(t5, e5, n5, i5) {
        if ("" === t5) return "?" === e5[0] ? this.indentate(i5) + "<" + e5 + n5 + "?" + this.tagEndChar : this.indentate(i5) + "<" + e5 + n5 + this.closeTag(e5) + this.tagEndChar;
        {
          let s5 = "</" + e5 + this.tagEndChar, r5 = "";
          return "?" === e5[0] && (r5 = "?", s5 = ""), !n5 && "" !== n5 || -1 !== t5.indexOf("<") ? false !== this.options.commentPropName && e5 === this.options.commentPropName && 0 === r5.length ? this.indentate(i5) + `<!--${t5}-->` + this.newLine : this.indentate(i5) + "<" + e5 + n5 + r5 + this.tagEndChar + t5 + this.indentate(i5) + s5 : this.indentate(i5) + "<" + e5 + n5 + r5 + ">" + t5 + s5;
        }
      }, ft.prototype.closeTag = function(t5) {
        let e5 = "";
        return -1 !== this.options.unpairedTags.indexOf(t5) ? this.options.suppressUnpairedNode || (e5 = "/") : e5 = this.options.suppressEmptyNode ? "/" : `></${t5}`, e5;
      }, ft.prototype.buildTextValNode = function(t5, e5, n5, i5) {
        if (false !== this.options.cdataPropName && e5 === this.options.cdataPropName) return this.indentate(i5) + `<![CDATA[${t5}]]>` + this.newLine;
        if (false !== this.options.commentPropName && e5 === this.options.commentPropName) return this.indentate(i5) + `<!--${t5}-->` + this.newLine;
        if ("?" === e5[0]) return this.indentate(i5) + "<" + e5 + n5 + "?" + this.tagEndChar;
        {
          let s5 = this.options.tagValueProcessor(e5, t5);
          return s5 = this.replaceEntitiesValue(s5), "" === s5 ? this.indentate(i5) + "<" + e5 + n5 + this.closeTag(e5) + this.tagEndChar : this.indentate(i5) + "<" + e5 + n5 + ">" + s5 + "</" + e5 + this.tagEndChar;
        }
      }, ft.prototype.replaceEntitiesValue = function(t5) {
        if (t5 && t5.length > 0 && this.options.processEntities) for (let e5 = 0; e5 < this.options.entities.length; e5++) {
          const n5 = this.options.entities[e5];
          t5 = t5.replace(n5.regex, n5.val);
        }
        return t5;
      };
      const mt = { validate: a4 };
      module2.exports = e4;
    })();
  }
});

// node_modules/.pnpm/@aws-sdk+xml-builder@3.969.0/node_modules/@aws-sdk/xml-builder/dist-cjs/xml-parser.js
var require_xml_parser = __commonJS({
  "node_modules/.pnpm/@aws-sdk+xml-builder@3.969.0/node_modules/@aws-sdk/xml-builder/dist-cjs/xml-parser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseXML = parseXML3;
    var fast_xml_parser_1 = require_fxp();
    var parser = new fast_xml_parser_1.XMLParser({
      attributeNamePrefix: "",
      htmlEntities: true,
      ignoreAttributes: false,
      ignoreDeclaration: true,
      parseTagValue: false,
      trimValues: false,
      tagValueProcessor: (_, val) => val.trim() === "" && val.includes("\n") ? "" : void 0
    });
    parser.addEntity("#xD", "\r");
    parser.addEntity("#10", "\n");
    function parseXML3(xmlString) {
      return parser.parse(xmlString, true);
    }
  }
});

// node_modules/.pnpm/@aws-sdk+xml-builder@3.969.0/node_modules/@aws-sdk/xml-builder/dist-cjs/index.js
var require_dist_cjs21 = __commonJS({
  "node_modules/.pnpm/@aws-sdk+xml-builder@3.969.0/node_modules/@aws-sdk/xml-builder/dist-cjs/index.js"(exports2) {
    "use strict";
    var xmlParser = require_xml_parser();
    function escapeAttribute2(value) {
      return value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
    }
    function escapeElement(value) {
      return value.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&apos;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#x0D;").replace(/\n/g, "&#x0A;").replace(/\u0085/g, "&#x85;").replace(/\u2028/, "&#x2028;");
    }
    var XmlText2 = class {
      value;
      constructor(value) {
        this.value = value;
      }
      toString() {
        return escapeElement("" + this.value);
      }
    };
    var XmlNode2 = class _XmlNode {
      name;
      children;
      attributes = {};
      static of(name, childText, withName) {
        const node = new _XmlNode(name);
        if (childText !== void 0) {
          node.addChildNode(new XmlText2(childText));
        }
        if (withName !== void 0) {
          node.withName(withName);
        }
        return node;
      }
      constructor(name, children = []) {
        this.name = name;
        this.children = children;
      }
      withName(name) {
        this.name = name;
        return this;
      }
      addAttribute(name, value) {
        this.attributes[name] = value;
        return this;
      }
      addChildNode(child) {
        this.children.push(child);
        return this;
      }
      removeAttribute(name) {
        delete this.attributes[name];
        return this;
      }
      n(name) {
        this.name = name;
        return this;
      }
      c(child) {
        this.children.push(child);
        return this;
      }
      a(name, value) {
        if (value != null) {
          this.attributes[name] = value;
        }
        return this;
      }
      cc(input, field, withName = field) {
        if (input[field] != null) {
          const node = _XmlNode.of(field, input[field]).withName(withName);
          this.c(node);
        }
      }
      l(input, listName, memberName, valueProvider) {
        if (input[listName] != null) {
          const nodes = valueProvider();
          nodes.map((node) => {
            node.withName(memberName);
            this.c(node);
          });
        }
      }
      lc(input, listName, memberName, valueProvider) {
        if (input[listName] != null) {
          const nodes = valueProvider();
          const containerNode = new _XmlNode(memberName);
          nodes.map((node) => {
            containerNode.c(node);
          });
          this.c(containerNode);
        }
      }
      toString() {
        const hasChildren2 = Boolean(this.children.length);
        let xmlText = `<${this.name}`;
        const attributes = this.attributes;
        for (const attributeName of Object.keys(attributes)) {
          const attribute = attributes[attributeName];
          if (attribute != null) {
            xmlText += ` ${attributeName}="${escapeAttribute2("" + attribute)}"`;
          }
        }
        return xmlText += !hasChildren2 ? "/>" : `>${this.children.map((c4) => c4.toString()).join("")}</${this.name}>`;
      }
    };
    Object.defineProperty(exports2, "parseXML", {
      enumerable: true,
      get: function() {
        return xmlParser.parseXML;
      }
    });
    exports2.XmlNode = XmlNode2;
    exports2.XmlText = XmlText2;
  }
});

// node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/xml/XmlShapeDeserializer.js
var import_xml_builder, import_smithy_client4, import_util_utf87, XmlShapeDeserializer;
var init_XmlShapeDeserializer = __esm({
  "node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/xml/XmlShapeDeserializer.js"() {
    import_xml_builder = __toESM(require_dist_cjs21());
    init_protocols();
    init_schema();
    import_smithy_client4 = __toESM(require_dist_cjs20());
    import_util_utf87 = __toESM(require_dist_cjs8());
    init_ConfigurableSerdeContext();
    init_UnionSerde();
    XmlShapeDeserializer = class extends SerdeContextConfig {
      settings;
      stringDeserializer;
      constructor(settings) {
        super();
        this.settings = settings;
        this.stringDeserializer = new FromStringShapeDeserializer(settings);
      }
      setSerdeContext(serdeContext) {
        this.serdeContext = serdeContext;
        this.stringDeserializer.setSerdeContext(serdeContext);
      }
      read(schema, bytes, key) {
        const ns = NormalizedSchema.of(schema);
        const memberSchemas = ns.getMemberSchemas();
        const isEventPayload = ns.isStructSchema() && ns.isMemberSchema() && !!Object.values(memberSchemas).find((memberNs) => {
          return !!memberNs.getMemberTraits().eventPayload;
        });
        if (isEventPayload) {
          const output = {};
          const memberName = Object.keys(memberSchemas)[0];
          const eventMemberSchema = memberSchemas[memberName];
          if (eventMemberSchema.isBlobSchema()) {
            output[memberName] = bytes;
          } else {
            output[memberName] = this.read(memberSchemas[memberName], bytes);
          }
          return output;
        }
        const xmlString = (this.serdeContext?.utf8Encoder ?? import_util_utf87.toUtf8)(bytes);
        const parsedObject = this.parseXml(xmlString);
        return this.readSchema(schema, key ? parsedObject[key] : parsedObject);
      }
      readSchema(_schema, value) {
        const ns = NormalizedSchema.of(_schema);
        if (ns.isUnitSchema()) {
          return;
        }
        const traits = ns.getMergedTraits();
        if (ns.isListSchema() && !Array.isArray(value)) {
          return this.readSchema(ns, [value]);
        }
        if (value == null) {
          return value;
        }
        if (typeof value === "object") {
          const sparse = !!traits.sparse;
          const flat = !!traits.xmlFlattened;
          if (ns.isListSchema()) {
            const listValue = ns.getValueSchema();
            const buffer2 = [];
            const sourceKey = listValue.getMergedTraits().xmlName ?? "member";
            const source = flat ? value : (value[0] ?? value)[sourceKey];
            const sourceArray = Array.isArray(source) ? source : [source];
            for (const v4 of sourceArray) {
              if (v4 != null || sparse) {
                buffer2.push(this.readSchema(listValue, v4));
              }
            }
            return buffer2;
          }
          const buffer = {};
          if (ns.isMapSchema()) {
            const keyNs = ns.getKeySchema();
            const memberNs = ns.getValueSchema();
            let entries;
            if (flat) {
              entries = Array.isArray(value) ? value : [value];
            } else {
              entries = Array.isArray(value.entry) ? value.entry : [value.entry];
            }
            const keyProperty = keyNs.getMergedTraits().xmlName ?? "key";
            const valueProperty = memberNs.getMergedTraits().xmlName ?? "value";
            for (const entry of entries) {
              const key = entry[keyProperty];
              const value2 = entry[valueProperty];
              if (value2 != null || sparse) {
                buffer[key] = this.readSchema(memberNs, value2);
              }
            }
            return buffer;
          }
          if (ns.isStructSchema()) {
            const union = ns.isUnionSchema();
            let unionSerde;
            if (union) {
              unionSerde = new UnionSerde(value, buffer);
            }
            for (const [memberName, memberSchema] of ns.structIterator()) {
              const memberTraits = memberSchema.getMergedTraits();
              const xmlObjectKey = !memberTraits.httpPayload ? memberSchema.getMemberTraits().xmlName ?? memberName : memberTraits.xmlName ?? memberSchema.getName();
              if (union) {
                unionSerde.mark(xmlObjectKey);
              }
              if (value[xmlObjectKey] != null) {
                buffer[memberName] = this.readSchema(memberSchema, value[xmlObjectKey]);
              }
            }
            if (union) {
              unionSerde.writeUnknown();
            }
            return buffer;
          }
          if (ns.isDocumentSchema()) {
            return value;
          }
          throw new Error(`@aws-sdk/core/protocols - xml deserializer unhandled schema type for ${ns.getName(true)}`);
        }
        if (ns.isListSchema()) {
          return [];
        }
        if (ns.isMapSchema() || ns.isStructSchema()) {
          return {};
        }
        return this.stringDeserializer.read(ns, value);
      }
      parseXml(xml) {
        if (xml.length) {
          let parsedObj;
          try {
            parsedObj = (0, import_xml_builder.parseXML)(xml);
          } catch (e4) {
            if (e4 && typeof e4 === "object") {
              Object.defineProperty(e4, "$responseBodyText", {
                value: xml
              });
            }
            throw e4;
          }
          const textNodeName = "#text";
          const key = Object.keys(parsedObj)[0];
          const parsedObjToReturn = parsedObj[key];
          if (parsedObjToReturn[textNodeName]) {
            parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
            delete parsedObjToReturn[textNodeName];
          }
          return (0, import_smithy_client4.getValueFromTextNode)(parsedObjToReturn);
        }
        return {};
      }
    };
  }
});

// node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/query/QueryShapeSerializer.js
var import_smithy_client5, import_util_base646, QueryShapeSerializer;
var init_QueryShapeSerializer = __esm({
  "node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/query/QueryShapeSerializer.js"() {
    init_protocols();
    init_schema();
    init_serde();
    import_smithy_client5 = __toESM(require_dist_cjs20());
    import_util_base646 = __toESM(require_dist_cjs9());
    init_ConfigurableSerdeContext();
    init_structIterator();
    QueryShapeSerializer = class extends SerdeContextConfig {
      settings;
      buffer;
      constructor(settings) {
        super();
        this.settings = settings;
      }
      write(schema, value, prefix = "") {
        if (this.buffer === void 0) {
          this.buffer = "";
        }
        const ns = NormalizedSchema.of(schema);
        if (prefix && !prefix.endsWith(".")) {
          prefix += ".";
        }
        if (ns.isBlobSchema()) {
          if (typeof value === "string" || value instanceof Uint8Array) {
            this.writeKey(prefix);
            this.writeValue((this.serdeContext?.base64Encoder ?? import_util_base646.toBase64)(value));
          }
        } else if (ns.isBooleanSchema() || ns.isNumericSchema() || ns.isStringSchema()) {
          if (value != null) {
            this.writeKey(prefix);
            this.writeValue(String(value));
          } else if (ns.isIdempotencyToken()) {
            this.writeKey(prefix);
            this.writeValue((0, import_uuid.v4)());
          }
        } else if (ns.isBigIntegerSchema()) {
          if (value != null) {
            this.writeKey(prefix);
            this.writeValue(String(value));
          }
        } else if (ns.isBigDecimalSchema()) {
          if (value != null) {
            this.writeKey(prefix);
            this.writeValue(value instanceof NumericValue ? value.string : String(value));
          }
        } else if (ns.isTimestampSchema()) {
          if (value instanceof Date) {
            this.writeKey(prefix);
            const format2 = determineTimestampFormat(ns, this.settings);
            switch (format2) {
              case 5:
                this.writeValue(value.toISOString().replace(".000Z", "Z"));
                break;
              case 6:
                this.writeValue((0, import_smithy_client5.dateToUtcString)(value));
                break;
              case 7:
                this.writeValue(String(value.getTime() / 1e3));
                break;
            }
          }
        } else if (ns.isDocumentSchema()) {
          if (Array.isArray(value)) {
            this.write(64 | 15, value, prefix);
          } else if (value instanceof Date) {
            this.write(4, value, prefix);
          } else if (value instanceof Uint8Array) {
            this.write(21, value, prefix);
          } else if (value && typeof value === "object") {
            this.write(128 | 15, value, prefix);
          } else {
            this.writeKey(prefix);
            this.writeValue(String(value));
          }
        } else if (ns.isListSchema()) {
          if (Array.isArray(value)) {
            if (value.length === 0) {
              if (this.settings.serializeEmptyLists) {
                this.writeKey(prefix);
                this.writeValue("");
              }
            } else {
              const member2 = ns.getValueSchema();
              const flat = this.settings.flattenLists || ns.getMergedTraits().xmlFlattened;
              let i4 = 1;
              for (const item of value) {
                if (item == null) {
                  continue;
                }
                const suffix = this.getKey("member", member2.getMergedTraits().xmlName);
                const key = flat ? `${prefix}${i4}` : `${prefix}${suffix}.${i4}`;
                this.write(member2, item, key);
                ++i4;
              }
            }
          }
        } else if (ns.isMapSchema()) {
          if (value && typeof value === "object") {
            const keySchema = ns.getKeySchema();
            const memberSchema = ns.getValueSchema();
            const flat = ns.getMergedTraits().xmlFlattened;
            let i4 = 1;
            for (const [k4, v4] of Object.entries(value)) {
              if (v4 == null) {
                continue;
              }
              const keySuffix = this.getKey("key", keySchema.getMergedTraits().xmlName);
              const key = flat ? `${prefix}${i4}.${keySuffix}` : `${prefix}entry.${i4}.${keySuffix}`;
              const valueSuffix = this.getKey("value", memberSchema.getMergedTraits().xmlName);
              const valueKey = flat ? `${prefix}${i4}.${valueSuffix}` : `${prefix}entry.${i4}.${valueSuffix}`;
              this.write(keySchema, k4, key);
              this.write(memberSchema, v4, valueKey);
              ++i4;
            }
          }
        } else if (ns.isStructSchema()) {
          if (value && typeof value === "object") {
            let didWriteMember = false;
            for (const [memberName, member2] of serializingStructIterator(ns, value)) {
              if (value[memberName] == null && !member2.isIdempotencyToken()) {
                continue;
              }
              const suffix = this.getKey(memberName, member2.getMergedTraits().xmlName);
              const key = `${prefix}${suffix}`;
              this.write(member2, value[memberName], key);
              didWriteMember = true;
            }
            if (!didWriteMember && ns.isUnionSchema()) {
              const { $unknown } = value;
              if (Array.isArray($unknown)) {
                const [k4, v4] = $unknown;
                const key = `${prefix}${k4}`;
                this.write(15, v4, key);
              }
            }
          }
        } else if (ns.isUnitSchema()) {
        } else {
          throw new Error(`@aws-sdk/core/protocols - QuerySerializer unrecognized schema type ${ns.getName(true)}`);
        }
      }
      flush() {
        if (this.buffer === void 0) {
          throw new Error("@aws-sdk/core/protocols - QuerySerializer cannot flush with nothing written to buffer.");
        }
        const str = this.buffer;
        delete this.buffer;
        return str;
      }
      getKey(memberName, xmlName) {
        const key = xmlName ?? memberName;
        if (this.settings.capitalizeKeys) {
          return key[0].toUpperCase() + key.slice(1);
        }
        return key;
      }
      writeKey(key) {
        if (key.endsWith(".")) {
          key = key.slice(0, key.length - 1);
        }
        this.buffer += `&${extendedEncodeURIComponent(key)}=`;
      }
      writeValue(value) {
        this.buffer += extendedEncodeURIComponent(value);
      }
    };
  }
});

// node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/query/AwsQueryProtocol.js
var AwsQueryProtocol;
var init_AwsQueryProtocol = __esm({
  "node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/query/AwsQueryProtocol.js"() {
    init_protocols();
    init_schema();
    init_ProtocolLib();
    init_XmlShapeDeserializer();
    init_QueryShapeSerializer();
    AwsQueryProtocol = class extends RpcProtocol {
      options;
      serializer;
      deserializer;
      mixin = new ProtocolLib();
      constructor(options) {
        super({
          defaultNamespace: options.defaultNamespace
        });
        this.options = options;
        const settings = {
          timestampFormat: {
            useTrait: true,
            default: 5
          },
          httpBindings: false,
          xmlNamespace: options.xmlNamespace,
          serviceNamespace: options.defaultNamespace,
          serializeEmptyLists: true
        };
        this.serializer = new QueryShapeSerializer(settings);
        this.deserializer = new XmlShapeDeserializer(settings);
      }
      getShapeId() {
        return "aws.protocols#awsQuery";
      }
      setSerdeContext(serdeContext) {
        this.serializer.setSerdeContext(serdeContext);
        this.deserializer.setSerdeContext(serdeContext);
      }
      getPayloadCodec() {
        throw new Error("AWSQuery protocol has no payload codec.");
      }
      async serializeRequest(operationSchema, input, context) {
        const request2 = await super.serializeRequest(operationSchema, input, context);
        if (!request2.path.endsWith("/")) {
          request2.path += "/";
        }
        Object.assign(request2.headers, {
          "content-type": `application/x-www-form-urlencoded`
        });
        if (deref(operationSchema.input) === "unit" || !request2.body) {
          request2.body = "";
        }
        const action = operationSchema.name.split("#")[1] ?? operationSchema.name;
        request2.body = `Action=${action}&Version=${this.options.version}` + request2.body;
        if (request2.body.endsWith("&")) {
          request2.body = request2.body.slice(-1);
        }
        return request2;
      }
      async deserializeResponse(operationSchema, context, response2) {
        const deserializer = this.deserializer;
        const ns = NormalizedSchema.of(operationSchema.output);
        const dataObject = {};
        if (response2.statusCode >= 300) {
          const bytes2 = await collectBody(response2.body, context);
          if (bytes2.byteLength > 0) {
            Object.assign(dataObject, await deserializer.read(15, bytes2));
          }
          await this.handleError(operationSchema, context, response2, dataObject, this.deserializeMetadata(response2));
        }
        for (const header in response2.headers) {
          const value = response2.headers[header];
          delete response2.headers[header];
          response2.headers[header.toLowerCase()] = value;
        }
        const shortName = operationSchema.name.split("#")[1] ?? operationSchema.name;
        const awsQueryResultKey = ns.isStructSchema() && this.useNestedResult() ? shortName + "Result" : void 0;
        const bytes = await collectBody(response2.body, context);
        if (bytes.byteLength > 0) {
          Object.assign(dataObject, await deserializer.read(ns, bytes, awsQueryResultKey));
        }
        const output = {
          $metadata: this.deserializeMetadata(response2),
          ...dataObject
        };
        return output;
      }
      useNestedResult() {
        return true;
      }
      async handleError(operationSchema, context, response2, dataObject, metadata) {
        const errorIdentifier = this.loadQueryErrorCode(response2, dataObject) ?? "Unknown";
        const errorData = this.loadQueryError(dataObject);
        const message = this.loadQueryErrorMessage(dataObject);
        errorData.message = message;
        errorData.Error = {
          Type: errorData.Type,
          Code: errorData.Code,
          Message: message
        };
        const { errorSchema, errorMetadata } = await this.mixin.getErrorSchemaOrThrowBaseException(errorIdentifier, this.options.defaultNamespace, response2, errorData, metadata, this.mixin.findQueryCompatibleError);
        const ns = NormalizedSchema.of(errorSchema);
        const ErrorCtor = TypeRegistry.for(errorSchema[1]).getErrorCtor(errorSchema) ?? Error;
        const exception = new ErrorCtor(message);
        const output = {
          Type: errorData.Error.Type,
          Code: errorData.Error.Code,
          Error: errorData.Error
        };
        for (const [name, member2] of ns.structIterator()) {
          const target = member2.getMergedTraits().xmlName ?? name;
          const value = errorData[target] ?? dataObject[target];
          output[name] = this.deserializer.readSchema(member2, value);
        }
        throw this.mixin.decorateServiceException(Object.assign(exception, errorMetadata, {
          $fault: ns.getMergedTraits().error,
          message
        }, output), dataObject);
      }
      loadQueryErrorCode(output, data2) {
        const code = (data2.Errors?.[0]?.Error ?? data2.Errors?.Error ?? data2.Error)?.Code;
        if (code !== void 0) {
          return code;
        }
        if (output.statusCode == 404) {
          return "NotFound";
        }
      }
      loadQueryError(data2) {
        return data2.Errors?.[0]?.Error ?? data2.Errors?.Error ?? data2.Error;
      }
      loadQueryErrorMessage(data2) {
        const errorData = this.loadQueryError(data2);
        return errorData?.message ?? errorData?.Message ?? data2.message ?? data2.Message ?? "Unknown";
      }
      getDefaultContentType() {
        return "application/x-www-form-urlencoded";
      }
    };
  }
});

// node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/query/AwsEc2QueryProtocol.js
var AwsEc2QueryProtocol;
var init_AwsEc2QueryProtocol = __esm({
  "node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/query/AwsEc2QueryProtocol.js"() {
    init_AwsQueryProtocol();
    AwsEc2QueryProtocol = class extends AwsQueryProtocol {
      options;
      constructor(options) {
        super(options);
        this.options = options;
        const ec2Settings = {
          capitalizeKeys: true,
          flattenLists: true,
          serializeEmptyLists: false
        };
        Object.assign(this.serializer.settings, ec2Settings);
      }
      useNestedResult() {
        return false;
      }
    };
  }
});

// node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/xml/parseXmlBody.js
var import_xml_builder2, import_smithy_client6, parseXmlBody, parseXmlErrorBody, loadRestXmlErrorCode;
var init_parseXmlBody = __esm({
  "node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/xml/parseXmlBody.js"() {
    import_xml_builder2 = __toESM(require_dist_cjs21());
    import_smithy_client6 = __toESM(require_dist_cjs20());
    init_common();
    parseXmlBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
      if (encoded.length) {
        let parsedObj;
        try {
          parsedObj = (0, import_xml_builder2.parseXML)(encoded);
        } catch (e4) {
          if (e4 && typeof e4 === "object") {
            Object.defineProperty(e4, "$responseBodyText", {
              value: encoded
            });
          }
          throw e4;
        }
        const textNodeName = "#text";
        const key = Object.keys(parsedObj)[0];
        const parsedObjToReturn = parsedObj[key];
        if (parsedObjToReturn[textNodeName]) {
          parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
          delete parsedObjToReturn[textNodeName];
        }
        return (0, import_smithy_client6.getValueFromTextNode)(parsedObjToReturn);
      }
      return {};
    });
    parseXmlErrorBody = async (errorBody, context) => {
      const value = await parseXmlBody(errorBody, context);
      if (value.Error) {
        value.Error.message = value.Error.message ?? value.Error.Message;
      }
      return value;
    };
    loadRestXmlErrorCode = (output, data2) => {
      if (data2?.Error?.Code !== void 0) {
        return data2.Error.Code;
      }
      if (data2?.Code !== void 0) {
        return data2.Code;
      }
      if (output.statusCode == 404) {
        return "NotFound";
      }
    };
  }
});

// node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/xml/XmlShapeSerializer.js
var import_xml_builder3, import_smithy_client7, import_util_base647, XmlShapeSerializer;
var init_XmlShapeSerializer = __esm({
  "node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/xml/XmlShapeSerializer.js"() {
    import_xml_builder3 = __toESM(require_dist_cjs21());
    init_protocols();
    init_schema();
    init_serde();
    import_smithy_client7 = __toESM(require_dist_cjs20());
    import_util_base647 = __toESM(require_dist_cjs9());
    init_ConfigurableSerdeContext();
    init_structIterator();
    XmlShapeSerializer = class extends SerdeContextConfig {
      settings;
      stringBuffer;
      byteBuffer;
      buffer;
      constructor(settings) {
        super();
        this.settings = settings;
      }
      write(schema, value) {
        const ns = NormalizedSchema.of(schema);
        if (ns.isStringSchema() && typeof value === "string") {
          this.stringBuffer = value;
        } else if (ns.isBlobSchema()) {
          this.byteBuffer = "byteLength" in value ? value : (this.serdeContext?.base64Decoder ?? import_util_base647.fromBase64)(value);
        } else {
          this.buffer = this.writeStruct(ns, value, void 0);
          const traits = ns.getMergedTraits();
          if (traits.httpPayload && !traits.xmlName) {
            this.buffer.withName(ns.getName());
          }
        }
      }
      flush() {
        if (this.byteBuffer !== void 0) {
          const bytes = this.byteBuffer;
          delete this.byteBuffer;
          return bytes;
        }
        if (this.stringBuffer !== void 0) {
          const str = this.stringBuffer;
          delete this.stringBuffer;
          return str;
        }
        const buffer = this.buffer;
        if (this.settings.xmlNamespace) {
          if (!buffer?.attributes?.["xmlns"]) {
            buffer.addAttribute("xmlns", this.settings.xmlNamespace);
          }
        }
        delete this.buffer;
        return buffer.toString();
      }
      writeStruct(ns, value, parentXmlns) {
        const traits = ns.getMergedTraits();
        const name = ns.isMemberSchema() && !traits.httpPayload ? ns.getMemberTraits().xmlName ?? ns.getMemberName() : traits.xmlName ?? ns.getName();
        if (!name || !ns.isStructSchema()) {
          throw new Error(`@aws-sdk/core/protocols - xml serializer, cannot write struct with empty name or non-struct, schema=${ns.getName(true)}.`);
        }
        const structXmlNode = import_xml_builder3.XmlNode.of(name);
        const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(ns, parentXmlns);
        for (const [memberName, memberSchema] of serializingStructIterator(ns, value)) {
          const val = value[memberName];
          if (val != null || memberSchema.isIdempotencyToken()) {
            if (memberSchema.getMergedTraits().xmlAttribute) {
              structXmlNode.addAttribute(memberSchema.getMergedTraits().xmlName ?? memberName, this.writeSimple(memberSchema, val));
              continue;
            }
            if (memberSchema.isListSchema()) {
              this.writeList(memberSchema, val, structXmlNode, xmlns);
            } else if (memberSchema.isMapSchema()) {
              this.writeMap(memberSchema, val, structXmlNode, xmlns);
            } else if (memberSchema.isStructSchema()) {
              structXmlNode.addChildNode(this.writeStruct(memberSchema, val, xmlns));
            } else {
              const memberNode = import_xml_builder3.XmlNode.of(memberSchema.getMergedTraits().xmlName ?? memberSchema.getMemberName());
              this.writeSimpleInto(memberSchema, val, memberNode, xmlns);
              structXmlNode.addChildNode(memberNode);
            }
          }
        }
        const { $unknown } = value;
        if ($unknown && ns.isUnionSchema() && Array.isArray($unknown) && Object.keys(value).length === 1) {
          const [k4, v4] = $unknown;
          const node = import_xml_builder3.XmlNode.of(k4);
          if (typeof v4 !== "string") {
            if (value instanceof import_xml_builder3.XmlNode || value instanceof import_xml_builder3.XmlText) {
              structXmlNode.addChildNode(value);
            } else {
              throw new Error(`@aws-sdk - $unknown union member in XML requires value of type string, @aws-sdk/xml-builder::XmlNode or XmlText.`);
            }
          }
          this.writeSimpleInto(0, v4, node, xmlns);
          structXmlNode.addChildNode(node);
        }
        if (xmlns) {
          structXmlNode.addAttribute(xmlnsAttr, xmlns);
        }
        return structXmlNode;
      }
      writeList(listMember, array, container, parentXmlns) {
        if (!listMember.isMemberSchema()) {
          throw new Error(`@aws-sdk/core/protocols - xml serializer, cannot write non-member list: ${listMember.getName(true)}`);
        }
        const listTraits = listMember.getMergedTraits();
        const listValueSchema = listMember.getValueSchema();
        const listValueTraits = listValueSchema.getMergedTraits();
        const sparse = !!listValueTraits.sparse;
        const flat = !!listTraits.xmlFlattened;
        const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(listMember, parentXmlns);
        const writeItem = (container2, value) => {
          if (listValueSchema.isListSchema()) {
            this.writeList(listValueSchema, Array.isArray(value) ? value : [value], container2, xmlns);
          } else if (listValueSchema.isMapSchema()) {
            this.writeMap(listValueSchema, value, container2, xmlns);
          } else if (listValueSchema.isStructSchema()) {
            const struct2 = this.writeStruct(listValueSchema, value, xmlns);
            container2.addChildNode(struct2.withName(flat ? listTraits.xmlName ?? listMember.getMemberName() : listValueTraits.xmlName ?? "member"));
          } else {
            const listItemNode = import_xml_builder3.XmlNode.of(flat ? listTraits.xmlName ?? listMember.getMemberName() : listValueTraits.xmlName ?? "member");
            this.writeSimpleInto(listValueSchema, value, listItemNode, xmlns);
            container2.addChildNode(listItemNode);
          }
        };
        if (flat) {
          for (const value of array) {
            if (sparse || value != null) {
              writeItem(container, value);
            }
          }
        } else {
          const listNode = import_xml_builder3.XmlNode.of(listTraits.xmlName ?? listMember.getMemberName());
          if (xmlns) {
            listNode.addAttribute(xmlnsAttr, xmlns);
          }
          for (const value of array) {
            if (sparse || value != null) {
              writeItem(listNode, value);
            }
          }
          container.addChildNode(listNode);
        }
      }
      writeMap(mapMember, map2, container, parentXmlns, containerIsMap = false) {
        if (!mapMember.isMemberSchema()) {
          throw new Error(`@aws-sdk/core/protocols - xml serializer, cannot write non-member map: ${mapMember.getName(true)}`);
        }
        const mapTraits = mapMember.getMergedTraits();
        const mapKeySchema = mapMember.getKeySchema();
        const mapKeyTraits = mapKeySchema.getMergedTraits();
        const keyTag = mapKeyTraits.xmlName ?? "key";
        const mapValueSchema = mapMember.getValueSchema();
        const mapValueTraits = mapValueSchema.getMergedTraits();
        const valueTag = mapValueTraits.xmlName ?? "value";
        const sparse = !!mapValueTraits.sparse;
        const flat = !!mapTraits.xmlFlattened;
        const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(mapMember, parentXmlns);
        const addKeyValue = (entry, key, val) => {
          const keyNode = import_xml_builder3.XmlNode.of(keyTag, key);
          const [keyXmlnsAttr, keyXmlns] = this.getXmlnsAttribute(mapKeySchema, xmlns);
          if (keyXmlns) {
            keyNode.addAttribute(keyXmlnsAttr, keyXmlns);
          }
          entry.addChildNode(keyNode);
          let valueNode = import_xml_builder3.XmlNode.of(valueTag);
          if (mapValueSchema.isListSchema()) {
            this.writeList(mapValueSchema, val, valueNode, xmlns);
          } else if (mapValueSchema.isMapSchema()) {
            this.writeMap(mapValueSchema, val, valueNode, xmlns, true);
          } else if (mapValueSchema.isStructSchema()) {
            valueNode = this.writeStruct(mapValueSchema, val, xmlns);
          } else {
            this.writeSimpleInto(mapValueSchema, val, valueNode, xmlns);
          }
          entry.addChildNode(valueNode);
        };
        if (flat) {
          for (const [key, val] of Object.entries(map2)) {
            if (sparse || val != null) {
              const entry = import_xml_builder3.XmlNode.of(mapTraits.xmlName ?? mapMember.getMemberName());
              addKeyValue(entry, key, val);
              container.addChildNode(entry);
            }
          }
        } else {
          let mapNode;
          if (!containerIsMap) {
            mapNode = import_xml_builder3.XmlNode.of(mapTraits.xmlName ?? mapMember.getMemberName());
            if (xmlns) {
              mapNode.addAttribute(xmlnsAttr, xmlns);
            }
            container.addChildNode(mapNode);
          }
          for (const [key, val] of Object.entries(map2)) {
            if (sparse || val != null) {
              const entry = import_xml_builder3.XmlNode.of("entry");
              addKeyValue(entry, key, val);
              (containerIsMap ? container : mapNode).addChildNode(entry);
            }
          }
        }
      }
      writeSimple(_schema, value) {
        if (null === value) {
          throw new Error("@aws-sdk/core/protocols - (XML serializer) cannot write null value.");
        }
        const ns = NormalizedSchema.of(_schema);
        let nodeContents = null;
        if (value && typeof value === "object") {
          if (ns.isBlobSchema()) {
            nodeContents = (this.serdeContext?.base64Encoder ?? import_util_base647.toBase64)(value);
          } else if (ns.isTimestampSchema() && value instanceof Date) {
            const format2 = determineTimestampFormat(ns, this.settings);
            switch (format2) {
              case 5:
                nodeContents = value.toISOString().replace(".000Z", "Z");
                break;
              case 6:
                nodeContents = (0, import_smithy_client7.dateToUtcString)(value);
                break;
              case 7:
                nodeContents = String(value.getTime() / 1e3);
                break;
              default:
                console.warn("Missing timestamp format, using http date", value);
                nodeContents = (0, import_smithy_client7.dateToUtcString)(value);
                break;
            }
          } else if (ns.isBigDecimalSchema() && value) {
            if (value instanceof NumericValue) {
              return value.string;
            }
            return String(value);
          } else if (ns.isMapSchema() || ns.isListSchema()) {
            throw new Error("@aws-sdk/core/protocols - xml serializer, cannot call _write() on List/Map schema, call writeList or writeMap() instead.");
          } else {
            throw new Error(`@aws-sdk/core/protocols - xml serializer, unhandled schema type for object value and schema: ${ns.getName(true)}`);
          }
        }
        if (ns.isBooleanSchema() || ns.isNumericSchema() || ns.isBigIntegerSchema() || ns.isBigDecimalSchema()) {
          nodeContents = String(value);
        }
        if (ns.isStringSchema()) {
          if (value === void 0 && ns.isIdempotencyToken()) {
            nodeContents = (0, import_uuid.v4)();
          } else {
            nodeContents = String(value);
          }
        }
        if (nodeContents === null) {
          throw new Error(`Unhandled schema-value pair ${ns.getName(true)}=${value}`);
        }
        return nodeContents;
      }
      writeSimpleInto(_schema, value, into, parentXmlns) {
        const nodeContents = this.writeSimple(_schema, value);
        const ns = NormalizedSchema.of(_schema);
        const content = new import_xml_builder3.XmlText(nodeContents);
        const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(ns, parentXmlns);
        if (xmlns) {
          into.addAttribute(xmlnsAttr, xmlns);
        }
        into.addChildNode(content);
      }
      getXmlnsAttribute(ns, parentXmlns) {
        const traits = ns.getMergedTraits();
        const [prefix, xmlns] = traits.xmlNamespace ?? [];
        if (xmlns && xmlns !== parentXmlns) {
          return [prefix ? `xmlns:${prefix}` : "xmlns", xmlns];
        }
        return [void 0, void 0];
      }
    };
  }
});

// node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/xml/XmlCodec.js
var XmlCodec;
var init_XmlCodec = __esm({
  "node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/xml/XmlCodec.js"() {
    init_ConfigurableSerdeContext();
    init_XmlShapeDeserializer();
    init_XmlShapeSerializer();
    XmlCodec = class extends SerdeContextConfig {
      settings;
      constructor(settings) {
        super();
        this.settings = settings;
      }
      createSerializer() {
        const serializer = new XmlShapeSerializer(this.settings);
        serializer.setSerdeContext(this.serdeContext);
        return serializer;
      }
      createDeserializer() {
        const deserializer = new XmlShapeDeserializer(this.settings);
        deserializer.setSerdeContext(this.serdeContext);
        return deserializer;
      }
    };
  }
});

// node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/xml/AwsRestXmlProtocol.js
var AwsRestXmlProtocol;
var init_AwsRestXmlProtocol = __esm({
  "node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/xml/AwsRestXmlProtocol.js"() {
    init_protocols();
    init_schema();
    init_ProtocolLib();
    init_parseXmlBody();
    init_XmlCodec();
    AwsRestXmlProtocol = class extends HttpBindingProtocol {
      codec;
      serializer;
      deserializer;
      mixin = new ProtocolLib();
      constructor(options) {
        super(options);
        const settings = {
          timestampFormat: {
            useTrait: true,
            default: 5
          },
          httpBindings: true,
          xmlNamespace: options.xmlNamespace,
          serviceNamespace: options.defaultNamespace
        };
        this.codec = new XmlCodec(settings);
        this.serializer = new HttpInterceptingShapeSerializer(this.codec.createSerializer(), settings);
        this.deserializer = new HttpInterceptingShapeDeserializer(this.codec.createDeserializer(), settings);
      }
      getPayloadCodec() {
        return this.codec;
      }
      getShapeId() {
        return "aws.protocols#restXml";
      }
      async serializeRequest(operationSchema, input, context) {
        const request2 = await super.serializeRequest(operationSchema, input, context);
        const inputSchema = NormalizedSchema.of(operationSchema.input);
        if (!request2.headers["content-type"]) {
          const contentType = this.mixin.resolveRestContentType(this.getDefaultContentType(), inputSchema);
          if (contentType) {
            request2.headers["content-type"] = contentType;
          }
        }
        if (typeof request2.body === "string" && request2.headers["content-type"] === this.getDefaultContentType() && !request2.body.startsWith("<?xml ") && !this.hasUnstructuredPayloadBinding(inputSchema)) {
          request2.body = '<?xml version="1.0" encoding="UTF-8"?>' + request2.body;
        }
        return request2;
      }
      async deserializeResponse(operationSchema, context, response2) {
        return super.deserializeResponse(operationSchema, context, response2);
      }
      async handleError(operationSchema, context, response2, dataObject, metadata) {
        const errorIdentifier = loadRestXmlErrorCode(response2, dataObject) ?? "Unknown";
        const { errorSchema, errorMetadata } = await this.mixin.getErrorSchemaOrThrowBaseException(errorIdentifier, this.options.defaultNamespace, response2, dataObject, metadata);
        const ns = NormalizedSchema.of(errorSchema);
        const message = dataObject.Error?.message ?? dataObject.Error?.Message ?? dataObject.message ?? dataObject.Message ?? "Unknown";
        const ErrorCtor = TypeRegistry.for(errorSchema[1]).getErrorCtor(errorSchema) ?? Error;
        const exception = new ErrorCtor(message);
        await this.deserializeHttpMessage(errorSchema, context, response2, dataObject);
        const output = {};
        for (const [name, member2] of ns.structIterator()) {
          const target = member2.getMergedTraits().xmlName ?? name;
          const value = dataObject.Error?.[target] ?? dataObject[target];
          output[name] = this.codec.createDeserializer().readSchema(member2, value);
        }
        throw this.mixin.decorateServiceException(Object.assign(exception, errorMetadata, {
          $fault: ns.getMergedTraits().error,
          message
        }, output), dataObject);
      }
      getDefaultContentType() {
        return "application/xml";
      }
      hasUnstructuredPayloadBinding(ns) {
        for (const [, member2] of ns.structIterator()) {
          if (member2.getMergedTraits().httpPayload) {
            return !(member2.isStructSchema() || member2.isMapSchema() || member2.isListSchema());
          }
        }
        return false;
      }
    };
  }
});

// node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/index.js
var protocols_exports2 = {};
__export(protocols_exports2, {
  AwsEc2QueryProtocol: () => AwsEc2QueryProtocol,
  AwsJson1_0Protocol: () => AwsJson1_0Protocol,
  AwsJson1_1Protocol: () => AwsJson1_1Protocol,
  AwsJsonRpcProtocol: () => AwsJsonRpcProtocol,
  AwsQueryProtocol: () => AwsQueryProtocol,
  AwsRestJsonProtocol: () => AwsRestJsonProtocol,
  AwsRestXmlProtocol: () => AwsRestXmlProtocol,
  AwsSmithyRpcV2CborProtocol: () => AwsSmithyRpcV2CborProtocol,
  JsonCodec: () => JsonCodec,
  JsonShapeDeserializer: () => JsonShapeDeserializer,
  JsonShapeSerializer: () => JsonShapeSerializer,
  XmlCodec: () => XmlCodec,
  XmlShapeDeserializer: () => XmlShapeDeserializer,
  XmlShapeSerializer: () => XmlShapeSerializer,
  _toBool: () => _toBool,
  _toNum: () => _toNum,
  _toStr: () => _toStr,
  awsExpectUnion: () => awsExpectUnion,
  loadRestJsonErrorCode: () => loadRestJsonErrorCode,
  loadRestXmlErrorCode: () => loadRestXmlErrorCode,
  parseJsonBody: () => parseJsonBody,
  parseJsonErrorBody: () => parseJsonErrorBody,
  parseXmlBody: () => parseXmlBody,
  parseXmlErrorBody: () => parseXmlErrorBody
});
var init_protocols2 = __esm({
  "node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/submodules/protocols/index.js"() {
    init_AwsSmithyRpcV2CborProtocol();
    init_coercing_serializers();
    init_AwsJson1_0Protocol();
    init_AwsJson1_1Protocol();
    init_AwsJsonRpcProtocol();
    init_AwsRestJsonProtocol();
    init_JsonCodec();
    init_JsonShapeDeserializer();
    init_JsonShapeSerializer();
    init_awsExpectUnion();
    init_parseJsonBody();
    init_AwsEc2QueryProtocol();
    init_AwsQueryProtocol();
    init_AwsRestXmlProtocol();
    init_XmlCodec();
    init_XmlShapeDeserializer();
    init_XmlShapeSerializer();
    init_parseXmlBody();
  }
});

// node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/index.js
var dist_es_exports2 = {};
__export(dist_es_exports2, {
  AWSSDKSigV4Signer: () => AWSSDKSigV4Signer,
  AwsEc2QueryProtocol: () => AwsEc2QueryProtocol,
  AwsJson1_0Protocol: () => AwsJson1_0Protocol,
  AwsJson1_1Protocol: () => AwsJson1_1Protocol,
  AwsJsonRpcProtocol: () => AwsJsonRpcProtocol,
  AwsQueryProtocol: () => AwsQueryProtocol,
  AwsRestJsonProtocol: () => AwsRestJsonProtocol,
  AwsRestXmlProtocol: () => AwsRestXmlProtocol,
  AwsSdkSigV4ASigner: () => AwsSdkSigV4ASigner,
  AwsSdkSigV4Signer: () => AwsSdkSigV4Signer,
  AwsSmithyRpcV2CborProtocol: () => AwsSmithyRpcV2CborProtocol,
  JsonCodec: () => JsonCodec,
  JsonShapeDeserializer: () => JsonShapeDeserializer,
  JsonShapeSerializer: () => JsonShapeSerializer,
  NODE_AUTH_SCHEME_PREFERENCE_OPTIONS: () => NODE_AUTH_SCHEME_PREFERENCE_OPTIONS,
  NODE_SIGV4A_CONFIG_OPTIONS: () => NODE_SIGV4A_CONFIG_OPTIONS,
  XmlCodec: () => XmlCodec,
  XmlShapeDeserializer: () => XmlShapeDeserializer,
  XmlShapeSerializer: () => XmlShapeSerializer,
  _toBool: () => _toBool,
  _toNum: () => _toNum,
  _toStr: () => _toStr,
  awsExpectUnion: () => awsExpectUnion,
  emitWarningIfUnsupportedVersion: () => emitWarningIfUnsupportedVersion,
  getBearerTokenEnvKey: () => getBearerTokenEnvKey,
  loadRestJsonErrorCode: () => loadRestJsonErrorCode,
  loadRestXmlErrorCode: () => loadRestXmlErrorCode,
  parseJsonBody: () => parseJsonBody,
  parseJsonErrorBody: () => parseJsonErrorBody,
  parseXmlBody: () => parseXmlBody,
  parseXmlErrorBody: () => parseXmlErrorBody,
  resolveAWSSDKSigV4Config: () => resolveAWSSDKSigV4Config,
  resolveAwsSdkSigV4AConfig: () => resolveAwsSdkSigV4AConfig,
  resolveAwsSdkSigV4Config: () => resolveAwsSdkSigV4Config,
  setCredentialFeature: () => setCredentialFeature,
  setFeature: () => setFeature,
  setTokenFeature: () => setTokenFeature,
  state: () => state,
  validateSigningProperties: () => validateSigningProperties
});
var init_dist_es2 = __esm({
  "node_modules/.pnpm/@aws-sdk+core@3.970.0/node_modules/@aws-sdk/core/dist-es/index.js"() {
    init_client();
    init_httpAuthSchemes2();
    init_protocols2();
  }
});

// node_modules/.pnpm/@smithy+is-array-buffer@2.2.0/node_modules/@smithy/is-array-buffer/dist-cjs/index.js
var require_dist_cjs22 = __commonJS({
  "node_modules/.pnpm/@smithy+is-array-buffer@2.2.0/node_modules/@smithy/is-array-buffer/dist-cjs/index.js"(exports2, module2) {
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      isArrayBuffer: () => isArrayBuffer
    });
    module2.exports = __toCommonJS2(src_exports);
    var isArrayBuffer = /* @__PURE__ */ __name((arg) => typeof ArrayBuffer === "function" && arg instanceof ArrayBuffer || Object.prototype.toString.call(arg) === "[object ArrayBuffer]", "isArrayBuffer");
  }
});

// node_modules/.pnpm/@smithy+util-buffer-from@2.2.0/node_modules/@smithy/util-buffer-from/dist-cjs/index.js
var require_dist_cjs23 = __commonJS({
  "node_modules/.pnpm/@smithy+util-buffer-from@2.2.0/node_modules/@smithy/util-buffer-from/dist-cjs/index.js"(exports2, module2) {
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      fromArrayBuffer: () => fromArrayBuffer,
      fromString: () => fromString
    });
    module2.exports = __toCommonJS2(src_exports);
    var import_is_array_buffer = require_dist_cjs22();
    var import_buffer = require("buffer");
    var fromArrayBuffer = /* @__PURE__ */ __name((input, offset = 0, length = input.byteLength - offset) => {
      if (!(0, import_is_array_buffer.isArrayBuffer)(input)) {
        throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof input} (${input})`);
      }
      return import_buffer.Buffer.from(input, offset, length);
    }, "fromArrayBuffer");
    var fromString = /* @__PURE__ */ __name((input, encoding2) => {
      if (typeof input !== "string") {
        throw new TypeError(`The "input" argument must be of type string. Received type ${typeof input} (${input})`);
      }
      return encoding2 ? import_buffer.Buffer.from(input, encoding2) : import_buffer.Buffer.from(input);
    }, "fromString");
  }
});

// node_modules/.pnpm/@smithy+util-utf8@2.3.0/node_modules/@smithy/util-utf8/dist-cjs/index.js
var require_dist_cjs24 = __commonJS({
  "node_modules/.pnpm/@smithy+util-utf8@2.3.0/node_modules/@smithy/util-utf8/dist-cjs/index.js"(exports2, module2) {
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      fromUtf8: () => fromUtf87,
      toUint8Array: () => toUint8Array2,
      toUtf8: () => toUtf810
    });
    module2.exports = __toCommonJS2(src_exports);
    var import_util_buffer_from = require_dist_cjs23();
    var fromUtf87 = /* @__PURE__ */ __name((input) => {
      const buf = (0, import_util_buffer_from.fromString)(input, "utf8");
      return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    }, "fromUtf8");
    var toUint8Array2 = /* @__PURE__ */ __name((data2) => {
      if (typeof data2 === "string") {
        return fromUtf87(data2);
      }
      if (ArrayBuffer.isView(data2)) {
        return new Uint8Array(data2.buffer, data2.byteOffset, data2.byteLength / Uint8Array.BYTES_PER_ELEMENT);
      }
      return new Uint8Array(data2);
    }, "toUint8Array");
    var toUtf810 = /* @__PURE__ */ __name((input) => {
      if (typeof input === "string") {
        return input;
      }
      if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
        throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.");
      }
      return (0, import_util_buffer_from.fromArrayBuffer)(input.buffer, input.byteOffset, input.byteLength).toString("utf8");
    }, "toUtf8");
  }
});

// node_modules/.pnpm/@aws-crypto+util@5.2.0/node_modules/@aws-crypto/util/build/main/convertToBuffer.js
var require_convertToBuffer = __commonJS({
  "node_modules/.pnpm/@aws-crypto+util@5.2.0/node_modules/@aws-crypto/util/build/main/convertToBuffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.convertToBuffer = void 0;
    var util_utf8_1 = require_dist_cjs24();
    var fromUtf87 = typeof Buffer !== "undefined" && Buffer.from ? function(input) {
      return Buffer.from(input, "utf8");
    } : util_utf8_1.fromUtf8;
    function convertToBuffer(data2) {
      if (data2 instanceof Uint8Array)
        return data2;
      if (typeof data2 === "string") {
        return fromUtf87(data2);
      }
      if (ArrayBuffer.isView(data2)) {
        return new Uint8Array(data2.buffer, data2.byteOffset, data2.byteLength / Uint8Array.BYTES_PER_ELEMENT);
      }
      return new Uint8Array(data2);
    }
    exports2.convertToBuffer = convertToBuffer;
  }
});

// node_modules/.pnpm/@aws-crypto+util@5.2.0/node_modules/@aws-crypto/util/build/main/isEmptyData.js
var require_isEmptyData = __commonJS({
  "node_modules/.pnpm/@aws-crypto+util@5.2.0/node_modules/@aws-crypto/util/build/main/isEmptyData.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isEmptyData = void 0;
    function isEmptyData(data2) {
      if (typeof data2 === "string") {
        return data2.length === 0;
      }
      return data2.byteLength === 0;
    }
    exports2.isEmptyData = isEmptyData;
  }
});

// node_modules/.pnpm/@aws-crypto+util@5.2.0/node_modules/@aws-crypto/util/build/main/numToUint8.js
var require_numToUint8 = __commonJS({
  "node_modules/.pnpm/@aws-crypto+util@5.2.0/node_modules/@aws-crypto/util/build/main/numToUint8.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.numToUint8 = void 0;
    function numToUint8(num) {
      return new Uint8Array([
        (num & 4278190080) >> 24,
        (num & 16711680) >> 16,
        (num & 65280) >> 8,
        num & 255
      ]);
    }
    exports2.numToUint8 = numToUint8;
  }
});

// node_modules/.pnpm/@aws-crypto+util@5.2.0/node_modules/@aws-crypto/util/build/main/uint32ArrayFrom.js
var require_uint32ArrayFrom = __commonJS({
  "node_modules/.pnpm/@aws-crypto+util@5.2.0/node_modules/@aws-crypto/util/build/main/uint32ArrayFrom.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.uint32ArrayFrom = void 0;
    function uint32ArrayFrom(a_lookUpTable) {
      if (!Uint32Array.from) {
        var return_array = new Uint32Array(a_lookUpTable.length);
        var a_index = 0;
        while (a_index < a_lookUpTable.length) {
          return_array[a_index] = a_lookUpTable[a_index];
          a_index += 1;
        }
        return return_array;
      }
      return Uint32Array.from(a_lookUpTable);
    }
    exports2.uint32ArrayFrom = uint32ArrayFrom;
  }
});

// node_modules/.pnpm/@aws-crypto+util@5.2.0/node_modules/@aws-crypto/util/build/main/index.js
var require_main = __commonJS({
  "node_modules/.pnpm/@aws-crypto+util@5.2.0/node_modules/@aws-crypto/util/build/main/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.uint32ArrayFrom = exports2.numToUint8 = exports2.isEmptyData = exports2.convertToBuffer = void 0;
    var convertToBuffer_1 = require_convertToBuffer();
    Object.defineProperty(exports2, "convertToBuffer", { enumerable: true, get: function() {
      return convertToBuffer_1.convertToBuffer;
    } });
    var isEmptyData_1 = require_isEmptyData();
    Object.defineProperty(exports2, "isEmptyData", { enumerable: true, get: function() {
      return isEmptyData_1.isEmptyData;
    } });
    var numToUint8_1 = require_numToUint8();
    Object.defineProperty(exports2, "numToUint8", { enumerable: true, get: function() {
      return numToUint8_1.numToUint8;
    } });
    var uint32ArrayFrom_1 = require_uint32ArrayFrom();
    Object.defineProperty(exports2, "uint32ArrayFrom", { enumerable: true, get: function() {
      return uint32ArrayFrom_1.uint32ArrayFrom;
    } });
  }
});

// node_modules/.pnpm/@aws-crypto+crc32c@5.2.0/node_modules/@aws-crypto/crc32c/build/main/aws_crc32c.js
var require_aws_crc32c = __commonJS({
  "node_modules/.pnpm/@aws-crypto+crc32c@5.2.0/node_modules/@aws-crypto/crc32c/build/main/aws_crc32c.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AwsCrc32c = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var util_1 = require_main();
    var index_1 = require_main2();
    var AwsCrc32c = (
      /** @class */
      (function() {
        function AwsCrc32c2() {
          this.crc32c = new index_1.Crc32c();
        }
        AwsCrc32c2.prototype.update = function(toHash) {
          if ((0, util_1.isEmptyData)(toHash))
            return;
          this.crc32c.update((0, util_1.convertToBuffer)(toHash));
        };
        AwsCrc32c2.prototype.digest = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            return tslib_1.__generator(this, function(_a2) {
              return [2, (0, util_1.numToUint8)(this.crc32c.digest())];
            });
          });
        };
        AwsCrc32c2.prototype.reset = function() {
          this.crc32c = new index_1.Crc32c();
        };
        return AwsCrc32c2;
      })()
    );
    exports2.AwsCrc32c = AwsCrc32c;
  }
});

// node_modules/.pnpm/@aws-crypto+crc32c@5.2.0/node_modules/@aws-crypto/crc32c/build/main/index.js
var require_main2 = __commonJS({
  "node_modules/.pnpm/@aws-crypto+crc32c@5.2.0/node_modules/@aws-crypto/crc32c/build/main/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AwsCrc32c = exports2.Crc32c = exports2.crc32c = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var util_1 = require_main();
    function crc32c(data2) {
      return new Crc32c().update(data2).digest();
    }
    exports2.crc32c = crc32c;
    var Crc32c = (
      /** @class */
      (function() {
        function Crc32c2() {
          this.checksum = 4294967295;
        }
        Crc32c2.prototype.update = function(data2) {
          var e_1, _a2;
          try {
            for (var data_1 = tslib_1.__values(data2), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
              var byte = data_1_1.value;
              this.checksum = this.checksum >>> 8 ^ lookupTable[(this.checksum ^ byte) & 255];
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (data_1_1 && !data_1_1.done && (_a2 = data_1.return)) _a2.call(data_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          return this;
        };
        Crc32c2.prototype.digest = function() {
          return (this.checksum ^ 4294967295) >>> 0;
        };
        return Crc32c2;
      })()
    );
    exports2.Crc32c = Crc32c;
    var a_lookupTable = [
      0,
      4067132163,
      3778769143,
      324072436,
      3348797215,
      904991772,
      648144872,
      3570033899,
      2329499855,
      2024987596,
      1809983544,
      2575936315,
      1296289744,
      3207089363,
      2893594407,
      1578318884,
      274646895,
      3795141740,
      4049975192,
      51262619,
      3619967088,
      632279923,
      922689671,
      3298075524,
      2592579488,
      1760304291,
      2075979607,
      2312596564,
      1562183871,
      2943781820,
      3156637768,
      1313733451,
      549293790,
      3537243613,
      3246849577,
      871202090,
      3878099393,
      357341890,
      102525238,
      4101499445,
      2858735121,
      1477399826,
      1264559846,
      3107202533,
      1845379342,
      2677391885,
      2361733625,
      2125378298,
      820201905,
      3263744690,
      3520608582,
      598981189,
      4151959214,
      85089709,
      373468761,
      3827903834,
      3124367742,
      1213305469,
      1526817161,
      2842354314,
      2107672161,
      2412447074,
      2627466902,
      1861252501,
      1098587580,
      3004210879,
      2688576843,
      1378610760,
      2262928035,
      1955203488,
      1742404180,
      2511436119,
      3416409459,
      969524848,
      714683780,
      3639785095,
      205050476,
      4266873199,
      3976438427,
      526918040,
      1361435347,
      2739821008,
      2954799652,
      1114974503,
      2529119692,
      1691668175,
      2005155131,
      2247081528,
      3690758684,
      697762079,
      986182379,
      3366744552,
      476452099,
      3993867776,
      4250756596,
      255256311,
      1640403810,
      2477592673,
      2164122517,
      1922457750,
      2791048317,
      1412925310,
      1197962378,
      3037525897,
      3944729517,
      427051182,
      170179418,
      4165941337,
      746937522,
      3740196785,
      3451792453,
      1070968646,
      1905808397,
      2213795598,
      2426610938,
      1657317369,
      3053634322,
      1147748369,
      1463399397,
      2773627110,
      4215344322,
      153784257,
      444234805,
      3893493558,
      1021025245,
      3467647198,
      3722505002,
      797665321,
      2197175160,
      1889384571,
      1674398607,
      2443626636,
      1164749927,
      3070701412,
      2757221520,
      1446797203,
      137323447,
      4198817972,
      3910406976,
      461344835,
      3484808360,
      1037989803,
      781091935,
      3705997148,
      2460548119,
      1623424788,
      1939049696,
      2180517859,
      1429367560,
      2807687179,
      3020495871,
      1180866812,
      410100952,
      3927582683,
      4182430767,
      186734380,
      3756733383,
      763408580,
      1053836080,
      3434856499,
      2722870694,
      1344288421,
      1131464017,
      2971354706,
      1708204729,
      2545590714,
      2229949006,
      1988219213,
      680717673,
      3673779818,
      3383336350,
      1002577565,
      4010310262,
      493091189,
      238226049,
      4233660802,
      2987750089,
      1082061258,
      1395524158,
      2705686845,
      1972364758,
      2279892693,
      2494862625,
      1725896226,
      952904198,
      3399985413,
      3656866545,
      731699698,
      4283874585,
      222117402,
      510512622,
      3959836397,
      3280807620,
      837199303,
      582374963,
      3504198960,
      68661723,
      4135334616,
      3844915500,
      390545967,
      1230274059,
      3141532936,
      2825850620,
      1510247935,
      2395924756,
      2091215383,
      1878366691,
      2644384480,
      3553878443,
      565732008,
      854102364,
      3229815391,
      340358836,
      3861050807,
      4117890627,
      119113024,
      1493875044,
      2875275879,
      3090270611,
      1247431312,
      2660249211,
      1828433272,
      2141937292,
      2378227087,
      3811616794,
      291187481,
      34330861,
      4032846830,
      615137029,
      3603020806,
      3314634738,
      939183345,
      1776939221,
      2609017814,
      2295496738,
      2058945313,
      2926798794,
      1545135305,
      1330124605,
      3173225534,
      4084100981,
      17165430,
      307568514,
      3762199681,
      888469610,
      3332340585,
      3587147933,
      665062302,
      2042050490,
      2346497209,
      2559330125,
      1793573966,
      3190661285,
      1279665062,
      1595330642,
      2910671697
    ];
    var lookupTable = (0, util_1.uint32ArrayFrom)(a_lookupTable);
    var aws_crc32c_1 = require_aws_crc32c();
    Object.defineProperty(exports2, "AwsCrc32c", { enumerable: true, get: function() {
      return aws_crc32c_1.AwsCrc32c;
    } });
  }
});

// node_modules/.pnpm/@aws-sdk+crc64-nvme@3.969.0/node_modules/@aws-sdk/crc64-nvme/dist-cjs/index.js
var require_dist_cjs25 = __commonJS({
  "node_modules/.pnpm/@aws-sdk+crc64-nvme@3.969.0/node_modules/@aws-sdk/crc64-nvme/dist-cjs/index.js"(exports2) {
    "use strict";
    var generateCRC64NVMETable = () => {
      const sliceLength = 8;
      const tables = new Array(sliceLength);
      for (let slice = 0; slice < sliceLength; slice++) {
        const table = new Array(512);
        for (let i4 = 0; i4 < 256; i4++) {
          let crc = BigInt(i4);
          for (let j4 = 0; j4 < 8 * (slice + 1); j4++) {
            if (crc & 1n) {
              crc = crc >> 1n ^ 0x9a6c9329ac4bc9b5n;
            } else {
              crc = crc >> 1n;
            }
          }
          table[i4 * 2] = Number(crc >> 32n & 0xffffffffn);
          table[i4 * 2 + 1] = Number(crc & 0xffffffffn);
        }
        tables[slice] = new Uint32Array(table);
      }
      return tables;
    };
    var CRC64_NVME_REVERSED_TABLE;
    var t0;
    var t1;
    var t22;
    var t32;
    var t4;
    var t5;
    var t6;
    var t7;
    var ensureTablesInitialized = () => {
      if (!CRC64_NVME_REVERSED_TABLE) {
        CRC64_NVME_REVERSED_TABLE = generateCRC64NVMETable();
        [t0, t1, t22, t32, t4, t5, t6, t7] = CRC64_NVME_REVERSED_TABLE;
      }
    };
    var Crc64Nvme = class {
      c1 = 0;
      c2 = 0;
      constructor() {
        ensureTablesInitialized();
        this.reset();
      }
      update(data2) {
        const len = data2.length;
        let i4 = 0;
        let crc1 = this.c1;
        let crc2 = this.c2;
        while (i4 + 8 <= len) {
          const idx0 = ((crc2 ^ data2[i4++]) & 255) << 1;
          const idx1 = ((crc2 >>> 8 ^ data2[i4++]) & 255) << 1;
          const idx2 = ((crc2 >>> 16 ^ data2[i4++]) & 255) << 1;
          const idx3 = ((crc2 >>> 24 ^ data2[i4++]) & 255) << 1;
          const idx4 = ((crc1 ^ data2[i4++]) & 255) << 1;
          const idx5 = ((crc1 >>> 8 ^ data2[i4++]) & 255) << 1;
          const idx6 = ((crc1 >>> 16 ^ data2[i4++]) & 255) << 1;
          const idx7 = ((crc1 >>> 24 ^ data2[i4++]) & 255) << 1;
          crc1 = t7[idx0] ^ t6[idx1] ^ t5[idx2] ^ t4[idx3] ^ t32[idx4] ^ t22[idx5] ^ t1[idx6] ^ t0[idx7];
          crc2 = t7[idx0 + 1] ^ t6[idx1 + 1] ^ t5[idx2 + 1] ^ t4[idx3 + 1] ^ t32[idx4 + 1] ^ t22[idx5 + 1] ^ t1[idx6 + 1] ^ t0[idx7 + 1];
        }
        while (i4 < len) {
          const idx = ((crc2 ^ data2[i4]) & 255) << 1;
          crc2 = (crc2 >>> 8 | (crc1 & 255) << 24) >>> 0;
          crc1 = crc1 >>> 8 ^ t0[idx];
          crc2 ^= t0[idx + 1];
          i4++;
        }
        this.c1 = crc1;
        this.c2 = crc2;
      }
      async digest() {
        const c1 = this.c1 ^ 4294967295;
        const c22 = this.c2 ^ 4294967295;
        return new Uint8Array([
          c1 >>> 24,
          c1 >>> 16 & 255,
          c1 >>> 8 & 255,
          c1 & 255,
          c22 >>> 24,
          c22 >>> 16 & 255,
          c22 >>> 8 & 255,
          c22 & 255
        ]);
      }
      reset() {
        this.c1 = 4294967295;
        this.c2 = 4294967295;
      }
    };
    var crc64NvmeCrtContainer = {
      CrtCrc64Nvme: null
    };
    exports2.Crc64Nvme = Crc64Nvme;
    exports2.crc64NvmeCrtContainer = crc64NvmeCrtContainer;
  }
});

// node_modules/.pnpm/@aws-crypto+crc32@5.2.0/node_modules/@aws-crypto/crc32/build/main/aws_crc32.js
var require_aws_crc32 = __commonJS({
  "node_modules/.pnpm/@aws-crypto+crc32@5.2.0/node_modules/@aws-crypto/crc32/build/main/aws_crc32.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AwsCrc32 = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var util_1 = require_main();
    var index_1 = require_main3();
    var AwsCrc32 = (
      /** @class */
      (function() {
        function AwsCrc322() {
          this.crc32 = new index_1.Crc32();
        }
        AwsCrc322.prototype.update = function(toHash) {
          if ((0, util_1.isEmptyData)(toHash))
            return;
          this.crc32.update((0, util_1.convertToBuffer)(toHash));
        };
        AwsCrc322.prototype.digest = function() {
          return tslib_1.__awaiter(this, void 0, void 0, function() {
            return tslib_1.__generator(this, function(_a2) {
              return [2, (0, util_1.numToUint8)(this.crc32.digest())];
            });
          });
        };
        AwsCrc322.prototype.reset = function() {
          this.crc32 = new index_1.Crc32();
        };
        return AwsCrc322;
      })()
    );
    exports2.AwsCrc32 = AwsCrc32;
  }
});

// node_modules/.pnpm/@aws-crypto+crc32@5.2.0/node_modules/@aws-crypto/crc32/build/main/index.js
var require_main3 = __commonJS({
  "node_modules/.pnpm/@aws-crypto+crc32@5.2.0/node_modules/@aws-crypto/crc32/build/main/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AwsCrc32 = exports2.Crc32 = exports2.crc32 = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var util_1 = require_main();
    function crc32(data2) {
      return new Crc32().update(data2).digest();
    }
    exports2.crc32 = crc32;
    var Crc32 = (
      /** @class */
      (function() {
        function Crc322() {
          this.checksum = 4294967295;
        }
        Crc322.prototype.update = function(data2) {
          var e_1, _a2;
          try {
            for (var data_1 = tslib_1.__values(data2), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
              var byte = data_1_1.value;
              this.checksum = this.checksum >>> 8 ^ lookupTable[(this.checksum ^ byte) & 255];
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (data_1_1 && !data_1_1.done && (_a2 = data_1.return)) _a2.call(data_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          return this;
        };
        Crc322.prototype.digest = function() {
          return (this.checksum ^ 4294967295) >>> 0;
        };
        return Crc322;
      })()
    );
    exports2.Crc32 = Crc32;
    var a_lookUpTable = [
      0,
      1996959894,
      3993919788,
      2567524794,
      124634137,
      1886057615,
      3915621685,
      2657392035,
      249268274,
      2044508324,
      3772115230,
      2547177864,
      162941995,
      2125561021,
      3887607047,
      2428444049,
      498536548,
      1789927666,
      4089016648,
      2227061214,
      450548861,
      1843258603,
      4107580753,
      2211677639,
      325883990,
      1684777152,
      4251122042,
      2321926636,
      335633487,
      1661365465,
      4195302755,
      2366115317,
      997073096,
      1281953886,
      3579855332,
      2724688242,
      1006888145,
      1258607687,
      3524101629,
      2768942443,
      901097722,
      1119000684,
      3686517206,
      2898065728,
      853044451,
      1172266101,
      3705015759,
      2882616665,
      651767980,
      1373503546,
      3369554304,
      3218104598,
      565507253,
      1454621731,
      3485111705,
      3099436303,
      671266974,
      1594198024,
      3322730930,
      2970347812,
      795835527,
      1483230225,
      3244367275,
      3060149565,
      1994146192,
      31158534,
      2563907772,
      4023717930,
      1907459465,
      112637215,
      2680153253,
      3904427059,
      2013776290,
      251722036,
      2517215374,
      3775830040,
      2137656763,
      141376813,
      2439277719,
      3865271297,
      1802195444,
      476864866,
      2238001368,
      4066508878,
      1812370925,
      453092731,
      2181625025,
      4111451223,
      1706088902,
      314042704,
      2344532202,
      4240017532,
      1658658271,
      366619977,
      2362670323,
      4224994405,
      1303535960,
      984961486,
      2747007092,
      3569037538,
      1256170817,
      1037604311,
      2765210733,
      3554079995,
      1131014506,
      879679996,
      2909243462,
      3663771856,
      1141124467,
      855842277,
      2852801631,
      3708648649,
      1342533948,
      654459306,
      3188396048,
      3373015174,
      1466479909,
      544179635,
      3110523913,
      3462522015,
      1591671054,
      702138776,
      2966460450,
      3352799412,
      1504918807,
      783551873,
      3082640443,
      3233442989,
      3988292384,
      2596254646,
      62317068,
      1957810842,
      3939845945,
      2647816111,
      81470997,
      1943803523,
      3814918930,
      2489596804,
      225274430,
      2053790376,
      3826175755,
      2466906013,
      167816743,
      2097651377,
      4027552580,
      2265490386,
      503444072,
      1762050814,
      4150417245,
      2154129355,
      426522225,
      1852507879,
      4275313526,
      2312317920,
      282753626,
      1742555852,
      4189708143,
      2394877945,
      397917763,
      1622183637,
      3604390888,
      2714866558,
      953729732,
      1340076626,
      3518719985,
      2797360999,
      1068828381,
      1219638859,
      3624741850,
      2936675148,
      906185462,
      1090812512,
      3747672003,
      2825379669,
      829329135,
      1181335161,
      3412177804,
      3160834842,
      628085408,
      1382605366,
      3423369109,
      3138078467,
      570562233,
      1426400815,
      3317316542,
      2998733608,
      733239954,
      1555261956,
      3268935591,
      3050360625,
      752459403,
      1541320221,
      2607071920,
      3965973030,
      1969922972,
      40735498,
      2617837225,
      3943577151,
      1913087877,
      83908371,
      2512341634,
      3803740692,
      2075208622,
      213261112,
      2463272603,
      3855990285,
      2094854071,
      198958881,
      2262029012,
      4057260610,
      1759359992,
      534414190,
      2176718541,
      4139329115,
      1873836001,
      414664567,
      2282248934,
      4279200368,
      1711684554,
      285281116,
      2405801727,
      4167216745,
      1634467795,
      376229701,
      2685067896,
      3608007406,
      1308918612,
      956543938,
      2808555105,
      3495958263,
      1231636301,
      1047427035,
      2932959818,
      3654703836,
      1088359270,
      936918e3,
      2847714899,
      3736837829,
      1202900863,
      817233897,
      3183342108,
      3401237130,
      1404277552,
      615818150,
      3134207493,
      3453421203,
      1423857449,
      601450431,
      3009837614,
      3294710456,
      1567103746,
      711928724,
      3020668471,
      3272380065,
      1510334235,
      755167117
    ];
    var lookupTable = (0, util_1.uint32ArrayFrom)(a_lookUpTable);
    var aws_crc32_1 = require_aws_crc32();
    Object.defineProperty(exports2, "AwsCrc32", { enumerable: true, get: function() {
      return aws_crc32_1.AwsCrc32;
    } });
  }
});

// node_modules/.pnpm/@aws-sdk+middleware-flexible-checksums@3.971.0/node_modules/@aws-sdk/middleware-flexible-checksums/dist-cjs/getCrc32ChecksumAlgorithmFunction.js
var require_getCrc32ChecksumAlgorithmFunction = __commonJS({
  "node_modules/.pnpm/@aws-sdk+middleware-flexible-checksums@3.971.0/node_modules/@aws-sdk/middleware-flexible-checksums/dist-cjs/getCrc32ChecksumAlgorithmFunction.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getCrc32ChecksumAlgorithmFunction = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var crc32_1 = require_main3();
    var util_1 = require_main();
    var zlib2 = tslib_1.__importStar(require("zlib"));
    var NodeCrc32 = class {
      checksum = 0;
      update(data2) {
        this.checksum = zlib2.crc32(data2, this.checksum);
      }
      async digest() {
        return (0, util_1.numToUint8)(this.checksum);
      }
      reset() {
        this.checksum = 0;
      }
    };
    var getCrc32ChecksumAlgorithmFunction = () => {
      if (typeof zlib2.crc32 === "undefined") {
        return crc32_1.AwsCrc32;
      }
      return NodeCrc32;
    };
    exports2.getCrc32ChecksumAlgorithmFunction = getCrc32ChecksumAlgorithmFunction;
  }
});

// node_modules/.pnpm/@aws-sdk+middleware-flexible-checksums@3.971.0/node_modules/@aws-sdk/middleware-flexible-checksums/dist-cjs/index.js
var require_dist_cjs26 = __commonJS({
  "node_modules/.pnpm/@aws-sdk+middleware-flexible-checksums@3.971.0/node_modules/@aws-sdk/middleware-flexible-checksums/dist-cjs/index.js"(exports2) {
    "use strict";
    var core = (init_dist_es2(), __toCommonJS(dist_es_exports2));
    var protocolHttp = require_dist_cjs2();
    var utilStream = require_dist_cjs15();
    var isArrayBuffer = require_dist_cjs6();
    var crc32c = require_main2();
    var crc64Nvme = require_dist_cjs25();
    var getCrc32ChecksumAlgorithmFunction = require_getCrc32ChecksumAlgorithmFunction();
    var utilUtf8 = require_dist_cjs8();
    var utilMiddleware = require_dist_cjs4();
    var RequestChecksumCalculation = {
      WHEN_SUPPORTED: "WHEN_SUPPORTED",
      WHEN_REQUIRED: "WHEN_REQUIRED"
    };
    var DEFAULT_REQUEST_CHECKSUM_CALCULATION = RequestChecksumCalculation.WHEN_SUPPORTED;
    var ResponseChecksumValidation = {
      WHEN_SUPPORTED: "WHEN_SUPPORTED",
      WHEN_REQUIRED: "WHEN_REQUIRED"
    };
    var DEFAULT_RESPONSE_CHECKSUM_VALIDATION = RequestChecksumCalculation.WHEN_SUPPORTED;
    exports2.ChecksumAlgorithm = void 0;
    (function(ChecksumAlgorithm) {
      ChecksumAlgorithm["MD5"] = "MD5";
      ChecksumAlgorithm["CRC32"] = "CRC32";
      ChecksumAlgorithm["CRC32C"] = "CRC32C";
      ChecksumAlgorithm["CRC64NVME"] = "CRC64NVME";
      ChecksumAlgorithm["SHA1"] = "SHA1";
      ChecksumAlgorithm["SHA256"] = "SHA256";
    })(exports2.ChecksumAlgorithm || (exports2.ChecksumAlgorithm = {}));
    exports2.ChecksumLocation = void 0;
    (function(ChecksumLocation) {
      ChecksumLocation["HEADER"] = "header";
      ChecksumLocation["TRAILER"] = "trailer";
    })(exports2.ChecksumLocation || (exports2.ChecksumLocation = {}));
    var DEFAULT_CHECKSUM_ALGORITHM = exports2.ChecksumAlgorithm.CRC32;
    var SelectorType2;
    (function(SelectorType3) {
      SelectorType3["ENV"] = "env";
      SelectorType3["CONFIG"] = "shared config entry";
    })(SelectorType2 || (SelectorType2 = {}));
    var stringUnionSelector = (obj, key, union, type) => {
      if (!(key in obj))
        return void 0;
      const value = obj[key].toUpperCase();
      if (!Object.values(union).includes(value)) {
        throw new TypeError(`Cannot load ${type} '${key}'. Expected one of ${Object.values(union)}, got '${obj[key]}'.`);
      }
      return value;
    };
    var ENV_REQUEST_CHECKSUM_CALCULATION = "AWS_REQUEST_CHECKSUM_CALCULATION";
    var CONFIG_REQUEST_CHECKSUM_CALCULATION = "request_checksum_calculation";
    var NODE_REQUEST_CHECKSUM_CALCULATION_CONFIG_OPTIONS = {
      environmentVariableSelector: (env) => stringUnionSelector(env, ENV_REQUEST_CHECKSUM_CALCULATION, RequestChecksumCalculation, SelectorType2.ENV),
      configFileSelector: (profile) => stringUnionSelector(profile, CONFIG_REQUEST_CHECKSUM_CALCULATION, RequestChecksumCalculation, SelectorType2.CONFIG),
      default: DEFAULT_REQUEST_CHECKSUM_CALCULATION
    };
    var ENV_RESPONSE_CHECKSUM_VALIDATION = "AWS_RESPONSE_CHECKSUM_VALIDATION";
    var CONFIG_RESPONSE_CHECKSUM_VALIDATION = "response_checksum_validation";
    var NODE_RESPONSE_CHECKSUM_VALIDATION_CONFIG_OPTIONS = {
      environmentVariableSelector: (env) => stringUnionSelector(env, ENV_RESPONSE_CHECKSUM_VALIDATION, ResponseChecksumValidation, SelectorType2.ENV),
      configFileSelector: (profile) => stringUnionSelector(profile, CONFIG_RESPONSE_CHECKSUM_VALIDATION, ResponseChecksumValidation, SelectorType2.CONFIG),
      default: DEFAULT_RESPONSE_CHECKSUM_VALIDATION
    };
    var CLIENT_SUPPORTED_ALGORITHMS = [
      exports2.ChecksumAlgorithm.CRC32,
      exports2.ChecksumAlgorithm.CRC32C,
      exports2.ChecksumAlgorithm.CRC64NVME,
      exports2.ChecksumAlgorithm.SHA1,
      exports2.ChecksumAlgorithm.SHA256
    ];
    var PRIORITY_ORDER_ALGORITHMS = [
      exports2.ChecksumAlgorithm.SHA256,
      exports2.ChecksumAlgorithm.SHA1,
      exports2.ChecksumAlgorithm.CRC32,
      exports2.ChecksumAlgorithm.CRC32C,
      exports2.ChecksumAlgorithm.CRC64NVME
    ];
    var getChecksumAlgorithmForRequest = (input, { requestChecksumRequired, requestAlgorithmMember, requestChecksumCalculation }) => {
      if (!requestAlgorithmMember) {
        return requestChecksumCalculation === RequestChecksumCalculation.WHEN_SUPPORTED || requestChecksumRequired ? DEFAULT_CHECKSUM_ALGORITHM : void 0;
      }
      if (!input[requestAlgorithmMember]) {
        return void 0;
      }
      const checksumAlgorithm = input[requestAlgorithmMember];
      if (!CLIENT_SUPPORTED_ALGORITHMS.includes(checksumAlgorithm)) {
        throw new Error(`The checksum algorithm "${checksumAlgorithm}" is not supported by the client. Select one of ${CLIENT_SUPPORTED_ALGORITHMS}.`);
      }
      return checksumAlgorithm;
    };
    var getChecksumLocationName = (algorithm) => algorithm === exports2.ChecksumAlgorithm.MD5 ? "content-md5" : `x-amz-checksum-${algorithm.toLowerCase()}`;
    var hasHeader = (header, headers2) => {
      const soughtHeader = header.toLowerCase();
      for (const headerName of Object.keys(headers2)) {
        if (soughtHeader === headerName.toLowerCase()) {
          return true;
        }
      }
      return false;
    };
    var hasHeaderWithPrefix = (headerPrefix, headers2) => {
      const soughtHeaderPrefix = headerPrefix.toLowerCase();
      for (const headerName of Object.keys(headers2)) {
        if (headerName.toLowerCase().startsWith(soughtHeaderPrefix)) {
          return true;
        }
      }
      return false;
    };
    var isStreaming = (body2) => body2 !== void 0 && typeof body2 !== "string" && !ArrayBuffer.isView(body2) && !isArrayBuffer.isArrayBuffer(body2);
    var selectChecksumAlgorithmFunction = (checksumAlgorithm, config) => {
      switch (checksumAlgorithm) {
        case exports2.ChecksumAlgorithm.MD5:
          return config.md5;
        case exports2.ChecksumAlgorithm.CRC32:
          return getCrc32ChecksumAlgorithmFunction.getCrc32ChecksumAlgorithmFunction();
        case exports2.ChecksumAlgorithm.CRC32C:
          return crc32c.AwsCrc32c;
        case exports2.ChecksumAlgorithm.CRC64NVME:
          if (typeof crc64Nvme.crc64NvmeCrtContainer.CrtCrc64Nvme !== "function") {
            return crc64Nvme.Crc64Nvme;
          }
          return crc64Nvme.crc64NvmeCrtContainer.CrtCrc64Nvme;
        case exports2.ChecksumAlgorithm.SHA1:
          return config.sha1;
        case exports2.ChecksumAlgorithm.SHA256:
          return config.sha256;
        default:
          throw new Error(`Unsupported checksum algorithm: ${checksumAlgorithm}`);
      }
    };
    var stringHasher = (checksumAlgorithmFn, body2) => {
      const hash = new checksumAlgorithmFn();
      hash.update(utilUtf8.toUint8Array(body2 || ""));
      return hash.digest();
    };
    var flexibleChecksumsMiddlewareOptions = {
      name: "flexibleChecksumsMiddleware",
      step: "build",
      tags: ["BODY_CHECKSUM"],
      override: true
    };
    var flexibleChecksumsMiddleware = (config, middlewareConfig) => (next, context) => async (args) => {
      if (!protocolHttp.HttpRequest.isInstance(args.request)) {
        return next(args);
      }
      if (hasHeaderWithPrefix("x-amz-checksum-", args.request.headers)) {
        return next(args);
      }
      const { request: request2, input } = args;
      const { body: requestBody, headers: headers2 } = request2;
      const { base64Encoder, streamHasher } = config;
      const { requestChecksumRequired, requestAlgorithmMember } = middlewareConfig;
      const requestChecksumCalculation = await config.requestChecksumCalculation();
      const requestAlgorithmMemberName = requestAlgorithmMember?.name;
      const requestAlgorithmMemberHttpHeader = requestAlgorithmMember?.httpHeader;
      if (requestAlgorithmMemberName && !input[requestAlgorithmMemberName]) {
        if (requestChecksumCalculation === RequestChecksumCalculation.WHEN_SUPPORTED || requestChecksumRequired) {
          input[requestAlgorithmMemberName] = DEFAULT_CHECKSUM_ALGORITHM;
          if (requestAlgorithmMemberHttpHeader) {
            headers2[requestAlgorithmMemberHttpHeader] = DEFAULT_CHECKSUM_ALGORITHM;
          }
        }
      }
      const checksumAlgorithm = getChecksumAlgorithmForRequest(input, {
        requestChecksumRequired,
        requestAlgorithmMember: requestAlgorithmMember?.name,
        requestChecksumCalculation
      });
      let updatedBody = requestBody;
      let updatedHeaders = headers2;
      if (checksumAlgorithm) {
        switch (checksumAlgorithm) {
          case exports2.ChecksumAlgorithm.CRC32:
            core.setFeature(context, "FLEXIBLE_CHECKSUMS_REQ_CRC32", "U");
            break;
          case exports2.ChecksumAlgorithm.CRC32C:
            core.setFeature(context, "FLEXIBLE_CHECKSUMS_REQ_CRC32C", "V");
            break;
          case exports2.ChecksumAlgorithm.CRC64NVME:
            core.setFeature(context, "FLEXIBLE_CHECKSUMS_REQ_CRC64", "W");
            break;
          case exports2.ChecksumAlgorithm.SHA1:
            core.setFeature(context, "FLEXIBLE_CHECKSUMS_REQ_SHA1", "X");
            break;
          case exports2.ChecksumAlgorithm.SHA256:
            core.setFeature(context, "FLEXIBLE_CHECKSUMS_REQ_SHA256", "Y");
            break;
        }
        const checksumLocationName = getChecksumLocationName(checksumAlgorithm);
        const checksumAlgorithmFn = selectChecksumAlgorithmFunction(checksumAlgorithm, config);
        if (isStreaming(requestBody)) {
          const { getAwsChunkedEncodingStream, bodyLengthChecker } = config;
          updatedBody = getAwsChunkedEncodingStream(typeof config.requestStreamBufferSize === "number" && config.requestStreamBufferSize >= 8 * 1024 ? utilStream.createBufferedReadable(requestBody, config.requestStreamBufferSize, context.logger) : requestBody, {
            base64Encoder,
            bodyLengthChecker,
            checksumLocationName,
            checksumAlgorithmFn,
            streamHasher
          });
          updatedHeaders = {
            ...headers2,
            "content-encoding": headers2["content-encoding"] ? `${headers2["content-encoding"]},aws-chunked` : "aws-chunked",
            "transfer-encoding": "chunked",
            "x-amz-decoded-content-length": headers2["content-length"],
            "x-amz-content-sha256": "STREAMING-UNSIGNED-PAYLOAD-TRAILER",
            "x-amz-trailer": checksumLocationName
          };
          delete updatedHeaders["content-length"];
        } else if (!hasHeader(checksumLocationName, headers2)) {
          const rawChecksum = await stringHasher(checksumAlgorithmFn, requestBody);
          updatedHeaders = {
            ...headers2,
            [checksumLocationName]: base64Encoder(rawChecksum)
          };
        }
      }
      try {
        const result = await next({
          ...args,
          request: {
            ...request2,
            headers: updatedHeaders,
            body: updatedBody
          }
        });
        return result;
      } catch (e4) {
        if (e4 instanceof Error && e4.name === "InvalidChunkSizeError") {
          try {
            if (!e4.message.endsWith(".")) {
              e4.message += ".";
            }
            e4.message += " Set [requestStreamBufferSize=number e.g. 65_536] in client constructor to instruct AWS SDK to buffer your input stream.";
          } catch (ignored) {
          }
        }
        throw e4;
      }
    };
    var flexibleChecksumsInputMiddlewareOptions = {
      name: "flexibleChecksumsInputMiddleware",
      toMiddleware: "serializerMiddleware",
      relation: "before",
      tags: ["BODY_CHECKSUM"],
      override: true
    };
    var flexibleChecksumsInputMiddleware = (config, middlewareConfig) => (next, context) => async (args) => {
      const input = args.input;
      const { requestValidationModeMember } = middlewareConfig;
      const requestChecksumCalculation = await config.requestChecksumCalculation();
      const responseChecksumValidation = await config.responseChecksumValidation();
      switch (requestChecksumCalculation) {
        case RequestChecksumCalculation.WHEN_REQUIRED:
          core.setFeature(context, "FLEXIBLE_CHECKSUMS_REQ_WHEN_REQUIRED", "a");
          break;
        case RequestChecksumCalculation.WHEN_SUPPORTED:
          core.setFeature(context, "FLEXIBLE_CHECKSUMS_REQ_WHEN_SUPPORTED", "Z");
          break;
      }
      switch (responseChecksumValidation) {
        case ResponseChecksumValidation.WHEN_REQUIRED:
          core.setFeature(context, "FLEXIBLE_CHECKSUMS_RES_WHEN_REQUIRED", "c");
          break;
        case ResponseChecksumValidation.WHEN_SUPPORTED:
          core.setFeature(context, "FLEXIBLE_CHECKSUMS_RES_WHEN_SUPPORTED", "b");
          break;
      }
      if (requestValidationModeMember && !input[requestValidationModeMember]) {
        if (responseChecksumValidation === ResponseChecksumValidation.WHEN_SUPPORTED) {
          input[requestValidationModeMember] = "ENABLED";
        }
      }
      return next(args);
    };
    var getChecksumAlgorithmListForResponse = (responseAlgorithms = []) => {
      const validChecksumAlgorithms = [];
      for (const algorithm of PRIORITY_ORDER_ALGORITHMS) {
        if (!responseAlgorithms.includes(algorithm) || !CLIENT_SUPPORTED_ALGORITHMS.includes(algorithm)) {
          continue;
        }
        validChecksumAlgorithms.push(algorithm);
      }
      return validChecksumAlgorithms;
    };
    var isChecksumWithPartNumber = (checksum) => {
      const lastHyphenIndex = checksum.lastIndexOf("-");
      if (lastHyphenIndex !== -1) {
        const numberPart = checksum.slice(lastHyphenIndex + 1);
        if (!numberPart.startsWith("0")) {
          const number = parseInt(numberPart, 10);
          if (!isNaN(number) && number >= 1 && number <= 1e4) {
            return true;
          }
        }
      }
      return false;
    };
    var getChecksum = async (body2, { checksumAlgorithmFn, base64Encoder }) => base64Encoder(await stringHasher(checksumAlgorithmFn, body2));
    var validateChecksumFromResponse = async (response2, { config, responseAlgorithms, logger: logger3 }) => {
      const checksumAlgorithms = getChecksumAlgorithmListForResponse(responseAlgorithms);
      const { body: responseBody, headers: responseHeaders } = response2;
      for (const algorithm of checksumAlgorithms) {
        const responseHeader = getChecksumLocationName(algorithm);
        const checksumFromResponse = responseHeaders[responseHeader];
        if (checksumFromResponse) {
          let checksumAlgorithmFn;
          try {
            checksumAlgorithmFn = selectChecksumAlgorithmFunction(algorithm, config);
          } catch (error2) {
            if (algorithm === exports2.ChecksumAlgorithm.CRC64NVME) {
              logger3?.warn(`Skipping ${exports2.ChecksumAlgorithm.CRC64NVME} checksum validation: ${error2.message}`);
              continue;
            }
            throw error2;
          }
          const { base64Encoder } = config;
          if (isStreaming(responseBody)) {
            response2.body = utilStream.createChecksumStream({
              expectedChecksum: checksumFromResponse,
              checksumSourceLocation: responseHeader,
              checksum: new checksumAlgorithmFn(),
              source: responseBody,
              base64Encoder
            });
            return;
          }
          const checksum = await getChecksum(responseBody, { checksumAlgorithmFn, base64Encoder });
          if (checksum === checksumFromResponse) {
            break;
          }
          throw new Error(`Checksum mismatch: expected "${checksum}" but received "${checksumFromResponse}" in response header "${responseHeader}".`);
        }
      }
    };
    var flexibleChecksumsResponseMiddlewareOptions = {
      name: "flexibleChecksumsResponseMiddleware",
      toMiddleware: "deserializerMiddleware",
      relation: "after",
      tags: ["BODY_CHECKSUM"],
      override: true
    };
    var flexibleChecksumsResponseMiddleware = (config, middlewareConfig) => (next, context) => async (args) => {
      if (!protocolHttp.HttpRequest.isInstance(args.request)) {
        return next(args);
      }
      const input = args.input;
      const result = await next(args);
      const response2 = result.response;
      const { requestValidationModeMember, responseAlgorithms } = middlewareConfig;
      if (requestValidationModeMember && input[requestValidationModeMember] === "ENABLED") {
        const { clientName, commandName } = context;
        const isS3WholeObjectMultipartGetResponseChecksum = clientName === "S3Client" && commandName === "GetObjectCommand" && getChecksumAlgorithmListForResponse(responseAlgorithms).every((algorithm) => {
          const responseHeader = getChecksumLocationName(algorithm);
          const checksumFromResponse = response2.headers[responseHeader];
          return !checksumFromResponse || isChecksumWithPartNumber(checksumFromResponse);
        });
        if (isS3WholeObjectMultipartGetResponseChecksum) {
          return result;
        }
        await validateChecksumFromResponse(response2, {
          config,
          responseAlgorithms,
          logger: context.logger
        });
      }
      return result;
    };
    var getFlexibleChecksumsPlugin = (config, middlewareConfig) => ({
      applyToStack: (clientStack) => {
        clientStack.add(flexibleChecksumsMiddleware(config, middlewareConfig), flexibleChecksumsMiddlewareOptions);
        clientStack.addRelativeTo(flexibleChecksumsInputMiddleware(config, middlewareConfig), flexibleChecksumsInputMiddlewareOptions);
        clientStack.addRelativeTo(flexibleChecksumsResponseMiddleware(config, middlewareConfig), flexibleChecksumsResponseMiddlewareOptions);
      }
    });
    var resolveFlexibleChecksumsConfig = (input) => {
      const { requestChecksumCalculation, responseChecksumValidation, requestStreamBufferSize } = input;
      return Object.assign(input, {
        requestChecksumCalculation: utilMiddleware.normalizeProvider(requestChecksumCalculation ?? DEFAULT_REQUEST_CHECKSUM_CALCULATION),
        responseChecksumValidation: utilMiddleware.normalizeProvider(responseChecksumValidation ?? DEFAULT_RESPONSE_CHECKSUM_VALIDATION),
        requestStreamBufferSize: Number(requestStreamBufferSize ?? 0)
      });
    };
    exports2.CONFIG_REQUEST_CHECKSUM_CALCULATION = CONFIG_REQUEST_CHECKSUM_CALCULATION;
    exports2.CONFIG_RESPONSE_CHECKSUM_VALIDATION = CONFIG_RESPONSE_CHECKSUM_VALIDATION;
    exports2.DEFAULT_CHECKSUM_ALGORITHM = DEFAULT_CHECKSUM_ALGORITHM;
    exports2.DEFAULT_REQUEST_CHECKSUM_CALCULATION = DEFAULT_REQUEST_CHECKSUM_CALCULATION;
    exports2.DEFAULT_RESPONSE_CHECKSUM_VALIDATION = DEFAULT_RESPONSE_CHECKSUM_VALIDATION;
    exports2.ENV_REQUEST_CHECKSUM_CALCULATION = ENV_REQUEST_CHECKSUM_CALCULATION;
    exports2.ENV_RESPONSE_CHECKSUM_VALIDATION = ENV_RESPONSE_CHECKSUM_VALIDATION;
    exports2.NODE_REQUEST_CHECKSUM_CALCULATION_CONFIG_OPTIONS = NODE_REQUEST_CHECKSUM_CALCULATION_CONFIG_OPTIONS;
    exports2.NODE_RESPONSE_CHECKSUM_VALIDATION_CONFIG_OPTIONS = NODE_RESPONSE_CHECKSUM_VALIDATION_CONFIG_OPTIONS;
    exports2.RequestChecksumCalculation = RequestChecksumCalculation;
    exports2.ResponseChecksumValidation = ResponseChecksumValidation;
    exports2.flexibleChecksumsMiddleware = flexibleChecksumsMiddleware;
    exports2.flexibleChecksumsMiddlewareOptions = flexibleChecksumsMiddlewareOptions;
    exports2.getFlexibleChecksumsPlugin = getFlexibleChecksumsPlugin;
    exports2.resolveFlexibleChecksumsConfig = resolveFlexibleChecksumsConfig;
  }
});

// node_modules/.pnpm/@aws-sdk+middleware-host-header@3.969.0/node_modules/@aws-sdk/middleware-host-header/dist-cjs/index.js
var require_dist_cjs27 = __commonJS({
  "node_modules/.pnpm/@aws-sdk+middleware-host-header@3.969.0/node_modules/@aws-sdk/middleware-host-header/dist-cjs/index.js"(exports2) {
    "use strict";
    var protocolHttp = require_dist_cjs2();
    function resolveHostHeaderConfig4(input) {
      return input;
    }
    var hostHeaderMiddleware = (options) => (next) => async (args) => {
      if (!protocolHttp.HttpRequest.isInstance(args.request))
        return next(args);
      const { request: request2 } = args;
      const { handlerProtocol = "" } = options.requestHandler.metadata || {};
      if (handlerProtocol.indexOf("h2") >= 0 && !request2.headers[":authority"]) {
        delete request2.headers["host"];
        request2.headers[":authority"] = request2.hostname + (request2.port ? ":" + request2.port : "");
      } else if (!request2.headers["host"]) {
        let host = request2.hostname;
        if (request2.port != null)
          host += `:${request2.port}`;
        request2.headers["host"] = host;
      }
      return next(args);
    };
    var hostHeaderMiddlewareOptions = {
      name: "hostHeaderMiddleware",
      step: "build",
      priority: "low",
      tags: ["HOST"],
      override: true
    };
    var getHostHeaderPlugin4 = (options) => ({
      applyToStack: (clientStack) => {
        clientStack.add(hostHeaderMiddleware(options), hostHeaderMiddlewareOptions);
      }
    });
    exports2.getHostHeaderPlugin = getHostHeaderPlugin4;
    exports2.hostHeaderMiddleware = hostHeaderMiddleware;
    exports2.hostHeaderMiddlewareOptions = hostHeaderMiddlewareOptions;
    exports2.resolveHostHeaderConfig = resolveHostHeaderConfig4;
  }
});

// node_modules/.pnpm/@aws-sdk+middleware-logger@3.969.0/node_modules/@aws-sdk/middleware-logger/dist-cjs/index.js
var require_dist_cjs28 = __commonJS({
  "node_modules/.pnpm/@aws-sdk+middleware-logger@3.969.0/node_modules/@aws-sdk/middleware-logger/dist-cjs/index.js"(exports2) {
    "use strict";
    var loggerMiddleware = () => (next, context) => async (args) => {
      try {
        const response2 = await next(args);
        const { clientName, commandName, logger: logger3, dynamoDbDocumentClientOptions = {} } = context;
        const { overrideInputFilterSensitiveLog, overrideOutputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
        const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context.inputFilterSensitiveLog;
        const outputFilterSensitiveLog = overrideOutputFilterSensitiveLog ?? context.outputFilterSensitiveLog;
        const { $metadata, ...outputWithoutMetadata } = response2.output;
        logger3?.info?.({
          clientName,
          commandName,
          input: inputFilterSensitiveLog(args.input),
          output: outputFilterSensitiveLog(outputWithoutMetadata),
          metadata: $metadata
        });
        return response2;
      } catch (error2) {
        const { clientName, commandName, logger: logger3, dynamoDbDocumentClientOptions = {} } = context;
        const { overrideInputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
        const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context.inputFilterSensitiveLog;
        logger3?.error?.({
          clientName,
          commandName,
          input: inputFilterSensitiveLog(args.input),
          error: error2,
          metadata: error2.$metadata
        });
        throw error2;
      }
    };
    var loggerMiddlewareOptions = {
      name: "loggerMiddleware",
      tags: ["LOGGER"],
      step: "initialize",
      override: true
    };
    var getLoggerPlugin4 = (options) => ({
      applyToStack: (clientStack) => {
        clientStack.add(loggerMiddleware(), loggerMiddlewareOptions);
      }
    });
    exports2.getLoggerPlugin = getLoggerPlugin4;
    exports2.loggerMiddleware = loggerMiddleware;
    exports2.loggerMiddlewareOptions = loggerMiddlewareOptions;
  }
});

// node_modules/.pnpm/@aws+lambda-invoke-store@0.2.3/node_modules/@aws/lambda-invoke-store/dist-es/invoke-store.js
var invoke_store_exports = {};
__export(invoke_store_exports, {
  InvokeStore: () => InvokeStore,
  InvokeStoreBase: () => InvokeStoreBase
});
var PROTECTED_KEYS, NO_GLOBAL_AWS_LAMBDA, InvokeStoreBase, InvokeStoreSingle, InvokeStoreMulti, InvokeStore;
var init_invoke_store = __esm({
  "node_modules/.pnpm/@aws+lambda-invoke-store@0.2.3/node_modules/@aws/lambda-invoke-store/dist-es/invoke-store.js"() {
    PROTECTED_KEYS = {
      REQUEST_ID: /* @__PURE__ */ Symbol.for("_AWS_LAMBDA_REQUEST_ID"),
      X_RAY_TRACE_ID: /* @__PURE__ */ Symbol.for("_AWS_LAMBDA_X_RAY_TRACE_ID"),
      TENANT_ID: /* @__PURE__ */ Symbol.for("_AWS_LAMBDA_TENANT_ID")
    };
    NO_GLOBAL_AWS_LAMBDA = ["true", "1"].includes(process.env?.AWS_LAMBDA_NODEJS_NO_GLOBAL_AWSLAMBDA ?? "");
    if (!NO_GLOBAL_AWS_LAMBDA) {
      globalThis.awslambda = globalThis.awslambda || {};
    }
    InvokeStoreBase = class {
      static PROTECTED_KEYS = PROTECTED_KEYS;
      isProtectedKey(key) {
        return Object.values(PROTECTED_KEYS).includes(key);
      }
      getRequestId() {
        return this.get(PROTECTED_KEYS.REQUEST_ID) ?? "-";
      }
      getXRayTraceId() {
        return this.get(PROTECTED_KEYS.X_RAY_TRACE_ID);
      }
      getTenantId() {
        return this.get(PROTECTED_KEYS.TENANT_ID);
      }
    };
    InvokeStoreSingle = class extends InvokeStoreBase {
      currentContext;
      getContext() {
        return this.currentContext;
      }
      hasContext() {
        return this.currentContext !== void 0;
      }
      get(key) {
        return this.currentContext?.[key];
      }
      set(key, value) {
        if (this.isProtectedKey(key)) {
          throw new Error(`Cannot modify protected Lambda context field: ${String(key)}`);
        }
        this.currentContext = this.currentContext || {};
        this.currentContext[key] = value;
      }
      run(context, fn) {
        this.currentContext = context;
        return fn();
      }
    };
    InvokeStoreMulti = class _InvokeStoreMulti extends InvokeStoreBase {
      als;
      static async create() {
        const instance = new _InvokeStoreMulti();
        const asyncHooks = await import("node:async_hooks");
        instance.als = new asyncHooks.AsyncLocalStorage();
        return instance;
      }
      getContext() {
        return this.als.getStore();
      }
      hasContext() {
        return this.als.getStore() !== void 0;
      }
      get(key) {
        return this.als.getStore()?.[key];
      }
      set(key, value) {
        if (this.isProtectedKey(key)) {
          throw new Error(`Cannot modify protected Lambda context field: ${String(key)}`);
        }
        const store = this.als.getStore();
        if (!store) {
          throw new Error("No context available");
        }
        store[key] = value;
      }
      run(context, fn) {
        return this.als.run(context, fn);
      }
    };
    (function(InvokeStore2) {
      let instance = null;
      async function getInstanceAsync() {
        if (!instance) {
          instance = (async () => {
            const isMulti = "AWS_LAMBDA_MAX_CONCURRENCY" in process.env;
            const newInstance = isMulti ? await InvokeStoreMulti.create() : new InvokeStoreSingle();
            if (!NO_GLOBAL_AWS_LAMBDA && globalThis.awslambda?.InvokeStore) {
              return globalThis.awslambda.InvokeStore;
            } else if (!NO_GLOBAL_AWS_LAMBDA && globalThis.awslambda) {
              globalThis.awslambda.InvokeStore = newInstance;
              return newInstance;
            } else {
              return newInstance;
            }
          })();
        }
        return instance;
      }
      InvokeStore2.getInstanceAsync = getInstanceAsync;
      InvokeStore2._testing = process.env.AWS_LAMBDA_BENCHMARK_MODE === "1" ? {
        reset: () => {
          instance = null;
          if (globalThis.awslambda?.InvokeStore) {
            delete globalThis.awslambda.InvokeStore;
          }
          globalThis.awslambda = { InvokeStore: void 0 };
        }
      } : void 0;
    })(InvokeStore || (InvokeStore = {}));
  }
});

// node_modules/.pnpm/@aws-sdk+middleware-recursion-detection@3.969.0/node_modules/@aws-sdk/middleware-recursion-detection/dist-cjs/recursionDetectionMiddleware.js
var require_recursionDetectionMiddleware = __commonJS({
  "node_modules/.pnpm/@aws-sdk+middleware-recursion-detection@3.969.0/node_modules/@aws-sdk/middleware-recursion-detection/dist-cjs/recursionDetectionMiddleware.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.recursionDetectionMiddleware = void 0;
    var lambda_invoke_store_1 = (init_invoke_store(), __toCommonJS(invoke_store_exports));
    var protocol_http_1 = require_dist_cjs2();
    var TRACE_ID_HEADER_NAME = "X-Amzn-Trace-Id";
    var ENV_LAMBDA_FUNCTION_NAME = "AWS_LAMBDA_FUNCTION_NAME";
    var ENV_TRACE_ID = "_X_AMZN_TRACE_ID";
    var recursionDetectionMiddleware = () => (next) => async (args) => {
      const { request: request2 } = args;
      if (!protocol_http_1.HttpRequest.isInstance(request2)) {
        return next(args);
      }
      const traceIdHeader = Object.keys(request2.headers ?? {}).find((h4) => h4.toLowerCase() === TRACE_ID_HEADER_NAME.toLowerCase()) ?? TRACE_ID_HEADER_NAME;
      if (request2.headers.hasOwnProperty(traceIdHeader)) {
        return next(args);
      }
      const functionName = process.env[ENV_LAMBDA_FUNCTION_NAME];
      const traceIdFromEnv = process.env[ENV_TRACE_ID];
      const invokeStore = await lambda_invoke_store_1.InvokeStore.getInstanceAsync();
      const traceIdFromInvokeStore = invokeStore?.getXRayTraceId();
      const traceId = traceIdFromInvokeStore ?? traceIdFromEnv;
      const nonEmptyString = (str) => typeof str === "string" && str.length > 0;
      if (nonEmptyString(functionName) && nonEmptyString(traceId)) {
        request2.headers[TRACE_ID_HEADER_NAME] = traceId;
      }
      return next({
        ...args,
        request: request2
      });
    };
    exports2.recursionDetectionMiddleware = recursionDetectionMiddleware;
  }
});

// node_modules/.pnpm/@aws-sdk+middleware-recursion-detection@3.969.0/node_modules/@aws-sdk/middleware-recursion-detection/dist-cjs/index.js
var require_dist_cjs29 = __commonJS({
  "node_modules/.pnpm/@aws-sdk+middleware-recursion-detection@3.969.0/node_modules/@aws-sdk/middleware-recursion-detection/dist-cjs/index.js"(exports2) {
    "use strict";
    var recursionDetectionMiddleware = require_recursionDetectionMiddleware();
    var recursionDetectionMiddlewareOptions = {
      step: "build",
      tags: ["RECURSION_DETECTION"],
      name: "recursionDetectionMiddleware",
      override: true,
      priority: "low"
    };
    var getRecursionDetectionPlugin4 = (options) => ({
      applyToStack: (clientStack) => {
        clientStack.add(recursionDetectionMiddleware.recursionDetectionMiddleware(), recursionDetectionMiddlewareOptions);
      }
    });
    exports2.getRecursionDetectionPlugin = getRecursionDetectionPlugin4;
    Object.keys(recursionDetectionMiddleware).forEach(function(k4) {
      if (k4 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, k4)) Object.defineProperty(exports2, k4, {
        enumerable: true,
        get: function() {
          return recursionDetectionMiddleware[k4];
        }
      });
    });
  }
});

// node_modules/.pnpm/@aws-sdk+util-arn-parser@3.968.0/node_modules/@aws-sdk/util-arn-parser/dist-cjs/index.js
var require_dist_cjs30 = __commonJS({
  "node_modules/.pnpm/@aws-sdk+util-arn-parser@3.968.0/node_modules/@aws-sdk/util-arn-parser/dist-cjs/index.js"(exports2) {
    "use strict";
    var validate = (str) => typeof str === "string" && str.indexOf("arn:") === 0 && str.split(":").length >= 6;
    var parse2 = (arn) => {
      const segments = arn.split(":");
      if (segments.length < 6 || segments[0] !== "arn")
        throw new Error("Malformed ARN");
      const [, partition, service, region, accountId, ...resource] = segments;
      return {
        partition,
        service,
        region,
        accountId,
        resource: resource.join(":")
      };
    };
    var build = (arnObject) => {
      const { partition = "aws", service, region, accountId, resource } = arnObject;
      if ([service, region, accountId, resource].some((segment) => typeof segment !== "string")) {
        throw new Error("Input ARN object is invalid");
      }
      return `arn:${partition}:${service}:${region}:${accountId}:${resource}`;
    };
    exports2.build = build;
    exports2.parse = parse2;
    exports2.validate = validate;
  }
});

// node_modules/.pnpm/@smithy+util-config-provider@4.2.0/node_modules/@smithy/util-config-provider/dist-cjs/index.js
var require_dist_cjs31 = __commonJS({
  "node_modules/.pnpm/@smithy+util-config-provider@4.2.0/node_modules/@smithy/util-config-provider/dist-cjs/index.js"(exports2) {
    "use strict";
    var booleanSelector = (obj, key, type) => {
      if (!(key in obj))
        return void 0;
      if (obj[key] === "true")
        return true;
      if (obj[key] === "false")
        return false;
      throw new Error(`Cannot load ${type} "${key}". Expected "true" or "false", got ${obj[key]}.`);
    };
    var numberSelector = (obj, key, type) => {
      if (!(key in obj))
        return void 0;
      const numberValue = parseInt(obj[key], 10);
      if (Number.isNaN(numberValue)) {
        throw new TypeError(`Cannot load ${type} '${key}'. Expected number, got '${obj[key]}'.`);
      }
      return numberValue;
    };
    exports2.SelectorType = void 0;
    (function(SelectorType2) {
      SelectorType2["ENV"] = "env";
      SelectorType2["CONFIG"] = "shared config entry";
    })(exports2.SelectorType || (exports2.SelectorType = {}));
    exports2.booleanSelector = booleanSelector;
    exports2.numberSelector = numberSelector;
  }
});

// node_modules/.pnpm/@aws-sdk+middleware-sdk-s3@3.970.0/node_modules/@aws-sdk/middleware-sdk-s3/dist-cjs/index.js
var require_dist_cjs32 = __commonJS({
  "node_modules/.pnpm/@aws-sdk+middleware-sdk-s3@3.970.0/node_modules/@aws-sdk/middleware-sdk-s3/dist-cjs/index.js"(exports2) {
    "use strict";
    var protocolHttp = require_dist_cjs2();
    var smithyClient = require_dist_cjs20();
    var utilStream = require_dist_cjs15();
    var utilArnParser = require_dist_cjs30();
    var signatureV4 = require_dist_cjs18();
    var utilConfigProvider = require_dist_cjs31();
    var core = (init_dist_es2(), __toCommonJS(dist_es_exports2));
    var core$1 = (init_dist_es(), __toCommonJS(dist_es_exports));
    require_dist_cjs();
    var utilMiddleware = require_dist_cjs4();
    var CONTENT_LENGTH_HEADER = "content-length";
    var DECODED_CONTENT_LENGTH_HEADER = "x-amz-decoded-content-length";
    function checkContentLengthHeader() {
      return (next, context) => async (args) => {
        const { request: request2 } = args;
        if (protocolHttp.HttpRequest.isInstance(request2)) {
          if (!(CONTENT_LENGTH_HEADER in request2.headers) && !(DECODED_CONTENT_LENGTH_HEADER in request2.headers)) {
            const message = `Are you using a Stream of unknown length as the Body of a PutObject request? Consider using Upload instead from @aws-sdk/lib-storage.`;
            if (typeof context?.logger?.warn === "function" && !(context.logger instanceof smithyClient.NoOpLogger)) {
              context.logger.warn(message);
            } else {
              console.warn(message);
            }
          }
        }
        return next({ ...args });
      };
    }
    var checkContentLengthHeaderMiddlewareOptions = {
      step: "finalizeRequest",
      tags: ["CHECK_CONTENT_LENGTH_HEADER"],
      name: "getCheckContentLengthHeaderPlugin",
      override: true
    };
    var getCheckContentLengthHeaderPlugin = (unused) => ({
      applyToStack: (clientStack) => {
        clientStack.add(checkContentLengthHeader(), checkContentLengthHeaderMiddlewareOptions);
      }
    });
    var regionRedirectEndpointMiddleware = (config) => {
      return (next, context) => async (args) => {
        const originalRegion = await config.region();
        const regionProviderRef = config.region;
        let unlock = () => {
        };
        if (context.__s3RegionRedirect) {
          Object.defineProperty(config, "region", {
            writable: false,
            value: async () => {
              return context.__s3RegionRedirect;
            }
          });
          unlock = () => Object.defineProperty(config, "region", {
            writable: true,
            value: regionProviderRef
          });
        }
        try {
          const result = await next(args);
          if (context.__s3RegionRedirect) {
            unlock();
            const region = await config.region();
            if (originalRegion !== region) {
              throw new Error("Region was not restored following S3 region redirect.");
            }
          }
          return result;
        } catch (e4) {
          unlock();
          throw e4;
        }
      };
    };
    var regionRedirectEndpointMiddlewareOptions = {
      tags: ["REGION_REDIRECT", "S3"],
      name: "regionRedirectEndpointMiddleware",
      override: true,
      relation: "before",
      toMiddleware: "endpointV2Middleware"
    };
    function regionRedirectMiddleware(clientConfig) {
      return (next, context) => async (args) => {
        try {
          return await next(args);
        } catch (err) {
          if (clientConfig.followRegionRedirects) {
            const statusCode = err?.$metadata?.httpStatusCode;
            const isHeadBucket = context.commandName === "HeadBucketCommand";
            const bucketRegionHeader = err?.$response?.headers?.["x-amz-bucket-region"];
            if (bucketRegionHeader) {
              if (statusCode === 301 || statusCode === 400 && (err?.name === "IllegalLocationConstraintException" || isHeadBucket)) {
                try {
                  const actualRegion = bucketRegionHeader;
                  context.logger?.debug(`Redirecting from ${await clientConfig.region()} to ${actualRegion}`);
                  context.__s3RegionRedirect = actualRegion;
                } catch (e4) {
                  throw new Error("Region redirect failed: " + e4);
                }
                return next(args);
              }
            }
          }
          throw err;
        }
      };
    }
    var regionRedirectMiddlewareOptions = {
      step: "initialize",
      tags: ["REGION_REDIRECT", "S3"],
      name: "regionRedirectMiddleware",
      override: true
    };
    var getRegionRedirectMiddlewarePlugin = (clientConfig) => ({
      applyToStack: (clientStack) => {
        clientStack.add(regionRedirectMiddleware(clientConfig), regionRedirectMiddlewareOptions);
        clientStack.addRelativeTo(regionRedirectEndpointMiddleware(clientConfig), regionRedirectEndpointMiddlewareOptions);
      }
    });
    var s3ExpiresMiddleware = (config) => {
      return (next, context) => async (args) => {
        const result = await next(args);
        const { response: response2 } = result;
        if (protocolHttp.HttpResponse.isInstance(response2)) {
          if (response2.headers.expires) {
            response2.headers.expiresstring = response2.headers.expires;
            try {
              smithyClient.parseRfc7231DateTime(response2.headers.expires);
            } catch (e4) {
              context.logger?.warn(`AWS SDK Warning for ${context.clientName}::${context.commandName} response parsing (${response2.headers.expires}): ${e4}`);
              delete response2.headers.expires;
            }
          }
        }
        return result;
      };
    };
    var s3ExpiresMiddlewareOptions = {
      tags: ["S3"],
      name: "s3ExpiresMiddleware",
      override: true,
      relation: "after",
      toMiddleware: "deserializerMiddleware"
    };
    var getS3ExpiresMiddlewarePlugin = (clientConfig) => ({
      applyToStack: (clientStack) => {
        clientStack.addRelativeTo(s3ExpiresMiddleware(), s3ExpiresMiddlewareOptions);
      }
    });
    var S3ExpressIdentityCache = class _S3ExpressIdentityCache {
      data;
      lastPurgeTime = Date.now();
      static EXPIRED_CREDENTIAL_PURGE_INTERVAL_MS = 3e4;
      constructor(data2 = {}) {
        this.data = data2;
      }
      get(key) {
        const entry = this.data[key];
        if (!entry) {
          return;
        }
        return entry;
      }
      set(key, entry) {
        this.data[key] = entry;
        return entry;
      }
      delete(key) {
        delete this.data[key];
      }
      async purgeExpired() {
        const now = Date.now();
        if (this.lastPurgeTime + _S3ExpressIdentityCache.EXPIRED_CREDENTIAL_PURGE_INTERVAL_MS > now) {
          return;
        }
        for (const key in this.data) {
          const entry = this.data[key];
          if (!entry.isRefreshing) {
            const credential = await entry.identity;
            if (credential.expiration) {
              if (credential.expiration.getTime() < now) {
                delete this.data[key];
              }
            }
          }
        }
      }
    };
    var S3ExpressIdentityCacheEntry = class {
      _identity;
      isRefreshing;
      accessed;
      constructor(_identity, isRefreshing = false, accessed = Date.now()) {
        this._identity = _identity;
        this.isRefreshing = isRefreshing;
        this.accessed = accessed;
      }
      get identity() {
        this.accessed = Date.now();
        return this._identity;
      }
    };
    var S3ExpressIdentityProviderImpl = class _S3ExpressIdentityProviderImpl {
      createSessionFn;
      cache;
      static REFRESH_WINDOW_MS = 6e4;
      constructor(createSessionFn, cache5 = new S3ExpressIdentityCache()) {
        this.createSessionFn = createSessionFn;
        this.cache = cache5;
      }
      async getS3ExpressIdentity(awsIdentity, identityProperties) {
        const key = identityProperties.Bucket;
        const { cache: cache5 } = this;
        const entry = cache5.get(key);
        if (entry) {
          return entry.identity.then((identity2) => {
            const isExpired = (identity2.expiration?.getTime() ?? 0) < Date.now();
            if (isExpired) {
              return cache5.set(key, new S3ExpressIdentityCacheEntry(this.getIdentity(key))).identity;
            }
            const isExpiringSoon = (identity2.expiration?.getTime() ?? 0) < Date.now() + _S3ExpressIdentityProviderImpl.REFRESH_WINDOW_MS;
            if (isExpiringSoon && !entry.isRefreshing) {
              entry.isRefreshing = true;
              this.getIdentity(key).then((id2) => {
                cache5.set(key, new S3ExpressIdentityCacheEntry(Promise.resolve(id2)));
              });
            }
            return identity2;
          });
        }
        return cache5.set(key, new S3ExpressIdentityCacheEntry(this.getIdentity(key))).identity;
      }
      async getIdentity(key) {
        await this.cache.purgeExpired().catch((error2) => {
          console.warn("Error while clearing expired entries in S3ExpressIdentityCache: \n" + error2);
        });
        const session = await this.createSessionFn(key);
        if (!session.Credentials?.AccessKeyId || !session.Credentials?.SecretAccessKey) {
          throw new Error("s3#createSession response credential missing AccessKeyId or SecretAccessKey.");
        }
        const identity2 = {
          accessKeyId: session.Credentials.AccessKeyId,
          secretAccessKey: session.Credentials.SecretAccessKey,
          sessionToken: session.Credentials.SessionToken,
          expiration: session.Credentials.Expiration ? new Date(session.Credentials.Expiration) : void 0
        };
        return identity2;
      }
    };
    var S3_EXPRESS_BUCKET_TYPE = "Directory";
    var S3_EXPRESS_BACKEND = "S3Express";
    var S3_EXPRESS_AUTH_SCHEME = "sigv4-s3express";
    var SESSION_TOKEN_QUERY_PARAM = "X-Amz-S3session-Token";
    var SESSION_TOKEN_HEADER = SESSION_TOKEN_QUERY_PARAM.toLowerCase();
    var NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_ENV_NAME = "AWS_S3_DISABLE_EXPRESS_SESSION_AUTH";
    var NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_INI_NAME = "s3_disable_express_session_auth";
    var NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_OPTIONS = {
      environmentVariableSelector: (env) => utilConfigProvider.booleanSelector(env, NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_ENV_NAME, utilConfigProvider.SelectorType.ENV),
      configFileSelector: (profile) => utilConfigProvider.booleanSelector(profile, NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_INI_NAME, utilConfigProvider.SelectorType.CONFIG),
      default: false
    };
    var SignatureV4S3Express = class extends signatureV4.SignatureV4 {
      async signWithCredentials(requestToSign, credentials, options) {
        const credentialsWithoutSessionToken = getCredentialsWithoutSessionToken(credentials);
        requestToSign.headers[SESSION_TOKEN_HEADER] = credentials.sessionToken;
        const privateAccess = this;
        setSingleOverride(privateAccess, credentialsWithoutSessionToken);
        return privateAccess.signRequest(requestToSign, options ?? {});
      }
      async presignWithCredentials(requestToSign, credentials, options) {
        const credentialsWithoutSessionToken = getCredentialsWithoutSessionToken(credentials);
        delete requestToSign.headers[SESSION_TOKEN_HEADER];
        requestToSign.headers[SESSION_TOKEN_QUERY_PARAM] = credentials.sessionToken;
        requestToSign.query = requestToSign.query ?? {};
        requestToSign.query[SESSION_TOKEN_QUERY_PARAM] = credentials.sessionToken;
        const privateAccess = this;
        setSingleOverride(privateAccess, credentialsWithoutSessionToken);
        return this.presign(requestToSign, options);
      }
    };
    function getCredentialsWithoutSessionToken(credentials) {
      const credentialsWithoutSessionToken = {
        accessKeyId: credentials.accessKeyId,
        secretAccessKey: credentials.secretAccessKey,
        expiration: credentials.expiration
      };
      return credentialsWithoutSessionToken;
    }
    function setSingleOverride(privateAccess, credentialsWithoutSessionToken) {
      const id2 = setTimeout(() => {
        throw new Error("SignatureV4S3Express credential override was created but not called.");
      }, 10);
      const currentCredentialProvider = privateAccess.credentialProvider;
      const overrideCredentialsProviderOnce = () => {
        clearTimeout(id2);
        privateAccess.credentialProvider = currentCredentialProvider;
        return Promise.resolve(credentialsWithoutSessionToken);
      };
      privateAccess.credentialProvider = overrideCredentialsProviderOnce;
    }
    var s3ExpressMiddleware = (options) => {
      return (next, context) => async (args) => {
        if (context.endpointV2) {
          const endpoint = context.endpointV2;
          const isS3ExpressAuth = endpoint.properties?.authSchemes?.[0]?.name === S3_EXPRESS_AUTH_SCHEME;
          const isS3ExpressBucket = endpoint.properties?.backend === S3_EXPRESS_BACKEND || endpoint.properties?.bucketType === S3_EXPRESS_BUCKET_TYPE;
          if (isS3ExpressBucket) {
            core.setFeature(context, "S3_EXPRESS_BUCKET", "J");
            context.isS3ExpressBucket = true;
          }
          if (isS3ExpressAuth) {
            const requestBucket = args.input.Bucket;
            if (requestBucket) {
              const s3ExpressIdentity = await options.s3ExpressIdentityProvider.getS3ExpressIdentity(await options.credentials(), {
                Bucket: requestBucket
              });
              context.s3ExpressIdentity = s3ExpressIdentity;
              if (protocolHttp.HttpRequest.isInstance(args.request) && s3ExpressIdentity.sessionToken) {
                args.request.headers[SESSION_TOKEN_HEADER] = s3ExpressIdentity.sessionToken;
              }
            }
          }
        }
        return next(args);
      };
    };
    var s3ExpressMiddlewareOptions = {
      name: "s3ExpressMiddleware",
      step: "build",
      tags: ["S3", "S3_EXPRESS"],
      override: true
    };
    var getS3ExpressPlugin = (options) => ({
      applyToStack: (clientStack) => {
        clientStack.add(s3ExpressMiddleware(options), s3ExpressMiddlewareOptions);
      }
    });
    var signS3Express = async (s3ExpressIdentity, signingOptions, request2, sigV4MultiRegionSigner) => {
      const signedRequest = await sigV4MultiRegionSigner.signWithCredentials(request2, s3ExpressIdentity, {});
      if (signedRequest.headers["X-Amz-Security-Token"] || signedRequest.headers["x-amz-security-token"]) {
        throw new Error("X-Amz-Security-Token must not be set for s3-express requests.");
      }
      return signedRequest;
    };
    var defaultErrorHandler2 = (signingProperties) => (error2) => {
      throw error2;
    };
    var defaultSuccessHandler2 = (httpResponse, signingProperties) => {
    };
    var s3ExpressHttpSigningMiddlewareOptions = core$1.httpSigningMiddlewareOptions;
    var s3ExpressHttpSigningMiddleware = (config) => (next, context) => async (args) => {
      if (!protocolHttp.HttpRequest.isInstance(args.request)) {
        return next(args);
      }
      const smithyContext = utilMiddleware.getSmithyContext(context);
      const scheme = smithyContext.selectedHttpAuthScheme;
      if (!scheme) {
        throw new Error(`No HttpAuthScheme was selected: unable to sign request`);
      }
      const { httpAuthOption: { signingProperties = {} }, identity: identity2, signer } = scheme;
      let request2;
      if (context.s3ExpressIdentity) {
        request2 = await signS3Express(context.s3ExpressIdentity, signingProperties, args.request, await config.signer());
      } else {
        request2 = await signer.sign(args.request, identity2, signingProperties);
      }
      const output = await next({
        ...args,
        request: request2
      }).catch((signer.errorHandler || defaultErrorHandler2)(signingProperties));
      (signer.successHandler || defaultSuccessHandler2)(output.response, signingProperties);
      return output;
    };
    var getS3ExpressHttpSigningPlugin = (config) => ({
      applyToStack: (clientStack) => {
        clientStack.addRelativeTo(s3ExpressHttpSigningMiddleware(config), core$1.httpSigningMiddlewareOptions);
      }
    });
    var resolveS3Config = (input, { session }) => {
      const [s3ClientProvider, CreateSessionCommandCtor] = session;
      const { forcePathStyle, useAccelerateEndpoint, disableMultiregionAccessPoints, followRegionRedirects, s3ExpressIdentityProvider, bucketEndpoint, expectContinueHeader } = input;
      return Object.assign(input, {
        forcePathStyle: forcePathStyle ?? false,
        useAccelerateEndpoint: useAccelerateEndpoint ?? false,
        disableMultiregionAccessPoints: disableMultiregionAccessPoints ?? false,
        followRegionRedirects: followRegionRedirects ?? false,
        s3ExpressIdentityProvider: s3ExpressIdentityProvider ?? new S3ExpressIdentityProviderImpl(async (key) => s3ClientProvider().send(new CreateSessionCommandCtor({
          Bucket: key
        }))),
        bucketEndpoint: bucketEndpoint ?? false,
        expectContinueHeader: expectContinueHeader ?? 2097152
      });
    };
    var THROW_IF_EMPTY_BODY = {
      CopyObjectCommand: true,
      UploadPartCopyCommand: true,
      CompleteMultipartUploadCommand: true
    };
    var MAX_BYTES_TO_INSPECT = 3e3;
    var throw200ExceptionsMiddleware = (config) => (next, context) => async (args) => {
      const result = await next(args);
      const { response: response2 } = result;
      if (!protocolHttp.HttpResponse.isInstance(response2)) {
        return result;
      }
      const { statusCode, body: sourceBody } = response2;
      if (statusCode < 200 || statusCode >= 300) {
        return result;
      }
      const isSplittableStream = typeof sourceBody?.stream === "function" || typeof sourceBody?.pipe === "function" || typeof sourceBody?.tee === "function";
      if (!isSplittableStream) {
        return result;
      }
      let bodyCopy = sourceBody;
      let body2 = sourceBody;
      if (sourceBody && typeof sourceBody === "object" && !(sourceBody instanceof Uint8Array)) {
        [bodyCopy, body2] = await utilStream.splitStream(sourceBody);
      }
      response2.body = body2;
      const bodyBytes = await collectBody3(bodyCopy, {
        streamCollector: async (stream) => {
          return utilStream.headStream(stream, MAX_BYTES_TO_INSPECT);
        }
      });
      if (typeof bodyCopy?.destroy === "function") {
        bodyCopy.destroy();
      }
      const bodyStringTail = config.utf8Encoder(bodyBytes.subarray(bodyBytes.length - 16));
      if (bodyBytes.length === 0 && THROW_IF_EMPTY_BODY[context.commandName]) {
        const err = new Error("S3 aborted request");
        err.name = "InternalError";
        throw err;
      }
      if (bodyStringTail && bodyStringTail.endsWith("</Error>")) {
        response2.statusCode = 400;
      }
      return result;
    };
    var collectBody3 = (streamBody = new Uint8Array(), context) => {
      if (streamBody instanceof Uint8Array) {
        return Promise.resolve(streamBody);
      }
      return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
    };
    var throw200ExceptionsMiddlewareOptions = {
      relation: "after",
      toMiddleware: "deserializerMiddleware",
      tags: ["THROW_200_EXCEPTIONS", "S3"],
      name: "throw200ExceptionsMiddleware",
      override: true
    };
    var getThrow200ExceptionsPlugin = (config) => ({
      applyToStack: (clientStack) => {
        clientStack.addRelativeTo(throw200ExceptionsMiddleware(config), throw200ExceptionsMiddlewareOptions);
      }
    });
    function bucketEndpointMiddleware(options) {
      return (next, context) => async (args) => {
        if (options.bucketEndpoint) {
          const endpoint = context.endpointV2;
          if (endpoint) {
            const bucket = args.input.Bucket;
            if (typeof bucket === "string") {
              try {
                const bucketEndpointUrl = new URL(bucket);
                context.endpointV2 = {
                  ...endpoint,
                  url: bucketEndpointUrl
                };
              } catch (e4) {
                const warning2 = `@aws-sdk/middleware-sdk-s3: bucketEndpoint=true was set but Bucket=${bucket} could not be parsed as URL.`;
                if (context.logger?.constructor?.name === "NoOpLogger") {
                  console.warn(warning2);
                } else {
                  context.logger?.warn?.(warning2);
                }
                throw e4;
              }
            }
          }
        }
        return next(args);
      };
    }
    var bucketEndpointMiddlewareOptions = {
      name: "bucketEndpointMiddleware",
      override: true,
      relation: "after",
      toMiddleware: "endpointV2Middleware"
    };
    function validateBucketNameMiddleware({ bucketEndpoint }) {
      return (next) => async (args) => {
        const { input: { Bucket } } = args;
        if (!bucketEndpoint && typeof Bucket === "string" && !utilArnParser.validate(Bucket) && Bucket.indexOf("/") >= 0) {
          const err = new Error(`Bucket name shouldn't contain '/', received '${Bucket}'`);
          err.name = "InvalidBucketName";
          throw err;
        }
        return next({ ...args });
      };
    }
    var validateBucketNameMiddlewareOptions = {
      step: "initialize",
      tags: ["VALIDATE_BUCKET_NAME"],
      name: "validateBucketNameMiddleware",
      override: true
    };
    var getValidateBucketNamePlugin = (options) => ({
      applyToStack: (clientStack) => {
        clientStack.add(validateBucketNameMiddleware(options), validateBucketNameMiddlewareOptions);
        clientStack.addRelativeTo(bucketEndpointMiddleware(options), bucketEndpointMiddlewareOptions);
      }
    });
    exports2.NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_OPTIONS = NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_OPTIONS;
    exports2.S3ExpressIdentityCache = S3ExpressIdentityCache;
    exports2.S3ExpressIdentityCacheEntry = S3ExpressIdentityCacheEntry;
    exports2.S3ExpressIdentityProviderImpl = S3ExpressIdentityProviderImpl;
    exports2.SignatureV4S3Express = SignatureV4S3Express;
    exports2.checkContentLengthHeader = checkContentLengthHeader;
    exports2.checkContentLengthHeaderMiddlewareOptions = checkContentLengthHeaderMiddlewareOptions;
    exports2.getCheckContentLengthHeaderPlugin = getCheckContentLengthHeaderPlugin;
    exports2.getRegionRedirectMiddlewarePlugin = getRegionRedirectMiddlewarePlugin;
    exports2.getS3ExpiresMiddlewarePlugin = getS3ExpiresMiddlewarePlugin;
    exports2.getS3ExpressHttpSigningPlugin = getS3ExpressHttpSigningPlugin;
    exports2.getS3ExpressPlugin = getS3ExpressPlugin;
    exports2.getThrow200ExceptionsPlugin = getThrow200ExceptionsPlugin;
    exports2.getValidateBucketNamePlugin = getValidateBucketNamePlugin;
    exports2.regionRedirectEndpointMiddleware = regionRedirectEndpointMiddleware;
    exports2.regionRedirectEndpointMiddlewareOptions = regionRedirectEndpointMiddlewareOptions;
    exports2.regionRedirectMiddleware = regionRedirectMiddleware;
    exports2.regionRedirectMiddlewareOptions = regionRedirectMiddlewareOptions;
    exports2.resolveS3Config = resolveS3Config;
    exports2.s3ExpiresMiddleware = s3ExpiresMiddleware;
    exports2.s3ExpiresMiddlewareOptions = s3ExpiresMiddlewareOptions;
    exports2.s3ExpressHttpSigningMiddleware = s3ExpressHttpSigningMiddleware;
    exports2.s3ExpressHttpSigningMiddlewareOptions = s3ExpressHttpSigningMiddlewareOptions;
    exports2.s3ExpressMiddleware = s3ExpressMiddleware;
    exports2.s3ExpressMiddlewareOptions = s3ExpressMiddlewareOptions;
    exports2.throw200ExceptionsMiddleware = throw200ExceptionsMiddleware;
    exports2.throw200ExceptionsMiddlewareOptions = throw200ExceptionsMiddlewareOptions;
    exports2.validateBucketNameMiddleware = validateBucketNameMiddleware;
    exports2.validateBucketNameMiddlewareOptions = validateBucketNameMiddlewareOptions;
  }
});

// node_modules/.pnpm/@smithy+util-endpoints@3.2.8/node_modules/@smithy/util-endpoints/dist-cjs/index.js
var require_dist_cjs33 = __commonJS({
  "node_modules/.pnpm/@smithy+util-endpoints@3.2.8/node_modules/@smithy/util-endpoints/dist-cjs/index.js"(exports2) {
    "use strict";
    var types = require_dist_cjs();
    var EndpointCache4 = class {
      capacity;
      data = /* @__PURE__ */ new Map();
      parameters = [];
      constructor({ size, params }) {
        this.capacity = size ?? 50;
        if (params) {
          this.parameters = params;
        }
      }
      get(endpointParams, resolver) {
        const key = this.hash(endpointParams);
        if (key === false) {
          return resolver();
        }
        if (!this.data.has(key)) {
          if (this.data.size > this.capacity + 10) {
            const keys2 = this.data.keys();
            let i4 = 0;
            while (true) {
              const { value, done } = keys2.next();
              this.data.delete(value);
              if (done || ++i4 > 10) {
                break;
              }
            }
          }
          this.data.set(key, resolver());
        }
        return this.data.get(key);
      }
      size() {
        return this.data.size;
      }
      hash(endpointParams) {
        let buffer = "";
        const { parameters } = this;
        if (parameters.length === 0) {
          return false;
        }
        for (const param of parameters) {
          const val = String(endpointParams[param] ?? "");
          if (val.includes("|;")) {
            return false;
          }
          buffer += val + "|;";
        }
        return buffer;
      }
    };
    var IP_V4_REGEX = new RegExp(`^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$`);
    var isIpAddress = (value) => IP_V4_REGEX.test(value) || value.startsWith("[") && value.endsWith("]");
    var VALID_HOST_LABEL_REGEX = new RegExp(`^(?!.*-$)(?!-)[a-zA-Z0-9-]{1,63}$`);
    var isValidHostLabel = (value, allowSubDomains = false) => {
      if (!allowSubDomains) {
        return VALID_HOST_LABEL_REGEX.test(value);
      }
      const labels = value.split(".");
      for (const label of labels) {
        if (!isValidHostLabel(label)) {
          return false;
        }
      }
      return true;
    };
    var customEndpointFunctions4 = {};
    var debugId = "endpoints";
    function toDebugString(input) {
      if (typeof input !== "object" || input == null) {
        return input;
      }
      if ("ref" in input) {
        return `$${toDebugString(input.ref)}`;
      }
      if ("fn" in input) {
        return `${input.fn}(${(input.argv || []).map(toDebugString).join(", ")})`;
      }
      return JSON.stringify(input, null, 2);
    }
    var EndpointError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "EndpointError";
      }
    };
    var booleanEquals = (value1, value2) => value1 === value2;
    var getAttrPathList = (path3) => {
      const parts = path3.split(".");
      const pathList = [];
      for (const part of parts) {
        const squareBracketIndex = part.indexOf("[");
        if (squareBracketIndex !== -1) {
          if (part.indexOf("]") !== part.length - 1) {
            throw new EndpointError(`Path: '${path3}' does not end with ']'`);
          }
          const arrayIndex = part.slice(squareBracketIndex + 1, -1);
          if (Number.isNaN(parseInt(arrayIndex))) {
            throw new EndpointError(`Invalid array index: '${arrayIndex}' in path: '${path3}'`);
          }
          if (squareBracketIndex !== 0) {
            pathList.push(part.slice(0, squareBracketIndex));
          }
          pathList.push(arrayIndex);
        } else {
          pathList.push(part);
        }
      }
      return pathList;
    };
    var getAttr = (value, path3) => getAttrPathList(path3).reduce((acc, index) => {
      if (typeof acc !== "object") {
        throw new EndpointError(`Index '${index}' in '${path3}' not found in '${JSON.stringify(value)}'`);
      } else if (Array.isArray(acc)) {
        return acc[parseInt(index)];
      }
      return acc[index];
    }, value);
    var isSet2 = (value) => value != null;
    var not = (value) => !value;
    var DEFAULT_PORTS = {
      [types.EndpointURLScheme.HTTP]: 80,
      [types.EndpointURLScheme.HTTPS]: 443
    };
    var parseURL = (value) => {
      const whatwgURL = (() => {
        try {
          if (value instanceof URL) {
            return value;
          }
          if (typeof value === "object" && "hostname" in value) {
            const { hostname: hostname2, port, protocol: protocol2 = "", path: path3 = "", query = {} } = value;
            const url = new URL(`${protocol2}//${hostname2}${port ? `:${port}` : ""}${path3}`);
            url.search = Object.entries(query).map(([k4, v4]) => `${k4}=${v4}`).join("&");
            return url;
          }
          return new URL(value);
        } catch (error2) {
          return null;
        }
      })();
      if (!whatwgURL) {
        console.error(`Unable to parse ${JSON.stringify(value)} as a whatwg URL.`);
        return null;
      }
      const urlString = whatwgURL.href;
      const { host, hostname, pathname, protocol, search } = whatwgURL;
      if (search) {
        return null;
      }
      const scheme = protocol.slice(0, -1);
      if (!Object.values(types.EndpointURLScheme).includes(scheme)) {
        return null;
      }
      const isIp = isIpAddress(hostname);
      const inputContainsDefaultPort = urlString.includes(`${host}:${DEFAULT_PORTS[scheme]}`) || typeof value === "string" && value.includes(`${host}:${DEFAULT_PORTS[scheme]}`);
      const authority = `${host}${inputContainsDefaultPort ? `:${DEFAULT_PORTS[scheme]}` : ``}`;
      return {
        scheme,
        authority,
        path: pathname,
        normalizedPath: pathname.endsWith("/") ? pathname : `${pathname}/`,
        isIp
      };
    };
    var stringEquals = (value1, value2) => value1 === value2;
    var substring = (input, start, stop, reverse) => {
      if (start >= stop || input.length < stop) {
        return null;
      }
      if (!reverse) {
        return input.substring(start, stop);
      }
      return input.substring(input.length - stop, input.length - start);
    };
    var uriEncode = (value) => encodeURIComponent(value).replace(/[!*'()]/g, (c4) => `%${c4.charCodeAt(0).toString(16).toUpperCase()}`);
    var endpointFunctions = {
      booleanEquals,
      getAttr,
      isSet: isSet2,
      isValidHostLabel,
      not,
      parseURL,
      stringEquals,
      substring,
      uriEncode
    };
    var evaluateTemplate = (template, options) => {
      const evaluatedTemplateArr = [];
      const templateContext = {
        ...options.endpointParams,
        ...options.referenceRecord
      };
      let currentIndex = 0;
      while (currentIndex < template.length) {
        const openingBraceIndex = template.indexOf("{", currentIndex);
        if (openingBraceIndex === -1) {
          evaluatedTemplateArr.push(template.slice(currentIndex));
          break;
        }
        evaluatedTemplateArr.push(template.slice(currentIndex, openingBraceIndex));
        const closingBraceIndex = template.indexOf("}", openingBraceIndex);
        if (closingBraceIndex === -1) {
          evaluatedTemplateArr.push(template.slice(openingBraceIndex));
          break;
        }
        if (template[openingBraceIndex + 1] === "{" && template[closingBraceIndex + 1] === "}") {
          evaluatedTemplateArr.push(template.slice(openingBraceIndex + 1, closingBraceIndex));
          currentIndex = closingBraceIndex + 2;
        }
        const parameterName = template.substring(openingBraceIndex + 1, closingBraceIndex);
        if (parameterName.includes("#")) {
          const [refName, attrName] = parameterName.split("#");
          evaluatedTemplateArr.push(getAttr(templateContext[refName], attrName));
        } else {
          evaluatedTemplateArr.push(templateContext[parameterName]);
        }
        currentIndex = closingBraceIndex + 1;
      }
      return evaluatedTemplateArr.join("");
    };
    var getReferenceValue = ({ ref }, options) => {
      const referenceRecord = {
        ...options.endpointParams,
        ...options.referenceRecord
      };
      return referenceRecord[ref];
    };
    var evaluateExpression = (obj, keyName, options) => {
      if (typeof obj === "string") {
        return evaluateTemplate(obj, options);
      } else if (obj["fn"]) {
        return group$2.callFunction(obj, options);
      } else if (obj["ref"]) {
        return getReferenceValue(obj, options);
      }
      throw new EndpointError(`'${keyName}': ${String(obj)} is not a string, function or reference.`);
    };
    var callFunction = ({ fn, argv }, options) => {
      const evaluatedArgs = argv.map((arg) => ["boolean", "number"].includes(typeof arg) ? arg : group$2.evaluateExpression(arg, "arg", options));
      const fnSegments = fn.split(".");
      if (fnSegments[0] in customEndpointFunctions4 && fnSegments[1] != null) {
        return customEndpointFunctions4[fnSegments[0]][fnSegments[1]](...evaluatedArgs);
      }
      return endpointFunctions[fn](...evaluatedArgs);
    };
    var group$2 = {
      evaluateExpression,
      callFunction
    };
    var evaluateCondition = ({ assign, ...fnArgs }, options) => {
      if (assign && assign in options.referenceRecord) {
        throw new EndpointError(`'${assign}' is already defined in Reference Record.`);
      }
      const value = callFunction(fnArgs, options);
      options.logger?.debug?.(`${debugId} evaluateCondition: ${toDebugString(fnArgs)} = ${toDebugString(value)}`);
      return {
        result: value === "" ? true : !!value,
        ...assign != null && { toAssign: { name: assign, value } }
      };
    };
    var evaluateConditions = (conditions = [], options) => {
      const conditionsReferenceRecord = {};
      for (const condition of conditions) {
        const { result, toAssign } = evaluateCondition(condition, {
          ...options,
          referenceRecord: {
            ...options.referenceRecord,
            ...conditionsReferenceRecord
          }
        });
        if (!result) {
          return { result };
        }
        if (toAssign) {
          conditionsReferenceRecord[toAssign.name] = toAssign.value;
          options.logger?.debug?.(`${debugId} assign: ${toAssign.name} := ${toDebugString(toAssign.value)}`);
        }
      }
      return { result: true, referenceRecord: conditionsReferenceRecord };
    };
    var getEndpointHeaders = (headers2, options) => Object.entries(headers2).reduce((acc, [headerKey, headerVal]) => ({
      ...acc,
      [headerKey]: headerVal.map((headerValEntry) => {
        const processedExpr = evaluateExpression(headerValEntry, "Header value entry", options);
        if (typeof processedExpr !== "string") {
          throw new EndpointError(`Header '${headerKey}' value '${processedExpr}' is not a string`);
        }
        return processedExpr;
      })
    }), {});
    var getEndpointProperties = (properties, options) => Object.entries(properties).reduce((acc, [propertyKey, propertyVal]) => ({
      ...acc,
      [propertyKey]: group$1.getEndpointProperty(propertyVal, options)
    }), {});
    var getEndpointProperty = (property, options) => {
      if (Array.isArray(property)) {
        return property.map((propertyEntry) => getEndpointProperty(propertyEntry, options));
      }
      switch (typeof property) {
        case "string":
          return evaluateTemplate(property, options);
        case "object":
          if (property === null) {
            throw new EndpointError(`Unexpected endpoint property: ${property}`);
          }
          return group$1.getEndpointProperties(property, options);
        case "boolean":
          return property;
        default:
          throw new EndpointError(`Unexpected endpoint property type: ${typeof property}`);
      }
    };
    var group$1 = {
      getEndpointProperty,
      getEndpointProperties
    };
    var getEndpointUrl = (endpointUrl, options) => {
      const expression = evaluateExpression(endpointUrl, "Endpoint URL", options);
      if (typeof expression === "string") {
        try {
          return new URL(expression);
        } catch (error2) {
          console.error(`Failed to construct URL with ${expression}`, error2);
          throw error2;
        }
      }
      throw new EndpointError(`Endpoint URL must be a string, got ${typeof expression}`);
    };
    var evaluateEndpointRule = (endpointRule, options) => {
      const { conditions, endpoint } = endpointRule;
      const { result, referenceRecord } = evaluateConditions(conditions, options);
      if (!result) {
        return;
      }
      const endpointRuleOptions = {
        ...options,
        referenceRecord: { ...options.referenceRecord, ...referenceRecord }
      };
      const { url, properties, headers: headers2 } = endpoint;
      options.logger?.debug?.(`${debugId} Resolving endpoint from template: ${toDebugString(endpoint)}`);
      return {
        ...headers2 != void 0 && {
          headers: getEndpointHeaders(headers2, endpointRuleOptions)
        },
        ...properties != void 0 && {
          properties: getEndpointProperties(properties, endpointRuleOptions)
        },
        url: getEndpointUrl(url, endpointRuleOptions)
      };
    };
    var evaluateErrorRule = (errorRule, options) => {
      const { conditions, error: error2 } = errorRule;
      const { result, referenceRecord } = evaluateConditions(conditions, options);
      if (!result) {
        return;
      }
      throw new EndpointError(evaluateExpression(error2, "Error", {
        ...options,
        referenceRecord: { ...options.referenceRecord, ...referenceRecord }
      }));
    };
    var evaluateRules = (rules, options) => {
      for (const rule of rules) {
        if (rule.type === "endpoint") {
          const endpointOrUndefined = evaluateEndpointRule(rule, options);
          if (endpointOrUndefined) {
            return endpointOrUndefined;
          }
        } else if (rule.type === "error") {
          evaluateErrorRule(rule, options);
        } else if (rule.type === "tree") {
          const endpointOrUndefined = group.evaluateTreeRule(rule, options);
          if (endpointOrUndefined) {
            return endpointOrUndefined;
          }
        } else {
          throw new EndpointError(`Unknown endpoint rule: ${rule}`);
        }
      }
      throw new EndpointError(`Rules evaluation failed`);
    };
    var evaluateTreeRule = (treeRule, options) => {
      const { conditions, rules } = treeRule;
      const { result, referenceRecord } = evaluateConditions(conditions, options);
      if (!result) {
        return;
      }
      return group.evaluateRules(rules, {
        ...options,
        referenceRecord: { ...options.referenceRecord, ...referenceRecord }
      });
    };
    var group = {
      evaluateRules,
      evaluateTreeRule
    };
    var resolveEndpoint4 = (ruleSetObject, options) => {
      const { endpointParams, logger: logger3 } = options;
      const { parameters, rules } = ruleSetObject;
      options.logger?.debug?.(`${debugId} Initial EndpointParams: ${toDebugString(endpointParams)}`);
      const paramsWithDefault = Object.entries(parameters).filter(([, v4]) => v4.default != null).map(([k4, v4]) => [k4, v4.default]);
      if (paramsWithDefault.length > 0) {
        for (const [paramKey, paramDefaultValue] of paramsWithDefault) {
          endpointParams[paramKey] = endpointParams[paramKey] ?? paramDefaultValue;
        }
      }
      const requiredParams = Object.entries(parameters).filter(([, v4]) => v4.required).map(([k4]) => k4);
      for (const requiredParam of requiredParams) {
        if (endpointParams[requiredParam] == null) {
          throw new EndpointError(`Missing required parameter: '${requiredParam}'`);
        }
      }
      const endpoint = evaluateRules(rules, { endpointParams, logger: logger3, referenceRecord: {} });
      options.logger?.debug?.(`${debugId} Resolved endpoint: ${toDebugString(endpoint)}`);
      return endpoint;
    };
    exports2.EndpointCache = EndpointCache4;
    exports2.EndpointError = EndpointError;
    exports2.customEndpointFunctions = customEndpointFunctions4;
    exports2.isIpAddress = isIpAddress;
    exports2.isValidHostLabel = isValidHostLabel;
    exports2.resolveEndpoint = resolveEndpoint4;
  }
});

// node_modules/.pnpm/@smithy+querystring-parser@4.2.8/node_modules/@smithy/querystring-parser/dist-cjs/index.js
var require_dist_cjs34 = __commonJS({
  "node_modules/.pnpm/@smithy+querystring-parser@4.2.8/node_modules/@smithy/querystring-parser/dist-cjs/index.js"(exports2) {
    "use strict";
    function parseQueryString(querystring) {
      const query = {};
      querystring = querystring.replace(/^\?/, "");
      if (querystring) {
        for (const pair of querystring.split("&")) {
          let [key, value = null] = pair.split("=");
          key = decodeURIComponent(key);
          if (value) {
            value = decodeURIComponent(value);
          }
          if (!(key in query)) {
            query[key] = value;
          } else if (Array.isArray(query[key])) {
            query[key].push(value);
          } else {
            query[key] = [query[key], value];
          }
        }
      }
      return query;
    }
    exports2.parseQueryString = parseQueryString;
  }
});

// node_modules/.pnpm/@smithy+url-parser@4.2.8/node_modules/@smithy/url-parser/dist-cjs/index.js
var require_dist_cjs35 = __commonJS({
  "node_modules/.pnpm/@smithy+url-parser@4.2.8/node_modules/@smithy/url-parser/dist-cjs/index.js"(exports2) {
    "use strict";
    var querystringParser = require_dist_cjs34();
    var parseUrl4 = (url) => {
      if (typeof url === "string") {
        return parseUrl4(new URL(url));
      }
      const { hostname, pathname, port, protocol, search } = url;
      let query;
      if (search) {
        query = querystringParser.parseQueryString(search);
      }
      return {
        hostname,
        port: port ? parseInt(port) : void 0,
        protocol,
        path: pathname,
        query
      };
    };
    exports2.parseUrl = parseUrl4;
  }
});

// node_modules/.pnpm/@aws-sdk+util-endpoints@3.970.0/node_modules/@aws-sdk/util-endpoints/dist-cjs/index.js
var require_dist_cjs36 = __commonJS({
  "node_modules/.pnpm/@aws-sdk+util-endpoints@3.970.0/node_modules/@aws-sdk/util-endpoints/dist-cjs/index.js"(exports2) {
    "use strict";
    var utilEndpoints = require_dist_cjs33();
    var urlParser = require_dist_cjs35();
    var isVirtualHostableS3Bucket = (value, allowSubDomains = false) => {
      if (allowSubDomains) {
        for (const label of value.split(".")) {
          if (!isVirtualHostableS3Bucket(label)) {
            return false;
          }
        }
        return true;
      }
      if (!utilEndpoints.isValidHostLabel(value)) {
        return false;
      }
      if (value.length < 3 || value.length > 63) {
        return false;
      }
      if (value !== value.toLowerCase()) {
        return false;
      }
      if (utilEndpoints.isIpAddress(value)) {
        return false;
      }
      return true;
    };
    var ARN_DELIMITER = ":";
    var RESOURCE_DELIMITER = "/";
    var parseArn = (value) => {
      const segments = value.split(ARN_DELIMITER);
      if (segments.length < 6)
        return null;
      const [arn, partition2, service, region, accountId, ...resourcePath] = segments;
      if (arn !== "arn" || partition2 === "" || service === "" || resourcePath.join(ARN_DELIMITER) === "")
        return null;
      const resourceId = resourcePath.map((resource) => resource.split(RESOURCE_DELIMITER)).flat();
      return {
        partition: partition2,
        service,
        region,
        accountId,
        resourceId
      };
    };
    var partitions = [
      {
        id: "aws",
        outputs: {
          dnsSuffix: "amazonaws.com",
          dualStackDnsSuffix: "api.aws",
          implicitGlobalRegion: "us-east-1",
          name: "aws",
          supportsDualStack: true,
          supportsFIPS: true
        },
        regionRegex: "^(us|eu|ap|sa|ca|me|af|il|mx)\\-\\w+\\-\\d+$",
        regions: {
          "af-south-1": {
            description: "Africa (Cape Town)"
          },
          "ap-east-1": {
            description: "Asia Pacific (Hong Kong)"
          },
          "ap-east-2": {
            description: "Asia Pacific (Taipei)"
          },
          "ap-northeast-1": {
            description: "Asia Pacific (Tokyo)"
          },
          "ap-northeast-2": {
            description: "Asia Pacific (Seoul)"
          },
          "ap-northeast-3": {
            description: "Asia Pacific (Osaka)"
          },
          "ap-south-1": {
            description: "Asia Pacific (Mumbai)"
          },
          "ap-south-2": {
            description: "Asia Pacific (Hyderabad)"
          },
          "ap-southeast-1": {
            description: "Asia Pacific (Singapore)"
          },
          "ap-southeast-2": {
            description: "Asia Pacific (Sydney)"
          },
          "ap-southeast-3": {
            description: "Asia Pacific (Jakarta)"
          },
          "ap-southeast-4": {
            description: "Asia Pacific (Melbourne)"
          },
          "ap-southeast-5": {
            description: "Asia Pacific (Malaysia)"
          },
          "ap-southeast-6": {
            description: "Asia Pacific (New Zealand)"
          },
          "ap-southeast-7": {
            description: "Asia Pacific (Thailand)"
          },
          "aws-global": {
            description: "aws global region"
          },
          "ca-central-1": {
            description: "Canada (Central)"
          },
          "ca-west-1": {
            description: "Canada West (Calgary)"
          },
          "eu-central-1": {
            description: "Europe (Frankfurt)"
          },
          "eu-central-2": {
            description: "Europe (Zurich)"
          },
          "eu-north-1": {
            description: "Europe (Stockholm)"
          },
          "eu-south-1": {
            description: "Europe (Milan)"
          },
          "eu-south-2": {
            description: "Europe (Spain)"
          },
          "eu-west-1": {
            description: "Europe (Ireland)"
          },
          "eu-west-2": {
            description: "Europe (London)"
          },
          "eu-west-3": {
            description: "Europe (Paris)"
          },
          "il-central-1": {
            description: "Israel (Tel Aviv)"
          },
          "me-central-1": {
            description: "Middle East (UAE)"
          },
          "me-south-1": {
            description: "Middle East (Bahrain)"
          },
          "mx-central-1": {
            description: "Mexico (Central)"
          },
          "sa-east-1": {
            description: "South America (Sao Paulo)"
          },
          "us-east-1": {
            description: "US East (N. Virginia)"
          },
          "us-east-2": {
            description: "US East (Ohio)"
          },
          "us-west-1": {
            description: "US West (N. California)"
          },
          "us-west-2": {
            description: "US West (Oregon)"
          }
        }
      },
      {
        id: "aws-cn",
        outputs: {
          dnsSuffix: "amazonaws.com.cn",
          dualStackDnsSuffix: "api.amazonwebservices.com.cn",
          implicitGlobalRegion: "cn-northwest-1",
          name: "aws-cn",
          supportsDualStack: true,
          supportsFIPS: true
        },
        regionRegex: "^cn\\-\\w+\\-\\d+$",
        regions: {
          "aws-cn-global": {
            description: "aws-cn global region"
          },
          "cn-north-1": {
            description: "China (Beijing)"
          },
          "cn-northwest-1": {
            description: "China (Ningxia)"
          }
        }
      },
      {
        id: "aws-eusc",
        outputs: {
          dnsSuffix: "amazonaws.eu",
          dualStackDnsSuffix: "api.amazonwebservices.eu",
          implicitGlobalRegion: "eusc-de-east-1",
          name: "aws-eusc",
          supportsDualStack: true,
          supportsFIPS: true
        },
        regionRegex: "^eusc\\-(de)\\-\\w+\\-\\d+$",
        regions: {
          "eusc-de-east-1": {
            description: "AWS European Sovereign Cloud (Germany)"
          }
        }
      },
      {
        id: "aws-iso",
        outputs: {
          dnsSuffix: "c2s.ic.gov",
          dualStackDnsSuffix: "api.aws.ic.gov",
          implicitGlobalRegion: "us-iso-east-1",
          name: "aws-iso",
          supportsDualStack: true,
          supportsFIPS: true
        },
        regionRegex: "^us\\-iso\\-\\w+\\-\\d+$",
        regions: {
          "aws-iso-global": {
            description: "aws-iso global region"
          },
          "us-iso-east-1": {
            description: "US ISO East"
          },
          "us-iso-west-1": {
            description: "US ISO WEST"
          }
        }
      },
      {
        id: "aws-iso-b",
        outputs: {
          dnsSuffix: "sc2s.sgov.gov",
          dualStackDnsSuffix: "api.aws.scloud",
          implicitGlobalRegion: "us-isob-east-1",
          name: "aws-iso-b",
          supportsDualStack: true,
          supportsFIPS: true
        },
        regionRegex: "^us\\-isob\\-\\w+\\-\\d+$",
        regions: {
          "aws-iso-b-global": {
            description: "aws-iso-b global region"
          },
          "us-isob-east-1": {
            description: "US ISOB East (Ohio)"
          },
          "us-isob-west-1": {
            description: "US ISOB West"
          }
        }
      },
      {
        id: "aws-iso-e",
        outputs: {
          dnsSuffix: "cloud.adc-e.uk",
          dualStackDnsSuffix: "api.cloud-aws.adc-e.uk",
          implicitGlobalRegion: "eu-isoe-west-1",
          name: "aws-iso-e",
          supportsDualStack: true,
          supportsFIPS: true
        },
        regionRegex: "^eu\\-isoe\\-\\w+\\-\\d+$",
        regions: {
          "aws-iso-e-global": {
            description: "aws-iso-e global region"
          },
          "eu-isoe-west-1": {
            description: "EU ISOE West"
          }
        }
      },
      {
        id: "aws-iso-f",
        outputs: {
          dnsSuffix: "csp.hci.ic.gov",
          dualStackDnsSuffix: "api.aws.hci.ic.gov",
          implicitGlobalRegion: "us-isof-south-1",
          name: "aws-iso-f",
          supportsDualStack: true,
          supportsFIPS: true
        },
        regionRegex: "^us\\-isof\\-\\w+\\-\\d+$",
        regions: {
          "aws-iso-f-global": {
            description: "aws-iso-f global region"
          },
          "us-isof-east-1": {
            description: "US ISOF EAST"
          },
          "us-isof-south-1": {
            description: "US ISOF SOUTH"
          }
        }
      },
      {
        id: "aws-us-gov",
        outputs: {
          dnsSuffix: "amazonaws.com",
          dualStackDnsSuffix: "api.aws",
          implicitGlobalRegion: "us-gov-west-1",
          name: "aws-us-gov",
          supportsDualStack: true,
          supportsFIPS: true
        },
        regionRegex: "^us\\-gov\\-\\w+\\-\\d+$",
        regions: {
          "aws-us-gov-global": {
            description: "aws-us-gov global region"
          },
          "us-gov-east-1": {
            description: "AWS GovCloud (US-East)"
          },
          "us-gov-west-1": {
            description: "AWS GovCloud (US-West)"
          }
        }
      }
    ];
    var version = "1.1";
    var partitionsInfo = {
      partitions,
      version
    };
    var selectedPartitionsInfo = partitionsInfo;
    var selectedUserAgentPrefix = "";
    var partition = (value) => {
      const { partitions: partitions2 } = selectedPartitionsInfo;
      for (const partition2 of partitions2) {
        const { regions, outputs } = partition2;
        for (const [region, regionData] of Object.entries(regions)) {
          if (region === value) {
            return {
              ...outputs,
              ...regionData
            };
          }
        }
      }
      for (const partition2 of partitions2) {
        const { regionRegex, outputs } = partition2;
        if (new RegExp(regionRegex).test(value)) {
          return {
            ...outputs
          };
        }
      }
      const DEFAULT_PARTITION = partitions2.find((partition2) => partition2.id === "aws");
      if (!DEFAULT_PARTITION) {
        throw new Error("Provided region was not found in the partition array or regex, and default partition with id 'aws' doesn't exist.");
      }
      return {
        ...DEFAULT_PARTITION.outputs
      };
    };
    var setPartitionInfo = (partitionsInfo2, userAgentPrefix = "") => {
      selectedPartitionsInfo = partitionsInfo2;
      selectedUserAgentPrefix = userAgentPrefix;
    };
    var useDefaultPartitionInfo = () => {
      setPartitionInfo(partitionsInfo, "");
    };
    var getUserAgentPrefix = () => selectedUserAgentPrefix;
    var awsEndpointFunctions4 = {
      isVirtualHostableS3Bucket,
      parseArn,
      partition
    };
    utilEndpoints.customEndpointFunctions.aws = awsEndpointFunctions4;
    var resolveDefaultAwsRegionalEndpointsConfig = (input) => {
      if (typeof input.endpointProvider !== "function") {
        throw new Error("@aws-sdk/util-endpoint - endpointProvider and endpoint missing in config for this client.");
      }
      const { endpoint } = input;
      if (endpoint === void 0) {
        input.endpoint = async () => {
          return toEndpointV1(input.endpointProvider({
            Region: typeof input.region === "function" ? await input.region() : input.region,
            UseDualStack: typeof input.useDualstackEndpoint === "function" ? await input.useDualstackEndpoint() : input.useDualstackEndpoint,
            UseFIPS: typeof input.useFipsEndpoint === "function" ? await input.useFipsEndpoint() : input.useFipsEndpoint,
            Endpoint: void 0
          }, { logger: input.logger }));
        };
      }
      return input;
    };
    var toEndpointV1 = (endpoint) => urlParser.parseUrl(endpoint.url);
    Object.defineProperty(exports2, "EndpointError", {
      enumerable: true,
      get: function() {
        return utilEndpoints.EndpointError;
      }
    });
    Object.defineProperty(exports2, "isIpAddress", {
      enumerable: true,
      get: function() {
        return utilEndpoints.isIpAddress;
      }
    });
    Object.defineProperty(exports2, "resolveEndpoint", {
      enumerable: true,
      get: function() {
        return utilEndpoints.resolveEndpoint;
      }
    });
    exports2.awsEndpointFunctions = awsEndpointFunctions4;
    exports2.getUserAgentPrefix = getUserAgentPrefix;
    exports2.partition = partition;
    exports2.resolveDefaultAwsRegionalEndpointsConfig = resolveDefaultAwsRegionalEndpointsConfig;
    exports2.setPartitionInfo = setPartitionInfo;
    exports2.toEndpointV1 = toEndpointV1;
    exports2.useDefaultPartitionInfo = useDefaultPartitionInfo;
  }
});

// node_modules/.pnpm/@aws-sdk+middleware-user-agent@3.970.0/node_modules/@aws-sdk/middleware-user-agent/dist-cjs/index.js
var require_dist_cjs37 = __commonJS({
  "node_modules/.pnpm/@aws-sdk+middleware-user-agent@3.970.0/node_modules/@aws-sdk/middleware-user-agent/dist-cjs/index.js"(exports2) {
    "use strict";
    var core = (init_dist_es(), __toCommonJS(dist_es_exports));
    var utilEndpoints = require_dist_cjs36();
    var protocolHttp = require_dist_cjs2();
    var core$1 = (init_dist_es2(), __toCommonJS(dist_es_exports2));
    var DEFAULT_UA_APP_ID = void 0;
    function isValidUserAgentAppId(appId) {
      if (appId === void 0) {
        return true;
      }
      return typeof appId === "string" && appId.length <= 50;
    }
    function resolveUserAgentConfig4(input) {
      const normalizedAppIdProvider = core.normalizeProvider(input.userAgentAppId ?? DEFAULT_UA_APP_ID);
      const { customUserAgent } = input;
      return Object.assign(input, {
        customUserAgent: typeof customUserAgent === "string" ? [[customUserAgent]] : customUserAgent,
        userAgentAppId: async () => {
          const appId = await normalizedAppIdProvider();
          if (!isValidUserAgentAppId(appId)) {
            const logger3 = input.logger?.constructor?.name === "NoOpLogger" || !input.logger ? console : input.logger;
            if (typeof appId !== "string") {
              logger3?.warn("userAgentAppId must be a string or undefined.");
            } else if (appId.length > 50) {
              logger3?.warn("The provided userAgentAppId exceeds the maximum length of 50 characters.");
            }
          }
          return appId;
        }
      });
    }
    var ACCOUNT_ID_ENDPOINT_REGEX = /\d{12}\.ddb/;
    async function checkFeatures(context, config, args) {
      const request2 = args.request;
      if (request2?.headers?.["smithy-protocol"] === "rpc-v2-cbor") {
        core$1.setFeature(context, "PROTOCOL_RPC_V2_CBOR", "M");
      }
      if (typeof config.retryStrategy === "function") {
        const retryStrategy = await config.retryStrategy();
        if (typeof retryStrategy.acquireInitialRetryToken === "function") {
          if (retryStrategy.constructor?.name?.includes("Adaptive")) {
            core$1.setFeature(context, "RETRY_MODE_ADAPTIVE", "F");
          } else {
            core$1.setFeature(context, "RETRY_MODE_STANDARD", "E");
          }
        } else {
          core$1.setFeature(context, "RETRY_MODE_LEGACY", "D");
        }
      }
      if (typeof config.accountIdEndpointMode === "function") {
        const endpointV2 = context.endpointV2;
        if (String(endpointV2?.url?.hostname).match(ACCOUNT_ID_ENDPOINT_REGEX)) {
          core$1.setFeature(context, "ACCOUNT_ID_ENDPOINT", "O");
        }
        switch (await config.accountIdEndpointMode?.()) {
          case "disabled":
            core$1.setFeature(context, "ACCOUNT_ID_MODE_DISABLED", "Q");
            break;
          case "preferred":
            core$1.setFeature(context, "ACCOUNT_ID_MODE_PREFERRED", "P");
            break;
          case "required":
            core$1.setFeature(context, "ACCOUNT_ID_MODE_REQUIRED", "R");
            break;
        }
      }
      const identity2 = context.__smithy_context?.selectedHttpAuthScheme?.identity;
      if (identity2?.$source) {
        const credentials = identity2;
        if (credentials.accountId) {
          core$1.setFeature(context, "RESOLVED_ACCOUNT_ID", "T");
        }
        for (const [key, value] of Object.entries(credentials.$source ?? {})) {
          core$1.setFeature(context, key, value);
        }
      }
    }
    var USER_AGENT = "user-agent";
    var X_AMZ_USER_AGENT = "x-amz-user-agent";
    var SPACE = " ";
    var UA_NAME_SEPARATOR = "/";
    var UA_NAME_ESCAPE_REGEX = /[^!$%&'*+\-.^_`|~\w]/g;
    var UA_VALUE_ESCAPE_REGEX = /[^!$%&'*+\-.^_`|~\w#]/g;
    var UA_ESCAPE_CHAR = "-";
    var BYTE_LIMIT = 1024;
    function encodeFeatures(features) {
      let buffer = "";
      for (const key in features) {
        const val = features[key];
        if (buffer.length + val.length + 1 <= BYTE_LIMIT) {
          if (buffer.length) {
            buffer += "," + val;
          } else {
            buffer += val;
          }
          continue;
        }
        break;
      }
      return buffer;
    }
    var userAgentMiddleware = (options) => (next, context) => async (args) => {
      const { request: request2 } = args;
      if (!protocolHttp.HttpRequest.isInstance(request2)) {
        return next(args);
      }
      const { headers: headers2 } = request2;
      const userAgent = context?.userAgent?.map(escapeUserAgent) || [];
      const defaultUserAgent = (await options.defaultUserAgentProvider()).map(escapeUserAgent);
      await checkFeatures(context, options, args);
      const awsContext = context;
      defaultUserAgent.push(`m/${encodeFeatures(Object.assign({}, context.__smithy_context?.features, awsContext.__aws_sdk_context?.features))}`);
      const customUserAgent = options?.customUserAgent?.map(escapeUserAgent) || [];
      const appId = await options.userAgentAppId();
      if (appId) {
        defaultUserAgent.push(escapeUserAgent([`app`, `${appId}`]));
      }
      const prefix = utilEndpoints.getUserAgentPrefix();
      const sdkUserAgentValue = (prefix ? [prefix] : []).concat([...defaultUserAgent, ...userAgent, ...customUserAgent]).join(SPACE);
      const normalUAValue = [
        ...defaultUserAgent.filter((section) => section.startsWith("aws-sdk-")),
        ...customUserAgent
      ].join(SPACE);
      if (options.runtime !== "browser") {
        if (normalUAValue) {
          headers2[X_AMZ_USER_AGENT] = headers2[X_AMZ_USER_AGENT] ? `${headers2[USER_AGENT]} ${normalUAValue}` : normalUAValue;
        }
        headers2[USER_AGENT] = sdkUserAgentValue;
      } else {
        headers2[X_AMZ_USER_AGENT] = sdkUserAgentValue;
      }
      return next({
        ...args,
        request: request2
      });
    };
    var escapeUserAgent = (userAgentPair) => {
      const name = userAgentPair[0].split(UA_NAME_SEPARATOR).map((part) => part.replace(UA_NAME_ESCAPE_REGEX, UA_ESCAPE_CHAR)).join(UA_NAME_SEPARATOR);
      const version = userAgentPair[1]?.replace(UA_VALUE_ESCAPE_REGEX, UA_ESCAPE_CHAR);
      const prefixSeparatorIndex = name.indexOf(UA_NAME_SEPARATOR);
      const prefix = name.substring(0, prefixSeparatorIndex);
      let uaName = name.substring(prefixSeparatorIndex + 1);
      if (prefix === "api") {
        uaName = uaName.toLowerCase();
      }
      return [prefix, uaName, version].filter((item) => item && item.length > 0).reduce((acc, item, index) => {
        switch (index) {
          case 0:
            return item;
          case 1:
            return `${acc}/${item}`;
          default:
            return `${acc}#${item}`;
        }
      }, "");
    };
    var getUserAgentMiddlewareOptions = {
      name: "getUserAgentMiddleware",
      step: "build",
      priority: "low",
      tags: ["SET_USER_AGENT", "USER_AGENT"],
      override: true
    };
    var getUserAgentPlugin4 = (config) => ({
      applyToStack: (clientStack) => {
        clientStack.add(userAgentMiddleware(config), getUserAgentMiddlewareOptions);
      }
    });
    exports2.DEFAULT_UA_APP_ID = DEFAULT_UA_APP_ID;
    exports2.getUserAgentMiddlewareOptions = getUserAgentMiddlewareOptions;
    exports2.getUserAgentPlugin = getUserAgentPlugin4;
    exports2.resolveUserAgentConfig = resolveUserAgentConfig4;
    exports2.userAgentMiddleware = userAgentMiddleware;
  }
});

// node_modules/.pnpm/@smithy+config-resolver@4.4.6/node_modules/@smithy/config-resolver/dist-cjs/index.js
var require_dist_cjs38 = __commonJS({
  "node_modules/.pnpm/@smithy+config-resolver@4.4.6/node_modules/@smithy/config-resolver/dist-cjs/index.js"(exports2) {
    "use strict";
    var utilConfigProvider = require_dist_cjs31();
    var utilMiddleware = require_dist_cjs4();
    var utilEndpoints = require_dist_cjs33();
    var ENV_USE_DUALSTACK_ENDPOINT = "AWS_USE_DUALSTACK_ENDPOINT";
    var CONFIG_USE_DUALSTACK_ENDPOINT = "use_dualstack_endpoint";
    var DEFAULT_USE_DUALSTACK_ENDPOINT = false;
    var NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS4 = {
      environmentVariableSelector: (env) => utilConfigProvider.booleanSelector(env, ENV_USE_DUALSTACK_ENDPOINT, utilConfigProvider.SelectorType.ENV),
      configFileSelector: (profile) => utilConfigProvider.booleanSelector(profile, CONFIG_USE_DUALSTACK_ENDPOINT, utilConfigProvider.SelectorType.CONFIG),
      default: false
    };
    var ENV_USE_FIPS_ENDPOINT = "AWS_USE_FIPS_ENDPOINT";
    var CONFIG_USE_FIPS_ENDPOINT = "use_fips_endpoint";
    var DEFAULT_USE_FIPS_ENDPOINT = false;
    var NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS4 = {
      environmentVariableSelector: (env) => utilConfigProvider.booleanSelector(env, ENV_USE_FIPS_ENDPOINT, utilConfigProvider.SelectorType.ENV),
      configFileSelector: (profile) => utilConfigProvider.booleanSelector(profile, CONFIG_USE_FIPS_ENDPOINT, utilConfigProvider.SelectorType.CONFIG),
      default: false
    };
    var resolveCustomEndpointsConfig = (input) => {
      const { tls, endpoint, urlParser, useDualstackEndpoint } = input;
      return Object.assign(input, {
        tls: tls ?? true,
        endpoint: utilMiddleware.normalizeProvider(typeof endpoint === "string" ? urlParser(endpoint) : endpoint),
        isCustomEndpoint: true,
        useDualstackEndpoint: utilMiddleware.normalizeProvider(useDualstackEndpoint ?? false)
      });
    };
    var getEndpointFromRegion = async (input) => {
      const { tls = true } = input;
      const region = await input.region();
      const dnsHostRegex = new RegExp(/^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])$/);
      if (!dnsHostRegex.test(region)) {
        throw new Error("Invalid region in client config");
      }
      const useDualstackEndpoint = await input.useDualstackEndpoint();
      const useFipsEndpoint = await input.useFipsEndpoint();
      const { hostname } = await input.regionInfoProvider(region, { useDualstackEndpoint, useFipsEndpoint }) ?? {};
      if (!hostname) {
        throw new Error("Cannot resolve hostname from client config");
      }
      return input.urlParser(`${tls ? "https:" : "http:"}//${hostname}`);
    };
    var resolveEndpointsConfig = (input) => {
      const useDualstackEndpoint = utilMiddleware.normalizeProvider(input.useDualstackEndpoint ?? false);
      const { endpoint, useFipsEndpoint, urlParser, tls } = input;
      return Object.assign(input, {
        tls: tls ?? true,
        endpoint: endpoint ? utilMiddleware.normalizeProvider(typeof endpoint === "string" ? urlParser(endpoint) : endpoint) : () => getEndpointFromRegion({ ...input, useDualstackEndpoint, useFipsEndpoint }),
        isCustomEndpoint: !!endpoint,
        useDualstackEndpoint
      });
    };
    var REGION_ENV_NAME = "AWS_REGION";
    var REGION_INI_NAME = "region";
    var NODE_REGION_CONFIG_OPTIONS4 = {
      environmentVariableSelector: (env) => env[REGION_ENV_NAME],
      configFileSelector: (profile) => profile[REGION_INI_NAME],
      default: () => {
        throw new Error("Region is missing");
      }
    };
    var NODE_REGION_CONFIG_FILE_OPTIONS4 = {
      preferredFile: "credentials"
    };
    var validRegions = /* @__PURE__ */ new Set();
    var checkRegion = (region, check = utilEndpoints.isValidHostLabel) => {
      if (!validRegions.has(region) && !check(region)) {
        if (region === "*") {
          console.warn(`@smithy/config-resolver WARN - Please use the caller region instead of "*". See "sigv4a" in https://github.com/aws/aws-sdk-js-v3/blob/main/supplemental-docs/CLIENTS.md.`);
        } else {
          throw new Error(`Region not accepted: region="${region}" is not a valid hostname component.`);
        }
      } else {
        validRegions.add(region);
      }
    };
    var isFipsRegion = (region) => typeof region === "string" && (region.startsWith("fips-") || region.endsWith("-fips"));
    var getRealRegion = (region) => isFipsRegion(region) ? ["fips-aws-global", "aws-fips"].includes(region) ? "us-east-1" : region.replace(/fips-(dkr-|prod-)?|-fips/, "") : region;
    var resolveRegionConfig4 = (input) => {
      const { region, useFipsEndpoint } = input;
      if (!region) {
        throw new Error("Region is missing");
      }
      return Object.assign(input, {
        region: async () => {
          const providedRegion = typeof region === "function" ? await region() : region;
          const realRegion = getRealRegion(providedRegion);
          checkRegion(realRegion);
          return realRegion;
        },
        useFipsEndpoint: async () => {
          const providedRegion = typeof region === "string" ? region : await region();
          if (isFipsRegion(providedRegion)) {
            return true;
          }
          return typeof useFipsEndpoint !== "function" ? Promise.resolve(!!useFipsEndpoint) : useFipsEndpoint();
        }
      });
    };
    var getHostnameFromVariants = (variants = [], { useFipsEndpoint, useDualstackEndpoint }) => variants.find(({ tags }) => useFipsEndpoint === tags.includes("fips") && useDualstackEndpoint === tags.includes("dualstack"))?.hostname;
    var getResolvedHostname = (resolvedRegion, { regionHostname, partitionHostname }) => regionHostname ? regionHostname : partitionHostname ? partitionHostname.replace("{region}", resolvedRegion) : void 0;
    var getResolvedPartition = (region, { partitionHash }) => Object.keys(partitionHash || {}).find((key) => partitionHash[key].regions.includes(region)) ?? "aws";
    var getResolvedSigningRegion = (hostname, { signingRegion, regionRegex, useFipsEndpoint }) => {
      if (signingRegion) {
        return signingRegion;
      } else if (useFipsEndpoint) {
        const regionRegexJs = regionRegex.replace("\\\\", "\\").replace(/^\^/g, "\\.").replace(/\$$/g, "\\.");
        const regionRegexmatchArray = hostname.match(regionRegexJs);
        if (regionRegexmatchArray) {
          return regionRegexmatchArray[0].slice(1, -1);
        }
      }
    };
    var getRegionInfo = (region, { useFipsEndpoint = false, useDualstackEndpoint = false, signingService, regionHash, partitionHash }) => {
      const partition = getResolvedPartition(region, { partitionHash });
      const resolvedRegion = region in regionHash ? region : partitionHash[partition]?.endpoint ?? region;
      const hostnameOptions = { useFipsEndpoint, useDualstackEndpoint };
      const regionHostname = getHostnameFromVariants(regionHash[resolvedRegion]?.variants, hostnameOptions);
      const partitionHostname = getHostnameFromVariants(partitionHash[partition]?.variants, hostnameOptions);
      const hostname = getResolvedHostname(resolvedRegion, { regionHostname, partitionHostname });
      if (hostname === void 0) {
        throw new Error(`Endpoint resolution failed for: ${{ resolvedRegion, useFipsEndpoint, useDualstackEndpoint }}`);
      }
      const signingRegion = getResolvedSigningRegion(hostname, {
        signingRegion: regionHash[resolvedRegion]?.signingRegion,
        regionRegex: partitionHash[partition].regionRegex,
        useFipsEndpoint
      });
      return {
        partition,
        signingService,
        hostname,
        ...signingRegion && { signingRegion },
        ...regionHash[resolvedRegion]?.signingService && {
          signingService: regionHash[resolvedRegion].signingService
        }
      };
    };
    exports2.CONFIG_USE_DUALSTACK_ENDPOINT = CONFIG_USE_DUALSTACK_ENDPOINT;
    exports2.CONFIG_USE_FIPS_ENDPOINT = CONFIG_USE_FIPS_ENDPOINT;
    exports2.DEFAULT_USE_DUALSTACK_ENDPOINT = DEFAULT_USE_DUALSTACK_ENDPOINT;
    exports2.DEFAULT_USE_FIPS_ENDPOINT = DEFAULT_USE_FIPS_ENDPOINT;
    exports2.ENV_USE_DUALSTACK_ENDPOINT = ENV_USE_DUALSTACK_ENDPOINT;
    exports2.ENV_USE_FIPS_ENDPOINT = ENV_USE_FIPS_ENDPOINT;
    exports2.NODE_REGION_CONFIG_FILE_OPTIONS = NODE_REGION_CONFIG_FILE_OPTIONS4;
    exports2.NODE_REGION_CONFIG_OPTIONS = NODE_REGION_CONFIG_OPTIONS4;
    exports2.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS = NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS4;
    exports2.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS = NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS4;
    exports2.REGION_ENV_NAME = REGION_ENV_NAME;
    exports2.REGION_INI_NAME = REGION_INI_NAME;
    exports2.getRegionInfo = getRegionInfo;
    exports2.resolveCustomEndpointsConfig = resolveCustomEndpointsConfig;
    exports2.resolveEndpointsConfig = resolveEndpointsConfig;
    exports2.resolveRegionConfig = resolveRegionConfig4;
  }
});

// node_modules/.pnpm/@smithy+eventstream-serde-config-resolver@4.3.8/node_modules/@smithy/eventstream-serde-config-resolver/dist-cjs/index.js
var require_dist_cjs39 = __commonJS({
  "node_modules/.pnpm/@smithy+eventstream-serde-config-resolver@4.3.8/node_modules/@smithy/eventstream-serde-config-resolver/dist-cjs/index.js"(exports2) {
    "use strict";
    var resolveEventStreamSerdeConfig = (input) => Object.assign(input, {
      eventStreamMarshaller: input.eventStreamSerdeProvider(input)
    });
    exports2.resolveEventStreamSerdeConfig = resolveEventStreamSerdeConfig;
  }
});

// node_modules/.pnpm/@smithy+middleware-content-length@4.2.8/node_modules/@smithy/middleware-content-length/dist-cjs/index.js
var require_dist_cjs40 = __commonJS({
  "node_modules/.pnpm/@smithy+middleware-content-length@4.2.8/node_modules/@smithy/middleware-content-length/dist-cjs/index.js"(exports2) {
    "use strict";
    var protocolHttp = require_dist_cjs2();
    var CONTENT_LENGTH_HEADER = "content-length";
    function contentLengthMiddleware(bodyLengthChecker) {
      return (next) => async (args) => {
        const request2 = args.request;
        if (protocolHttp.HttpRequest.isInstance(request2)) {
          const { body: body2, headers: headers2 } = request2;
          if (body2 && Object.keys(headers2).map((str) => str.toLowerCase()).indexOf(CONTENT_LENGTH_HEADER) === -1) {
            try {
              const length = bodyLengthChecker(body2);
              request2.headers = {
                ...request2.headers,
                [CONTENT_LENGTH_HEADER]: String(length)
              };
            } catch (error2) {
            }
          }
        }
        return next({
          ...args,
          request: request2
        });
      };
    }
    var contentLengthMiddlewareOptions = {
      step: "build",
      tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"],
      name: "contentLengthMiddleware",
      override: true
    };
    var getContentLengthPlugin4 = (options) => ({
      applyToStack: (clientStack) => {
        clientStack.add(contentLengthMiddleware(options.bodyLengthChecker), contentLengthMiddlewareOptions);
      }
    });
    exports2.contentLengthMiddleware = contentLengthMiddleware;
    exports2.contentLengthMiddlewareOptions = contentLengthMiddlewareOptions;
    exports2.getContentLengthPlugin = getContentLengthPlugin4;
  }
});

// node_modules/.pnpm/@smithy+shared-ini-file-loader@4.4.3/node_modules/@smithy/shared-ini-file-loader/dist-cjs/getHomeDir.js
var require_getHomeDir = __commonJS({
  "node_modules/.pnpm/@smithy+shared-ini-file-loader@4.4.3/node_modules/@smithy/shared-ini-file-loader/dist-cjs/getHomeDir.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getHomeDir = void 0;
    var os_1 = require("os");
    var path_1 = require("path");
    var homeDirCache = {};
    var getHomeDirCacheKey = () => {
      if (process && process.geteuid) {
        return `${process.geteuid()}`;
      }
      return "DEFAULT";
    };
    var getHomeDir = () => {
      const { HOME, USERPROFILE, HOMEPATH, HOMEDRIVE = `C:${path_1.sep}` } = process.env;
      if (HOME)
        return HOME;
      if (USERPROFILE)
        return USERPROFILE;
      if (HOMEPATH)
        return `${HOMEDRIVE}${HOMEPATH}`;
      const homeDirCacheKey = getHomeDirCacheKey();
      if (!homeDirCache[homeDirCacheKey])
        homeDirCache[homeDirCacheKey] = (0, os_1.homedir)();
      return homeDirCache[homeDirCacheKey];
    };
    exports2.getHomeDir = getHomeDir;
  }
});

// node_modules/.pnpm/@smithy+shared-ini-file-loader@4.4.3/node_modules/@smithy/shared-ini-file-loader/dist-cjs/getSSOTokenFilepath.js
var require_getSSOTokenFilepath = __commonJS({
  "node_modules/.pnpm/@smithy+shared-ini-file-loader@4.4.3/node_modules/@smithy/shared-ini-file-loader/dist-cjs/getSSOTokenFilepath.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getSSOTokenFilepath = void 0;
    var crypto_1 = require("crypto");
    var path_1 = require("path");
    var getHomeDir_1 = require_getHomeDir();
    var getSSOTokenFilepath = (id2) => {
      const hasher = (0, crypto_1.createHash)("sha1");
      const cacheName = hasher.update(id2).digest("hex");
      return (0, path_1.join)((0, getHomeDir_1.getHomeDir)(), ".aws", "sso", "cache", `${cacheName}.json`);
    };
    exports2.getSSOTokenFilepath = getSSOTokenFilepath;
  }
});

// node_modules/.pnpm/@smithy+shared-ini-file-loader@4.4.3/node_modules/@smithy/shared-ini-file-loader/dist-cjs/getSSOTokenFromFile.js
var require_getSSOTokenFromFile = __commonJS({
  "node_modules/.pnpm/@smithy+shared-ini-file-loader@4.4.3/node_modules/@smithy/shared-ini-file-loader/dist-cjs/getSSOTokenFromFile.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getSSOTokenFromFile = exports2.tokenIntercept = void 0;
    var promises_1 = require("fs/promises");
    var getSSOTokenFilepath_1 = require_getSSOTokenFilepath();
    exports2.tokenIntercept = {};
    var getSSOTokenFromFile = async (id2) => {
      if (exports2.tokenIntercept[id2]) {
        return exports2.tokenIntercept[id2];
      }
      const ssoTokenFilepath = (0, getSSOTokenFilepath_1.getSSOTokenFilepath)(id2);
      const ssoTokenText = await (0, promises_1.readFile)(ssoTokenFilepath, "utf8");
      return JSON.parse(ssoTokenText);
    };
    exports2.getSSOTokenFromFile = getSSOTokenFromFile;
  }
});

// node_modules/.pnpm/@smithy+shared-ini-file-loader@4.4.3/node_modules/@smithy/shared-ini-file-loader/dist-cjs/readFile.js
var require_readFile = __commonJS({
  "node_modules/.pnpm/@smithy+shared-ini-file-loader@4.4.3/node_modules/@smithy/shared-ini-file-loader/dist-cjs/readFile.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.readFile = exports2.fileIntercept = exports2.filePromises = void 0;
    var promises_1 = require("node:fs/promises");
    exports2.filePromises = {};
    exports2.fileIntercept = {};
    var readFile2 = (path3, options) => {
      if (exports2.fileIntercept[path3] !== void 0) {
        return exports2.fileIntercept[path3];
      }
      if (!exports2.filePromises[path3] || options?.ignoreCache) {
        exports2.filePromises[path3] = (0, promises_1.readFile)(path3, "utf8");
      }
      return exports2.filePromises[path3];
    };
    exports2.readFile = readFile2;
  }
});

// node_modules/.pnpm/@smithy+shared-ini-file-loader@4.4.3/node_modules/@smithy/shared-ini-file-loader/dist-cjs/index.js
var require_dist_cjs41 = __commonJS({
  "node_modules/.pnpm/@smithy+shared-ini-file-loader@4.4.3/node_modules/@smithy/shared-ini-file-loader/dist-cjs/index.js"(exports2) {
    "use strict";
    var getHomeDir = require_getHomeDir();
    var getSSOTokenFilepath = require_getSSOTokenFilepath();
    var getSSOTokenFromFile = require_getSSOTokenFromFile();
    var path3 = require("path");
    var types = require_dist_cjs();
    var readFile2 = require_readFile();
    var ENV_PROFILE = "AWS_PROFILE";
    var DEFAULT_PROFILE = "default";
    var getProfileName = (init) => init.profile || process.env[ENV_PROFILE] || DEFAULT_PROFILE;
    var CONFIG_PREFIX_SEPARATOR = ".";
    var getConfigData = (data2) => Object.entries(data2).filter(([key]) => {
      const indexOfSeparator = key.indexOf(CONFIG_PREFIX_SEPARATOR);
      if (indexOfSeparator === -1) {
        return false;
      }
      return Object.values(types.IniSectionType).includes(key.substring(0, indexOfSeparator));
    }).reduce((acc, [key, value]) => {
      const indexOfSeparator = key.indexOf(CONFIG_PREFIX_SEPARATOR);
      const updatedKey = key.substring(0, indexOfSeparator) === types.IniSectionType.PROFILE ? key.substring(indexOfSeparator + 1) : key;
      acc[updatedKey] = value;
      return acc;
    }, {
      ...data2.default && { default: data2.default }
    });
    var ENV_CONFIG_PATH = "AWS_CONFIG_FILE";
    var getConfigFilepath = () => process.env[ENV_CONFIG_PATH] || path3.join(getHomeDir.getHomeDir(), ".aws", "config");
    var ENV_CREDENTIALS_PATH = "AWS_SHARED_CREDENTIALS_FILE";
    var getCredentialsFilepath = () => process.env[ENV_CREDENTIALS_PATH] || path3.join(getHomeDir.getHomeDir(), ".aws", "credentials");
    var prefixKeyRegex = /^([\w-]+)\s(["'])?([\w-@\+\.%:/]+)\2$/;
    var profileNameBlockList = ["__proto__", "profile __proto__"];
    var parseIni = (iniData) => {
      const map2 = {};
      let currentSection;
      let currentSubSection;
      for (const iniLine of iniData.split(/\r?\n/)) {
        const trimmedLine = iniLine.split(/(^|\s)[;#]/)[0].trim();
        const isSection = trimmedLine[0] === "[" && trimmedLine[trimmedLine.length - 1] === "]";
        if (isSection) {
          currentSection = void 0;
          currentSubSection = void 0;
          const sectionName = trimmedLine.substring(1, trimmedLine.length - 1);
          const matches = prefixKeyRegex.exec(sectionName);
          if (matches) {
            const [, prefix, , name] = matches;
            if (Object.values(types.IniSectionType).includes(prefix)) {
              currentSection = [prefix, name].join(CONFIG_PREFIX_SEPARATOR);
            }
          } else {
            currentSection = sectionName;
          }
          if (profileNameBlockList.includes(sectionName)) {
            throw new Error(`Found invalid profile name "${sectionName}"`);
          }
        } else if (currentSection) {
          const indexOfEqualsSign = trimmedLine.indexOf("=");
          if (![0, -1].includes(indexOfEqualsSign)) {
            const [name, value] = [
              trimmedLine.substring(0, indexOfEqualsSign).trim(),
              trimmedLine.substring(indexOfEqualsSign + 1).trim()
            ];
            if (value === "") {
              currentSubSection = name;
            } else {
              if (currentSubSection && iniLine.trimStart() === iniLine) {
                currentSubSection = void 0;
              }
              map2[currentSection] = map2[currentSection] || {};
              const key = currentSubSection ? [currentSubSection, name].join(CONFIG_PREFIX_SEPARATOR) : name;
              map2[currentSection][key] = value;
            }
          }
        }
      }
      return map2;
    };
    var swallowError$1 = () => ({});
    var loadSharedConfigFiles = async (init = {}) => {
      const { filepath = getCredentialsFilepath(), configFilepath = getConfigFilepath() } = init;
      const homeDir = getHomeDir.getHomeDir();
      const relativeHomeDirPrefix = "~/";
      let resolvedFilepath = filepath;
      if (filepath.startsWith(relativeHomeDirPrefix)) {
        resolvedFilepath = path3.join(homeDir, filepath.slice(2));
      }
      let resolvedConfigFilepath = configFilepath;
      if (configFilepath.startsWith(relativeHomeDirPrefix)) {
        resolvedConfigFilepath = path3.join(homeDir, configFilepath.slice(2));
      }
      const parsedFiles = await Promise.all([
        readFile2.readFile(resolvedConfigFilepath, {
          ignoreCache: init.ignoreCache
        }).then(parseIni).then(getConfigData).catch(swallowError$1),
        readFile2.readFile(resolvedFilepath, {
          ignoreCache: init.ignoreCache
        }).then(parseIni).catch(swallowError$1)
      ]);
      return {
        configFile: parsedFiles[0],
        credentialsFile: parsedFiles[1]
      };
    };
    var getSsoSessionData = (data2) => Object.entries(data2).filter(([key]) => key.startsWith(types.IniSectionType.SSO_SESSION + CONFIG_PREFIX_SEPARATOR)).reduce((acc, [key, value]) => ({ ...acc, [key.substring(key.indexOf(CONFIG_PREFIX_SEPARATOR) + 1)]: value }), {});
    var swallowError = () => ({});
    var loadSsoSessionData = async (init = {}) => readFile2.readFile(init.configFilepath ?? getConfigFilepath()).then(parseIni).then(getSsoSessionData).catch(swallowError);
    var mergeConfigFiles = (...files) => {
      const merged = {};
      for (const file of files) {
        for (const [key, values] of Object.entries(file)) {
          if (merged[key] !== void 0) {
            Object.assign(merged[key], values);
          } else {
            merged[key] = values;
          }
        }
      }
      return merged;
    };
    var parseKnownFiles = async (init) => {
      const parsedFiles = await loadSharedConfigFiles(init);
      return mergeConfigFiles(parsedFiles.configFile, parsedFiles.credentialsFile);
    };
    var externalDataInterceptor = {
      getFileRecord() {
        return readFile2.fileIntercept;
      },
      interceptFile(path4, contents) {
        readFile2.fileIntercept[path4] = Promise.resolve(contents);
      },
      getTokenRecord() {
        return getSSOTokenFromFile.tokenIntercept;
      },
      interceptToken(id2, contents) {
        getSSOTokenFromFile.tokenIntercept[id2] = contents;
      }
    };
    Object.defineProperty(exports2, "getSSOTokenFromFile", {
      enumerable: true,
      get: function() {
        return getSSOTokenFromFile.getSSOTokenFromFile;
      }
    });
    Object.defineProperty(exports2, "readFile", {
      enumerable: true,
      get: function() {
        return readFile2.readFile;
      }
    });
    exports2.CONFIG_PREFIX_SEPARATOR = CONFIG_PREFIX_SEPARATOR;
    exports2.DEFAULT_PROFILE = DEFAULT_PROFILE;
    exports2.ENV_PROFILE = ENV_PROFILE;
    exports2.externalDataInterceptor = externalDataInterceptor;
    exports2.getProfileName = getProfileName;
    exports2.loadSharedConfigFiles = loadSharedConfigFiles;
    exports2.loadSsoSessionData = loadSsoSessionData;
    exports2.parseKnownFiles = parseKnownFiles;
    Object.keys(getHomeDir).forEach(function(k4) {
      if (k4 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, k4)) Object.defineProperty(exports2, k4, {
        enumerable: true,
        get: function() {
          return getHomeDir[k4];
        }
      });
    });
    Object.keys(getSSOTokenFilepath).forEach(function(k4) {
      if (k4 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, k4)) Object.defineProperty(exports2, k4, {
        enumerable: true,
        get: function() {
          return getSSOTokenFilepath[k4];
        }
      });
    });
  }
});

// node_modules/.pnpm/@smithy+node-config-provider@4.3.8/node_modules/@smithy/node-config-provider/dist-cjs/index.js
var require_dist_cjs42 = __commonJS({
  "node_modules/.pnpm/@smithy+node-config-provider@4.3.8/node_modules/@smithy/node-config-provider/dist-cjs/index.js"(exports2) {
    "use strict";
    var propertyProvider = require_dist_cjs17();
    var sharedIniFileLoader = require_dist_cjs41();
    function getSelectorName(functionString) {
      try {
        const constants2 = new Set(Array.from(functionString.match(/([A-Z_]){3,}/g) ?? []));
        constants2.delete("CONFIG");
        constants2.delete("CONFIG_PREFIX_SEPARATOR");
        constants2.delete("ENV");
        return [...constants2].join(", ");
      } catch (e4) {
        return functionString;
      }
    }
    var fromEnv = (envVarSelector, options) => async () => {
      try {
        const config = envVarSelector(process.env, options);
        if (config === void 0) {
          throw new Error();
        }
        return config;
      } catch (e4) {
        throw new propertyProvider.CredentialsProviderError(e4.message || `Not found in ENV: ${getSelectorName(envVarSelector.toString())}`, { logger: options?.logger });
      }
    };
    var fromSharedConfigFiles = (configSelector, { preferredFile = "config", ...init } = {}) => async () => {
      const profile = sharedIniFileLoader.getProfileName(init);
      const { configFile, credentialsFile } = await sharedIniFileLoader.loadSharedConfigFiles(init);
      const profileFromCredentials = credentialsFile[profile] || {};
      const profileFromConfig = configFile[profile] || {};
      const mergedProfile = preferredFile === "config" ? { ...profileFromCredentials, ...profileFromConfig } : { ...profileFromConfig, ...profileFromCredentials };
      try {
        const cfgFile = preferredFile === "config" ? configFile : credentialsFile;
        const configValue = configSelector(mergedProfile, cfgFile);
        if (configValue === void 0) {
          throw new Error();
        }
        return configValue;
      } catch (e4) {
        throw new propertyProvider.CredentialsProviderError(e4.message || `Not found in config files w/ profile [${profile}]: ${getSelectorName(configSelector.toString())}`, { logger: init.logger });
      }
    };
    var isFunction2 = (func) => typeof func === "function";
    var fromStatic = (defaultValue) => isFunction2(defaultValue) ? async () => await defaultValue() : propertyProvider.fromStatic(defaultValue);
    var loadConfig = ({ environmentVariableSelector, configFileSelector, default: defaultValue }, configuration = {}) => {
      const { signingName, logger: logger3 } = configuration;
      const envOptions = { signingName, logger: logger3 };
      return propertyProvider.memoize(propertyProvider.chain(fromEnv(environmentVariableSelector, envOptions), fromSharedConfigFiles(configFileSelector, configuration), fromStatic(defaultValue)));
    };
    exports2.loadConfig = loadConfig;
  }
});

// node_modules/.pnpm/@smithy+middleware-endpoint@4.4.7/node_modules/@smithy/middleware-endpoint/dist-cjs/adaptors/getEndpointUrlConfig.js
var require_getEndpointUrlConfig = __commonJS({
  "node_modules/.pnpm/@smithy+middleware-endpoint@4.4.7/node_modules/@smithy/middleware-endpoint/dist-cjs/adaptors/getEndpointUrlConfig.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getEndpointUrlConfig = void 0;
    var shared_ini_file_loader_1 = require_dist_cjs41();
    var ENV_ENDPOINT_URL = "AWS_ENDPOINT_URL";
    var CONFIG_ENDPOINT_URL = "endpoint_url";
    var getEndpointUrlConfig = (serviceId) => ({
      environmentVariableSelector: (env) => {
        const serviceSuffixParts = serviceId.split(" ").map((w4) => w4.toUpperCase());
        const serviceEndpointUrl = env[[ENV_ENDPOINT_URL, ...serviceSuffixParts].join("_")];
        if (serviceEndpointUrl)
          return serviceEndpointUrl;
        const endpointUrl = env[ENV_ENDPOINT_URL];
        if (endpointUrl)
          return endpointUrl;
        return void 0;
      },
      configFileSelector: (profile, config) => {
        if (config && profile.services) {
          const servicesSection = config[["services", profile.services].join(shared_ini_file_loader_1.CONFIG_PREFIX_SEPARATOR)];
          if (servicesSection) {
            const servicePrefixParts = serviceId.split(" ").map((w4) => w4.toLowerCase());
            const endpointUrl2 = servicesSection[[servicePrefixParts.join("_"), CONFIG_ENDPOINT_URL].join(shared_ini_file_loader_1.CONFIG_PREFIX_SEPARATOR)];
            if (endpointUrl2)
              return endpointUrl2;
          }
        }
        const endpointUrl = profile[CONFIG_ENDPOINT_URL];
        if (endpointUrl)
          return endpointUrl;
        return void 0;
      },
      default: void 0
    });
    exports2.getEndpointUrlConfig = getEndpointUrlConfig;
  }
});

// node_modules/.pnpm/@smithy+middleware-endpoint@4.4.7/node_modules/@smithy/middleware-endpoint/dist-cjs/adaptors/getEndpointFromConfig.js
var require_getEndpointFromConfig = __commonJS({
  "node_modules/.pnpm/@smithy+middleware-endpoint@4.4.7/node_modules/@smithy/middleware-endpoint/dist-cjs/adaptors/getEndpointFromConfig.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getEndpointFromConfig = void 0;
    var node_config_provider_1 = require_dist_cjs42();
    var getEndpointUrlConfig_1 = require_getEndpointUrlConfig();
    var getEndpointFromConfig = async (serviceId) => (0, node_config_provider_1.loadConfig)((0, getEndpointUrlConfig_1.getEndpointUrlConfig)(serviceId ?? ""))();
    exports2.getEndpointFromConfig = getEndpointFromConfig;
  }
});

// node_modules/.pnpm/@smithy+middleware-endpoint@4.4.7/node_modules/@smithy/middleware-endpoint/dist-cjs/index.js
var require_dist_cjs43 = __commonJS({
  "node_modules/.pnpm/@smithy+middleware-endpoint@4.4.7/node_modules/@smithy/middleware-endpoint/dist-cjs/index.js"(exports2) {
    "use strict";
    var getEndpointFromConfig = require_getEndpointFromConfig();
    var urlParser = require_dist_cjs35();
    var core = (init_dist_es(), __toCommonJS(dist_es_exports));
    var utilMiddleware = require_dist_cjs4();
    var middlewareSerde = require_dist_cjs5();
    var resolveParamsForS3 = async (endpointParams) => {
      const bucket = endpointParams?.Bucket || "";
      if (typeof endpointParams.Bucket === "string") {
        endpointParams.Bucket = bucket.replace(/#/g, encodeURIComponent("#")).replace(/\?/g, encodeURIComponent("?"));
      }
      if (isArnBucketName(bucket)) {
        if (endpointParams.ForcePathStyle === true) {
          throw new Error("Path-style addressing cannot be used with ARN buckets");
        }
      } else if (!isDnsCompatibleBucketName(bucket) || bucket.indexOf(".") !== -1 && !String(endpointParams.Endpoint).startsWith("http:") || bucket.toLowerCase() !== bucket || bucket.length < 3) {
        endpointParams.ForcePathStyle = true;
      }
      if (endpointParams.DisableMultiRegionAccessPoints) {
        endpointParams.disableMultiRegionAccessPoints = true;
        endpointParams.DisableMRAP = true;
      }
      return endpointParams;
    };
    var DOMAIN_PATTERN = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/;
    var IP_ADDRESS_PATTERN = /(\d+\.){3}\d+/;
    var DOTS_PATTERN = /\.\./;
    var isDnsCompatibleBucketName = (bucketName) => DOMAIN_PATTERN.test(bucketName) && !IP_ADDRESS_PATTERN.test(bucketName) && !DOTS_PATTERN.test(bucketName);
    var isArnBucketName = (bucketName) => {
      const [arn, partition, service, , , bucket] = bucketName.split(":");
      const isArn = arn === "arn" && bucketName.split(":").length >= 6;
      const isValidArn = Boolean(isArn && partition && service && bucket);
      if (isArn && !isValidArn) {
        throw new Error(`Invalid ARN: ${bucketName} was an invalid ARN.`);
      }
      return isValidArn;
    };
    var createConfigValueProvider = (configKey, canonicalEndpointParamKey, config, isClientContextParam = false) => {
      const configProvider = async () => {
        let configValue;
        if (isClientContextParam) {
          const clientContextParams = config.clientContextParams;
          const nestedValue = clientContextParams?.[configKey];
          configValue = nestedValue ?? config[configKey] ?? config[canonicalEndpointParamKey];
        } else {
          configValue = config[configKey] ?? config[canonicalEndpointParamKey];
        }
        if (typeof configValue === "function") {
          return configValue();
        }
        return configValue;
      };
      if (configKey === "credentialScope" || canonicalEndpointParamKey === "CredentialScope") {
        return async () => {
          const credentials = typeof config.credentials === "function" ? await config.credentials() : config.credentials;
          const configValue = credentials?.credentialScope ?? credentials?.CredentialScope;
          return configValue;
        };
      }
      if (configKey === "accountId" || canonicalEndpointParamKey === "AccountId") {
        return async () => {
          const credentials = typeof config.credentials === "function" ? await config.credentials() : config.credentials;
          const configValue = credentials?.accountId ?? credentials?.AccountId;
          return configValue;
        };
      }
      if (configKey === "endpoint" || canonicalEndpointParamKey === "endpoint") {
        return async () => {
          if (config.isCustomEndpoint === false) {
            return void 0;
          }
          const endpoint = await configProvider();
          if (endpoint && typeof endpoint === "object") {
            if ("url" in endpoint) {
              return endpoint.url.href;
            }
            if ("hostname" in endpoint) {
              const { protocol, hostname, port, path: path3 } = endpoint;
              return `${protocol}//${hostname}${port ? ":" + port : ""}${path3}`;
            }
          }
          return endpoint;
        };
      }
      return configProvider;
    };
    var toEndpointV1 = (endpoint) => {
      if (typeof endpoint === "object") {
        if ("url" in endpoint) {
          return urlParser.parseUrl(endpoint.url);
        }
        return endpoint;
      }
      return urlParser.parseUrl(endpoint);
    };
    var getEndpointFromInstructions = async (commandInput, instructionsSupplier, clientConfig, context) => {
      if (!clientConfig.isCustomEndpoint) {
        let endpointFromConfig;
        if (clientConfig.serviceConfiguredEndpoint) {
          endpointFromConfig = await clientConfig.serviceConfiguredEndpoint();
        } else {
          endpointFromConfig = await getEndpointFromConfig.getEndpointFromConfig(clientConfig.serviceId);
        }
        if (endpointFromConfig) {
          clientConfig.endpoint = () => Promise.resolve(toEndpointV1(endpointFromConfig));
          clientConfig.isCustomEndpoint = true;
        }
      }
      const endpointParams = await resolveParams(commandInput, instructionsSupplier, clientConfig);
      if (typeof clientConfig.endpointProvider !== "function") {
        throw new Error("config.endpointProvider is not set.");
      }
      const endpoint = clientConfig.endpointProvider(endpointParams, context);
      return endpoint;
    };
    var resolveParams = async (commandInput, instructionsSupplier, clientConfig) => {
      const endpointParams = {};
      const instructions = instructionsSupplier?.getEndpointParameterInstructions?.() || {};
      for (const [name, instruction] of Object.entries(instructions)) {
        switch (instruction.type) {
          case "staticContextParams":
            endpointParams[name] = instruction.value;
            break;
          case "contextParams":
            endpointParams[name] = commandInput[instruction.name];
            break;
          case "clientContextParams":
          case "builtInParams":
            endpointParams[name] = await createConfigValueProvider(instruction.name, name, clientConfig, instruction.type !== "builtInParams")();
            break;
          case "operationContextParams":
            endpointParams[name] = instruction.get(commandInput);
            break;
          default:
            throw new Error("Unrecognized endpoint parameter instruction: " + JSON.stringify(instruction));
        }
      }
      if (Object.keys(instructions).length === 0) {
        Object.assign(endpointParams, clientConfig);
      }
      if (String(clientConfig.serviceId).toLowerCase() === "s3") {
        await resolveParamsForS3(endpointParams);
      }
      return endpointParams;
    };
    var endpointMiddleware = ({ config, instructions }) => {
      return (next, context) => async (args) => {
        if (config.isCustomEndpoint) {
          core.setFeature(context, "ENDPOINT_OVERRIDE", "N");
        }
        const endpoint = await getEndpointFromInstructions(args.input, {
          getEndpointParameterInstructions() {
            return instructions;
          }
        }, { ...config }, context);
        context.endpointV2 = endpoint;
        context.authSchemes = endpoint.properties?.authSchemes;
        const authScheme = context.authSchemes?.[0];
        if (authScheme) {
          context["signing_region"] = authScheme.signingRegion;
          context["signing_service"] = authScheme.signingName;
          const smithyContext = utilMiddleware.getSmithyContext(context);
          const httpAuthOption = smithyContext?.selectedHttpAuthScheme?.httpAuthOption;
          if (httpAuthOption) {
            httpAuthOption.signingProperties = Object.assign(httpAuthOption.signingProperties || {}, {
              signing_region: authScheme.signingRegion,
              signingRegion: authScheme.signingRegion,
              signing_service: authScheme.signingName,
              signingName: authScheme.signingName,
              signingRegionSet: authScheme.signingRegionSet
            }, authScheme.properties);
          }
        }
        return next({
          ...args
        });
      };
    };
    var endpointMiddlewareOptions = {
      step: "serialize",
      tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"],
      name: "endpointV2Middleware",
      override: true,
      relation: "before",
      toMiddleware: middlewareSerde.serializerMiddlewareOption.name
    };
    var getEndpointPlugin5 = (config, instructions) => ({
      applyToStack: (clientStack) => {
        clientStack.addRelativeTo(endpointMiddleware({
          config,
          instructions
        }), endpointMiddlewareOptions);
      }
    });
    var resolveEndpointConfig4 = (input) => {
      const tls = input.tls ?? true;
      const { endpoint, useDualstackEndpoint, useFipsEndpoint } = input;
      const customEndpointProvider = endpoint != null ? async () => toEndpointV1(await utilMiddleware.normalizeProvider(endpoint)()) : void 0;
      const isCustomEndpoint = !!endpoint;
      const resolvedConfig = Object.assign(input, {
        endpoint: customEndpointProvider,
        tls,
        isCustomEndpoint,
        useDualstackEndpoint: utilMiddleware.normalizeProvider(useDualstackEndpoint ?? false),
        useFipsEndpoint: utilMiddleware.normalizeProvider(useFipsEndpoint ?? false)
      });
      let configuredEndpointPromise = void 0;
      resolvedConfig.serviceConfiguredEndpoint = async () => {
        if (input.serviceId && !configuredEndpointPromise) {
          configuredEndpointPromise = getEndpointFromConfig.getEndpointFromConfig(input.serviceId);
        }
        return configuredEndpointPromise;
      };
      return resolvedConfig;
    };
    var resolveEndpointRequiredConfig = (input) => {
      const { endpoint } = input;
      if (endpoint === void 0) {
        input.endpoint = async () => {
          throw new Error("@smithy/middleware-endpoint: (default endpointRuleSet) endpoint is not set - you must configure an endpoint.");
        };
      }
      return input;
    };
    exports2.endpointMiddleware = endpointMiddleware;
    exports2.endpointMiddlewareOptions = endpointMiddlewareOptions;
    exports2.getEndpointFromInstructions = getEndpointFromInstructions;
    exports2.getEndpointPlugin = getEndpointPlugin5;
    exports2.resolveEndpointConfig = resolveEndpointConfig4;
    exports2.resolveEndpointRequiredConfig = resolveEndpointRequiredConfig;
    exports2.resolveParams = resolveParams;
    exports2.toEndpointV1 = toEndpointV1;
  }
});

// node_modules/.pnpm/@smithy+service-error-classification@4.2.8/node_modules/@smithy/service-error-classification/dist-cjs/index.js
var require_dist_cjs44 = __commonJS({
  "node_modules/.pnpm/@smithy+service-error-classification@4.2.8/node_modules/@smithy/service-error-classification/dist-cjs/index.js"(exports2) {
    "use strict";
    var CLOCK_SKEW_ERROR_CODES = [
      "AuthFailure",
      "InvalidSignatureException",
      "RequestExpired",
      "RequestInTheFuture",
      "RequestTimeTooSkewed",
      "SignatureDoesNotMatch"
    ];
    var THROTTLING_ERROR_CODES = [
      "BandwidthLimitExceeded",
      "EC2ThrottledException",
      "LimitExceededException",
      "PriorRequestNotComplete",
      "ProvisionedThroughputExceededException",
      "RequestLimitExceeded",
      "RequestThrottled",
      "RequestThrottledException",
      "SlowDown",
      "ThrottledException",
      "Throttling",
      "ThrottlingException",
      "TooManyRequestsException",
      "TransactionInProgressException"
    ];
    var TRANSIENT_ERROR_CODES = ["TimeoutError", "RequestTimeout", "RequestTimeoutException"];
    var TRANSIENT_ERROR_STATUS_CODES = [500, 502, 503, 504];
    var NODEJS_TIMEOUT_ERROR_CODES = ["ECONNRESET", "ECONNREFUSED", "EPIPE", "ETIMEDOUT"];
    var NODEJS_NETWORK_ERROR_CODES = ["EHOSTUNREACH", "ENETUNREACH", "ENOTFOUND"];
    var isRetryableByTrait = (error2) => error2?.$retryable !== void 0;
    var isClockSkewError = (error2) => CLOCK_SKEW_ERROR_CODES.includes(error2.name);
    var isClockSkewCorrectedError = (error2) => error2.$metadata?.clockSkewCorrected;
    var isBrowserNetworkError = (error2) => {
      const errorMessages = /* @__PURE__ */ new Set([
        "Failed to fetch",
        "NetworkError when attempting to fetch resource",
        "The Internet connection appears to be offline",
        "Load failed",
        "Network request failed"
      ]);
      const isValid = error2 && error2 instanceof TypeError;
      if (!isValid) {
        return false;
      }
      return errorMessages.has(error2.message);
    };
    var isThrottlingError = (error2) => error2.$metadata?.httpStatusCode === 429 || THROTTLING_ERROR_CODES.includes(error2.name) || error2.$retryable?.throttling == true;
    var isTransientError = (error2, depth = 0) => isRetryableByTrait(error2) || isClockSkewCorrectedError(error2) || TRANSIENT_ERROR_CODES.includes(error2.name) || NODEJS_TIMEOUT_ERROR_CODES.includes(error2?.code || "") || NODEJS_NETWORK_ERROR_CODES.includes(error2?.code || "") || TRANSIENT_ERROR_STATUS_CODES.includes(error2.$metadata?.httpStatusCode || 0) || isBrowserNetworkError(error2) || error2.cause !== void 0 && depth <= 10 && isTransientError(error2.cause, depth + 1);
    var isServerError = (error2) => {
      if (error2.$metadata?.httpStatusCode !== void 0) {
        const statusCode = error2.$metadata.httpStatusCode;
        if (500 <= statusCode && statusCode <= 599 && !isTransientError(error2)) {
          return true;
        }
        return false;
      }
      return false;
    };
    exports2.isBrowserNetworkError = isBrowserNetworkError;
    exports2.isClockSkewCorrectedError = isClockSkewCorrectedError;
    exports2.isClockSkewError = isClockSkewError;
    exports2.isRetryableByTrait = isRetryableByTrait;
    exports2.isServerError = isServerError;
    exports2.isThrottlingError = isThrottlingError;
    exports2.isTransientError = isTransientError;
  }
});

// node_modules/.pnpm/@smithy+util-retry@4.2.8/node_modules/@smithy/util-retry/dist-cjs/index.js
var require_dist_cjs45 = __commonJS({
  "node_modules/.pnpm/@smithy+util-retry@4.2.8/node_modules/@smithy/util-retry/dist-cjs/index.js"(exports2) {
    "use strict";
    var serviceErrorClassification = require_dist_cjs44();
    exports2.RETRY_MODES = void 0;
    (function(RETRY_MODES) {
      RETRY_MODES["STANDARD"] = "standard";
      RETRY_MODES["ADAPTIVE"] = "adaptive";
    })(exports2.RETRY_MODES || (exports2.RETRY_MODES = {}));
    var DEFAULT_MAX_ATTEMPTS = 3;
    var DEFAULT_RETRY_MODE4 = exports2.RETRY_MODES.STANDARD;
    var DefaultRateLimiter = class _DefaultRateLimiter {
      static setTimeoutFn = setTimeout;
      beta;
      minCapacity;
      minFillRate;
      scaleConstant;
      smooth;
      currentCapacity = 0;
      enabled = false;
      lastMaxRate = 0;
      measuredTxRate = 0;
      requestCount = 0;
      fillRate;
      lastThrottleTime;
      lastTimestamp = 0;
      lastTxRateBucket;
      maxCapacity;
      timeWindow = 0;
      constructor(options) {
        this.beta = options?.beta ?? 0.7;
        this.minCapacity = options?.minCapacity ?? 1;
        this.minFillRate = options?.minFillRate ?? 0.5;
        this.scaleConstant = options?.scaleConstant ?? 0.4;
        this.smooth = options?.smooth ?? 0.8;
        const currentTimeInSeconds = this.getCurrentTimeInSeconds();
        this.lastThrottleTime = currentTimeInSeconds;
        this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds());
        this.fillRate = this.minFillRate;
        this.maxCapacity = this.minCapacity;
      }
      getCurrentTimeInSeconds() {
        return Date.now() / 1e3;
      }
      async getSendToken() {
        return this.acquireTokenBucket(1);
      }
      async acquireTokenBucket(amount) {
        if (!this.enabled) {
          return;
        }
        this.refillTokenBucket();
        if (amount > this.currentCapacity) {
          const delay = (amount - this.currentCapacity) / this.fillRate * 1e3;
          await new Promise((resolve) => _DefaultRateLimiter.setTimeoutFn(resolve, delay));
        }
        this.currentCapacity = this.currentCapacity - amount;
      }
      refillTokenBucket() {
        const timestamp = this.getCurrentTimeInSeconds();
        if (!this.lastTimestamp) {
          this.lastTimestamp = timestamp;
          return;
        }
        const fillAmount = (timestamp - this.lastTimestamp) * this.fillRate;
        this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + fillAmount);
        this.lastTimestamp = timestamp;
      }
      updateClientSendingRate(response2) {
        let calculatedRate;
        this.updateMeasuredRate();
        if (serviceErrorClassification.isThrottlingError(response2)) {
          const rateToUse = !this.enabled ? this.measuredTxRate : Math.min(this.measuredTxRate, this.fillRate);
          this.lastMaxRate = rateToUse;
          this.calculateTimeWindow();
          this.lastThrottleTime = this.getCurrentTimeInSeconds();
          calculatedRate = this.cubicThrottle(rateToUse);
          this.enableTokenBucket();
        } else {
          this.calculateTimeWindow();
          calculatedRate = this.cubicSuccess(this.getCurrentTimeInSeconds());
        }
        const newRate = Math.min(calculatedRate, 2 * this.measuredTxRate);
        this.updateTokenBucketRate(newRate);
      }
      calculateTimeWindow() {
        this.timeWindow = this.getPrecise(Math.pow(this.lastMaxRate * (1 - this.beta) / this.scaleConstant, 1 / 3));
      }
      cubicThrottle(rateToUse) {
        return this.getPrecise(rateToUse * this.beta);
      }
      cubicSuccess(timestamp) {
        return this.getPrecise(this.scaleConstant * Math.pow(timestamp - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate);
      }
      enableTokenBucket() {
        this.enabled = true;
      }
      updateTokenBucketRate(newRate) {
        this.refillTokenBucket();
        this.fillRate = Math.max(newRate, this.minFillRate);
        this.maxCapacity = Math.max(newRate, this.minCapacity);
        this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);
      }
      updateMeasuredRate() {
        const t4 = this.getCurrentTimeInSeconds();
        const timeBucket = Math.floor(t4 * 2) / 2;
        this.requestCount++;
        if (timeBucket > this.lastTxRateBucket) {
          const currentRate = this.requestCount / (timeBucket - this.lastTxRateBucket);
          this.measuredTxRate = this.getPrecise(currentRate * this.smooth + this.measuredTxRate * (1 - this.smooth));
          this.requestCount = 0;
          this.lastTxRateBucket = timeBucket;
        }
      }
      getPrecise(num) {
        return parseFloat(num.toFixed(8));
      }
    };
    var DEFAULT_RETRY_DELAY_BASE = 100;
    var MAXIMUM_RETRY_DELAY = 20 * 1e3;
    var THROTTLING_RETRY_DELAY_BASE = 500;
    var INITIAL_RETRY_TOKENS = 500;
    var RETRY_COST = 5;
    var TIMEOUT_RETRY_COST = 10;
    var NO_RETRY_INCREMENT = 1;
    var INVOCATION_ID_HEADER = "amz-sdk-invocation-id";
    var REQUEST_HEADER = "amz-sdk-request";
    var getDefaultRetryBackoffStrategy = () => {
      let delayBase = DEFAULT_RETRY_DELAY_BASE;
      const computeNextBackoffDelay = (attempts) => {
        return Math.floor(Math.min(MAXIMUM_RETRY_DELAY, Math.random() * 2 ** attempts * delayBase));
      };
      const setDelayBase = (delay) => {
        delayBase = delay;
      };
      return {
        computeNextBackoffDelay,
        setDelayBase
      };
    };
    var createDefaultRetryToken = ({ retryDelay, retryCount, retryCost }) => {
      const getRetryCount = () => retryCount;
      const getRetryDelay = () => Math.min(MAXIMUM_RETRY_DELAY, retryDelay);
      const getRetryCost = () => retryCost;
      return {
        getRetryCount,
        getRetryDelay,
        getRetryCost
      };
    };
    var StandardRetryStrategy = class {
      maxAttempts;
      mode = exports2.RETRY_MODES.STANDARD;
      capacity = INITIAL_RETRY_TOKENS;
      retryBackoffStrategy = getDefaultRetryBackoffStrategy();
      maxAttemptsProvider;
      constructor(maxAttempts) {
        this.maxAttempts = maxAttempts;
        this.maxAttemptsProvider = typeof maxAttempts === "function" ? maxAttempts : async () => maxAttempts;
      }
      async acquireInitialRetryToken(retryTokenScope) {
        return createDefaultRetryToken({
          retryDelay: DEFAULT_RETRY_DELAY_BASE,
          retryCount: 0
        });
      }
      async refreshRetryTokenForRetry(token, errorInfo) {
        const maxAttempts = await this.getMaxAttempts();
        if (this.shouldRetry(token, errorInfo, maxAttempts)) {
          const errorType = errorInfo.errorType;
          this.retryBackoffStrategy.setDelayBase(errorType === "THROTTLING" ? THROTTLING_RETRY_DELAY_BASE : DEFAULT_RETRY_DELAY_BASE);
          const delayFromErrorType = this.retryBackoffStrategy.computeNextBackoffDelay(token.getRetryCount());
          const retryDelay = errorInfo.retryAfterHint ? Math.max(errorInfo.retryAfterHint.getTime() - Date.now() || 0, delayFromErrorType) : delayFromErrorType;
          const capacityCost = this.getCapacityCost(errorType);
          this.capacity -= capacityCost;
          return createDefaultRetryToken({
            retryDelay,
            retryCount: token.getRetryCount() + 1,
            retryCost: capacityCost
          });
        }
        throw new Error("No retry token available");
      }
      recordSuccess(token) {
        this.capacity = Math.max(INITIAL_RETRY_TOKENS, this.capacity + (token.getRetryCost() ?? NO_RETRY_INCREMENT));
      }
      getCapacity() {
        return this.capacity;
      }
      async getMaxAttempts() {
        try {
          return await this.maxAttemptsProvider();
        } catch (error2) {
          console.warn(`Max attempts provider could not resolve. Using default of ${DEFAULT_MAX_ATTEMPTS}`);
          return DEFAULT_MAX_ATTEMPTS;
        }
      }
      shouldRetry(tokenToRenew, errorInfo, maxAttempts) {
        const attempts = tokenToRenew.getRetryCount() + 1;
        return attempts < maxAttempts && this.capacity >= this.getCapacityCost(errorInfo.errorType) && this.isRetryableError(errorInfo.errorType);
      }
      getCapacityCost(errorType) {
        return errorType === "TRANSIENT" ? TIMEOUT_RETRY_COST : RETRY_COST;
      }
      isRetryableError(errorType) {
        return errorType === "THROTTLING" || errorType === "TRANSIENT";
      }
    };
    var AdaptiveRetryStrategy = class {
      maxAttemptsProvider;
      rateLimiter;
      standardRetryStrategy;
      mode = exports2.RETRY_MODES.ADAPTIVE;
      constructor(maxAttemptsProvider, options) {
        this.maxAttemptsProvider = maxAttemptsProvider;
        const { rateLimiter } = options ?? {};
        this.rateLimiter = rateLimiter ?? new DefaultRateLimiter();
        this.standardRetryStrategy = new StandardRetryStrategy(maxAttemptsProvider);
      }
      async acquireInitialRetryToken(retryTokenScope) {
        await this.rateLimiter.getSendToken();
        return this.standardRetryStrategy.acquireInitialRetryToken(retryTokenScope);
      }
      async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {
        this.rateLimiter.updateClientSendingRate(errorInfo);
        return this.standardRetryStrategy.refreshRetryTokenForRetry(tokenToRenew, errorInfo);
      }
      recordSuccess(token) {
        this.rateLimiter.updateClientSendingRate({});
        this.standardRetryStrategy.recordSuccess(token);
      }
    };
    var ConfiguredRetryStrategy = class extends StandardRetryStrategy {
      computeNextBackoffDelay;
      constructor(maxAttempts, computeNextBackoffDelay = DEFAULT_RETRY_DELAY_BASE) {
        super(typeof maxAttempts === "function" ? maxAttempts : async () => maxAttempts);
        if (typeof computeNextBackoffDelay === "number") {
          this.computeNextBackoffDelay = () => computeNextBackoffDelay;
        } else {
          this.computeNextBackoffDelay = computeNextBackoffDelay;
        }
      }
      async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {
        const token = await super.refreshRetryTokenForRetry(tokenToRenew, errorInfo);
        token.getRetryDelay = () => this.computeNextBackoffDelay(token.getRetryCount());
        return token;
      }
    };
    exports2.AdaptiveRetryStrategy = AdaptiveRetryStrategy;
    exports2.ConfiguredRetryStrategy = ConfiguredRetryStrategy;
    exports2.DEFAULT_MAX_ATTEMPTS = DEFAULT_MAX_ATTEMPTS;
    exports2.DEFAULT_RETRY_DELAY_BASE = DEFAULT_RETRY_DELAY_BASE;
    exports2.DEFAULT_RETRY_MODE = DEFAULT_RETRY_MODE4;
    exports2.DefaultRateLimiter = DefaultRateLimiter;
    exports2.INITIAL_RETRY_TOKENS = INITIAL_RETRY_TOKENS;
    exports2.INVOCATION_ID_HEADER = INVOCATION_ID_HEADER;
    exports2.MAXIMUM_RETRY_DELAY = MAXIMUM_RETRY_DELAY;
    exports2.NO_RETRY_INCREMENT = NO_RETRY_INCREMENT;
    exports2.REQUEST_HEADER = REQUEST_HEADER;
    exports2.RETRY_COST = RETRY_COST;
    exports2.StandardRetryStrategy = StandardRetryStrategy;
    exports2.THROTTLING_RETRY_DELAY_BASE = THROTTLING_RETRY_DELAY_BASE;
    exports2.TIMEOUT_RETRY_COST = TIMEOUT_RETRY_COST;
  }
});

// node_modules/.pnpm/@smithy+middleware-retry@4.4.23/node_modules/@smithy/middleware-retry/dist-cjs/isStreamingPayload/isStreamingPayload.js
var require_isStreamingPayload = __commonJS({
  "node_modules/.pnpm/@smithy+middleware-retry@4.4.23/node_modules/@smithy/middleware-retry/dist-cjs/isStreamingPayload/isStreamingPayload.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isStreamingPayload = void 0;
    var stream_1 = require("stream");
    var isStreamingPayload = (request2) => request2?.body instanceof stream_1.Readable || typeof ReadableStream !== "undefined" && request2?.body instanceof ReadableStream;
    exports2.isStreamingPayload = isStreamingPayload;
  }
});

// node_modules/.pnpm/@smithy+middleware-retry@4.4.23/node_modules/@smithy/middleware-retry/dist-cjs/index.js
var require_dist_cjs46 = __commonJS({
  "node_modules/.pnpm/@smithy+middleware-retry@4.4.23/node_modules/@smithy/middleware-retry/dist-cjs/index.js"(exports2) {
    "use strict";
    var utilRetry = require_dist_cjs45();
    var protocolHttp = require_dist_cjs2();
    var serviceErrorClassification = require_dist_cjs44();
    var uuid = require_dist_cjs16();
    var utilMiddleware = require_dist_cjs4();
    var smithyClient = require_dist_cjs20();
    var isStreamingPayload = require_isStreamingPayload();
    var getDefaultRetryQuota = (initialRetryTokens, options) => {
      const MAX_CAPACITY = initialRetryTokens;
      const noRetryIncrement = utilRetry.NO_RETRY_INCREMENT;
      const retryCost = utilRetry.RETRY_COST;
      const timeoutRetryCost = utilRetry.TIMEOUT_RETRY_COST;
      let availableCapacity = initialRetryTokens;
      const getCapacityAmount = (error2) => error2.name === "TimeoutError" ? timeoutRetryCost : retryCost;
      const hasRetryTokens = (error2) => getCapacityAmount(error2) <= availableCapacity;
      const retrieveRetryTokens = (error2) => {
        if (!hasRetryTokens(error2)) {
          throw new Error("No retry token available");
        }
        const capacityAmount = getCapacityAmount(error2);
        availableCapacity -= capacityAmount;
        return capacityAmount;
      };
      const releaseRetryTokens = (capacityReleaseAmount) => {
        availableCapacity += capacityReleaseAmount ?? noRetryIncrement;
        availableCapacity = Math.min(availableCapacity, MAX_CAPACITY);
      };
      return Object.freeze({
        hasRetryTokens,
        retrieveRetryTokens,
        releaseRetryTokens
      });
    };
    var defaultDelayDecider = (delayBase, attempts) => Math.floor(Math.min(utilRetry.MAXIMUM_RETRY_DELAY, Math.random() * 2 ** attempts * delayBase));
    var defaultRetryDecider = (error2) => {
      if (!error2) {
        return false;
      }
      return serviceErrorClassification.isRetryableByTrait(error2) || serviceErrorClassification.isClockSkewError(error2) || serviceErrorClassification.isThrottlingError(error2) || serviceErrorClassification.isTransientError(error2);
    };
    var asSdkError = (error2) => {
      if (error2 instanceof Error)
        return error2;
      if (error2 instanceof Object)
        return Object.assign(new Error(), error2);
      if (typeof error2 === "string")
        return new Error(error2);
      return new Error(`AWS SDK error wrapper for ${error2}`);
    };
    var StandardRetryStrategy = class {
      maxAttemptsProvider;
      retryDecider;
      delayDecider;
      retryQuota;
      mode = utilRetry.RETRY_MODES.STANDARD;
      constructor(maxAttemptsProvider, options) {
        this.maxAttemptsProvider = maxAttemptsProvider;
        this.retryDecider = options?.retryDecider ?? defaultRetryDecider;
        this.delayDecider = options?.delayDecider ?? defaultDelayDecider;
        this.retryQuota = options?.retryQuota ?? getDefaultRetryQuota(utilRetry.INITIAL_RETRY_TOKENS);
      }
      shouldRetry(error2, attempts, maxAttempts) {
        return attempts < maxAttempts && this.retryDecider(error2) && this.retryQuota.hasRetryTokens(error2);
      }
      async getMaxAttempts() {
        let maxAttempts;
        try {
          maxAttempts = await this.maxAttemptsProvider();
        } catch (error2) {
          maxAttempts = utilRetry.DEFAULT_MAX_ATTEMPTS;
        }
        return maxAttempts;
      }
      async retry(next, args, options) {
        let retryTokenAmount;
        let attempts = 0;
        let totalDelay = 0;
        const maxAttempts = await this.getMaxAttempts();
        const { request: request2 } = args;
        if (protocolHttp.HttpRequest.isInstance(request2)) {
          request2.headers[utilRetry.INVOCATION_ID_HEADER] = uuid.v4();
        }
        while (true) {
          try {
            if (protocolHttp.HttpRequest.isInstance(request2)) {
              request2.headers[utilRetry.REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;
            }
            if (options?.beforeRequest) {
              await options.beforeRequest();
            }
            const { response: response2, output } = await next(args);
            if (options?.afterRequest) {
              options.afterRequest(response2);
            }
            this.retryQuota.releaseRetryTokens(retryTokenAmount);
            output.$metadata.attempts = attempts + 1;
            output.$metadata.totalRetryDelay = totalDelay;
            return { response: response2, output };
          } catch (e4) {
            const err = asSdkError(e4);
            attempts++;
            if (this.shouldRetry(err, attempts, maxAttempts)) {
              retryTokenAmount = this.retryQuota.retrieveRetryTokens(err);
              const delayFromDecider = this.delayDecider(serviceErrorClassification.isThrottlingError(err) ? utilRetry.THROTTLING_RETRY_DELAY_BASE : utilRetry.DEFAULT_RETRY_DELAY_BASE, attempts);
              const delayFromResponse = getDelayFromRetryAfterHeader(err.$response);
              const delay = Math.max(delayFromResponse || 0, delayFromDecider);
              totalDelay += delay;
              await new Promise((resolve) => setTimeout(resolve, delay));
              continue;
            }
            if (!err.$metadata) {
              err.$metadata = {};
            }
            err.$metadata.attempts = attempts;
            err.$metadata.totalRetryDelay = totalDelay;
            throw err;
          }
        }
      }
    };
    var getDelayFromRetryAfterHeader = (response2) => {
      if (!protocolHttp.HttpResponse.isInstance(response2))
        return;
      const retryAfterHeaderName = Object.keys(response2.headers).find((key) => key.toLowerCase() === "retry-after");
      if (!retryAfterHeaderName)
        return;
      const retryAfter = response2.headers[retryAfterHeaderName];
      const retryAfterSeconds = Number(retryAfter);
      if (!Number.isNaN(retryAfterSeconds))
        return retryAfterSeconds * 1e3;
      const retryAfterDate = new Date(retryAfter);
      return retryAfterDate.getTime() - Date.now();
    };
    var AdaptiveRetryStrategy = class extends StandardRetryStrategy {
      rateLimiter;
      constructor(maxAttemptsProvider, options) {
        const { rateLimiter, ...superOptions } = options ?? {};
        super(maxAttemptsProvider, superOptions);
        this.rateLimiter = rateLimiter ?? new utilRetry.DefaultRateLimiter();
        this.mode = utilRetry.RETRY_MODES.ADAPTIVE;
      }
      async retry(next, args) {
        return super.retry(next, args, {
          beforeRequest: async () => {
            return this.rateLimiter.getSendToken();
          },
          afterRequest: (response2) => {
            this.rateLimiter.updateClientSendingRate(response2);
          }
        });
      }
    };
    var ENV_MAX_ATTEMPTS = "AWS_MAX_ATTEMPTS";
    var CONFIG_MAX_ATTEMPTS = "max_attempts";
    var NODE_MAX_ATTEMPT_CONFIG_OPTIONS4 = {
      environmentVariableSelector: (env) => {
        const value = env[ENV_MAX_ATTEMPTS];
        if (!value)
          return void 0;
        const maxAttempt = parseInt(value);
        if (Number.isNaN(maxAttempt)) {
          throw new Error(`Environment variable ${ENV_MAX_ATTEMPTS} mast be a number, got "${value}"`);
        }
        return maxAttempt;
      },
      configFileSelector: (profile) => {
        const value = profile[CONFIG_MAX_ATTEMPTS];
        if (!value)
          return void 0;
        const maxAttempt = parseInt(value);
        if (Number.isNaN(maxAttempt)) {
          throw new Error(`Shared config file entry ${CONFIG_MAX_ATTEMPTS} mast be a number, got "${value}"`);
        }
        return maxAttempt;
      },
      default: utilRetry.DEFAULT_MAX_ATTEMPTS
    };
    var resolveRetryConfig4 = (input) => {
      const { retryStrategy, retryMode: _retryMode, maxAttempts: _maxAttempts } = input;
      const maxAttempts = utilMiddleware.normalizeProvider(_maxAttempts ?? utilRetry.DEFAULT_MAX_ATTEMPTS);
      return Object.assign(input, {
        maxAttempts,
        retryStrategy: async () => {
          if (retryStrategy) {
            return retryStrategy;
          }
          const retryMode = await utilMiddleware.normalizeProvider(_retryMode)();
          if (retryMode === utilRetry.RETRY_MODES.ADAPTIVE) {
            return new utilRetry.AdaptiveRetryStrategy(maxAttempts);
          }
          return new utilRetry.StandardRetryStrategy(maxAttempts);
        }
      });
    };
    var ENV_RETRY_MODE = "AWS_RETRY_MODE";
    var CONFIG_RETRY_MODE = "retry_mode";
    var NODE_RETRY_MODE_CONFIG_OPTIONS4 = {
      environmentVariableSelector: (env) => env[ENV_RETRY_MODE],
      configFileSelector: (profile) => profile[CONFIG_RETRY_MODE],
      default: utilRetry.DEFAULT_RETRY_MODE
    };
    var omitRetryHeadersMiddleware = () => (next) => async (args) => {
      const { request: request2 } = args;
      if (protocolHttp.HttpRequest.isInstance(request2)) {
        delete request2.headers[utilRetry.INVOCATION_ID_HEADER];
        delete request2.headers[utilRetry.REQUEST_HEADER];
      }
      return next(args);
    };
    var omitRetryHeadersMiddlewareOptions = {
      name: "omitRetryHeadersMiddleware",
      tags: ["RETRY", "HEADERS", "OMIT_RETRY_HEADERS"],
      relation: "before",
      toMiddleware: "awsAuthMiddleware",
      override: true
    };
    var getOmitRetryHeadersPlugin = (options) => ({
      applyToStack: (clientStack) => {
        clientStack.addRelativeTo(omitRetryHeadersMiddleware(), omitRetryHeadersMiddlewareOptions);
      }
    });
    var retryMiddleware = (options) => (next, context) => async (args) => {
      let retryStrategy = await options.retryStrategy();
      const maxAttempts = await options.maxAttempts();
      if (isRetryStrategyV2(retryStrategy)) {
        retryStrategy = retryStrategy;
        let retryToken = await retryStrategy.acquireInitialRetryToken(context["partition_id"]);
        let lastError = new Error();
        let attempts = 0;
        let totalRetryDelay = 0;
        const { request: request2 } = args;
        const isRequest = protocolHttp.HttpRequest.isInstance(request2);
        if (isRequest) {
          request2.headers[utilRetry.INVOCATION_ID_HEADER] = uuid.v4();
        }
        while (true) {
          try {
            if (isRequest) {
              request2.headers[utilRetry.REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;
            }
            const { response: response2, output } = await next(args);
            retryStrategy.recordSuccess(retryToken);
            output.$metadata.attempts = attempts + 1;
            output.$metadata.totalRetryDelay = totalRetryDelay;
            return { response: response2, output };
          } catch (e4) {
            const retryErrorInfo = getRetryErrorInfo(e4);
            lastError = asSdkError(e4);
            if (isRequest && isStreamingPayload.isStreamingPayload(request2)) {
              (context.logger instanceof smithyClient.NoOpLogger ? console : context.logger)?.warn("An error was encountered in a non-retryable streaming request.");
              throw lastError;
            }
            try {
              retryToken = await retryStrategy.refreshRetryTokenForRetry(retryToken, retryErrorInfo);
            } catch (refreshError) {
              if (!lastError.$metadata) {
                lastError.$metadata = {};
              }
              lastError.$metadata.attempts = attempts + 1;
              lastError.$metadata.totalRetryDelay = totalRetryDelay;
              throw lastError;
            }
            attempts = retryToken.getRetryCount();
            const delay = retryToken.getRetryDelay();
            totalRetryDelay += delay;
            await new Promise((resolve) => setTimeout(resolve, delay));
          }
        }
      } else {
        retryStrategy = retryStrategy;
        if (retryStrategy?.mode)
          context.userAgent = [...context.userAgent || [], ["cfg/retry-mode", retryStrategy.mode]];
        return retryStrategy.retry(next, args);
      }
    };
    var isRetryStrategyV2 = (retryStrategy) => typeof retryStrategy.acquireInitialRetryToken !== "undefined" && typeof retryStrategy.refreshRetryTokenForRetry !== "undefined" && typeof retryStrategy.recordSuccess !== "undefined";
    var getRetryErrorInfo = (error2) => {
      const errorInfo = {
        error: error2,
        errorType: getRetryErrorType(error2)
      };
      const retryAfterHint = getRetryAfterHint(error2.$response);
      if (retryAfterHint) {
        errorInfo.retryAfterHint = retryAfterHint;
      }
      return errorInfo;
    };
    var getRetryErrorType = (error2) => {
      if (serviceErrorClassification.isThrottlingError(error2))
        return "THROTTLING";
      if (serviceErrorClassification.isTransientError(error2))
        return "TRANSIENT";
      if (serviceErrorClassification.isServerError(error2))
        return "SERVER_ERROR";
      return "CLIENT_ERROR";
    };
    var retryMiddlewareOptions = {
      name: "retryMiddleware",
      tags: ["RETRY"],
      step: "finalizeRequest",
      priority: "high",
      override: true
    };
    var getRetryPlugin4 = (options) => ({
      applyToStack: (clientStack) => {
        clientStack.add(retryMiddleware(options), retryMiddlewareOptions);
      }
    });
    var getRetryAfterHint = (response2) => {
      if (!protocolHttp.HttpResponse.isInstance(response2))
        return;
      const retryAfterHeaderName = Object.keys(response2.headers).find((key) => key.toLowerCase() === "retry-after");
      if (!retryAfterHeaderName)
        return;
      const retryAfter = response2.headers[retryAfterHeaderName];
      const retryAfterSeconds = Number(retryAfter);
      if (!Number.isNaN(retryAfterSeconds))
        return new Date(retryAfterSeconds * 1e3);
      const retryAfterDate = new Date(retryAfter);
      return retryAfterDate;
    };
    exports2.AdaptiveRetryStrategy = AdaptiveRetryStrategy;
    exports2.CONFIG_MAX_ATTEMPTS = CONFIG_MAX_ATTEMPTS;
    exports2.CONFIG_RETRY_MODE = CONFIG_RETRY_MODE;
    exports2.ENV_MAX_ATTEMPTS = ENV_MAX_ATTEMPTS;
    exports2.ENV_RETRY_MODE = ENV_RETRY_MODE;
    exports2.NODE_MAX_ATTEMPT_CONFIG_OPTIONS = NODE_MAX_ATTEMPT_CONFIG_OPTIONS4;
    exports2.NODE_RETRY_MODE_CONFIG_OPTIONS = NODE_RETRY_MODE_CONFIG_OPTIONS4;
    exports2.StandardRetryStrategy = StandardRetryStrategy;
    exports2.defaultDelayDecider = defaultDelayDecider;
    exports2.defaultRetryDecider = defaultRetryDecider;
    exports2.getOmitRetryHeadersPlugin = getOmitRetryHeadersPlugin;
    exports2.getRetryAfterHint = getRetryAfterHint;
    exports2.getRetryPlugin = getRetryPlugin4;
    exports2.omitRetryHeadersMiddleware = omitRetryHeadersMiddleware;
    exports2.omitRetryHeadersMiddlewareOptions = omitRetryHeadersMiddlewareOptions;
    exports2.resolveRetryConfig = resolveRetryConfig4;
    exports2.retryMiddleware = retryMiddleware;
    exports2.retryMiddlewareOptions = retryMiddlewareOptions;
  }
});

// node_modules/.pnpm/@aws-sdk+signature-v4-multi-region@3.970.0/node_modules/@aws-sdk/signature-v4-multi-region/dist-cjs/index.js
var require_dist_cjs47 = __commonJS({
  "node_modules/.pnpm/@aws-sdk+signature-v4-multi-region@3.970.0/node_modules/@aws-sdk/signature-v4-multi-region/dist-cjs/index.js"(exports2) {
    "use strict";
    var middlewareSdkS3 = require_dist_cjs32();
    var signatureV4 = require_dist_cjs18();
    var signatureV4CrtContainer = {
      CrtSignerV4: null
    };
    var SignatureV4MultiRegion = class {
      sigv4aSigner;
      sigv4Signer;
      signerOptions;
      static sigv4aDependency() {
        if (typeof signatureV4CrtContainer.CrtSignerV4 === "function") {
          return "crt";
        } else if (typeof signatureV4.signatureV4aContainer.SignatureV4a === "function") {
          return "js";
        }
        return "none";
      }
      constructor(options) {
        this.sigv4Signer = new middlewareSdkS3.SignatureV4S3Express(options);
        this.signerOptions = options;
      }
      async sign(requestToSign, options = {}) {
        if (options.signingRegion === "*") {
          return this.getSigv4aSigner().sign(requestToSign, options);
        }
        return this.sigv4Signer.sign(requestToSign, options);
      }
      async signWithCredentials(requestToSign, credentials, options = {}) {
        if (options.signingRegion === "*") {
          const signer = this.getSigv4aSigner();
          const CrtSignerV4 = signatureV4CrtContainer.CrtSignerV4;
          if (CrtSignerV4 && signer instanceof CrtSignerV4) {
            return signer.signWithCredentials(requestToSign, credentials, options);
          } else {
            throw new Error(`signWithCredentials with signingRegion '*' is only supported when using the CRT dependency @aws-sdk/signature-v4-crt. Please check whether you have installed the "@aws-sdk/signature-v4-crt" package explicitly. You must also register the package by calling [require("@aws-sdk/signature-v4-crt");] or an ESM equivalent such as [import "@aws-sdk/signature-v4-crt";]. For more information please go to https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt`);
          }
        }
        return this.sigv4Signer.signWithCredentials(requestToSign, credentials, options);
      }
      async presign(originalRequest, options = {}) {
        if (options.signingRegion === "*") {
          const signer = this.getSigv4aSigner();
          const CrtSignerV4 = signatureV4CrtContainer.CrtSignerV4;
          if (CrtSignerV4 && signer instanceof CrtSignerV4) {
            return signer.presign(originalRequest, options);
          } else {
            throw new Error(`presign with signingRegion '*' is only supported when using the CRT dependency @aws-sdk/signature-v4-crt. Please check whether you have installed the "@aws-sdk/signature-v4-crt" package explicitly. You must also register the package by calling [require("@aws-sdk/signature-v4-crt");] or an ESM equivalent such as [import "@aws-sdk/signature-v4-crt";]. For more information please go to https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt`);
          }
        }
        return this.sigv4Signer.presign(originalRequest, options);
      }
      async presignWithCredentials(originalRequest, credentials, options = {}) {
        if (options.signingRegion === "*") {
          throw new Error("Method presignWithCredentials is not supported for [signingRegion=*].");
        }
        return this.sigv4Signer.presignWithCredentials(originalRequest, credentials, options);
      }
      getSigv4aSigner() {
        if (!this.sigv4aSigner) {
          const CrtSignerV4 = signatureV4CrtContainer.CrtSignerV4;
          const JsSigV4aSigner = signatureV4.signatureV4aContainer.SignatureV4a;
          if (this.signerOptions.runtime === "node") {
            if (!CrtSignerV4 && !JsSigV4aSigner) {
              throw new Error("Neither CRT nor JS SigV4a implementation is available. Please load either @aws-sdk/signature-v4-crt or @aws-sdk/signature-v4a. For more information please go to https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt");
            }
            if (CrtSignerV4 && typeof CrtSignerV4 === "function") {
              this.sigv4aSigner = new CrtSignerV4({
                ...this.signerOptions,
                signingAlgorithm: 1
              });
            } else if (JsSigV4aSigner && typeof JsSigV4aSigner === "function") {
              this.sigv4aSigner = new JsSigV4aSigner({
                ...this.signerOptions
              });
            } else {
              throw new Error("Available SigV4a implementation is not a valid constructor. Please ensure you've properly imported @aws-sdk/signature-v4-crt or @aws-sdk/signature-v4a.For more information please go to https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt");
            }
          } else {
            if (!JsSigV4aSigner || typeof JsSigV4aSigner !== "function") {
              throw new Error("JS SigV4a implementation is not available or not a valid constructor. Please check whether you have installed the @aws-sdk/signature-v4a package explicitly. The CRT implementation is not available for browsers. You must also register the package by calling [require('@aws-sdk/signature-v4a');] or an ESM equivalent such as [import '@aws-sdk/signature-v4a';]. For more information please go to https://github.com/aws/aws-sdk-js-v3#using-javascript-non-crt-implementation-of-sigv4a");
            }
            this.sigv4aSigner = new JsSigV4aSigner({
              ...this.signerOptions
            });
          }
        }
        return this.sigv4aSigner;
      }
    };
    exports2.SignatureV4MultiRegion = SignatureV4MultiRegion;
    exports2.signatureV4CrtContainer = signatureV4CrtContainer;
  }
});

// node_modules/.pnpm/@aws-sdk+client-s3@3.971.0/node_modules/@aws-sdk/client-s3/dist-cjs/endpoint/ruleset.js
var require_ruleset = __commonJS({
  "node_modules/.pnpm/@aws-sdk+client-s3@3.971.0/node_modules/@aws-sdk/client-s3/dist-cjs/endpoint/ruleset.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ruleSet = void 0;
    var cs = "required";
    var ct = "type";
    var cu = "rules";
    var cv = "conditions";
    var cw = "fn";
    var cx = "argv";
    var cy = "ref";
    var cz = "assign";
    var cA = "url";
    var cB = "properties";
    var cC = "backend";
    var cD = "authSchemes";
    var cE = "disableDoubleEncoding";
    var cF = "signingName";
    var cG = "signingRegion";
    var cH = "headers";
    var cI = "signingRegionSet";
    var a4 = 6;
    var b4 = false;
    var c4 = true;
    var d4 = "isSet";
    var e4 = "booleanEquals";
    var f4 = "error";
    var g4 = "aws.partition";
    var h4 = "stringEquals";
    var i4 = "getAttr";
    var j4 = "name";
    var k4 = "substring";
    var l4 = "bucketSuffix";
    var m4 = "parseURL";
    var n4 = "endpoint";
    var o4 = "tree";
    var p4 = "aws.isVirtualHostableS3Bucket";
    var q4 = "{url#scheme}://{Bucket}.{url#authority}{url#path}";
    var r4 = "not";
    var s4 = "accessPointSuffix";
    var t4 = "{url#scheme}://{url#authority}{url#path}";
    var u4 = "hardwareType";
    var v4 = "regionPrefix";
    var w4 = "bucketAliasSuffix";
    var x4 = "outpostId";
    var y2 = "isValidHostLabel";
    var z2 = "sigv4a";
    var A2 = "s3-outposts";
    var B2 = "s3";
    var C2 = "{url#scheme}://{url#authority}{url#normalizedPath}{Bucket}";
    var D2 = "https://{Bucket}.s3-accelerate.{partitionResult#dnsSuffix}";
    var E2 = "https://{Bucket}.s3.{partitionResult#dnsSuffix}";
    var F2 = "aws.parseArn";
    var G2 = "bucketArn";
    var H2 = "arnType";
    var I2 = "";
    var J2 = "s3-object-lambda";
    var K = "accesspoint";
    var L = "accessPointName";
    var M = "{url#scheme}://{accessPointName}-{bucketArn#accountId}.{url#authority}{url#path}";
    var N = "mrapPartition";
    var O = "outpostType";
    var P = "arnPrefix";
    var Q = "{url#scheme}://{url#authority}{url#normalizedPath}{uri_encoded_bucket}";
    var R = "https://s3.{partitionResult#dnsSuffix}/{uri_encoded_bucket}";
    var S = "https://s3.{partitionResult#dnsSuffix}";
    var T = { [cs]: false, [ct]: "string" };
    var U = { [cs]: true, "default": false, [ct]: "boolean" };
    var V = { [cs]: false, [ct]: "boolean" };
    var W = { [cw]: e4, [cx]: [{ [cy]: "Accelerate" }, true] };
    var X = { [cw]: e4, [cx]: [{ [cy]: "UseFIPS" }, true] };
    var Y = { [cw]: e4, [cx]: [{ [cy]: "UseDualStack" }, true] };
    var Z = { [cw]: d4, [cx]: [{ [cy]: "Endpoint" }] };
    var aa = { [cw]: g4, [cx]: [{ [cy]: "Region" }], [cz]: "partitionResult" };
    var ab = { [cw]: h4, [cx]: [{ [cw]: i4, [cx]: [{ [cy]: "partitionResult" }, j4] }, "aws-cn"] };
    var ac = { [cw]: d4, [cx]: [{ [cy]: "Bucket" }] };
    var ad = { [cy]: "Bucket" };
    var ae = { [cv]: [W], [f4]: "S3Express does not support S3 Accelerate.", [ct]: f4 };
    var af = { [cv]: [Z, { [cw]: m4, [cx]: [{ [cy]: "Endpoint" }], [cz]: "url" }], [cu]: [{ [cv]: [{ [cw]: d4, [cx]: [{ [cy]: "DisableS3ExpressSessionAuth" }] }, { [cw]: e4, [cx]: [{ [cy]: "DisableS3ExpressSessionAuth" }, true] }], [cu]: [{ [cv]: [{ [cw]: e4, [cx]: [{ [cw]: i4, [cx]: [{ [cy]: "url" }, "isIp"] }, true] }], [cu]: [{ [cv]: [{ [cw]: "uriEncode", [cx]: [ad], [cz]: "uri_encoded_bucket" }], [cu]: [{ [n4]: { [cA]: "{url#scheme}://{url#authority}/{uri_encoded_bucket}{url#path}", [cB]: { [cC]: "S3Express", [cD]: [{ [cE]: true, [j4]: "sigv4", [cF]: "s3express", [cG]: "{Region}" }] }, [cH]: {} }, [ct]: n4 }], [ct]: o4 }], [ct]: o4 }, { [cv]: [{ [cw]: p4, [cx]: [ad, false] }], [cu]: [{ [n4]: { [cA]: q4, [cB]: { [cC]: "S3Express", [cD]: [{ [cE]: true, [j4]: "sigv4", [cF]: "s3express", [cG]: "{Region}" }] }, [cH]: {} }, [ct]: n4 }], [ct]: o4 }, { [f4]: "S3Express bucket name is not a valid virtual hostable name.", [ct]: f4 }], [ct]: o4 }, { [cv]: [{ [cw]: e4, [cx]: [{ [cw]: i4, [cx]: [{ [cy]: "url" }, "isIp"] }, true] }], [cu]: [{ [cv]: [{ [cw]: "uriEncode", [cx]: [ad], [cz]: "uri_encoded_bucket" }], [cu]: [{ [n4]: { [cA]: "{url#scheme}://{url#authority}/{uri_encoded_bucket}{url#path}", [cB]: { [cC]: "S3Express", [cD]: [{ [cE]: true, [j4]: "sigv4-s3express", [cF]: "s3express", [cG]: "{Region}" }] }, [cH]: {} }, [ct]: n4 }], [ct]: o4 }], [ct]: o4 }, { [cv]: [{ [cw]: p4, [cx]: [ad, false] }], [cu]: [{ [n4]: { [cA]: q4, [cB]: { [cC]: "S3Express", [cD]: [{ [cE]: true, [j4]: "sigv4-s3express", [cF]: "s3express", [cG]: "{Region}" }] }, [cH]: {} }, [ct]: n4 }], [ct]: o4 }, { [f4]: "S3Express bucket name is not a valid virtual hostable name.", [ct]: f4 }], [ct]: o4 };
    var ag = { [cw]: m4, [cx]: [{ [cy]: "Endpoint" }], [cz]: "url" };
    var ah = { [cw]: e4, [cx]: [{ [cw]: i4, [cx]: [{ [cy]: "url" }, "isIp"] }, true] };
    var ai = { [cy]: "url" };
    var aj = { [cw]: "uriEncode", [cx]: [ad], [cz]: "uri_encoded_bucket" };
    var ak = { [cC]: "S3Express", [cD]: [{ [cE]: true, [j4]: "sigv4", [cF]: "s3express", [cG]: "{Region}" }] };
    var al = {};
    var am = { [cw]: p4, [cx]: [ad, false] };
    var an = { [f4]: "S3Express bucket name is not a valid virtual hostable name.", [ct]: f4 };
    var ao = { [cw]: d4, [cx]: [{ [cy]: "UseS3ExpressControlEndpoint" }] };
    var ap = { [cw]: e4, [cx]: [{ [cy]: "UseS3ExpressControlEndpoint" }, true] };
    var aq = { [cw]: r4, [cx]: [Z] };
    var ar = { [cw]: e4, [cx]: [{ [cy]: "UseDualStack" }, false] };
    var as = { [cw]: e4, [cx]: [{ [cy]: "UseFIPS" }, false] };
    var at = { [f4]: "Unrecognized S3Express bucket name format.", [ct]: f4 };
    var au = { [cw]: r4, [cx]: [ac] };
    var av = { [cy]: u4 };
    var aw = { [cv]: [aq], [f4]: "Expected a endpoint to be specified but no endpoint was found", [ct]: f4 };
    var ax = { [cD]: [{ [cE]: true, [j4]: z2, [cF]: A2, [cI]: ["*"] }, { [cE]: true, [j4]: "sigv4", [cF]: A2, [cG]: "{Region}" }] };
    var ay = { [cw]: e4, [cx]: [{ [cy]: "ForcePathStyle" }, false] };
    var az = { [cy]: "ForcePathStyle" };
    var aA = { [cw]: e4, [cx]: [{ [cy]: "Accelerate" }, false] };
    var aB = { [cw]: h4, [cx]: [{ [cy]: "Region" }, "aws-global"] };
    var aC = { [cD]: [{ [cE]: true, [j4]: "sigv4", [cF]: B2, [cG]: "us-east-1" }] };
    var aD = { [cw]: r4, [cx]: [aB] };
    var aE = { [cw]: e4, [cx]: [{ [cy]: "UseGlobalEndpoint" }, true] };
    var aF = { [cA]: "https://{Bucket}.s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}", [cB]: { [cD]: [{ [cE]: true, [j4]: "sigv4", [cF]: B2, [cG]: "{Region}" }] }, [cH]: {} };
    var aG = { [cD]: [{ [cE]: true, [j4]: "sigv4", [cF]: B2, [cG]: "{Region}" }] };
    var aH = { [cw]: e4, [cx]: [{ [cy]: "UseGlobalEndpoint" }, false] };
    var aI = { [cA]: "https://{Bucket}.s3-fips.{Region}.{partitionResult#dnsSuffix}", [cB]: aG, [cH]: {} };
    var aJ = { [cA]: "https://{Bucket}.s3-accelerate.dualstack.{partitionResult#dnsSuffix}", [cB]: aG, [cH]: {} };
    var aK = { [cA]: "https://{Bucket}.s3.dualstack.{Region}.{partitionResult#dnsSuffix}", [cB]: aG, [cH]: {} };
    var aL = { [cw]: e4, [cx]: [{ [cw]: i4, [cx]: [ai, "isIp"] }, false] };
    var aM = { [cA]: C2, [cB]: aG, [cH]: {} };
    var aN = { [cA]: q4, [cB]: aG, [cH]: {} };
    var aO = { [n4]: aN, [ct]: n4 };
    var aP = { [cA]: D2, [cB]: aG, [cH]: {} };
    var aQ = { [cA]: "https://{Bucket}.s3.{Region}.{partitionResult#dnsSuffix}", [cB]: aG, [cH]: {} };
    var aR = { [f4]: "Invalid region: region was not a valid DNS name.", [ct]: f4 };
    var aS = { [cy]: G2 };
    var aT = { [cy]: H2 };
    var aU = { [cw]: i4, [cx]: [aS, "service"] };
    var aV = { [cy]: L };
    var aW = { [cv]: [Y], [f4]: "S3 Object Lambda does not support Dual-stack", [ct]: f4 };
    var aX = { [cv]: [W], [f4]: "S3 Object Lambda does not support S3 Accelerate", [ct]: f4 };
    var aY = { [cv]: [{ [cw]: d4, [cx]: [{ [cy]: "DisableAccessPoints" }] }, { [cw]: e4, [cx]: [{ [cy]: "DisableAccessPoints" }, true] }], [f4]: "Access points are not supported for this operation", [ct]: f4 };
    var aZ = { [cv]: [{ [cw]: d4, [cx]: [{ [cy]: "UseArnRegion" }] }, { [cw]: e4, [cx]: [{ [cy]: "UseArnRegion" }, false] }, { [cw]: r4, [cx]: [{ [cw]: h4, [cx]: [{ [cw]: i4, [cx]: [aS, "region"] }, "{Region}"] }] }], [f4]: "Invalid configuration: region from ARN `{bucketArn#region}` does not match client region `{Region}` and UseArnRegion is `false`", [ct]: f4 };
    var ba = { [cw]: i4, [cx]: [{ [cy]: "bucketPartition" }, j4] };
    var bb = { [cw]: i4, [cx]: [aS, "accountId"] };
    var bc = { [cD]: [{ [cE]: true, [j4]: "sigv4", [cF]: J2, [cG]: "{bucketArn#region}" }] };
    var bd = { [f4]: "Invalid ARN: The access point name may only contain a-z, A-Z, 0-9 and `-`. Found: `{accessPointName}`", [ct]: f4 };
    var be = { [f4]: "Invalid ARN: The account id may only contain a-z, A-Z, 0-9 and `-`. Found: `{bucketArn#accountId}`", [ct]: f4 };
    var bf = { [f4]: "Invalid region in ARN: `{bucketArn#region}` (invalid DNS name)", [ct]: f4 };
    var bg = { [f4]: "Client was configured for partition `{partitionResult#name}` but ARN (`{Bucket}`) has `{bucketPartition#name}`", [ct]: f4 };
    var bh = { [f4]: "Invalid ARN: The ARN may only contain a single resource component after `accesspoint`.", [ct]: f4 };
    var bi = { [f4]: "Invalid ARN: Expected a resource of the format `accesspoint:<accesspoint name>` but no name was provided", [ct]: f4 };
    var bj = { [cD]: [{ [cE]: true, [j4]: "sigv4", [cF]: B2, [cG]: "{bucketArn#region}" }] };
    var bk = { [cD]: [{ [cE]: true, [j4]: z2, [cF]: A2, [cI]: ["*"] }, { [cE]: true, [j4]: "sigv4", [cF]: A2, [cG]: "{bucketArn#region}" }] };
    var bl = { [cw]: F2, [cx]: [ad] };
    var bm = { [cA]: "https://s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cB]: aG, [cH]: {} };
    var bn = { [cA]: "https://s3-fips.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cB]: aG, [cH]: {} };
    var bo = { [cA]: "https://s3.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cB]: aG, [cH]: {} };
    var bp = { [cA]: Q, [cB]: aG, [cH]: {} };
    var bq = { [cA]: "https://s3.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cB]: aG, [cH]: {} };
    var br = { [cy]: "UseObjectLambdaEndpoint" };
    var bs = { [cD]: [{ [cE]: true, [j4]: "sigv4", [cF]: J2, [cG]: "{Region}" }] };
    var bt = { [cA]: "https://s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}", [cB]: aG, [cH]: {} };
    var bu = { [cA]: "https://s3-fips.{Region}.{partitionResult#dnsSuffix}", [cB]: aG, [cH]: {} };
    var bv = { [cA]: "https://s3.dualstack.{Region}.{partitionResult#dnsSuffix}", [cB]: aG, [cH]: {} };
    var bw = { [cA]: t4, [cB]: aG, [cH]: {} };
    var bx = { [cA]: "https://s3.{Region}.{partitionResult#dnsSuffix}", [cB]: aG, [cH]: {} };
    var by = [{ [cy]: "Region" }];
    var bz = [{ [cy]: "Endpoint" }];
    var bA = [ad];
    var bB = [W];
    var bC = [Z, ag];
    var bD = [{ [cw]: d4, [cx]: [{ [cy]: "DisableS3ExpressSessionAuth" }] }, { [cw]: e4, [cx]: [{ [cy]: "DisableS3ExpressSessionAuth" }, true] }];
    var bE = [aj];
    var bF = [am];
    var bG = [aa];
    var bH = [X, Y];
    var bI = [X, ar];
    var bJ = [as, Y];
    var bK = [as, ar];
    var bL = [{ [cw]: k4, [cx]: [ad, 6, 14, true], [cz]: "s3expressAvailabilityZoneId" }, { [cw]: k4, [cx]: [ad, 14, 16, true], [cz]: "s3expressAvailabilityZoneDelim" }, { [cw]: h4, [cx]: [{ [cy]: "s3expressAvailabilityZoneDelim" }, "--"] }];
    var bM = [{ [cv]: [X, Y], [n4]: { [cA]: "https://{Bucket}.s3express-fips-{s3expressAvailabilityZoneId}.dualstack.{Region}.{partitionResult#dnsSuffix}", [cB]: ak, [cH]: {} }, [ct]: n4 }, { [cv]: bI, [n4]: { [cA]: "https://{Bucket}.s3express-fips-{s3expressAvailabilityZoneId}.{Region}.{partitionResult#dnsSuffix}", [cB]: ak, [cH]: {} }, [ct]: n4 }, { [cv]: bJ, [n4]: { [cA]: "https://{Bucket}.s3express-{s3expressAvailabilityZoneId}.dualstack.{Region}.{partitionResult#dnsSuffix}", [cB]: ak, [cH]: {} }, [ct]: n4 }, { [cv]: bK, [n4]: { [cA]: "https://{Bucket}.s3express-{s3expressAvailabilityZoneId}.{Region}.{partitionResult#dnsSuffix}", [cB]: ak, [cH]: {} }, [ct]: n4 }];
    var bN = [{ [cw]: k4, [cx]: [ad, 6, 15, true], [cz]: "s3expressAvailabilityZoneId" }, { [cw]: k4, [cx]: [ad, 15, 17, true], [cz]: "s3expressAvailabilityZoneDelim" }, { [cw]: h4, [cx]: [{ [cy]: "s3expressAvailabilityZoneDelim" }, "--"] }];
    var bO = [{ [cw]: k4, [cx]: [ad, 6, 19, true], [cz]: "s3expressAvailabilityZoneId" }, { [cw]: k4, [cx]: [ad, 19, 21, true], [cz]: "s3expressAvailabilityZoneDelim" }, { [cw]: h4, [cx]: [{ [cy]: "s3expressAvailabilityZoneDelim" }, "--"] }];
    var bP = [{ [cw]: k4, [cx]: [ad, 6, 20, true], [cz]: "s3expressAvailabilityZoneId" }, { [cw]: k4, [cx]: [ad, 20, 22, true], [cz]: "s3expressAvailabilityZoneDelim" }, { [cw]: h4, [cx]: [{ [cy]: "s3expressAvailabilityZoneDelim" }, "--"] }];
    var bQ = [{ [cw]: k4, [cx]: [ad, 6, 26, true], [cz]: "s3expressAvailabilityZoneId" }, { [cw]: k4, [cx]: [ad, 26, 28, true], [cz]: "s3expressAvailabilityZoneDelim" }, { [cw]: h4, [cx]: [{ [cy]: "s3expressAvailabilityZoneDelim" }, "--"] }];
    var bR = [{ [cv]: [X, Y], [n4]: { [cA]: "https://{Bucket}.s3express-fips-{s3expressAvailabilityZoneId}.dualstack.{Region}.{partitionResult#dnsSuffix}", [cB]: { [cC]: "S3Express", [cD]: [{ [cE]: true, [j4]: "sigv4-s3express", [cF]: "s3express", [cG]: "{Region}" }] }, [cH]: {} }, [ct]: n4 }, { [cv]: bI, [n4]: { [cA]: "https://{Bucket}.s3express-fips-{s3expressAvailabilityZoneId}.{Region}.{partitionResult#dnsSuffix}", [cB]: { [cC]: "S3Express", [cD]: [{ [cE]: true, [j4]: "sigv4-s3express", [cF]: "s3express", [cG]: "{Region}" }] }, [cH]: {} }, [ct]: n4 }, { [cv]: bJ, [n4]: { [cA]: "https://{Bucket}.s3express-{s3expressAvailabilityZoneId}.dualstack.{Region}.{partitionResult#dnsSuffix}", [cB]: { [cC]: "S3Express", [cD]: [{ [cE]: true, [j4]: "sigv4-s3express", [cF]: "s3express", [cG]: "{Region}" }] }, [cH]: {} }, [ct]: n4 }, { [cv]: bK, [n4]: { [cA]: "https://{Bucket}.s3express-{s3expressAvailabilityZoneId}.{Region}.{partitionResult#dnsSuffix}", [cB]: { [cC]: "S3Express", [cD]: [{ [cE]: true, [j4]: "sigv4-s3express", [cF]: "s3express", [cG]: "{Region}" }] }, [cH]: {} }, [ct]: n4 }];
    var bS = [ad, 0, 7, true];
    var bT = [{ [cw]: k4, [cx]: [ad, 7, 15, true], [cz]: "s3expressAvailabilityZoneId" }, { [cw]: k4, [cx]: [ad, 15, 17, true], [cz]: "s3expressAvailabilityZoneDelim" }, { [cw]: h4, [cx]: [{ [cy]: "s3expressAvailabilityZoneDelim" }, "--"] }];
    var bU = [{ [cw]: k4, [cx]: [ad, 7, 16, true], [cz]: "s3expressAvailabilityZoneId" }, { [cw]: k4, [cx]: [ad, 16, 18, true], [cz]: "s3expressAvailabilityZoneDelim" }, { [cw]: h4, [cx]: [{ [cy]: "s3expressAvailabilityZoneDelim" }, "--"] }];
    var bV = [{ [cw]: k4, [cx]: [ad, 7, 20, true], [cz]: "s3expressAvailabilityZoneId" }, { [cw]: k4, [cx]: [ad, 20, 22, true], [cz]: "s3expressAvailabilityZoneDelim" }, { [cw]: h4, [cx]: [{ [cy]: "s3expressAvailabilityZoneDelim" }, "--"] }];
    var bW = [{ [cw]: k4, [cx]: [ad, 7, 21, true], [cz]: "s3expressAvailabilityZoneId" }, { [cw]: k4, [cx]: [ad, 21, 23, true], [cz]: "s3expressAvailabilityZoneDelim" }, { [cw]: h4, [cx]: [{ [cy]: "s3expressAvailabilityZoneDelim" }, "--"] }];
    var bX = [{ [cw]: k4, [cx]: [ad, 7, 27, true], [cz]: "s3expressAvailabilityZoneId" }, { [cw]: k4, [cx]: [ad, 27, 29, true], [cz]: "s3expressAvailabilityZoneDelim" }, { [cw]: h4, [cx]: [{ [cy]: "s3expressAvailabilityZoneDelim" }, "--"] }];
    var bY = [ac];
    var bZ = [{ [cw]: y2, [cx]: [{ [cy]: x4 }, false] }];
    var ca = [{ [cw]: h4, [cx]: [{ [cy]: v4 }, "beta"] }];
    var cb = ["*"];
    var cc = [{ [cw]: y2, [cx]: [{ [cy]: "Region" }, false] }];
    var cd = [{ [cw]: h4, [cx]: [{ [cy]: "Region" }, "us-east-1"] }];
    var ce = [{ [cw]: h4, [cx]: [aT, K] }];
    var cf = [{ [cw]: i4, [cx]: [aS, "resourceId[1]"], [cz]: L }, { [cw]: r4, [cx]: [{ [cw]: h4, [cx]: [aV, I2] }] }];
    var cg = [aS, "resourceId[1]"];
    var ch = [Y];
    var ci = [{ [cw]: r4, [cx]: [{ [cw]: h4, [cx]: [{ [cw]: i4, [cx]: [aS, "region"] }, I2] }] }];
    var cj = [{ [cw]: r4, [cx]: [{ [cw]: d4, [cx]: [{ [cw]: i4, [cx]: [aS, "resourceId[2]"] }] }] }];
    var ck = [aS, "resourceId[2]"];
    var cl = [{ [cw]: g4, [cx]: [{ [cw]: i4, [cx]: [aS, "region"] }], [cz]: "bucketPartition" }];
    var cm = [{ [cw]: h4, [cx]: [ba, { [cw]: i4, [cx]: [{ [cy]: "partitionResult" }, j4] }] }];
    var cn = [{ [cw]: y2, [cx]: [{ [cw]: i4, [cx]: [aS, "region"] }, true] }];
    var co = [{ [cw]: y2, [cx]: [bb, false] }];
    var cp = [{ [cw]: y2, [cx]: [aV, false] }];
    var cq = [X];
    var cr = [{ [cw]: y2, [cx]: [{ [cy]: "Region" }, true] }];
    var _data4 = { version: "1.0", parameters: { Bucket: T, Region: T, UseFIPS: U, UseDualStack: U, Endpoint: T, ForcePathStyle: U, Accelerate: U, UseGlobalEndpoint: U, UseObjectLambdaEndpoint: V, Key: T, Prefix: T, CopySource: T, DisableAccessPoints: V, DisableMultiRegionAccessPoints: U, UseArnRegion: V, UseS3ExpressControlEndpoint: V, DisableS3ExpressSessionAuth: V }, [cu]: [{ [cv]: [{ [cw]: d4, [cx]: by }], [cu]: [{ [cv]: [W, X], error: "Accelerate cannot be used with FIPS", [ct]: f4 }, { [cv]: [Y, Z], error: "Cannot set dual-stack in combination with a custom endpoint.", [ct]: f4 }, { [cv]: [Z, X], error: "A custom endpoint cannot be combined with FIPS", [ct]: f4 }, { [cv]: [Z, W], error: "A custom endpoint cannot be combined with S3 Accelerate", [ct]: f4 }, { [cv]: [X, aa, ab], error: "Partition does not support FIPS", [ct]: f4 }, { [cv]: [ac, { [cw]: k4, [cx]: [ad, 0, a4, c4], [cz]: l4 }, { [cw]: h4, [cx]: [{ [cy]: l4 }, "--x-s3"] }], [cu]: [ae, af, { [cv]: [ao, ap], [cu]: [{ [cv]: bG, [cu]: [{ [cv]: [aj, aq], [cu]: [{ [cv]: bH, endpoint: { [cA]: "https://s3express-control-fips.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cB]: ak, [cH]: al }, [ct]: n4 }, { [cv]: bI, endpoint: { [cA]: "https://s3express-control-fips.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cB]: ak, [cH]: al }, [ct]: n4 }, { [cv]: bJ, endpoint: { [cA]: "https://s3express-control.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cB]: ak, [cH]: al }, [ct]: n4 }, { [cv]: bK, endpoint: { [cA]: "https://s3express-control.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cB]: ak, [cH]: al }, [ct]: n4 }], [ct]: o4 }], [ct]: o4 }], [ct]: o4 }, { [cv]: bF, [cu]: [{ [cv]: bG, [cu]: [{ [cv]: bD, [cu]: [{ [cv]: bL, [cu]: bM, [ct]: o4 }, { [cv]: bN, [cu]: bM, [ct]: o4 }, { [cv]: bO, [cu]: bM, [ct]: o4 }, { [cv]: bP, [cu]: bM, [ct]: o4 }, { [cv]: bQ, [cu]: bM, [ct]: o4 }, at], [ct]: o4 }, { [cv]: bL, [cu]: bR, [ct]: o4 }, { [cv]: bN, [cu]: bR, [ct]: o4 }, { [cv]: bO, [cu]: bR, [ct]: o4 }, { [cv]: bP, [cu]: bR, [ct]: o4 }, { [cv]: bQ, [cu]: bR, [ct]: o4 }, at], [ct]: o4 }], [ct]: o4 }, an], [ct]: o4 }, { [cv]: [ac, { [cw]: k4, [cx]: bS, [cz]: s4 }, { [cw]: h4, [cx]: [{ [cy]: s4 }, "--xa-s3"] }], [cu]: [ae, af, { [cv]: bF, [cu]: [{ [cv]: bG, [cu]: [{ [cv]: bD, [cu]: [{ [cv]: bT, [cu]: bM, [ct]: o4 }, { [cv]: bU, [cu]: bM, [ct]: o4 }, { [cv]: bV, [cu]: bM, [ct]: o4 }, { [cv]: bW, [cu]: bM, [ct]: o4 }, { [cv]: bX, [cu]: bM, [ct]: o4 }, at], [ct]: o4 }, { [cv]: bT, [cu]: bR, [ct]: o4 }, { [cv]: bU, [cu]: bR, [ct]: o4 }, { [cv]: bV, [cu]: bR, [ct]: o4 }, { [cv]: bW, [cu]: bR, [ct]: o4 }, { [cv]: bX, [cu]: bR, [ct]: o4 }, at], [ct]: o4 }], [ct]: o4 }, an], [ct]: o4 }, { [cv]: [au, ao, ap], [cu]: [{ [cv]: bG, [cu]: [{ [cv]: bC, endpoint: { [cA]: t4, [cB]: ak, [cH]: al }, [ct]: n4 }, { [cv]: bH, endpoint: { [cA]: "https://s3express-control-fips.dualstack.{Region}.{partitionResult#dnsSuffix}", [cB]: ak, [cH]: al }, [ct]: n4 }, { [cv]: bI, endpoint: { [cA]: "https://s3express-control-fips.{Region}.{partitionResult#dnsSuffix}", [cB]: ak, [cH]: al }, [ct]: n4 }, { [cv]: bJ, endpoint: { [cA]: "https://s3express-control.dualstack.{Region}.{partitionResult#dnsSuffix}", [cB]: ak, [cH]: al }, [ct]: n4 }, { [cv]: bK, endpoint: { [cA]: "https://s3express-control.{Region}.{partitionResult#dnsSuffix}", [cB]: ak, [cH]: al }, [ct]: n4 }], [ct]: o4 }], [ct]: o4 }, { [cv]: [ac, { [cw]: k4, [cx]: [ad, 49, 50, c4], [cz]: u4 }, { [cw]: k4, [cx]: [ad, 8, 12, c4], [cz]: v4 }, { [cw]: k4, [cx]: bS, [cz]: w4 }, { [cw]: k4, [cx]: [ad, 32, 49, c4], [cz]: x4 }, { [cw]: g4, [cx]: by, [cz]: "regionPartition" }, { [cw]: h4, [cx]: [{ [cy]: w4 }, "--op-s3"] }], [cu]: [{ [cv]: bZ, [cu]: [{ [cv]: bF, [cu]: [{ [cv]: [{ [cw]: h4, [cx]: [av, "e"] }], [cu]: [{ [cv]: ca, [cu]: [aw, { [cv]: bC, endpoint: { [cA]: "https://{Bucket}.ec2.{url#authority}", [cB]: ax, [cH]: al }, [ct]: n4 }], [ct]: o4 }, { endpoint: { [cA]: "https://{Bucket}.ec2.s3-outposts.{Region}.{regionPartition#dnsSuffix}", [cB]: ax, [cH]: al }, [ct]: n4 }], [ct]: o4 }, { [cv]: [{ [cw]: h4, [cx]: [av, "o"] }], [cu]: [{ [cv]: ca, [cu]: [aw, { [cv]: bC, endpoint: { [cA]: "https://{Bucket}.op-{outpostId}.{url#authority}", [cB]: ax, [cH]: al }, [ct]: n4 }], [ct]: o4 }, { endpoint: { [cA]: "https://{Bucket}.op-{outpostId}.s3-outposts.{Region}.{regionPartition#dnsSuffix}", [cB]: ax, [cH]: al }, [ct]: n4 }], [ct]: o4 }, { error: 'Unrecognized hardware type: "Expected hardware type o or e but got {hardwareType}"', [ct]: f4 }], [ct]: o4 }, { error: "Invalid Outposts Bucket alias - it must be a valid bucket name.", [ct]: f4 }], [ct]: o4 }, { error: "Invalid ARN: The outpost Id must only contain a-z, A-Z, 0-9 and `-`.", [ct]: f4 }], [ct]: o4 }, { [cv]: bY, [cu]: [{ [cv]: [Z, { [cw]: r4, [cx]: [{ [cw]: d4, [cx]: [{ [cw]: m4, [cx]: bz }] }] }], error: "Custom endpoint `{Endpoint}` was not a valid URI", [ct]: f4 }, { [cv]: [ay, am], [cu]: [{ [cv]: bG, [cu]: [{ [cv]: cc, [cu]: [{ [cv]: [W, ab], error: "S3 Accelerate cannot be used in this region", [ct]: f4 }, { [cv]: [Y, X, aA, aq, aB], endpoint: { [cA]: "https://{Bucket}.s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cB]: aC, [cH]: al }, [ct]: n4 }, { [cv]: [Y, X, aA, aq, aD, aE], [cu]: [{ endpoint: aF, [ct]: n4 }], [ct]: o4 }, { [cv]: [Y, X, aA, aq, aD, aH], endpoint: aF, [ct]: n4 }, { [cv]: [ar, X, aA, aq, aB], endpoint: { [cA]: "https://{Bucket}.s3-fips.us-east-1.{partitionResult#dnsSuffix}", [cB]: aC, [cH]: al }, [ct]: n4 }, { [cv]: [ar, X, aA, aq, aD, aE], [cu]: [{ endpoint: aI, [ct]: n4 }], [ct]: o4 }, { [cv]: [ar, X, aA, aq, aD, aH], endpoint: aI, [ct]: n4 }, { [cv]: [Y, as, W, aq, aB], endpoint: { [cA]: "https://{Bucket}.s3-accelerate.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cB]: aC, [cH]: al }, [ct]: n4 }, { [cv]: [Y, as, W, aq, aD, aE], [cu]: [{ endpoint: aJ, [ct]: n4 }], [ct]: o4 }, { [cv]: [Y, as, W, aq, aD, aH], endpoint: aJ, [ct]: n4 }, { [cv]: [Y, as, aA, aq, aB], endpoint: { [cA]: "https://{Bucket}.s3.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cB]: aC, [cH]: al }, [ct]: n4 }, { [cv]: [Y, as, aA, aq, aD, aE], [cu]: [{ endpoint: aK, [ct]: n4 }], [ct]: o4 }, { [cv]: [Y, as, aA, aq, aD, aH], endpoint: aK, [ct]: n4 }, { [cv]: [ar, as, aA, Z, ag, ah, aB], endpoint: { [cA]: C2, [cB]: aC, [cH]: al }, [ct]: n4 }, { [cv]: [ar, as, aA, Z, ag, aL, aB], endpoint: { [cA]: q4, [cB]: aC, [cH]: al }, [ct]: n4 }, { [cv]: [ar, as, aA, Z, ag, ah, aD, aE], [cu]: [{ [cv]: cd, endpoint: aM, [ct]: n4 }, { endpoint: aM, [ct]: n4 }], [ct]: o4 }, { [cv]: [ar, as, aA, Z, ag, aL, aD, aE], [cu]: [{ [cv]: cd, endpoint: aN, [ct]: n4 }, aO], [ct]: o4 }, { [cv]: [ar, as, aA, Z, ag, ah, aD, aH], endpoint: aM, [ct]: n4 }, { [cv]: [ar, as, aA, Z, ag, aL, aD, aH], endpoint: aN, [ct]: n4 }, { [cv]: [ar, as, W, aq, aB], endpoint: { [cA]: D2, [cB]: aC, [cH]: al }, [ct]: n4 }, { [cv]: [ar, as, W, aq, aD, aE], [cu]: [{ [cv]: cd, endpoint: aP, [ct]: n4 }, { endpoint: aP, [ct]: n4 }], [ct]: o4 }, { [cv]: [ar, as, W, aq, aD, aH], endpoint: aP, [ct]: n4 }, { [cv]: [ar, as, aA, aq, aB], endpoint: { [cA]: E2, [cB]: aC, [cH]: al }, [ct]: n4 }, { [cv]: [ar, as, aA, aq, aD, aE], [cu]: [{ [cv]: cd, endpoint: { [cA]: E2, [cB]: aG, [cH]: al }, [ct]: n4 }, { endpoint: aQ, [ct]: n4 }], [ct]: o4 }, { [cv]: [ar, as, aA, aq, aD, aH], endpoint: aQ, [ct]: n4 }], [ct]: o4 }, aR], [ct]: o4 }], [ct]: o4 }, { [cv]: [Z, ag, { [cw]: h4, [cx]: [{ [cw]: i4, [cx]: [ai, "scheme"] }, "http"] }, { [cw]: p4, [cx]: [ad, c4] }, ay, as, ar, aA], [cu]: [{ [cv]: bG, [cu]: [{ [cv]: cc, [cu]: [aO], [ct]: o4 }, aR], [ct]: o4 }], [ct]: o4 }, { [cv]: [ay, { [cw]: F2, [cx]: bA, [cz]: G2 }], [cu]: [{ [cv]: [{ [cw]: i4, [cx]: [aS, "resourceId[0]"], [cz]: H2 }, { [cw]: r4, [cx]: [{ [cw]: h4, [cx]: [aT, I2] }] }], [cu]: [{ [cv]: [{ [cw]: h4, [cx]: [aU, J2] }], [cu]: [{ [cv]: ce, [cu]: [{ [cv]: cf, [cu]: [aW, aX, { [cv]: ci, [cu]: [aY, { [cv]: cj, [cu]: [aZ, { [cv]: cl, [cu]: [{ [cv]: bG, [cu]: [{ [cv]: cm, [cu]: [{ [cv]: cn, [cu]: [{ [cv]: [{ [cw]: h4, [cx]: [bb, I2] }], error: "Invalid ARN: Missing account id", [ct]: f4 }, { [cv]: co, [cu]: [{ [cv]: cp, [cu]: [{ [cv]: bC, endpoint: { [cA]: M, [cB]: bc, [cH]: al }, [ct]: n4 }, { [cv]: cq, endpoint: { [cA]: "https://{accessPointName}-{bucketArn#accountId}.s3-object-lambda-fips.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cB]: bc, [cH]: al }, [ct]: n4 }, { endpoint: { [cA]: "https://{accessPointName}-{bucketArn#accountId}.s3-object-lambda.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cB]: bc, [cH]: al }, [ct]: n4 }], [ct]: o4 }, bd], [ct]: o4 }, be], [ct]: o4 }, bf], [ct]: o4 }, bg], [ct]: o4 }], [ct]: o4 }], [ct]: o4 }, bh], [ct]: o4 }, { error: "Invalid ARN: bucket ARN is missing a region", [ct]: f4 }], [ct]: o4 }, bi], [ct]: o4 }, { error: "Invalid ARN: Object Lambda ARNs only support `accesspoint` arn types, but found: `{arnType}`", [ct]: f4 }], [ct]: o4 }, { [cv]: ce, [cu]: [{ [cv]: cf, [cu]: [{ [cv]: ci, [cu]: [{ [cv]: ce, [cu]: [{ [cv]: ci, [cu]: [aY, { [cv]: cj, [cu]: [aZ, { [cv]: cl, [cu]: [{ [cv]: bG, [cu]: [{ [cv]: [{ [cw]: h4, [cx]: [ba, "{partitionResult#name}"] }], [cu]: [{ [cv]: cn, [cu]: [{ [cv]: [{ [cw]: h4, [cx]: [aU, B2] }], [cu]: [{ [cv]: co, [cu]: [{ [cv]: cp, [cu]: [{ [cv]: bB, error: "Access Points do not support S3 Accelerate", [ct]: f4 }, { [cv]: bH, endpoint: { [cA]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint-fips.dualstack.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cB]: bj, [cH]: al }, [ct]: n4 }, { [cv]: bI, endpoint: { [cA]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint-fips.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cB]: bj, [cH]: al }, [ct]: n4 }, { [cv]: bJ, endpoint: { [cA]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint.dualstack.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cB]: bj, [cH]: al }, [ct]: n4 }, { [cv]: [as, ar, Z, ag], endpoint: { [cA]: M, [cB]: bj, [cH]: al }, [ct]: n4 }, { [cv]: bK, endpoint: { [cA]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cB]: bj, [cH]: al }, [ct]: n4 }], [ct]: o4 }, bd], [ct]: o4 }, be], [ct]: o4 }, { error: "Invalid ARN: The ARN was not for the S3 service, found: {bucketArn#service}", [ct]: f4 }], [ct]: o4 }, bf], [ct]: o4 }, bg], [ct]: o4 }], [ct]: o4 }], [ct]: o4 }, bh], [ct]: o4 }], [ct]: o4 }], [ct]: o4 }, { [cv]: [{ [cw]: y2, [cx]: [aV, c4] }], [cu]: [{ [cv]: ch, error: "S3 MRAP does not support dual-stack", [ct]: f4 }, { [cv]: cq, error: "S3 MRAP does not support FIPS", [ct]: f4 }, { [cv]: bB, error: "S3 MRAP does not support S3 Accelerate", [ct]: f4 }, { [cv]: [{ [cw]: e4, [cx]: [{ [cy]: "DisableMultiRegionAccessPoints" }, c4] }], error: "Invalid configuration: Multi-Region Access Point ARNs are disabled.", [ct]: f4 }, { [cv]: [{ [cw]: g4, [cx]: by, [cz]: N }], [cu]: [{ [cv]: [{ [cw]: h4, [cx]: [{ [cw]: i4, [cx]: [{ [cy]: N }, j4] }, { [cw]: i4, [cx]: [aS, "partition"] }] }], [cu]: [{ endpoint: { [cA]: "https://{accessPointName}.accesspoint.s3-global.{mrapPartition#dnsSuffix}", [cB]: { [cD]: [{ [cE]: c4, name: z2, [cF]: B2, [cI]: cb }] }, [cH]: al }, [ct]: n4 }], [ct]: o4 }, { error: "Client was configured for partition `{mrapPartition#name}` but bucket referred to partition `{bucketArn#partition}`", [ct]: f4 }], [ct]: o4 }], [ct]: o4 }, { error: "Invalid Access Point Name", [ct]: f4 }], [ct]: o4 }, bi], [ct]: o4 }, { [cv]: [{ [cw]: h4, [cx]: [aU, A2] }], [cu]: [{ [cv]: ch, error: "S3 Outposts does not support Dual-stack", [ct]: f4 }, { [cv]: cq, error: "S3 Outposts does not support FIPS", [ct]: f4 }, { [cv]: bB, error: "S3 Outposts does not support S3 Accelerate", [ct]: f4 }, { [cv]: [{ [cw]: d4, [cx]: [{ [cw]: i4, [cx]: [aS, "resourceId[4]"] }] }], error: "Invalid Arn: Outpost Access Point ARN contains sub resources", [ct]: f4 }, { [cv]: [{ [cw]: i4, [cx]: cg, [cz]: x4 }], [cu]: [{ [cv]: bZ, [cu]: [aZ, { [cv]: cl, [cu]: [{ [cv]: bG, [cu]: [{ [cv]: cm, [cu]: [{ [cv]: cn, [cu]: [{ [cv]: co, [cu]: [{ [cv]: [{ [cw]: i4, [cx]: ck, [cz]: O }], [cu]: [{ [cv]: [{ [cw]: i4, [cx]: [aS, "resourceId[3]"], [cz]: L }], [cu]: [{ [cv]: [{ [cw]: h4, [cx]: [{ [cy]: O }, K] }], [cu]: [{ [cv]: bC, endpoint: { [cA]: "https://{accessPointName}-{bucketArn#accountId}.{outpostId}.{url#authority}", [cB]: bk, [cH]: al }, [ct]: n4 }, { endpoint: { [cA]: "https://{accessPointName}-{bucketArn#accountId}.{outpostId}.s3-outposts.{bucketArn#region}.{bucketPartition#dnsSuffix}", [cB]: bk, [cH]: al }, [ct]: n4 }], [ct]: o4 }, { error: "Expected an outpost type `accesspoint`, found {outpostType}", [ct]: f4 }], [ct]: o4 }, { error: "Invalid ARN: expected an access point name", [ct]: f4 }], [ct]: o4 }, { error: "Invalid ARN: Expected a 4-component resource", [ct]: f4 }], [ct]: o4 }, be], [ct]: o4 }, bf], [ct]: o4 }, bg], [ct]: o4 }], [ct]: o4 }], [ct]: o4 }, { error: "Invalid ARN: The outpost Id may only contain a-z, A-Z, 0-9 and `-`. Found: `{outpostId}`", [ct]: f4 }], [ct]: o4 }, { error: "Invalid ARN: The Outpost Id was not set", [ct]: f4 }], [ct]: o4 }, { error: "Invalid ARN: Unrecognized format: {Bucket} (type: {arnType})", [ct]: f4 }], [ct]: o4 }, { error: "Invalid ARN: No ARN type specified", [ct]: f4 }], [ct]: o4 }, { [cv]: [{ [cw]: k4, [cx]: [ad, 0, 4, b4], [cz]: P }, { [cw]: h4, [cx]: [{ [cy]: P }, "arn:"] }, { [cw]: r4, [cx]: [{ [cw]: d4, [cx]: [bl] }] }], error: "Invalid ARN: `{Bucket}` was not a valid ARN", [ct]: f4 }, { [cv]: [{ [cw]: e4, [cx]: [az, c4] }, bl], error: "Path-style addressing cannot be used with ARN buckets", [ct]: f4 }, { [cv]: bE, [cu]: [{ [cv]: bG, [cu]: [{ [cv]: [aA], [cu]: [{ [cv]: [Y, aq, X, aB], endpoint: { [cA]: "https://s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cB]: aC, [cH]: al }, [ct]: n4 }, { [cv]: [Y, aq, X, aD, aE], [cu]: [{ endpoint: bm, [ct]: n4 }], [ct]: o4 }, { [cv]: [Y, aq, X, aD, aH], endpoint: bm, [ct]: n4 }, { [cv]: [ar, aq, X, aB], endpoint: { [cA]: "https://s3-fips.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cB]: aC, [cH]: al }, [ct]: n4 }, { [cv]: [ar, aq, X, aD, aE], [cu]: [{ endpoint: bn, [ct]: n4 }], [ct]: o4 }, { [cv]: [ar, aq, X, aD, aH], endpoint: bn, [ct]: n4 }, { [cv]: [Y, aq, as, aB], endpoint: { [cA]: "https://s3.dualstack.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [cB]: aC, [cH]: al }, [ct]: n4 }, { [cv]: [Y, aq, as, aD, aE], [cu]: [{ endpoint: bo, [ct]: n4 }], [ct]: o4 }, { [cv]: [Y, aq, as, aD, aH], endpoint: bo, [ct]: n4 }, { [cv]: [ar, Z, ag, as, aB], endpoint: { [cA]: Q, [cB]: aC, [cH]: al }, [ct]: n4 }, { [cv]: [ar, Z, ag, as, aD, aE], [cu]: [{ [cv]: cd, endpoint: bp, [ct]: n4 }, { endpoint: bp, [ct]: n4 }], [ct]: o4 }, { [cv]: [ar, Z, ag, as, aD, aH], endpoint: bp, [ct]: n4 }, { [cv]: [ar, aq, as, aB], endpoint: { [cA]: R, [cB]: aC, [cH]: al }, [ct]: n4 }, { [cv]: [ar, aq, as, aD, aE], [cu]: [{ [cv]: cd, endpoint: { [cA]: R, [cB]: aG, [cH]: al }, [ct]: n4 }, { endpoint: bq, [ct]: n4 }], [ct]: o4 }, { [cv]: [ar, aq, as, aD, aH], endpoint: bq, [ct]: n4 }], [ct]: o4 }, { error: "Path-style addressing cannot be used with S3 Accelerate", [ct]: f4 }], [ct]: o4 }], [ct]: o4 }], [ct]: o4 }, { [cv]: [{ [cw]: d4, [cx]: [br] }, { [cw]: e4, [cx]: [br, c4] }], [cu]: [{ [cv]: bG, [cu]: [{ [cv]: cr, [cu]: [aW, aX, { [cv]: bC, endpoint: { [cA]: t4, [cB]: bs, [cH]: al }, [ct]: n4 }, { [cv]: cq, endpoint: { [cA]: "https://s3-object-lambda-fips.{Region}.{partitionResult#dnsSuffix}", [cB]: bs, [cH]: al }, [ct]: n4 }, { endpoint: { [cA]: "https://s3-object-lambda.{Region}.{partitionResult#dnsSuffix}", [cB]: bs, [cH]: al }, [ct]: n4 }], [ct]: o4 }, aR], [ct]: o4 }], [ct]: o4 }, { [cv]: [au], [cu]: [{ [cv]: bG, [cu]: [{ [cv]: cr, [cu]: [{ [cv]: [X, Y, aq, aB], endpoint: { [cA]: "https://s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cB]: aC, [cH]: al }, [ct]: n4 }, { [cv]: [X, Y, aq, aD, aE], [cu]: [{ endpoint: bt, [ct]: n4 }], [ct]: o4 }, { [cv]: [X, Y, aq, aD, aH], endpoint: bt, [ct]: n4 }, { [cv]: [X, ar, aq, aB], endpoint: { [cA]: "https://s3-fips.us-east-1.{partitionResult#dnsSuffix}", [cB]: aC, [cH]: al }, [ct]: n4 }, { [cv]: [X, ar, aq, aD, aE], [cu]: [{ endpoint: bu, [ct]: n4 }], [ct]: o4 }, { [cv]: [X, ar, aq, aD, aH], endpoint: bu, [ct]: n4 }, { [cv]: [as, Y, aq, aB], endpoint: { [cA]: "https://s3.dualstack.us-east-1.{partitionResult#dnsSuffix}", [cB]: aC, [cH]: al }, [ct]: n4 }, { [cv]: [as, Y, aq, aD, aE], [cu]: [{ endpoint: bv, [ct]: n4 }], [ct]: o4 }, { [cv]: [as, Y, aq, aD, aH], endpoint: bv, [ct]: n4 }, { [cv]: [as, ar, Z, ag, aB], endpoint: { [cA]: t4, [cB]: aC, [cH]: al }, [ct]: n4 }, { [cv]: [as, ar, Z, ag, aD, aE], [cu]: [{ [cv]: cd, endpoint: bw, [ct]: n4 }, { endpoint: bw, [ct]: n4 }], [ct]: o4 }, { [cv]: [as, ar, Z, ag, aD, aH], endpoint: bw, [ct]: n4 }, { [cv]: [as, ar, aq, aB], endpoint: { [cA]: S, [cB]: aC, [cH]: al }, [ct]: n4 }, { [cv]: [as, ar, aq, aD, aE], [cu]: [{ [cv]: cd, endpoint: { [cA]: S, [cB]: aG, [cH]: al }, [ct]: n4 }, { endpoint: bx, [ct]: n4 }], [ct]: o4 }, { [cv]: [as, ar, aq, aD, aH], endpoint: bx, [ct]: n4 }], [ct]: o4 }, aR], [ct]: o4 }], [ct]: o4 }], [ct]: o4 }, { error: "A region must be set when sending requests to S3.", [ct]: f4 }] };
    exports2.ruleSet = _data4;
  }
});

// node_modules/.pnpm/@aws-sdk+client-s3@3.971.0/node_modules/@aws-sdk/client-s3/dist-cjs/endpoint/endpointResolver.js
var require_endpointResolver = __commonJS({
  "node_modules/.pnpm/@aws-sdk+client-s3@3.971.0/node_modules/@aws-sdk/client-s3/dist-cjs/endpoint/endpointResolver.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultEndpointResolver = void 0;
    var util_endpoints_1 = require_dist_cjs36();
    var util_endpoints_2 = require_dist_cjs33();
    var ruleset_1 = require_ruleset();
    var cache5 = new util_endpoints_2.EndpointCache({
      size: 50,
      params: [
        "Accelerate",
        "Bucket",
        "DisableAccessPoints",
        "DisableMultiRegionAccessPoints",
        "DisableS3ExpressSessionAuth",
        "Endpoint",
        "ForcePathStyle",
        "Region",
        "UseArnRegion",
        "UseDualStack",
        "UseFIPS",
        "UseGlobalEndpoint",
        "UseObjectLambdaEndpoint",
        "UseS3ExpressControlEndpoint"
      ]
    });
    var defaultEndpointResolver4 = (endpointParams, context = {}) => {
      return cache5.get(endpointParams, () => (0, util_endpoints_2.resolveEndpoint)(ruleset_1.ruleSet, {
        endpointParams,
        logger: context.logger
      }));
    };
    exports2.defaultEndpointResolver = defaultEndpointResolver4;
    util_endpoints_2.customEndpointFunctions.aws = util_endpoints_1.awsEndpointFunctions;
  }
});

// node_modules/.pnpm/@aws-sdk+client-s3@3.971.0/node_modules/@aws-sdk/client-s3/dist-cjs/auth/httpAuthSchemeProvider.js
var require_httpAuthSchemeProvider = __commonJS({
  "node_modules/.pnpm/@aws-sdk+client-s3@3.971.0/node_modules/@aws-sdk/client-s3/dist-cjs/auth/httpAuthSchemeProvider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveHttpAuthSchemeConfig = exports2.defaultS3HttpAuthSchemeProvider = exports2.defaultS3HttpAuthSchemeParametersProvider = void 0;
    var core_1 = (init_dist_es2(), __toCommonJS(dist_es_exports2));
    var signature_v4_multi_region_1 = require_dist_cjs47();
    var middleware_endpoint_1 = require_dist_cjs43();
    var util_middleware_1 = require_dist_cjs4();
    var endpointResolver_1 = require_endpointResolver();
    var createEndpointRuleSetHttpAuthSchemeParametersProvider = (defaultHttpAuthSchemeParametersProvider) => async (config, context, input) => {
      if (!input) {
        throw new Error("Could not find `input` for `defaultEndpointRuleSetHttpAuthSchemeParametersProvider`");
      }
      const defaultParameters = await defaultHttpAuthSchemeParametersProvider(config, context, input);
      const instructionsFn = (0, util_middleware_1.getSmithyContext)(context)?.commandInstance?.constructor?.getEndpointParameterInstructions;
      if (!instructionsFn) {
        throw new Error(`getEndpointParameterInstructions() is not defined on '${context.commandName}'`);
      }
      const endpointParameters = await (0, middleware_endpoint_1.resolveParams)(input, { getEndpointParameterInstructions: instructionsFn }, config);
      return Object.assign(defaultParameters, endpointParameters);
    };
    var _defaultS3HttpAuthSchemeParametersProvider = async (config, context, input) => {
      return {
        operation: (0, util_middleware_1.getSmithyContext)(context).operation,
        region: await (0, util_middleware_1.normalizeProvider)(config.region)() || (() => {
          throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
        })()
      };
    };
    exports2.defaultS3HttpAuthSchemeParametersProvider = createEndpointRuleSetHttpAuthSchemeParametersProvider(_defaultS3HttpAuthSchemeParametersProvider);
    function createAwsAuthSigv4HttpAuthOption4(authParameters) {
      return {
        schemeId: "aws.auth#sigv4",
        signingProperties: {
          name: "s3",
          region: authParameters.region
        },
        propertiesExtractor: (config, context) => ({
          signingProperties: {
            config,
            context
          }
        })
      };
    }
    function createAwsAuthSigv4aHttpAuthOption(authParameters) {
      return {
        schemeId: "aws.auth#sigv4a",
        signingProperties: {
          name: "s3",
          region: authParameters.region
        },
        propertiesExtractor: (config, context) => ({
          signingProperties: {
            config,
            context
          }
        })
      };
    }
    var createEndpointRuleSetHttpAuthSchemeProvider = (defaultEndpointResolver4, defaultHttpAuthSchemeResolver, createHttpAuthOptionFunctions) => {
      const endpointRuleSetHttpAuthSchemeProvider = (authParameters) => {
        const endpoint = defaultEndpointResolver4(authParameters);
        const authSchemes = endpoint.properties?.authSchemes;
        if (!authSchemes) {
          return defaultHttpAuthSchemeResolver(authParameters);
        }
        const options = [];
        for (const scheme of authSchemes) {
          const { name: resolvedName, properties = {}, ...rest } = scheme;
          const name = resolvedName.toLowerCase();
          if (resolvedName !== name) {
            console.warn(`HttpAuthScheme has been normalized with lowercasing: '${resolvedName}' to '${name}'`);
          }
          let schemeId;
          if (name === "sigv4a") {
            schemeId = "aws.auth#sigv4a";
            const sigv4Present = authSchemes.find((s4) => {
              const name2 = s4.name.toLowerCase();
              return name2 !== "sigv4a" && name2.startsWith("sigv4");
            });
            if (signature_v4_multi_region_1.SignatureV4MultiRegion.sigv4aDependency() === "none" && sigv4Present) {
              continue;
            }
          } else if (name.startsWith("sigv4")) {
            schemeId = "aws.auth#sigv4";
          } else {
            throw new Error(`Unknown HttpAuthScheme found in '@smithy.rules#endpointRuleSet': '${name}'`);
          }
          const createOption = createHttpAuthOptionFunctions[schemeId];
          if (!createOption) {
            throw new Error(`Could not find HttpAuthOption create function for '${schemeId}'`);
          }
          const option = createOption(authParameters);
          option.schemeId = schemeId;
          option.signingProperties = { ...option.signingProperties || {}, ...rest, ...properties };
          options.push(option);
        }
        return options;
      };
      return endpointRuleSetHttpAuthSchemeProvider;
    };
    var _defaultS3HttpAuthSchemeProvider = (authParameters) => {
      const options = [];
      switch (authParameters.operation) {
        default: {
          options.push(createAwsAuthSigv4HttpAuthOption4(authParameters));
          options.push(createAwsAuthSigv4aHttpAuthOption(authParameters));
        }
      }
      return options;
    };
    exports2.defaultS3HttpAuthSchemeProvider = createEndpointRuleSetHttpAuthSchemeProvider(endpointResolver_1.defaultEndpointResolver, _defaultS3HttpAuthSchemeProvider, {
      "aws.auth#sigv4": createAwsAuthSigv4HttpAuthOption4,
      "aws.auth#sigv4a": createAwsAuthSigv4aHttpAuthOption
    });
    var resolveHttpAuthSchemeConfig4 = (config) => {
      const config_0 = (0, core_1.resolveAwsSdkSigV4Config)(config);
      const config_1 = (0, core_1.resolveAwsSdkSigV4AConfig)(config_0);
      return Object.assign(config_1, {
        authSchemePreference: (0, util_middleware_1.normalizeProvider)(config.authSchemePreference ?? [])
      });
    };
    exports2.resolveHttpAuthSchemeConfig = resolveHttpAuthSchemeConfig4;
  }
});

// node_modules/.pnpm/@aws-sdk+client-s3@3.971.0/node_modules/@aws-sdk/client-s3/package.json
var require_package = __commonJS({
  "node_modules/.pnpm/@aws-sdk+client-s3@3.971.0/node_modules/@aws-sdk/client-s3/package.json"(exports2, module2) {
    module2.exports = {
      name: "@aws-sdk/client-s3",
      description: "AWS SDK for JavaScript S3 Client for Node.js, Browser and React Native",
      version: "3.971.0",
      scripts: {
        build: "concurrently 'yarn:build:types' 'yarn:build:es' && yarn build:cjs",
        "build:cjs": "node ../../scripts/compilation/inline client-s3",
        "build:es": "tsc -p tsconfig.es.json",
        "build:include:deps": 'yarn g:turbo run build -F="$npm_package_name"',
        "build:types": "tsc -p tsconfig.types.json",
        "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
        clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
        "extract:docs": "api-extractor run --local",
        "generate:client": "node ../../scripts/generate-clients/single-service --solo s3",
        test: "yarn g:vitest run",
        "test:browser": "node ./test/browser-build/esbuild && yarn g:vitest run -c vitest.config.browser.mts",
        "test:browser:watch": "node ./test/browser-build/esbuild && yarn g:vitest watch -c vitest.config.browser.mts",
        "test:e2e": "yarn g:vitest run -c vitest.config.e2e.mts && yarn test:browser",
        "test:e2e:watch": "yarn g:vitest watch -c vitest.config.e2e.mts",
        "test:index": "tsc --noEmit ./test/index-types.ts && node ./test/index-objects.spec.mjs",
        "test:integration": "yarn g:vitest run -c vitest.config.integ.mts",
        "test:integration:watch": "yarn g:vitest watch -c vitest.config.integ.mts",
        "test:watch": "yarn g:vitest watch"
      },
      main: "./dist-cjs/index.js",
      types: "./dist-types/index.d.ts",
      module: "./dist-es/index.js",
      sideEffects: false,
      dependencies: {
        "@aws-crypto/sha1-browser": "5.2.0",
        "@aws-crypto/sha256-browser": "5.2.0",
        "@aws-crypto/sha256-js": "5.2.0",
        "@aws-sdk/core": "3.970.0",
        "@aws-sdk/credential-provider-node": "3.971.0",
        "@aws-sdk/middleware-bucket-endpoint": "3.969.0",
        "@aws-sdk/middleware-expect-continue": "3.969.0",
        "@aws-sdk/middleware-flexible-checksums": "3.971.0",
        "@aws-sdk/middleware-host-header": "3.969.0",
        "@aws-sdk/middleware-location-constraint": "3.969.0",
        "@aws-sdk/middleware-logger": "3.969.0",
        "@aws-sdk/middleware-recursion-detection": "3.969.0",
        "@aws-sdk/middleware-sdk-s3": "3.970.0",
        "@aws-sdk/middleware-ssec": "3.971.0",
        "@aws-sdk/middleware-user-agent": "3.970.0",
        "@aws-sdk/region-config-resolver": "3.969.0",
        "@aws-sdk/signature-v4-multi-region": "3.970.0",
        "@aws-sdk/types": "3.969.0",
        "@aws-sdk/util-endpoints": "3.970.0",
        "@aws-sdk/util-user-agent-browser": "3.969.0",
        "@aws-sdk/util-user-agent-node": "3.971.0",
        "@smithy/config-resolver": "^4.4.6",
        "@smithy/core": "^3.20.6",
        "@smithy/eventstream-serde-browser": "^4.2.8",
        "@smithy/eventstream-serde-config-resolver": "^4.3.8",
        "@smithy/eventstream-serde-node": "^4.2.8",
        "@smithy/fetch-http-handler": "^5.3.9",
        "@smithy/hash-blob-browser": "^4.2.9",
        "@smithy/hash-node": "^4.2.8",
        "@smithy/hash-stream-node": "^4.2.8",
        "@smithy/invalid-dependency": "^4.2.8",
        "@smithy/md5-js": "^4.2.8",
        "@smithy/middleware-content-length": "^4.2.8",
        "@smithy/middleware-endpoint": "^4.4.7",
        "@smithy/middleware-retry": "^4.4.23",
        "@smithy/middleware-serde": "^4.2.9",
        "@smithy/middleware-stack": "^4.2.8",
        "@smithy/node-config-provider": "^4.3.8",
        "@smithy/node-http-handler": "^4.4.8",
        "@smithy/protocol-http": "^5.3.8",
        "@smithy/smithy-client": "^4.10.8",
        "@smithy/types": "^4.12.0",
        "@smithy/url-parser": "^4.2.8",
        "@smithy/util-base64": "^4.3.0",
        "@smithy/util-body-length-browser": "^4.2.0",
        "@smithy/util-body-length-node": "^4.2.1",
        "@smithy/util-defaults-mode-browser": "^4.3.22",
        "@smithy/util-defaults-mode-node": "^4.2.25",
        "@smithy/util-endpoints": "^3.2.8",
        "@smithy/util-middleware": "^4.2.8",
        "@smithy/util-retry": "^4.2.8",
        "@smithy/util-stream": "^4.5.10",
        "@smithy/util-utf8": "^4.2.0",
        "@smithy/util-waiter": "^4.2.8",
        tslib: "^2.6.2"
      },
      devDependencies: {
        "@aws-sdk/signature-v4-crt": "3.971.0",
        "@tsconfig/node20": "20.1.8",
        "@types/node": "^20.14.8",
        concurrently: "7.0.0",
        "downlevel-dts": "0.10.1",
        rimraf: "5.0.10",
        typescript: "~5.8.3"
      },
      engines: {
        node: ">=20.0.0"
      },
      typesVersions: {
        "<4.0": {
          "dist-types/*": [
            "dist-types/ts3.4/*"
          ]
        }
      },
      files: [
        "dist-*/**"
      ],
      author: {
        name: "AWS SDK for JavaScript Team",
        url: "https://aws.amazon.com/javascript/"
      },
      license: "Apache-2.0",
      browser: {
        "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
      },
      "react-native": {
        "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
      },
      homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-s3",
      repository: {
        type: "git",
        url: "https://github.com/aws/aws-sdk-js-v3.git",
        directory: "clients/client-s3"
      }
    };
  }
});

// node_modules/.pnpm/@aws-sdk+credential-provider-env@3.970.0/node_modules/@aws-sdk/credential-provider-env/dist-cjs/index.js
var require_dist_cjs48 = __commonJS({
  "node_modules/.pnpm/@aws-sdk+credential-provider-env@3.970.0/node_modules/@aws-sdk/credential-provider-env/dist-cjs/index.js"(exports2) {
    "use strict";
    var client2 = (init_client(), __toCommonJS(client_exports));
    var propertyProvider = require_dist_cjs17();
    var ENV_KEY = "AWS_ACCESS_KEY_ID";
    var ENV_SECRET = "AWS_SECRET_ACCESS_KEY";
    var ENV_SESSION = "AWS_SESSION_TOKEN";
    var ENV_EXPIRATION = "AWS_CREDENTIAL_EXPIRATION";
    var ENV_CREDENTIAL_SCOPE = "AWS_CREDENTIAL_SCOPE";
    var ENV_ACCOUNT_ID = "AWS_ACCOUNT_ID";
    var fromEnv = (init) => async () => {
      init?.logger?.debug("@aws-sdk/credential-provider-env - fromEnv");
      const accessKeyId = process.env[ENV_KEY];
      const secretAccessKey = process.env[ENV_SECRET];
      const sessionToken = process.env[ENV_SESSION];
      const expiry = process.env[ENV_EXPIRATION];
      const credentialScope = process.env[ENV_CREDENTIAL_SCOPE];
      const accountId = process.env[ENV_ACCOUNT_ID];
      if (accessKeyId && secretAccessKey) {
        const credentials = {
          accessKeyId,
          secretAccessKey,
          ...sessionToken && { sessionToken },
          ...expiry && { expiration: new Date(expiry) },
          ...credentialScope && { credentialScope },
          ...accountId && { accountId }
        };
        client2.setCredentialFeature(credentials, "CREDENTIALS_ENV_VARS", "g");
        return credentials;
      }
      throw new propertyProvider.CredentialsProviderError("Unable to find environment variable credentials.", { logger: init?.logger });
    };
    exports2.ENV_ACCOUNT_ID = ENV_ACCOUNT_ID;
    exports2.ENV_CREDENTIAL_SCOPE = ENV_CREDENTIAL_SCOPE;
    exports2.ENV_EXPIRATION = ENV_EXPIRATION;
    exports2.ENV_KEY = ENV_KEY;
    exports2.ENV_SECRET = ENV_SECRET;
    exports2.ENV_SESSION = ENV_SESSION;
    exports2.fromEnv = fromEnv;
  }
});

// node_modules/.pnpm/@smithy+credential-provider-imds@4.2.8/node_modules/@smithy/credential-provider-imds/dist-cjs/index.js
var require_dist_cjs49 = __commonJS({
  "node_modules/.pnpm/@smithy+credential-provider-imds@4.2.8/node_modules/@smithy/credential-provider-imds/dist-cjs/index.js"(exports2) {
    "use strict";
    var propertyProvider = require_dist_cjs17();
    var url = require("url");
    var buffer = require("buffer");
    var http = require("http");
    var nodeConfigProvider = require_dist_cjs42();
    var urlParser = require_dist_cjs35();
    function httpRequest(options) {
      return new Promise((resolve, reject) => {
        const req = http.request({
          method: "GET",
          ...options,
          hostname: options.hostname?.replace(/^\[(.+)\]$/, "$1")
        });
        req.on("error", (err) => {
          reject(Object.assign(new propertyProvider.ProviderError("Unable to connect to instance metadata service"), err));
          req.destroy();
        });
        req.on("timeout", () => {
          reject(new propertyProvider.ProviderError("TimeoutError from instance metadata service"));
          req.destroy();
        });
        req.on("response", (res) => {
          const { statusCode = 400 } = res;
          if (statusCode < 200 || 300 <= statusCode) {
            reject(Object.assign(new propertyProvider.ProviderError("Error response received from instance metadata service"), { statusCode }));
            req.destroy();
          }
          const chunks = [];
          res.on("data", (chunk2) => {
            chunks.push(chunk2);
          });
          res.on("end", () => {
            resolve(buffer.Buffer.concat(chunks));
            req.destroy();
          });
        });
        req.end();
      });
    }
    var isImdsCredentials = (arg) => Boolean(arg) && typeof arg === "object" && typeof arg.AccessKeyId === "string" && typeof arg.SecretAccessKey === "string" && typeof arg.Token === "string" && typeof arg.Expiration === "string";
    var fromImdsCredentials = (creds) => ({
      accessKeyId: creds.AccessKeyId,
      secretAccessKey: creds.SecretAccessKey,
      sessionToken: creds.Token,
      expiration: new Date(creds.Expiration),
      ...creds.AccountId && { accountId: creds.AccountId }
    });
    var DEFAULT_TIMEOUT = 1e3;
    var DEFAULT_MAX_RETRIES = 0;
    var providerConfigFromInit = ({ maxRetries = DEFAULT_MAX_RETRIES, timeout = DEFAULT_TIMEOUT }) => ({ maxRetries, timeout });
    var retry2 = (toRetry, maxRetries) => {
      let promise2 = toRetry();
      for (let i4 = 0; i4 < maxRetries; i4++) {
        promise2 = promise2.catch(toRetry);
      }
      return promise2;
    };
    var ENV_CMDS_FULL_URI = "AWS_CONTAINER_CREDENTIALS_FULL_URI";
    var ENV_CMDS_RELATIVE_URI = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI";
    var ENV_CMDS_AUTH_TOKEN = "AWS_CONTAINER_AUTHORIZATION_TOKEN";
    var fromContainerMetadata = (init = {}) => {
      const { timeout, maxRetries } = providerConfigFromInit(init);
      return () => retry2(async () => {
        const requestOptions = await getCmdsUri({ logger: init.logger });
        const credsResponse = JSON.parse(await requestFromEcsImds(timeout, requestOptions));
        if (!isImdsCredentials(credsResponse)) {
          throw new propertyProvider.CredentialsProviderError("Invalid response received from instance metadata service.", {
            logger: init.logger
          });
        }
        return fromImdsCredentials(credsResponse);
      }, maxRetries);
    };
    var requestFromEcsImds = async (timeout, options) => {
      if (process.env[ENV_CMDS_AUTH_TOKEN]) {
        options.headers = {
          ...options.headers,
          Authorization: process.env[ENV_CMDS_AUTH_TOKEN]
        };
      }
      const buffer2 = await httpRequest({
        ...options,
        timeout
      });
      return buffer2.toString();
    };
    var CMDS_IP = "169.254.170.2";
    var GREENGRASS_HOSTS = {
      localhost: true,
      "127.0.0.1": true
    };
    var GREENGRASS_PROTOCOLS = {
      "http:": true,
      "https:": true
    };
    var getCmdsUri = async ({ logger: logger3 }) => {
      if (process.env[ENV_CMDS_RELATIVE_URI]) {
        return {
          hostname: CMDS_IP,
          path: process.env[ENV_CMDS_RELATIVE_URI]
        };
      }
      if (process.env[ENV_CMDS_FULL_URI]) {
        const parsed = url.parse(process.env[ENV_CMDS_FULL_URI]);
        if (!parsed.hostname || !(parsed.hostname in GREENGRASS_HOSTS)) {
          throw new propertyProvider.CredentialsProviderError(`${parsed.hostname} is not a valid container metadata service hostname`, {
            tryNextLink: false,
            logger: logger3
          });
        }
        if (!parsed.protocol || !(parsed.protocol in GREENGRASS_PROTOCOLS)) {
          throw new propertyProvider.CredentialsProviderError(`${parsed.protocol} is not a valid container metadata service protocol`, {
            tryNextLink: false,
            logger: logger3
          });
        }
        return {
          ...parsed,
          port: parsed.port ? parseInt(parsed.port, 10) : void 0
        };
      }
      throw new propertyProvider.CredentialsProviderError(`The container metadata credential provider cannot be used unless the ${ENV_CMDS_RELATIVE_URI} or ${ENV_CMDS_FULL_URI} environment variable is set`, {
        tryNextLink: false,
        logger: logger3
      });
    };
    var InstanceMetadataV1FallbackError = class _InstanceMetadataV1FallbackError extends propertyProvider.CredentialsProviderError {
      tryNextLink;
      name = "InstanceMetadataV1FallbackError";
      constructor(message, tryNextLink = true) {
        super(message, tryNextLink);
        this.tryNextLink = tryNextLink;
        Object.setPrototypeOf(this, _InstanceMetadataV1FallbackError.prototype);
      }
    };
    exports2.Endpoint = void 0;
    (function(Endpoint) {
      Endpoint["IPv4"] = "http://169.254.169.254";
      Endpoint["IPv6"] = "http://[fd00:ec2::254]";
    })(exports2.Endpoint || (exports2.Endpoint = {}));
    var ENV_ENDPOINT_NAME = "AWS_EC2_METADATA_SERVICE_ENDPOINT";
    var CONFIG_ENDPOINT_NAME = "ec2_metadata_service_endpoint";
    var ENDPOINT_CONFIG_OPTIONS = {
      environmentVariableSelector: (env) => env[ENV_ENDPOINT_NAME],
      configFileSelector: (profile) => profile[CONFIG_ENDPOINT_NAME],
      default: void 0
    };
    var EndpointMode;
    (function(EndpointMode2) {
      EndpointMode2["IPv4"] = "IPv4";
      EndpointMode2["IPv6"] = "IPv6";
    })(EndpointMode || (EndpointMode = {}));
    var ENV_ENDPOINT_MODE_NAME = "AWS_EC2_METADATA_SERVICE_ENDPOINT_MODE";
    var CONFIG_ENDPOINT_MODE_NAME = "ec2_metadata_service_endpoint_mode";
    var ENDPOINT_MODE_CONFIG_OPTIONS = {
      environmentVariableSelector: (env) => env[ENV_ENDPOINT_MODE_NAME],
      configFileSelector: (profile) => profile[CONFIG_ENDPOINT_MODE_NAME],
      default: EndpointMode.IPv4
    };
    var getInstanceMetadataEndpoint = async () => urlParser.parseUrl(await getFromEndpointConfig() || await getFromEndpointModeConfig());
    var getFromEndpointConfig = async () => nodeConfigProvider.loadConfig(ENDPOINT_CONFIG_OPTIONS)();
    var getFromEndpointModeConfig = async () => {
      const endpointMode = await nodeConfigProvider.loadConfig(ENDPOINT_MODE_CONFIG_OPTIONS)();
      switch (endpointMode) {
        case EndpointMode.IPv4:
          return exports2.Endpoint.IPv4;
        case EndpointMode.IPv6:
          return exports2.Endpoint.IPv6;
        default:
          throw new Error(`Unsupported endpoint mode: ${endpointMode}. Select from ${Object.values(EndpointMode)}`);
      }
    };
    var STATIC_STABILITY_REFRESH_INTERVAL_SECONDS = 5 * 60;
    var STATIC_STABILITY_REFRESH_INTERVAL_JITTER_WINDOW_SECONDS = 5 * 60;
    var STATIC_STABILITY_DOC_URL = "https://docs.aws.amazon.com/sdkref/latest/guide/feature-static-credentials.html";
    var getExtendedInstanceMetadataCredentials = (credentials, logger3) => {
      const refreshInterval = STATIC_STABILITY_REFRESH_INTERVAL_SECONDS + Math.floor(Math.random() * STATIC_STABILITY_REFRESH_INTERVAL_JITTER_WINDOW_SECONDS);
      const newExpiration = new Date(Date.now() + refreshInterval * 1e3);
      logger3.warn(`Attempting credential expiration extension due to a credential service availability issue. A refresh of these credentials will be attempted after ${new Date(newExpiration)}.
For more information, please visit: ` + STATIC_STABILITY_DOC_URL);
      const originalExpiration = credentials.originalExpiration ?? credentials.expiration;
      return {
        ...credentials,
        ...originalExpiration ? { originalExpiration } : {},
        expiration: newExpiration
      };
    };
    var staticStabilityProvider = (provider, options = {}) => {
      const logger3 = options?.logger || console;
      let pastCredentials;
      return async () => {
        let credentials;
        try {
          credentials = await provider();
          if (credentials.expiration && credentials.expiration.getTime() < Date.now()) {
            credentials = getExtendedInstanceMetadataCredentials(credentials, logger3);
          }
        } catch (e4) {
          if (pastCredentials) {
            logger3.warn("Credential renew failed: ", e4);
            credentials = getExtendedInstanceMetadataCredentials(pastCredentials, logger3);
          } else {
            throw e4;
          }
        }
        pastCredentials = credentials;
        return credentials;
      };
    };
    var IMDS_PATH = "/latest/meta-data/iam/security-credentials/";
    var IMDS_TOKEN_PATH = "/latest/api/token";
    var AWS_EC2_METADATA_V1_DISABLED = "AWS_EC2_METADATA_V1_DISABLED";
    var PROFILE_AWS_EC2_METADATA_V1_DISABLED = "ec2_metadata_v1_disabled";
    var X_AWS_EC2_METADATA_TOKEN = "x-aws-ec2-metadata-token";
    var fromInstanceMetadata = (init = {}) => staticStabilityProvider(getInstanceMetadataProvider(init), { logger: init.logger });
    var getInstanceMetadataProvider = (init = {}) => {
      let disableFetchToken = false;
      const { logger: logger3, profile } = init;
      const { timeout, maxRetries } = providerConfigFromInit(init);
      const getCredentials = async (maxRetries2, options) => {
        const isImdsV1Fallback = disableFetchToken || options.headers?.[X_AWS_EC2_METADATA_TOKEN] == null;
        if (isImdsV1Fallback) {
          let fallbackBlockedFromProfile = false;
          let fallbackBlockedFromProcessEnv = false;
          const configValue = await nodeConfigProvider.loadConfig({
            environmentVariableSelector: (env) => {
              const envValue = env[AWS_EC2_METADATA_V1_DISABLED];
              fallbackBlockedFromProcessEnv = !!envValue && envValue !== "false";
              if (envValue === void 0) {
                throw new propertyProvider.CredentialsProviderError(`${AWS_EC2_METADATA_V1_DISABLED} not set in env, checking config file next.`, { logger: init.logger });
              }
              return fallbackBlockedFromProcessEnv;
            },
            configFileSelector: (profile2) => {
              const profileValue = profile2[PROFILE_AWS_EC2_METADATA_V1_DISABLED];
              fallbackBlockedFromProfile = !!profileValue && profileValue !== "false";
              return fallbackBlockedFromProfile;
            },
            default: false
          }, {
            profile
          })();
          if (init.ec2MetadataV1Disabled || configValue) {
            const causes = [];
            if (init.ec2MetadataV1Disabled)
              causes.push("credential provider initialization (runtime option ec2MetadataV1Disabled)");
            if (fallbackBlockedFromProfile)
              causes.push(`config file profile (${PROFILE_AWS_EC2_METADATA_V1_DISABLED})`);
            if (fallbackBlockedFromProcessEnv)
              causes.push(`process environment variable (${AWS_EC2_METADATA_V1_DISABLED})`);
            throw new InstanceMetadataV1FallbackError(`AWS EC2 Metadata v1 fallback has been blocked by AWS SDK configuration in the following: [${causes.join(", ")}].`);
          }
        }
        const imdsProfile = (await retry2(async () => {
          let profile2;
          try {
            profile2 = await getProfile(options);
          } catch (err) {
            if (err.statusCode === 401) {
              disableFetchToken = false;
            }
            throw err;
          }
          return profile2;
        }, maxRetries2)).trim();
        return retry2(async () => {
          let creds;
          try {
            creds = await getCredentialsFromProfile(imdsProfile, options, init);
          } catch (err) {
            if (err.statusCode === 401) {
              disableFetchToken = false;
            }
            throw err;
          }
          return creds;
        }, maxRetries2);
      };
      return async () => {
        const endpoint = await getInstanceMetadataEndpoint();
        if (disableFetchToken) {
          logger3?.debug("AWS SDK Instance Metadata", "using v1 fallback (no token fetch)");
          return getCredentials(maxRetries, { ...endpoint, timeout });
        } else {
          let token;
          try {
            token = (await getMetadataToken({ ...endpoint, timeout })).toString();
          } catch (error2) {
            if (error2?.statusCode === 400) {
              throw Object.assign(error2, {
                message: "EC2 Metadata token request returned error"
              });
            } else if (error2.message === "TimeoutError" || [403, 404, 405].includes(error2.statusCode)) {
              disableFetchToken = true;
            }
            logger3?.debug("AWS SDK Instance Metadata", "using v1 fallback (initial)");
            return getCredentials(maxRetries, { ...endpoint, timeout });
          }
          return getCredentials(maxRetries, {
            ...endpoint,
            headers: {
              [X_AWS_EC2_METADATA_TOKEN]: token
            },
            timeout
          });
        }
      };
    };
    var getMetadataToken = async (options) => httpRequest({
      ...options,
      path: IMDS_TOKEN_PATH,
      method: "PUT",
      headers: {
        "x-aws-ec2-metadata-token-ttl-seconds": "21600"
      }
    });
    var getProfile = async (options) => (await httpRequest({ ...options, path: IMDS_PATH })).toString();
    var getCredentialsFromProfile = async (profile, options, init) => {
      const credentialsResponse = JSON.parse((await httpRequest({
        ...options,
        path: IMDS_PATH + profile
      })).toString());
      if (!isImdsCredentials(credentialsResponse)) {
        throw new propertyProvider.CredentialsProviderError("Invalid response received from instance metadata service.", {
          logger: init.logger
        });
      }
      return fromImdsCredentials(credentialsResponse);
    };
    exports2.DEFAULT_MAX_RETRIES = DEFAULT_MAX_RETRIES;
    exports2.DEFAULT_TIMEOUT = DEFAULT_TIMEOUT;
    exports2.ENV_CMDS_AUTH_TOKEN = ENV_CMDS_AUTH_TOKEN;
    exports2.ENV_CMDS_FULL_URI = ENV_CMDS_FULL_URI;
    exports2.ENV_CMDS_RELATIVE_URI = ENV_CMDS_RELATIVE_URI;
    exports2.fromContainerMetadata = fromContainerMetadata;
    exports2.fromInstanceMetadata = fromInstanceMetadata;
    exports2.getInstanceMetadataEndpoint = getInstanceMetadataEndpoint;
    exports2.httpRequest = httpRequest;
    exports2.providerConfigFromInit = providerConfigFromInit;
  }
});

// node_modules/.pnpm/@aws-sdk+credential-provider-http@3.970.0/node_modules/@aws-sdk/credential-provider-http/dist-cjs/fromHttp/checkUrl.js
var require_checkUrl = __commonJS({
  "node_modules/.pnpm/@aws-sdk+credential-provider-http@3.970.0/node_modules/@aws-sdk/credential-provider-http/dist-cjs/fromHttp/checkUrl.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.checkUrl = void 0;
    var property_provider_1 = require_dist_cjs17();
    var ECS_CONTAINER_HOST = "169.254.170.2";
    var EKS_CONTAINER_HOST_IPv4 = "169.254.170.23";
    var EKS_CONTAINER_HOST_IPv6 = "[fd00:ec2::23]";
    var checkUrl = (url, logger3) => {
      if (url.protocol === "https:") {
        return;
      }
      if (url.hostname === ECS_CONTAINER_HOST || url.hostname === EKS_CONTAINER_HOST_IPv4 || url.hostname === EKS_CONTAINER_HOST_IPv6) {
        return;
      }
      if (url.hostname.includes("[")) {
        if (url.hostname === "[::1]" || url.hostname === "[0000:0000:0000:0000:0000:0000:0000:0001]") {
          return;
        }
      } else {
        if (url.hostname === "localhost") {
          return;
        }
        const ipComponents = url.hostname.split(".");
        const inRange = (component) => {
          const num = parseInt(component, 10);
          return 0 <= num && num <= 255;
        };
        if (ipComponents[0] === "127" && inRange(ipComponents[1]) && inRange(ipComponents[2]) && inRange(ipComponents[3]) && ipComponents.length === 4) {
          return;
        }
      }
      throw new property_provider_1.CredentialsProviderError(`URL not accepted. It must either be HTTPS or match one of the following:
  - loopback CIDR 127.0.0.0/8 or [::1/128]
  - ECS container host 169.254.170.2
  - EKS container host 169.254.170.23 or [fd00:ec2::23]`, { logger: logger3 });
    };
    exports2.checkUrl = checkUrl;
  }
});

// node_modules/.pnpm/@aws-sdk+credential-provider-http@3.970.0/node_modules/@aws-sdk/credential-provider-http/dist-cjs/fromHttp/requestHelpers.js
var require_requestHelpers = __commonJS({
  "node_modules/.pnpm/@aws-sdk+credential-provider-http@3.970.0/node_modules/@aws-sdk/credential-provider-http/dist-cjs/fromHttp/requestHelpers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createGetRequest = createGetRequest;
    exports2.getCredentials = getCredentials;
    var property_provider_1 = require_dist_cjs17();
    var protocol_http_1 = require_dist_cjs2();
    var smithy_client_1 = require_dist_cjs20();
    var util_stream_1 = require_dist_cjs15();
    function createGetRequest(url) {
      return new protocol_http_1.HttpRequest({
        protocol: url.protocol,
        hostname: url.hostname,
        port: Number(url.port),
        path: url.pathname,
        query: Array.from(url.searchParams.entries()).reduce((acc, [k4, v4]) => {
          acc[k4] = v4;
          return acc;
        }, {}),
        fragment: url.hash
      });
    }
    async function getCredentials(response2, logger3) {
      const stream = (0, util_stream_1.sdkStreamMixin)(response2.body);
      const str = await stream.transformToString();
      if (response2.statusCode === 200) {
        const parsed = JSON.parse(str);
        if (typeof parsed.AccessKeyId !== "string" || typeof parsed.SecretAccessKey !== "string" || typeof parsed.Token !== "string" || typeof parsed.Expiration !== "string") {
          throw new property_provider_1.CredentialsProviderError("HTTP credential provider response not of the required format, an object matching: { AccessKeyId: string, SecretAccessKey: string, Token: string, Expiration: string(rfc3339) }", { logger: logger3 });
        }
        return {
          accessKeyId: parsed.AccessKeyId,
          secretAccessKey: parsed.SecretAccessKey,
          sessionToken: parsed.Token,
          expiration: (0, smithy_client_1.parseRfc3339DateTime)(parsed.Expiration)
        };
      }
      if (response2.statusCode >= 400 && response2.statusCode < 500) {
        let parsedBody = {};
        try {
          parsedBody = JSON.parse(str);
        } catch (e4) {
        }
        throw Object.assign(new property_provider_1.CredentialsProviderError(`Server responded with status: ${response2.statusCode}`, { logger: logger3 }), {
          Code: parsedBody.Code,
          Message: parsedBody.Message
        });
      }
      throw new property_provider_1.CredentialsProviderError(`Server responded with status: ${response2.statusCode}`, { logger: logger3 });
    }
  }
});

// node_modules/.pnpm/@aws-sdk+credential-provider-http@3.970.0/node_modules/@aws-sdk/credential-provider-http/dist-cjs/fromHttp/retry-wrapper.js
var require_retry_wrapper = __commonJS({
  "node_modules/.pnpm/@aws-sdk+credential-provider-http@3.970.0/node_modules/@aws-sdk/credential-provider-http/dist-cjs/fromHttp/retry-wrapper.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.retryWrapper = void 0;
    var retryWrapper = (toRetry, maxRetries, delayMs) => {
      return async () => {
        for (let i4 = 0; i4 < maxRetries; ++i4) {
          try {
            return await toRetry();
          } catch (e4) {
            await new Promise((resolve) => setTimeout(resolve, delayMs));
          }
        }
        return await toRetry();
      };
    };
    exports2.retryWrapper = retryWrapper;
  }
});

// node_modules/.pnpm/@aws-sdk+credential-provider-http@3.970.0/node_modules/@aws-sdk/credential-provider-http/dist-cjs/fromHttp/fromHttp.js
var require_fromHttp = __commonJS({
  "node_modules/.pnpm/@aws-sdk+credential-provider-http@3.970.0/node_modules/@aws-sdk/credential-provider-http/dist-cjs/fromHttp/fromHttp.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fromHttp = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var client_1 = (init_client(), __toCommonJS(client_exports));
    var node_http_handler_1 = require_dist_cjs12();
    var property_provider_1 = require_dist_cjs17();
    var promises_1 = tslib_1.__importDefault(require("fs/promises"));
    var checkUrl_1 = require_checkUrl();
    var requestHelpers_1 = require_requestHelpers();
    var retry_wrapper_1 = require_retry_wrapper();
    var AWS_CONTAINER_CREDENTIALS_RELATIVE_URI = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI";
    var DEFAULT_LINK_LOCAL_HOST = "http://169.254.170.2";
    var AWS_CONTAINER_CREDENTIALS_FULL_URI = "AWS_CONTAINER_CREDENTIALS_FULL_URI";
    var AWS_CONTAINER_AUTHORIZATION_TOKEN_FILE = "AWS_CONTAINER_AUTHORIZATION_TOKEN_FILE";
    var AWS_CONTAINER_AUTHORIZATION_TOKEN = "AWS_CONTAINER_AUTHORIZATION_TOKEN";
    var fromHttp = (options = {}) => {
      options.logger?.debug("@aws-sdk/credential-provider-http - fromHttp");
      let host;
      const relative = options.awsContainerCredentialsRelativeUri ?? process.env[AWS_CONTAINER_CREDENTIALS_RELATIVE_URI];
      const full = options.awsContainerCredentialsFullUri ?? process.env[AWS_CONTAINER_CREDENTIALS_FULL_URI];
      const token = options.awsContainerAuthorizationToken ?? process.env[AWS_CONTAINER_AUTHORIZATION_TOKEN];
      const tokenFile = options.awsContainerAuthorizationTokenFile ?? process.env[AWS_CONTAINER_AUTHORIZATION_TOKEN_FILE];
      const warn = options.logger?.constructor?.name === "NoOpLogger" || !options.logger?.warn ? console.warn : options.logger.warn.bind(options.logger);
      if (relative && full) {
        warn("@aws-sdk/credential-provider-http: you have set both awsContainerCredentialsRelativeUri and awsContainerCredentialsFullUri.");
        warn("awsContainerCredentialsFullUri will take precedence.");
      }
      if (token && tokenFile) {
        warn("@aws-sdk/credential-provider-http: you have set both awsContainerAuthorizationToken and awsContainerAuthorizationTokenFile.");
        warn("awsContainerAuthorizationToken will take precedence.");
      }
      if (full) {
        host = full;
      } else if (relative) {
        host = `${DEFAULT_LINK_LOCAL_HOST}${relative}`;
      } else {
        throw new property_provider_1.CredentialsProviderError(`No HTTP credential provider host provided.
Set AWS_CONTAINER_CREDENTIALS_FULL_URI or AWS_CONTAINER_CREDENTIALS_RELATIVE_URI.`, { logger: options.logger });
      }
      const url = new URL(host);
      (0, checkUrl_1.checkUrl)(url, options.logger);
      const requestHandler = node_http_handler_1.NodeHttpHandler.create({
        requestTimeout: options.timeout ?? 1e3,
        connectionTimeout: options.timeout ?? 1e3
      });
      return (0, retry_wrapper_1.retryWrapper)(async () => {
        const request2 = (0, requestHelpers_1.createGetRequest)(url);
        if (token) {
          request2.headers.Authorization = token;
        } else if (tokenFile) {
          request2.headers.Authorization = (await promises_1.default.readFile(tokenFile)).toString();
        }
        try {
          const result = await requestHandler.handle(request2);
          return (0, requestHelpers_1.getCredentials)(result.response).then((creds) => (0, client_1.setCredentialFeature)(creds, "CREDENTIALS_HTTP", "z"));
        } catch (e4) {
          throw new property_provider_1.CredentialsProviderError(String(e4), { logger: options.logger });
        }
      }, options.maxRetries ?? 3, options.timeout ?? 1e3);
    };
    exports2.fromHttp = fromHttp;
  }
});

// node_modules/.pnpm/@aws-sdk+credential-provider-http@3.970.0/node_modules/@aws-sdk/credential-provider-http/dist-cjs/index.js
var require_dist_cjs50 = __commonJS({
  "node_modules/.pnpm/@aws-sdk+credential-provider-http@3.970.0/node_modules/@aws-sdk/credential-provider-http/dist-cjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fromHttp = void 0;
    var fromHttp_1 = require_fromHttp();
    Object.defineProperty(exports2, "fromHttp", { enumerable: true, get: function() {
      return fromHttp_1.fromHttp;
    } });
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/auth/httpAuthSchemeProvider.js
function createAwsAuthSigv4HttpAuthOption(authParameters) {
  return {
    schemeId: "aws.auth#sigv4",
    signingProperties: {
      name: "sso-oauth",
      region: authParameters.region
    },
    propertiesExtractor: (config, context) => ({
      signingProperties: {
        config,
        context
      }
    })
  };
}
function createSmithyApiNoAuthHttpAuthOption(authParameters) {
  return {
    schemeId: "smithy.api#noAuth"
  };
}
var import_util_middleware6, defaultSSOOIDCHttpAuthSchemeParametersProvider, defaultSSOOIDCHttpAuthSchemeProvider, resolveHttpAuthSchemeConfig;
var init_httpAuthSchemeProvider = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/auth/httpAuthSchemeProvider.js"() {
    init_dist_es2();
    import_util_middleware6 = __toESM(require_dist_cjs4());
    defaultSSOOIDCHttpAuthSchemeParametersProvider = async (config, context, input) => {
      return {
        operation: (0, import_util_middleware6.getSmithyContext)(context).operation,
        region: await (0, import_util_middleware6.normalizeProvider)(config.region)() || (() => {
          throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
        })()
      };
    };
    defaultSSOOIDCHttpAuthSchemeProvider = (authParameters) => {
      const options = [];
      switch (authParameters.operation) {
        case "CreateToken": {
          options.push(createSmithyApiNoAuthHttpAuthOption(authParameters));
          break;
        }
        default: {
          options.push(createAwsAuthSigv4HttpAuthOption(authParameters));
        }
      }
      return options;
    };
    resolveHttpAuthSchemeConfig = (config) => {
      const config_0 = resolveAwsSdkSigV4Config(config);
      return Object.assign(config_0, {
        authSchemePreference: (0, import_util_middleware6.normalizeProvider)(config.authSchemePreference ?? [])
      });
    };
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/endpoint/EndpointParameters.js
var resolveClientEndpointParameters, commonParams;
var init_EndpointParameters = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/endpoint/EndpointParameters.js"() {
    resolveClientEndpointParameters = (options) => {
      return Object.assign(options, {
        useDualstackEndpoint: options.useDualstackEndpoint ?? false,
        useFipsEndpoint: options.useFipsEndpoint ?? false,
        defaultSigningName: "sso-oauth"
      });
    };
    commonParams = {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/package.json
var package_default;
var init_package = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/package.json"() {
    package_default = {
      name: "@aws-sdk/nested-clients",
      version: "3.971.0",
      description: "Nested clients for AWS SDK packages.",
      main: "./dist-cjs/index.js",
      module: "./dist-es/index.js",
      types: "./dist-types/index.d.ts",
      scripts: {
        build: "yarn lint && concurrently 'yarn:build:types' 'yarn:build:es' && yarn build:cjs",
        "build:cjs": "node ../../scripts/compilation/inline nested-clients",
        "build:es": "tsc -p tsconfig.es.json",
        "build:include:deps": 'yarn g:turbo run build -F="$npm_package_name"',
        "build:types": "tsc -p tsconfig.types.json",
        "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
        clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
        lint: "node ../../scripts/validation/submodules-linter.js --pkg nested-clients",
        test: "yarn g:vitest run",
        "test:watch": "yarn g:vitest watch"
      },
      engines: {
        node: ">=20.0.0"
      },
      sideEffects: false,
      author: {
        name: "AWS SDK for JavaScript Team",
        url: "https://aws.amazon.com/javascript/"
      },
      license: "Apache-2.0",
      dependencies: {
        "@aws-crypto/sha256-browser": "5.2.0",
        "@aws-crypto/sha256-js": "5.2.0",
        "@aws-sdk/core": "3.970.0",
        "@aws-sdk/middleware-host-header": "3.969.0",
        "@aws-sdk/middleware-logger": "3.969.0",
        "@aws-sdk/middleware-recursion-detection": "3.969.0",
        "@aws-sdk/middleware-user-agent": "3.970.0",
        "@aws-sdk/region-config-resolver": "3.969.0",
        "@aws-sdk/types": "3.969.0",
        "@aws-sdk/util-endpoints": "3.970.0",
        "@aws-sdk/util-user-agent-browser": "3.969.0",
        "@aws-sdk/util-user-agent-node": "3.971.0",
        "@smithy/config-resolver": "^4.4.6",
        "@smithy/core": "^3.20.6",
        "@smithy/fetch-http-handler": "^5.3.9",
        "@smithy/hash-node": "^4.2.8",
        "@smithy/invalid-dependency": "^4.2.8",
        "@smithy/middleware-content-length": "^4.2.8",
        "@smithy/middleware-endpoint": "^4.4.7",
        "@smithy/middleware-retry": "^4.4.23",
        "@smithy/middleware-serde": "^4.2.9",
        "@smithy/middleware-stack": "^4.2.8",
        "@smithy/node-config-provider": "^4.3.8",
        "@smithy/node-http-handler": "^4.4.8",
        "@smithy/protocol-http": "^5.3.8",
        "@smithy/smithy-client": "^4.10.8",
        "@smithy/types": "^4.12.0",
        "@smithy/url-parser": "^4.2.8",
        "@smithy/util-base64": "^4.3.0",
        "@smithy/util-body-length-browser": "^4.2.0",
        "@smithy/util-body-length-node": "^4.2.1",
        "@smithy/util-defaults-mode-browser": "^4.3.22",
        "@smithy/util-defaults-mode-node": "^4.2.25",
        "@smithy/util-endpoints": "^3.2.8",
        "@smithy/util-middleware": "^4.2.8",
        "@smithy/util-retry": "^4.2.8",
        "@smithy/util-utf8": "^4.2.0",
        tslib: "^2.6.2"
      },
      devDependencies: {
        concurrently: "7.0.0",
        "downlevel-dts": "0.10.1",
        rimraf: "5.0.10",
        typescript: "~5.8.3"
      },
      typesVersions: {
        "<4.0": {
          "dist-types/*": [
            "dist-types/ts3.4/*"
          ]
        }
      },
      files: [
        "./signin.d.ts",
        "./signin.js",
        "./sso-oidc.d.ts",
        "./sso-oidc.js",
        "./sts.d.ts",
        "./sts.js",
        "dist-*/**"
      ],
      browser: {
        "./dist-es/submodules/signin/runtimeConfig": "./dist-es/submodules/signin/runtimeConfig.browser",
        "./dist-es/submodules/sso-oidc/runtimeConfig": "./dist-es/submodules/sso-oidc/runtimeConfig.browser",
        "./dist-es/submodules/sts/runtimeConfig": "./dist-es/submodules/sts/runtimeConfig.browser"
      },
      "react-native": {},
      homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/packages/nested-clients",
      repository: {
        type: "git",
        url: "https://github.com/aws/aws-sdk-js-v3.git",
        directory: "packages/nested-clients"
      },
      exports: {
        "./package.json": "./package.json",
        "./sso-oidc": {
          types: "./dist-types/submodules/sso-oidc/index.d.ts",
          module: "./dist-es/submodules/sso-oidc/index.js",
          node: "./dist-cjs/submodules/sso-oidc/index.js",
          import: "./dist-es/submodules/sso-oidc/index.js",
          require: "./dist-cjs/submodules/sso-oidc/index.js"
        },
        "./sts": {
          types: "./dist-types/submodules/sts/index.d.ts",
          module: "./dist-es/submodules/sts/index.js",
          node: "./dist-cjs/submodules/sts/index.js",
          import: "./dist-es/submodules/sts/index.js",
          require: "./dist-cjs/submodules/sts/index.js"
        },
        "./signin": {
          types: "./dist-types/submodules/signin/index.d.ts",
          module: "./dist-es/submodules/signin/index.js",
          node: "./dist-cjs/submodules/signin/index.js",
          import: "./dist-es/submodules/signin/index.js",
          require: "./dist-cjs/submodules/signin/index.js"
        }
      }
    };
  }
});

// node_modules/.pnpm/@aws-sdk+util-user-agent-node@3.971.0/node_modules/@aws-sdk/util-user-agent-node/dist-cjs/index.js
var require_dist_cjs51 = __commonJS({
  "node_modules/.pnpm/@aws-sdk+util-user-agent-node@3.971.0/node_modules/@aws-sdk/util-user-agent-node/dist-cjs/index.js"(exports2) {
    "use strict";
    var os3 = require("os");
    var process2 = require("process");
    var middlewareUserAgent = require_dist_cjs37();
    var crtAvailability = {
      isCrtAvailable: false
    };
    var isCrtAvailable = () => {
      if (crtAvailability.isCrtAvailable) {
        return ["md/crt-avail"];
      }
      return null;
    };
    var createDefaultUserAgentProvider4 = ({ serviceId, clientVersion }) => {
      return async (config) => {
        const sections = [
          ["aws-sdk-js", clientVersion],
          ["ua", "2.1"],
          [`os/${os3.platform()}`, os3.release()],
          ["lang/js"],
          ["md/nodejs", `${process2.versions.node}`]
        ];
        const crtAvailable = isCrtAvailable();
        if (crtAvailable) {
          sections.push(crtAvailable);
        }
        if (serviceId) {
          sections.push([`api/${serviceId}`, clientVersion]);
        }
        if (process2.env.AWS_EXECUTION_ENV) {
          sections.push([`exec-env/${process2.env.AWS_EXECUTION_ENV}`]);
        }
        const appId = await config?.userAgentAppId?.();
        const resolvedUserAgent = appId ? [...sections, [`app/${appId}`]] : [...sections];
        return resolvedUserAgent;
      };
    };
    var defaultUserAgent = createDefaultUserAgentProvider4;
    var UA_APP_ID_ENV_NAME = "AWS_SDK_UA_APP_ID";
    var UA_APP_ID_INI_NAME = "sdk_ua_app_id";
    var UA_APP_ID_INI_NAME_DEPRECATED = "sdk-ua-app-id";
    var NODE_APP_ID_CONFIG_OPTIONS4 = {
      environmentVariableSelector: (env) => env[UA_APP_ID_ENV_NAME],
      configFileSelector: (profile) => profile[UA_APP_ID_INI_NAME] ?? profile[UA_APP_ID_INI_NAME_DEPRECATED],
      default: middlewareUserAgent.DEFAULT_UA_APP_ID
    };
    exports2.NODE_APP_ID_CONFIG_OPTIONS = NODE_APP_ID_CONFIG_OPTIONS4;
    exports2.UA_APP_ID_ENV_NAME = UA_APP_ID_ENV_NAME;
    exports2.UA_APP_ID_INI_NAME = UA_APP_ID_INI_NAME;
    exports2.createDefaultUserAgentProvider = createDefaultUserAgentProvider4;
    exports2.crtAvailability = crtAvailability;
    exports2.defaultUserAgent = defaultUserAgent;
  }
});

// node_modules/.pnpm/@smithy+hash-node@4.2.8/node_modules/@smithy/hash-node/dist-cjs/index.js
var require_dist_cjs52 = __commonJS({
  "node_modules/.pnpm/@smithy+hash-node@4.2.8/node_modules/@smithy/hash-node/dist-cjs/index.js"(exports2) {
    "use strict";
    var utilBufferFrom = require_dist_cjs7();
    var utilUtf8 = require_dist_cjs8();
    var buffer = require("buffer");
    var crypto5 = require("crypto");
    var Hash5 = class {
      algorithmIdentifier;
      secret;
      hash;
      constructor(algorithmIdentifier, secret) {
        this.algorithmIdentifier = algorithmIdentifier;
        this.secret = secret;
        this.reset();
      }
      update(toHash, encoding2) {
        this.hash.update(utilUtf8.toUint8Array(castSourceData(toHash, encoding2)));
      }
      digest() {
        return Promise.resolve(this.hash.digest());
      }
      reset() {
        this.hash = this.secret ? crypto5.createHmac(this.algorithmIdentifier, castSourceData(this.secret)) : crypto5.createHash(this.algorithmIdentifier);
      }
    };
    function castSourceData(toCast, encoding2) {
      if (buffer.Buffer.isBuffer(toCast)) {
        return toCast;
      }
      if (typeof toCast === "string") {
        return utilBufferFrom.fromString(toCast, encoding2);
      }
      if (ArrayBuffer.isView(toCast)) {
        return utilBufferFrom.fromArrayBuffer(toCast.buffer, toCast.byteOffset, toCast.byteLength);
      }
      return utilBufferFrom.fromArrayBuffer(toCast);
    }
    exports2.Hash = Hash5;
  }
});

// node_modules/.pnpm/@smithy+util-body-length-node@4.2.1/node_modules/@smithy/util-body-length-node/dist-cjs/index.js
var require_dist_cjs53 = __commonJS({
  "node_modules/.pnpm/@smithy+util-body-length-node@4.2.1/node_modules/@smithy/util-body-length-node/dist-cjs/index.js"(exports2) {
    "use strict";
    var node_fs = require("node:fs");
    var calculateBodyLength4 = (body2) => {
      if (!body2) {
        return 0;
      }
      if (typeof body2 === "string") {
        return Buffer.byteLength(body2);
      } else if (typeof body2.byteLength === "number") {
        return body2.byteLength;
      } else if (typeof body2.size === "number") {
        return body2.size;
      } else if (typeof body2.start === "number" && typeof body2.end === "number") {
        return body2.end + 1 - body2.start;
      } else if (body2 instanceof node_fs.ReadStream) {
        if (body2.path != null) {
          return node_fs.lstatSync(body2.path).size;
        } else if (typeof body2.fd === "number") {
          return node_fs.fstatSync(body2.fd).size;
        }
      }
      throw new Error(`Body Length computation failed for ${body2}`);
    };
    exports2.calculateBodyLength = calculateBodyLength4;
  }
});

// node_modules/.pnpm/@smithy+util-defaults-mode-node@4.2.25/node_modules/@smithy/util-defaults-mode-node/dist-cjs/index.js
var require_dist_cjs54 = __commonJS({
  "node_modules/.pnpm/@smithy+util-defaults-mode-node@4.2.25/node_modules/@smithy/util-defaults-mode-node/dist-cjs/index.js"(exports2) {
    "use strict";
    var configResolver = require_dist_cjs38();
    var nodeConfigProvider = require_dist_cjs42();
    var propertyProvider = require_dist_cjs17();
    var AWS_EXECUTION_ENV = "AWS_EXECUTION_ENV";
    var AWS_REGION_ENV = "AWS_REGION";
    var AWS_DEFAULT_REGION_ENV = "AWS_DEFAULT_REGION";
    var ENV_IMDS_DISABLED = "AWS_EC2_METADATA_DISABLED";
    var DEFAULTS_MODE_OPTIONS = ["in-region", "cross-region", "mobile", "standard", "legacy"];
    var IMDS_REGION_PATH = "/latest/meta-data/placement/region";
    var AWS_DEFAULTS_MODE_ENV = "AWS_DEFAULTS_MODE";
    var AWS_DEFAULTS_MODE_CONFIG = "defaults_mode";
    var NODE_DEFAULTS_MODE_CONFIG_OPTIONS = {
      environmentVariableSelector: (env) => {
        return env[AWS_DEFAULTS_MODE_ENV];
      },
      configFileSelector: (profile) => {
        return profile[AWS_DEFAULTS_MODE_CONFIG];
      },
      default: "legacy"
    };
    var resolveDefaultsModeConfig4 = ({ region = nodeConfigProvider.loadConfig(configResolver.NODE_REGION_CONFIG_OPTIONS), defaultsMode = nodeConfigProvider.loadConfig(NODE_DEFAULTS_MODE_CONFIG_OPTIONS) } = {}) => propertyProvider.memoize(async () => {
      const mode = typeof defaultsMode === "function" ? await defaultsMode() : defaultsMode;
      switch (mode?.toLowerCase()) {
        case "auto":
          return resolveNodeDefaultsModeAuto(region);
        case "in-region":
        case "cross-region":
        case "mobile":
        case "standard":
        case "legacy":
          return Promise.resolve(mode?.toLocaleLowerCase());
        case void 0:
          return Promise.resolve("legacy");
        default:
          throw new Error(`Invalid parameter for "defaultsMode", expect ${DEFAULTS_MODE_OPTIONS.join(", ")}, got ${mode}`);
      }
    });
    var resolveNodeDefaultsModeAuto = async (clientRegion) => {
      if (clientRegion) {
        const resolvedRegion = typeof clientRegion === "function" ? await clientRegion() : clientRegion;
        const inferredRegion = await inferPhysicalRegion();
        if (!inferredRegion) {
          return "standard";
        }
        if (resolvedRegion === inferredRegion) {
          return "in-region";
        } else {
          return "cross-region";
        }
      }
      return "standard";
    };
    var inferPhysicalRegion = async () => {
      if (process.env[AWS_EXECUTION_ENV] && (process.env[AWS_REGION_ENV] || process.env[AWS_DEFAULT_REGION_ENV])) {
        return process.env[AWS_REGION_ENV] ?? process.env[AWS_DEFAULT_REGION_ENV];
      }
      if (!process.env[ENV_IMDS_DISABLED]) {
        try {
          const { getInstanceMetadataEndpoint, httpRequest } = await Promise.resolve().then(() => __toESM(require_dist_cjs49()));
          const endpoint = await getInstanceMetadataEndpoint();
          return (await httpRequest({ ...endpoint, path: IMDS_REGION_PATH })).toString();
        } catch (e4) {
        }
      }
    };
    exports2.resolveDefaultsModeConfig = resolveDefaultsModeConfig4;
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/endpoint/ruleset.js
var u, v, w, x, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, _data, ruleSet;
var init_ruleset = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/endpoint/ruleset.js"() {
    u = "required";
    v = "fn";
    w = "argv";
    x = "ref";
    a = true;
    b = "isSet";
    c = "booleanEquals";
    d = "error";
    e = "endpoint";
    f = "tree";
    g = "PartitionResult";
    h = "getAttr";
    i = { [u]: false, "type": "string" };
    j = { [u]: true, "default": false, "type": "boolean" };
    k = { [x]: "Endpoint" };
    l = { [v]: c, [w]: [{ [x]: "UseFIPS" }, true] };
    m = { [v]: c, [w]: [{ [x]: "UseDualStack" }, true] };
    n = {};
    o = { [v]: h, [w]: [{ [x]: g }, "supportsFIPS"] };
    p = { [x]: g };
    q = { [v]: c, [w]: [true, { [v]: h, [w]: [p, "supportsDualStack"] }] };
    r = [l];
    s = [m];
    t = [{ [x]: "Region" }];
    _data = { version: "1.0", parameters: { Region: i, UseDualStack: j, UseFIPS: j, Endpoint: i }, rules: [{ conditions: [{ [v]: b, [w]: [k] }], rules: [{ conditions: r, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: d }, { conditions: s, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: d }, { endpoint: { url: k, properties: n, headers: n }, type: e }], type: f }, { conditions: [{ [v]: b, [w]: t }], rules: [{ conditions: [{ [v]: "aws.partition", [w]: t, assign: g }], rules: [{ conditions: [l, m], rules: [{ conditions: [{ [v]: c, [w]: [a, o] }, q], rules: [{ endpoint: { url: "https://oidc-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: n, headers: n }, type: e }], type: f }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: d }], type: f }, { conditions: r, rules: [{ conditions: [{ [v]: c, [w]: [o, a] }], rules: [{ conditions: [{ [v]: "stringEquals", [w]: [{ [v]: h, [w]: [p, "name"] }, "aws-us-gov"] }], endpoint: { url: "https://oidc.{Region}.amazonaws.com", properties: n, headers: n }, type: e }, { endpoint: { url: "https://oidc-fips.{Region}.{PartitionResult#dnsSuffix}", properties: n, headers: n }, type: e }], type: f }, { error: "FIPS is enabled but this partition does not support FIPS", type: d }], type: f }, { conditions: s, rules: [{ conditions: [q], rules: [{ endpoint: { url: "https://oidc.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: n, headers: n }, type: e }], type: f }, { error: "DualStack is enabled but this partition does not support DualStack", type: d }], type: f }, { endpoint: { url: "https://oidc.{Region}.{PartitionResult#dnsSuffix}", properties: n, headers: n }, type: e }], type: f }], type: f }, { error: "Invalid Configuration: Missing Region", type: d }] };
    ruleSet = _data;
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/endpoint/endpointResolver.js
var import_util_endpoints, import_util_endpoints2, cache, defaultEndpointResolver;
var init_endpointResolver = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/endpoint/endpointResolver.js"() {
    import_util_endpoints = __toESM(require_dist_cjs36());
    import_util_endpoints2 = __toESM(require_dist_cjs33());
    init_ruleset();
    cache = new import_util_endpoints2.EndpointCache({
      size: 50,
      params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"]
    });
    defaultEndpointResolver = (endpointParams, context = {}) => {
      return cache.get(endpointParams, () => (0, import_util_endpoints2.resolveEndpoint)(ruleSet, {
        endpointParams,
        logger: context.logger
      }));
    };
    import_util_endpoints2.customEndpointFunctions.aws = import_util_endpoints.awsEndpointFunctions;
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/runtimeConfig.shared.js
var import_smithy_client8, import_url_parser, import_util_base648, import_util_utf88, getRuntimeConfig;
var init_runtimeConfig_shared = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/runtimeConfig.shared.js"() {
    init_dist_es2();
    init_protocols2();
    init_dist_es();
    import_smithy_client8 = __toESM(require_dist_cjs20());
    import_url_parser = __toESM(require_dist_cjs35());
    import_util_base648 = __toESM(require_dist_cjs9());
    import_util_utf88 = __toESM(require_dist_cjs8());
    init_httpAuthSchemeProvider();
    init_endpointResolver();
    getRuntimeConfig = (config) => {
      return {
        apiVersion: "2019-06-10",
        base64Decoder: config?.base64Decoder ?? import_util_base648.fromBase64,
        base64Encoder: config?.base64Encoder ?? import_util_base648.toBase64,
        disableHostPrefix: config?.disableHostPrefix ?? false,
        endpointProvider: config?.endpointProvider ?? defaultEndpointResolver,
        extensions: config?.extensions ?? [],
        httpAuthSchemeProvider: config?.httpAuthSchemeProvider ?? defaultSSOOIDCHttpAuthSchemeProvider,
        httpAuthSchemes: config?.httpAuthSchemes ?? [
          {
            schemeId: "aws.auth#sigv4",
            identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
            signer: new AwsSdkSigV4Signer()
          },
          {
            schemeId: "smithy.api#noAuth",
            identityProvider: (ipc) => ipc.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
            signer: new NoAuthSigner()
          }
        ],
        logger: config?.logger ?? new import_smithy_client8.NoOpLogger(),
        protocol: config?.protocol ?? AwsRestJsonProtocol,
        protocolSettings: config?.protocolSettings ?? {
          defaultNamespace: "com.amazonaws.ssooidc",
          version: "2019-06-10",
          serviceTarget: "AWSSSOOIDCService"
        },
        serviceId: config?.serviceId ?? "SSO OIDC",
        urlParser: config?.urlParser ?? import_url_parser.parseUrl,
        utf8Decoder: config?.utf8Decoder ?? import_util_utf88.fromUtf8,
        utf8Encoder: config?.utf8Encoder ?? import_util_utf88.toUtf8
      };
    };
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/runtimeConfig.js
var import_util_user_agent_node, import_config_resolver, import_hash_node, import_middleware_retry, import_node_config_provider, import_node_http_handler, import_smithy_client9, import_util_body_length_node, import_util_defaults_mode_node, import_util_retry, getRuntimeConfig2;
var init_runtimeConfig = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/runtimeConfig.js"() {
    init_package();
    init_dist_es2();
    import_util_user_agent_node = __toESM(require_dist_cjs51());
    import_config_resolver = __toESM(require_dist_cjs38());
    import_hash_node = __toESM(require_dist_cjs52());
    import_middleware_retry = __toESM(require_dist_cjs46());
    import_node_config_provider = __toESM(require_dist_cjs42());
    import_node_http_handler = __toESM(require_dist_cjs12());
    import_smithy_client9 = __toESM(require_dist_cjs20());
    import_util_body_length_node = __toESM(require_dist_cjs53());
    import_util_defaults_mode_node = __toESM(require_dist_cjs54());
    import_util_retry = __toESM(require_dist_cjs45());
    init_runtimeConfig_shared();
    getRuntimeConfig2 = (config) => {
      (0, import_smithy_client9.emitWarningIfUnsupportedVersion)(process.version);
      const defaultsMode = (0, import_util_defaults_mode_node.resolveDefaultsModeConfig)(config);
      const defaultConfigProvider = () => defaultsMode().then(import_smithy_client9.loadConfigsForDefaultMode);
      const clientSharedValues = getRuntimeConfig(config);
      emitWarningIfUnsupportedVersion(process.version);
      const loaderConfig = {
        profile: config?.profile,
        logger: clientSharedValues.logger
      };
      return {
        ...clientSharedValues,
        ...config,
        runtime: "node",
        defaultsMode,
        authSchemePreference: config?.authSchemePreference ?? (0, import_node_config_provider.loadConfig)(NODE_AUTH_SCHEME_PREFERENCE_OPTIONS, loaderConfig),
        bodyLengthChecker: config?.bodyLengthChecker ?? import_util_body_length_node.calculateBodyLength,
        defaultUserAgentProvider: config?.defaultUserAgentProvider ?? (0, import_util_user_agent_node.createDefaultUserAgentProvider)({ serviceId: clientSharedValues.serviceId, clientVersion: package_default.version }),
        maxAttempts: config?.maxAttempts ?? (0, import_node_config_provider.loadConfig)(import_middleware_retry.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, config),
        region: config?.region ?? (0, import_node_config_provider.loadConfig)(import_config_resolver.NODE_REGION_CONFIG_OPTIONS, { ...import_config_resolver.NODE_REGION_CONFIG_FILE_OPTIONS, ...loaderConfig }),
        requestHandler: import_node_http_handler.NodeHttpHandler.create(config?.requestHandler ?? defaultConfigProvider),
        retryMode: config?.retryMode ?? (0, import_node_config_provider.loadConfig)({
          ...import_middleware_retry.NODE_RETRY_MODE_CONFIG_OPTIONS,
          default: async () => (await defaultConfigProvider()).retryMode || import_util_retry.DEFAULT_RETRY_MODE
        }, config),
        sha256: config?.sha256 ?? import_hash_node.Hash.bind(null, "sha256"),
        streamCollector: config?.streamCollector ?? import_node_http_handler.streamCollector,
        useDualstackEndpoint: config?.useDualstackEndpoint ?? (0, import_node_config_provider.loadConfig)(import_config_resolver.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, loaderConfig),
        useFipsEndpoint: config?.useFipsEndpoint ?? (0, import_node_config_provider.loadConfig)(import_config_resolver.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, loaderConfig),
        userAgentAppId: config?.userAgentAppId ?? (0, import_node_config_provider.loadConfig)(import_util_user_agent_node.NODE_APP_ID_CONFIG_OPTIONS, loaderConfig)
      };
    };
  }
});

// node_modules/.pnpm/@aws-sdk+region-config-resolver@3.969.0/node_modules/@aws-sdk/region-config-resolver/dist-cjs/regionConfig/stsRegionDefaultResolver.js
var require_stsRegionDefaultResolver = __commonJS({
  "node_modules/.pnpm/@aws-sdk+region-config-resolver@3.969.0/node_modules/@aws-sdk/region-config-resolver/dist-cjs/regionConfig/stsRegionDefaultResolver.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.warning = void 0;
    exports2.stsRegionDefaultResolver = stsRegionDefaultResolver2;
    var config_resolver_1 = require_dist_cjs38();
    var node_config_provider_1 = require_dist_cjs42();
    function stsRegionDefaultResolver2(loaderConfig = {}) {
      return (0, node_config_provider_1.loadConfig)({
        ...config_resolver_1.NODE_REGION_CONFIG_OPTIONS,
        async default() {
          if (!exports2.warning.silence) {
            console.warn("@aws-sdk - WARN - default STS region of us-east-1 used. See @aws-sdk/credential-providers README and set a region explicitly.");
          }
          return "us-east-1";
        }
      }, { ...config_resolver_1.NODE_REGION_CONFIG_FILE_OPTIONS, ...loaderConfig });
    }
    exports2.warning = {
      silence: false
    };
  }
});

// node_modules/.pnpm/@aws-sdk+region-config-resolver@3.969.0/node_modules/@aws-sdk/region-config-resolver/dist-cjs/index.js
var require_dist_cjs55 = __commonJS({
  "node_modules/.pnpm/@aws-sdk+region-config-resolver@3.969.0/node_modules/@aws-sdk/region-config-resolver/dist-cjs/index.js"(exports2) {
    "use strict";
    var stsRegionDefaultResolver2 = require_stsRegionDefaultResolver();
    var configResolver = require_dist_cjs38();
    var getAwsRegionExtensionConfiguration4 = (runtimeConfig) => {
      return {
        setRegion(region) {
          runtimeConfig.region = region;
        },
        region() {
          return runtimeConfig.region;
        }
      };
    };
    var resolveAwsRegionExtensionConfiguration4 = (awsRegionExtensionConfiguration) => {
      return {
        region: awsRegionExtensionConfiguration.region()
      };
    };
    Object.defineProperty(exports2, "NODE_REGION_CONFIG_FILE_OPTIONS", {
      enumerable: true,
      get: function() {
        return configResolver.NODE_REGION_CONFIG_FILE_OPTIONS;
      }
    });
    Object.defineProperty(exports2, "NODE_REGION_CONFIG_OPTIONS", {
      enumerable: true,
      get: function() {
        return configResolver.NODE_REGION_CONFIG_OPTIONS;
      }
    });
    Object.defineProperty(exports2, "REGION_ENV_NAME", {
      enumerable: true,
      get: function() {
        return configResolver.REGION_ENV_NAME;
      }
    });
    Object.defineProperty(exports2, "REGION_INI_NAME", {
      enumerable: true,
      get: function() {
        return configResolver.REGION_INI_NAME;
      }
    });
    Object.defineProperty(exports2, "resolveRegionConfig", {
      enumerable: true,
      get: function() {
        return configResolver.resolveRegionConfig;
      }
    });
    exports2.getAwsRegionExtensionConfiguration = getAwsRegionExtensionConfiguration4;
    exports2.resolveAwsRegionExtensionConfiguration = resolveAwsRegionExtensionConfiguration4;
    Object.keys(stsRegionDefaultResolver2).forEach(function(k4) {
      if (k4 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, k4)) Object.defineProperty(exports2, k4, {
        enumerable: true,
        get: function() {
          return stsRegionDefaultResolver2[k4];
        }
      });
    });
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/auth/httpAuthExtensionConfiguration.js
var getHttpAuthExtensionConfiguration, resolveHttpAuthRuntimeConfig;
var init_httpAuthExtensionConfiguration = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/auth/httpAuthExtensionConfiguration.js"() {
    getHttpAuthExtensionConfiguration = (runtimeConfig) => {
      const _httpAuthSchemes = runtimeConfig.httpAuthSchemes;
      let _httpAuthSchemeProvider = runtimeConfig.httpAuthSchemeProvider;
      let _credentials = runtimeConfig.credentials;
      return {
        setHttpAuthScheme(httpAuthScheme) {
          const index = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
          if (index === -1) {
            _httpAuthSchemes.push(httpAuthScheme);
          } else {
            _httpAuthSchemes.splice(index, 1, httpAuthScheme);
          }
        },
        httpAuthSchemes() {
          return _httpAuthSchemes;
        },
        setHttpAuthSchemeProvider(httpAuthSchemeProvider) {
          _httpAuthSchemeProvider = httpAuthSchemeProvider;
        },
        httpAuthSchemeProvider() {
          return _httpAuthSchemeProvider;
        },
        setCredentials(credentials) {
          _credentials = credentials;
        },
        credentials() {
          return _credentials;
        }
      };
    };
    resolveHttpAuthRuntimeConfig = (config) => {
      return {
        httpAuthSchemes: config.httpAuthSchemes(),
        httpAuthSchemeProvider: config.httpAuthSchemeProvider(),
        credentials: config.credentials()
      };
    };
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/runtimeExtensions.js
var import_region_config_resolver, import_protocol_http12, import_smithy_client10, resolveRuntimeExtensions;
var init_runtimeExtensions = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/runtimeExtensions.js"() {
    import_region_config_resolver = __toESM(require_dist_cjs55());
    import_protocol_http12 = __toESM(require_dist_cjs2());
    import_smithy_client10 = __toESM(require_dist_cjs20());
    init_httpAuthExtensionConfiguration();
    resolveRuntimeExtensions = (runtimeConfig, extensions) => {
      const extensionConfiguration = Object.assign((0, import_region_config_resolver.getAwsRegionExtensionConfiguration)(runtimeConfig), (0, import_smithy_client10.getDefaultExtensionConfiguration)(runtimeConfig), (0, import_protocol_http12.getHttpHandlerExtensionConfiguration)(runtimeConfig), getHttpAuthExtensionConfiguration(runtimeConfig));
      extensions.forEach((extension) => extension.configure(extensionConfiguration));
      return Object.assign(runtimeConfig, (0, import_region_config_resolver.resolveAwsRegionExtensionConfiguration)(extensionConfiguration), (0, import_smithy_client10.resolveDefaultRuntimeConfig)(extensionConfiguration), (0, import_protocol_http12.resolveHttpHandlerRuntimeConfig)(extensionConfiguration), resolveHttpAuthRuntimeConfig(extensionConfiguration));
    };
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/SSOOIDCClient.js
var import_middleware_host_header, import_middleware_logger, import_middleware_recursion_detection, import_middleware_user_agent, import_config_resolver2, import_middleware_content_length, import_middleware_endpoint, import_middleware_retry2, import_smithy_client11, SSOOIDCClient;
var init_SSOOIDCClient = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/SSOOIDCClient.js"() {
    import_middleware_host_header = __toESM(require_dist_cjs27());
    import_middleware_logger = __toESM(require_dist_cjs28());
    import_middleware_recursion_detection = __toESM(require_dist_cjs29());
    import_middleware_user_agent = __toESM(require_dist_cjs37());
    import_config_resolver2 = __toESM(require_dist_cjs38());
    init_dist_es();
    init_schema();
    import_middleware_content_length = __toESM(require_dist_cjs40());
    import_middleware_endpoint = __toESM(require_dist_cjs43());
    import_middleware_retry2 = __toESM(require_dist_cjs46());
    import_smithy_client11 = __toESM(require_dist_cjs20());
    init_httpAuthSchemeProvider();
    init_EndpointParameters();
    init_runtimeConfig();
    init_runtimeExtensions();
    SSOOIDCClient = class extends import_smithy_client11.Client {
      config;
      constructor(...[configuration]) {
        const _config_0 = getRuntimeConfig2(configuration || {});
        super(_config_0);
        this.initConfig = _config_0;
        const _config_1 = resolveClientEndpointParameters(_config_0);
        const _config_2 = (0, import_middleware_user_agent.resolveUserAgentConfig)(_config_1);
        const _config_3 = (0, import_middleware_retry2.resolveRetryConfig)(_config_2);
        const _config_4 = (0, import_config_resolver2.resolveRegionConfig)(_config_3);
        const _config_5 = (0, import_middleware_host_header.resolveHostHeaderConfig)(_config_4);
        const _config_6 = (0, import_middleware_endpoint.resolveEndpointConfig)(_config_5);
        const _config_7 = resolveHttpAuthSchemeConfig(_config_6);
        const _config_8 = resolveRuntimeExtensions(_config_7, configuration?.extensions || []);
        this.config = _config_8;
        this.middlewareStack.use(getSchemaSerdePlugin(this.config));
        this.middlewareStack.use((0, import_middleware_user_agent.getUserAgentPlugin)(this.config));
        this.middlewareStack.use((0, import_middleware_retry2.getRetryPlugin)(this.config));
        this.middlewareStack.use((0, import_middleware_content_length.getContentLengthPlugin)(this.config));
        this.middlewareStack.use((0, import_middleware_host_header.getHostHeaderPlugin)(this.config));
        this.middlewareStack.use((0, import_middleware_logger.getLoggerPlugin)(this.config));
        this.middlewareStack.use((0, import_middleware_recursion_detection.getRecursionDetectionPlugin)(this.config));
        this.middlewareStack.use(getHttpAuthSchemeEndpointRuleSetPlugin(this.config, {
          httpAuthSchemeParametersProvider: defaultSSOOIDCHttpAuthSchemeParametersProvider,
          identityProviderConfigProvider: async (config) => new DefaultIdentityProviderConfig({
            "aws.auth#sigv4": config.credentials
          })
        }));
        this.middlewareStack.use(getHttpSigningPlugin(this.config));
      }
      destroy() {
        super.destroy();
      }
    };
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/models/SSOOIDCServiceException.js
var import_smithy_client12, SSOOIDCServiceException;
var init_SSOOIDCServiceException = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/models/SSOOIDCServiceException.js"() {
    import_smithy_client12 = __toESM(require_dist_cjs20());
    SSOOIDCServiceException = class _SSOOIDCServiceException extends import_smithy_client12.ServiceException {
      constructor(options) {
        super(options);
        Object.setPrototypeOf(this, _SSOOIDCServiceException.prototype);
      }
    };
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/models/errors.js
var AccessDeniedException, AuthorizationPendingException, ExpiredTokenException, InternalServerException, InvalidClientException, InvalidGrantException, InvalidRequestException, InvalidScopeException, SlowDownException, UnauthorizedClientException, UnsupportedGrantTypeException;
var init_errors = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/models/errors.js"() {
    init_SSOOIDCServiceException();
    AccessDeniedException = class _AccessDeniedException extends SSOOIDCServiceException {
      name = "AccessDeniedException";
      $fault = "client";
      error;
      reason;
      error_description;
      constructor(opts) {
        super({
          name: "AccessDeniedException",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _AccessDeniedException.prototype);
        this.error = opts.error;
        this.reason = opts.reason;
        this.error_description = opts.error_description;
      }
    };
    AuthorizationPendingException = class _AuthorizationPendingException extends SSOOIDCServiceException {
      name = "AuthorizationPendingException";
      $fault = "client";
      error;
      error_description;
      constructor(opts) {
        super({
          name: "AuthorizationPendingException",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _AuthorizationPendingException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
      }
    };
    ExpiredTokenException = class _ExpiredTokenException extends SSOOIDCServiceException {
      name = "ExpiredTokenException";
      $fault = "client";
      error;
      error_description;
      constructor(opts) {
        super({
          name: "ExpiredTokenException",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _ExpiredTokenException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
      }
    };
    InternalServerException = class _InternalServerException extends SSOOIDCServiceException {
      name = "InternalServerException";
      $fault = "server";
      error;
      error_description;
      constructor(opts) {
        super({
          name: "InternalServerException",
          $fault: "server",
          ...opts
        });
        Object.setPrototypeOf(this, _InternalServerException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
      }
    };
    InvalidClientException = class _InvalidClientException extends SSOOIDCServiceException {
      name = "InvalidClientException";
      $fault = "client";
      error;
      error_description;
      constructor(opts) {
        super({
          name: "InvalidClientException",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _InvalidClientException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
      }
    };
    InvalidGrantException = class _InvalidGrantException extends SSOOIDCServiceException {
      name = "InvalidGrantException";
      $fault = "client";
      error;
      error_description;
      constructor(opts) {
        super({
          name: "InvalidGrantException",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _InvalidGrantException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
      }
    };
    InvalidRequestException = class _InvalidRequestException extends SSOOIDCServiceException {
      name = "InvalidRequestException";
      $fault = "client";
      error;
      reason;
      error_description;
      constructor(opts) {
        super({
          name: "InvalidRequestException",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _InvalidRequestException.prototype);
        this.error = opts.error;
        this.reason = opts.reason;
        this.error_description = opts.error_description;
      }
    };
    InvalidScopeException = class _InvalidScopeException extends SSOOIDCServiceException {
      name = "InvalidScopeException";
      $fault = "client";
      error;
      error_description;
      constructor(opts) {
        super({
          name: "InvalidScopeException",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _InvalidScopeException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
      }
    };
    SlowDownException = class _SlowDownException extends SSOOIDCServiceException {
      name = "SlowDownException";
      $fault = "client";
      error;
      error_description;
      constructor(opts) {
        super({
          name: "SlowDownException",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _SlowDownException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
      }
    };
    UnauthorizedClientException = class _UnauthorizedClientException extends SSOOIDCServiceException {
      name = "UnauthorizedClientException";
      $fault = "client";
      error;
      error_description;
      constructor(opts) {
        super({
          name: "UnauthorizedClientException",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _UnauthorizedClientException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
      }
    };
    UnsupportedGrantTypeException = class _UnsupportedGrantTypeException extends SSOOIDCServiceException {
      name = "UnsupportedGrantTypeException";
      $fault = "client";
      error;
      error_description;
      constructor(opts) {
        super({
          name: "UnsupportedGrantTypeException",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _UnsupportedGrantTypeException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
      }
    };
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/schemas/schemas_0.js
var _ADE, _APE, _AT, _CS, _CT, _CTR, _CTRr, _CV, _ETE, _ICE, _IGE, _IRE, _ISE, _ISEn, _IT, _RT, _SDE, _UCE, _UGTE, _aT, _c, _cI, _cS, _cV, _co, _dC, _e, _eI, _ed, _gT, _h, _hE, _iT, _r, _rT, _rU, _s, _se, _sm, _tT, n0, AccessToken, ClientSecret, CodeVerifier, IdToken, RefreshToken, AccessDeniedException$, AuthorizationPendingException$, CreateTokenRequest$, CreateTokenResponse$, ExpiredTokenException$, InternalServerException$, InvalidClientException$, InvalidGrantException$, InvalidRequestException$, InvalidScopeException$, SlowDownException$, UnauthorizedClientException$, UnsupportedGrantTypeException$, SSOOIDCServiceException$, Scopes, CreateToken$;
var init_schemas_0 = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/schemas/schemas_0.js"() {
    init_schema();
    init_errors();
    init_SSOOIDCServiceException();
    _ADE = "AccessDeniedException";
    _APE = "AuthorizationPendingException";
    _AT = "AccessToken";
    _CS = "ClientSecret";
    _CT = "CreateToken";
    _CTR = "CreateTokenRequest";
    _CTRr = "CreateTokenResponse";
    _CV = "CodeVerifier";
    _ETE = "ExpiredTokenException";
    _ICE = "InvalidClientException";
    _IGE = "InvalidGrantException";
    _IRE = "InvalidRequestException";
    _ISE = "InternalServerException";
    _ISEn = "InvalidScopeException";
    _IT = "IdToken";
    _RT = "RefreshToken";
    _SDE = "SlowDownException";
    _UCE = "UnauthorizedClientException";
    _UGTE = "UnsupportedGrantTypeException";
    _aT = "accessToken";
    _c = "client";
    _cI = "clientId";
    _cS = "clientSecret";
    _cV = "codeVerifier";
    _co = "code";
    _dC = "deviceCode";
    _e = "error";
    _eI = "expiresIn";
    _ed = "error_description";
    _gT = "grantType";
    _h = "http";
    _hE = "httpError";
    _iT = "idToken";
    _r = "reason";
    _rT = "refreshToken";
    _rU = "redirectUri";
    _s = "scope";
    _se = "server";
    _sm = "smithy.ts.sdk.synthetic.com.amazonaws.ssooidc";
    _tT = "tokenType";
    n0 = "com.amazonaws.ssooidc";
    AccessToken = [0, n0, _AT, 8, 0];
    ClientSecret = [0, n0, _CS, 8, 0];
    CodeVerifier = [0, n0, _CV, 8, 0];
    IdToken = [0, n0, _IT, 8, 0];
    RefreshToken = [0, n0, _RT, 8, 0];
    AccessDeniedException$ = [
      -3,
      n0,
      _ADE,
      { [_e]: _c, [_hE]: 400 },
      [_e, _r, _ed],
      [0, 0, 0]
    ];
    TypeRegistry.for(n0).registerError(AccessDeniedException$, AccessDeniedException);
    AuthorizationPendingException$ = [
      -3,
      n0,
      _APE,
      { [_e]: _c, [_hE]: 400 },
      [_e, _ed],
      [0, 0]
    ];
    TypeRegistry.for(n0).registerError(AuthorizationPendingException$, AuthorizationPendingException);
    CreateTokenRequest$ = [
      3,
      n0,
      _CTR,
      0,
      [_cI, _cS, _gT, _dC, _co, _rT, _s, _rU, _cV],
      [0, [() => ClientSecret, 0], 0, 0, 0, [() => RefreshToken, 0], 64 | 0, 0, [() => CodeVerifier, 0]],
      3
    ];
    CreateTokenResponse$ = [
      3,
      n0,
      _CTRr,
      0,
      [_aT, _tT, _eI, _rT, _iT],
      [[() => AccessToken, 0], 0, 1, [() => RefreshToken, 0], [() => IdToken, 0]]
    ];
    ExpiredTokenException$ = [-3, n0, _ETE, { [_e]: _c, [_hE]: 400 }, [_e, _ed], [0, 0]];
    TypeRegistry.for(n0).registerError(ExpiredTokenException$, ExpiredTokenException);
    InternalServerException$ = [-3, n0, _ISE, { [_e]: _se, [_hE]: 500 }, [_e, _ed], [0, 0]];
    TypeRegistry.for(n0).registerError(InternalServerException$, InternalServerException);
    InvalidClientException$ = [-3, n0, _ICE, { [_e]: _c, [_hE]: 401 }, [_e, _ed], [0, 0]];
    TypeRegistry.for(n0).registerError(InvalidClientException$, InvalidClientException);
    InvalidGrantException$ = [-3, n0, _IGE, { [_e]: _c, [_hE]: 400 }, [_e, _ed], [0, 0]];
    TypeRegistry.for(n0).registerError(InvalidGrantException$, InvalidGrantException);
    InvalidRequestException$ = [
      -3,
      n0,
      _IRE,
      { [_e]: _c, [_hE]: 400 },
      [_e, _r, _ed],
      [0, 0, 0]
    ];
    TypeRegistry.for(n0).registerError(InvalidRequestException$, InvalidRequestException);
    InvalidScopeException$ = [-3, n0, _ISEn, { [_e]: _c, [_hE]: 400 }, [_e, _ed], [0, 0]];
    TypeRegistry.for(n0).registerError(InvalidScopeException$, InvalidScopeException);
    SlowDownException$ = [-3, n0, _SDE, { [_e]: _c, [_hE]: 400 }, [_e, _ed], [0, 0]];
    TypeRegistry.for(n0).registerError(SlowDownException$, SlowDownException);
    UnauthorizedClientException$ = [
      -3,
      n0,
      _UCE,
      { [_e]: _c, [_hE]: 400 },
      [_e, _ed],
      [0, 0]
    ];
    TypeRegistry.for(n0).registerError(UnauthorizedClientException$, UnauthorizedClientException);
    UnsupportedGrantTypeException$ = [
      -3,
      n0,
      _UGTE,
      { [_e]: _c, [_hE]: 400 },
      [_e, _ed],
      [0, 0]
    ];
    TypeRegistry.for(n0).registerError(UnsupportedGrantTypeException$, UnsupportedGrantTypeException);
    SSOOIDCServiceException$ = [-3, _sm, "SSOOIDCServiceException", 0, [], []];
    TypeRegistry.for(_sm).registerError(SSOOIDCServiceException$, SSOOIDCServiceException);
    Scopes = 64 | 0;
    CreateToken$ = [
      9,
      n0,
      _CT,
      { [_h]: ["POST", "/token", 200] },
      () => CreateTokenRequest$,
      () => CreateTokenResponse$
    ];
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/commands/CreateTokenCommand.js
var import_middleware_endpoint2, import_smithy_client13, CreateTokenCommand;
var init_CreateTokenCommand = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/commands/CreateTokenCommand.js"() {
    import_middleware_endpoint2 = __toESM(require_dist_cjs43());
    import_smithy_client13 = __toESM(require_dist_cjs20());
    init_EndpointParameters();
    init_schemas_0();
    CreateTokenCommand = class extends import_smithy_client13.Command.classBuilder().ep(commonParams).m(function(Command, cs, config, o4) {
      return [(0, import_middleware_endpoint2.getEndpointPlugin)(config, Command.getEndpointParameterInstructions())];
    }).s("AWSSSOOIDCService", "CreateToken", {}).n("SSOOIDCClient", "CreateTokenCommand").sc(CreateToken$).build() {
    };
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/SSOOIDC.js
var import_smithy_client14, commands, SSOOIDC;
var init_SSOOIDC = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/SSOOIDC.js"() {
    import_smithy_client14 = __toESM(require_dist_cjs20());
    init_CreateTokenCommand();
    init_SSOOIDCClient();
    commands = {
      CreateTokenCommand
    };
    SSOOIDC = class extends SSOOIDCClient {
    };
    (0, import_smithy_client14.createAggregatedClient)(commands, SSOOIDC);
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/commands/index.js
var init_commands = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/commands/index.js"() {
    init_CreateTokenCommand();
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/models/enums.js
var AccessDeniedExceptionReason, InvalidRequestExceptionReason;
var init_enums = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/models/enums.js"() {
    AccessDeniedExceptionReason = {
      KMS_ACCESS_DENIED: "KMS_AccessDeniedException"
    };
    InvalidRequestExceptionReason = {
      KMS_DISABLED_KEY: "KMS_DisabledException",
      KMS_INVALID_KEY_USAGE: "KMS_InvalidKeyUsageException",
      KMS_INVALID_STATE: "KMS_InvalidStateException",
      KMS_KEY_NOT_FOUND: "KMS_NotFoundException"
    };
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/models/models_0.js
var init_models_0 = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/models/models_0.js"() {
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/index.js
var sso_oidc_exports = {};
__export(sso_oidc_exports, {
  $Command: () => import_smithy_client13.Command,
  AccessDeniedException: () => AccessDeniedException,
  AccessDeniedException$: () => AccessDeniedException$,
  AccessDeniedExceptionReason: () => AccessDeniedExceptionReason,
  AuthorizationPendingException: () => AuthorizationPendingException,
  AuthorizationPendingException$: () => AuthorizationPendingException$,
  CreateToken$: () => CreateToken$,
  CreateTokenCommand: () => CreateTokenCommand,
  CreateTokenRequest$: () => CreateTokenRequest$,
  CreateTokenResponse$: () => CreateTokenResponse$,
  ExpiredTokenException: () => ExpiredTokenException,
  ExpiredTokenException$: () => ExpiredTokenException$,
  InternalServerException: () => InternalServerException,
  InternalServerException$: () => InternalServerException$,
  InvalidClientException: () => InvalidClientException,
  InvalidClientException$: () => InvalidClientException$,
  InvalidGrantException: () => InvalidGrantException,
  InvalidGrantException$: () => InvalidGrantException$,
  InvalidRequestException: () => InvalidRequestException,
  InvalidRequestException$: () => InvalidRequestException$,
  InvalidRequestExceptionReason: () => InvalidRequestExceptionReason,
  InvalidScopeException: () => InvalidScopeException,
  InvalidScopeException$: () => InvalidScopeException$,
  SSOOIDC: () => SSOOIDC,
  SSOOIDCClient: () => SSOOIDCClient,
  SSOOIDCServiceException: () => SSOOIDCServiceException,
  SSOOIDCServiceException$: () => SSOOIDCServiceException$,
  SlowDownException: () => SlowDownException,
  SlowDownException$: () => SlowDownException$,
  UnauthorizedClientException: () => UnauthorizedClientException,
  UnauthorizedClientException$: () => UnauthorizedClientException$,
  UnsupportedGrantTypeException: () => UnsupportedGrantTypeException,
  UnsupportedGrantTypeException$: () => UnsupportedGrantTypeException$,
  __Client: () => import_smithy_client11.Client
});
var init_sso_oidc = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/index.js"() {
    init_SSOOIDCClient();
    init_SSOOIDC();
    init_commands();
    init_schemas_0();
    init_enums();
    init_errors();
    init_models_0();
    init_SSOOIDCServiceException();
  }
});

// node_modules/.pnpm/@aws-sdk+token-providers@3.971.0/node_modules/@aws-sdk/token-providers/dist-cjs/index.js
var require_dist_cjs56 = __commonJS({
  "node_modules/.pnpm/@aws-sdk+token-providers@3.971.0/node_modules/@aws-sdk/token-providers/dist-cjs/index.js"(exports2) {
    "use strict";
    var client2 = (init_client(), __toCommonJS(client_exports));
    var httpAuthSchemes = (init_httpAuthSchemes2(), __toCommonJS(httpAuthSchemes_exports));
    var propertyProvider = require_dist_cjs17();
    var sharedIniFileLoader = require_dist_cjs41();
    var fs3 = require("fs");
    var fromEnvSigningName = ({ logger: logger3, signingName } = {}) => async () => {
      logger3?.debug?.("@aws-sdk/token-providers - fromEnvSigningName");
      if (!signingName) {
        throw new propertyProvider.TokenProviderError("Please pass 'signingName' to compute environment variable key", { logger: logger3 });
      }
      const bearerTokenKey = httpAuthSchemes.getBearerTokenEnvKey(signingName);
      if (!(bearerTokenKey in process.env)) {
        throw new propertyProvider.TokenProviderError(`Token not present in '${bearerTokenKey}' environment variable`, { logger: logger3 });
      }
      const token = { token: process.env[bearerTokenKey] };
      client2.setTokenFeature(token, "BEARER_SERVICE_ENV_VARS", "3");
      return token;
    };
    var EXPIRE_WINDOW_MS = 5 * 60 * 1e3;
    var REFRESH_MESSAGE = `To refresh this SSO session run 'aws sso login' with the corresponding profile.`;
    var getSsoOidcClient = async (ssoRegion, init = {}, callerClientConfig) => {
      const { SSOOIDCClient: SSOOIDCClient2 } = await Promise.resolve().then(() => (init_sso_oidc(), sso_oidc_exports));
      const coalesce = (prop) => init.clientConfig?.[prop] ?? init.parentClientConfig?.[prop] ?? callerClientConfig?.[prop];
      const ssoOidcClient = new SSOOIDCClient2(Object.assign({}, init.clientConfig ?? {}, {
        region: ssoRegion ?? init.clientConfig?.region,
        logger: coalesce("logger"),
        userAgentAppId: coalesce("userAgentAppId")
      }));
      return ssoOidcClient;
    };
    var getNewSsoOidcToken = async (ssoToken, ssoRegion, init = {}, callerClientConfig) => {
      const { CreateTokenCommand: CreateTokenCommand2 } = await Promise.resolve().then(() => (init_sso_oidc(), sso_oidc_exports));
      const ssoOidcClient = await getSsoOidcClient(ssoRegion, init, callerClientConfig);
      return ssoOidcClient.send(new CreateTokenCommand2({
        clientId: ssoToken.clientId,
        clientSecret: ssoToken.clientSecret,
        refreshToken: ssoToken.refreshToken,
        grantType: "refresh_token"
      }));
    };
    var validateTokenExpiry = (token) => {
      if (token.expiration && token.expiration.getTime() < Date.now()) {
        throw new propertyProvider.TokenProviderError(`Token is expired. ${REFRESH_MESSAGE}`, false);
      }
    };
    var validateTokenKey = (key, value, forRefresh = false) => {
      if (typeof value === "undefined") {
        throw new propertyProvider.TokenProviderError(`Value not present for '${key}' in SSO Token${forRefresh ? ". Cannot refresh" : ""}. ${REFRESH_MESSAGE}`, false);
      }
    };
    var { writeFile: writeFile2 } = fs3.promises;
    var writeSSOTokenToFile = (id2, ssoToken) => {
      const tokenFilepath = sharedIniFileLoader.getSSOTokenFilepath(id2);
      const tokenString = JSON.stringify(ssoToken, null, 2);
      return writeFile2(tokenFilepath, tokenString);
    };
    var lastRefreshAttemptTime = /* @__PURE__ */ new Date(0);
    var fromSso = (init = {}) => async ({ callerClientConfig } = {}) => {
      init.logger?.debug("@aws-sdk/token-providers - fromSso");
      const profiles = await sharedIniFileLoader.parseKnownFiles(init);
      const profileName = sharedIniFileLoader.getProfileName({
        profile: init.profile ?? callerClientConfig?.profile
      });
      const profile = profiles[profileName];
      if (!profile) {
        throw new propertyProvider.TokenProviderError(`Profile '${profileName}' could not be found in shared credentials file.`, false);
      } else if (!profile["sso_session"]) {
        throw new propertyProvider.TokenProviderError(`Profile '${profileName}' is missing required property 'sso_session'.`);
      }
      const ssoSessionName = profile["sso_session"];
      const ssoSessions = await sharedIniFileLoader.loadSsoSessionData(init);
      const ssoSession = ssoSessions[ssoSessionName];
      if (!ssoSession) {
        throw new propertyProvider.TokenProviderError(`Sso session '${ssoSessionName}' could not be found in shared credentials file.`, false);
      }
      for (const ssoSessionRequiredKey of ["sso_start_url", "sso_region"]) {
        if (!ssoSession[ssoSessionRequiredKey]) {
          throw new propertyProvider.TokenProviderError(`Sso session '${ssoSessionName}' is missing required property '${ssoSessionRequiredKey}'.`, false);
        }
      }
      ssoSession["sso_start_url"];
      const ssoRegion = ssoSession["sso_region"];
      let ssoToken;
      try {
        ssoToken = await sharedIniFileLoader.getSSOTokenFromFile(ssoSessionName);
      } catch (e4) {
        throw new propertyProvider.TokenProviderError(`The SSO session token associated with profile=${profileName} was not found or is invalid. ${REFRESH_MESSAGE}`, false);
      }
      validateTokenKey("accessToken", ssoToken.accessToken);
      validateTokenKey("expiresAt", ssoToken.expiresAt);
      const { accessToken, expiresAt } = ssoToken;
      const existingToken = { token: accessToken, expiration: new Date(expiresAt) };
      if (existingToken.expiration.getTime() - Date.now() > EXPIRE_WINDOW_MS) {
        return existingToken;
      }
      if (Date.now() - lastRefreshAttemptTime.getTime() < 30 * 1e3) {
        validateTokenExpiry(existingToken);
        return existingToken;
      }
      validateTokenKey("clientId", ssoToken.clientId, true);
      validateTokenKey("clientSecret", ssoToken.clientSecret, true);
      validateTokenKey("refreshToken", ssoToken.refreshToken, true);
      try {
        lastRefreshAttemptTime.setTime(Date.now());
        const newSsoOidcToken = await getNewSsoOidcToken(ssoToken, ssoRegion, init, callerClientConfig);
        validateTokenKey("accessToken", newSsoOidcToken.accessToken);
        validateTokenKey("expiresIn", newSsoOidcToken.expiresIn);
        const newTokenExpiration = new Date(Date.now() + newSsoOidcToken.expiresIn * 1e3);
        try {
          await writeSSOTokenToFile(ssoSessionName, {
            ...ssoToken,
            accessToken: newSsoOidcToken.accessToken,
            expiresAt: newTokenExpiration.toISOString(),
            refreshToken: newSsoOidcToken.refreshToken
          });
        } catch (error2) {
        }
        return {
          token: newSsoOidcToken.accessToken,
          expiration: newTokenExpiration
        };
      } catch (error2) {
        validateTokenExpiry(existingToken);
        return existingToken;
      }
    };
    var fromStatic = ({ token, logger: logger3 }) => async () => {
      logger3?.debug("@aws-sdk/token-providers - fromStatic");
      if (!token || !token.token) {
        throw new propertyProvider.TokenProviderError(`Please pass a valid token to fromStatic`, false);
      }
      return token;
    };
    var nodeProvider = (init = {}) => propertyProvider.memoize(propertyProvider.chain(fromSso(init), async () => {
      throw new propertyProvider.TokenProviderError("Could not load token from any providers", false);
    }), (token) => token.expiration !== void 0 && token.expiration.getTime() - Date.now() < 3e5, (token) => token.expiration !== void 0);
    exports2.fromEnvSigningName = fromEnvSigningName;
    exports2.fromSso = fromSso;
    exports2.fromStatic = fromStatic;
    exports2.nodeProvider = nodeProvider;
  }
});

// node_modules/.pnpm/@aws-sdk+client-sso@3.971.0/node_modules/@aws-sdk/client-sso/dist-cjs/auth/httpAuthSchemeProvider.js
var require_httpAuthSchemeProvider2 = __commonJS({
  "node_modules/.pnpm/@aws-sdk+client-sso@3.971.0/node_modules/@aws-sdk/client-sso/dist-cjs/auth/httpAuthSchemeProvider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveHttpAuthSchemeConfig = exports2.defaultSSOHttpAuthSchemeProvider = exports2.defaultSSOHttpAuthSchemeParametersProvider = void 0;
    var core_1 = (init_dist_es2(), __toCommonJS(dist_es_exports2));
    var util_middleware_1 = require_dist_cjs4();
    var defaultSSOHttpAuthSchemeParametersProvider = async (config, context, input) => {
      return {
        operation: (0, util_middleware_1.getSmithyContext)(context).operation,
        region: await (0, util_middleware_1.normalizeProvider)(config.region)() || (() => {
          throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
        })()
      };
    };
    exports2.defaultSSOHttpAuthSchemeParametersProvider = defaultSSOHttpAuthSchemeParametersProvider;
    function createAwsAuthSigv4HttpAuthOption4(authParameters) {
      return {
        schemeId: "aws.auth#sigv4",
        signingProperties: {
          name: "awsssoportal",
          region: authParameters.region
        },
        propertiesExtractor: (config, context) => ({
          signingProperties: {
            config,
            context
          }
        })
      };
    }
    function createSmithyApiNoAuthHttpAuthOption4(authParameters) {
      return {
        schemeId: "smithy.api#noAuth"
      };
    }
    var defaultSSOHttpAuthSchemeProvider = (authParameters) => {
      const options = [];
      switch (authParameters.operation) {
        case "GetRoleCredentials":
          {
            options.push(createSmithyApiNoAuthHttpAuthOption4(authParameters));
            break;
          }
          ;
        case "ListAccountRoles":
          {
            options.push(createSmithyApiNoAuthHttpAuthOption4(authParameters));
            break;
          }
          ;
        case "ListAccounts":
          {
            options.push(createSmithyApiNoAuthHttpAuthOption4(authParameters));
            break;
          }
          ;
        case "Logout":
          {
            options.push(createSmithyApiNoAuthHttpAuthOption4(authParameters));
            break;
          }
          ;
        default: {
          options.push(createAwsAuthSigv4HttpAuthOption4(authParameters));
        }
      }
      return options;
    };
    exports2.defaultSSOHttpAuthSchemeProvider = defaultSSOHttpAuthSchemeProvider;
    var resolveHttpAuthSchemeConfig4 = (config) => {
      const config_0 = (0, core_1.resolveAwsSdkSigV4Config)(config);
      return Object.assign(config_0, {
        authSchemePreference: (0, util_middleware_1.normalizeProvider)(config.authSchemePreference ?? [])
      });
    };
    exports2.resolveHttpAuthSchemeConfig = resolveHttpAuthSchemeConfig4;
  }
});

// node_modules/.pnpm/@aws-sdk+client-sso@3.971.0/node_modules/@aws-sdk/client-sso/package.json
var require_package2 = __commonJS({
  "node_modules/.pnpm/@aws-sdk+client-sso@3.971.0/node_modules/@aws-sdk/client-sso/package.json"(exports2, module2) {
    module2.exports = {
      name: "@aws-sdk/client-sso",
      description: "AWS SDK for JavaScript Sso Client for Node.js, Browser and React Native",
      version: "3.971.0",
      scripts: {
        build: "concurrently 'yarn:build:types' 'yarn:build:es' && yarn build:cjs",
        "build:cjs": "node ../../scripts/compilation/inline client-sso",
        "build:es": "tsc -p tsconfig.es.json",
        "build:include:deps": 'yarn g:turbo run build -F="$npm_package_name"',
        "build:types": "tsc -p tsconfig.types.json",
        "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
        clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
        "extract:docs": "api-extractor run --local",
        "generate:client": "node ../../scripts/generate-clients/single-service --solo sso",
        "test:index": "tsc --noEmit ./test/index-types.ts && node ./test/index-objects.spec.mjs"
      },
      main: "./dist-cjs/index.js",
      types: "./dist-types/index.d.ts",
      module: "./dist-es/index.js",
      sideEffects: false,
      dependencies: {
        "@aws-crypto/sha256-browser": "5.2.0",
        "@aws-crypto/sha256-js": "5.2.0",
        "@aws-sdk/core": "3.970.0",
        "@aws-sdk/middleware-host-header": "3.969.0",
        "@aws-sdk/middleware-logger": "3.969.0",
        "@aws-sdk/middleware-recursion-detection": "3.969.0",
        "@aws-sdk/middleware-user-agent": "3.970.0",
        "@aws-sdk/region-config-resolver": "3.969.0",
        "@aws-sdk/types": "3.969.0",
        "@aws-sdk/util-endpoints": "3.970.0",
        "@aws-sdk/util-user-agent-browser": "3.969.0",
        "@aws-sdk/util-user-agent-node": "3.971.0",
        "@smithy/config-resolver": "^4.4.6",
        "@smithy/core": "^3.20.6",
        "@smithy/fetch-http-handler": "^5.3.9",
        "@smithy/hash-node": "^4.2.8",
        "@smithy/invalid-dependency": "^4.2.8",
        "@smithy/middleware-content-length": "^4.2.8",
        "@smithy/middleware-endpoint": "^4.4.7",
        "@smithy/middleware-retry": "^4.4.23",
        "@smithy/middleware-serde": "^4.2.9",
        "@smithy/middleware-stack": "^4.2.8",
        "@smithy/node-config-provider": "^4.3.8",
        "@smithy/node-http-handler": "^4.4.8",
        "@smithy/protocol-http": "^5.3.8",
        "@smithy/smithy-client": "^4.10.8",
        "@smithy/types": "^4.12.0",
        "@smithy/url-parser": "^4.2.8",
        "@smithy/util-base64": "^4.3.0",
        "@smithy/util-body-length-browser": "^4.2.0",
        "@smithy/util-body-length-node": "^4.2.1",
        "@smithy/util-defaults-mode-browser": "^4.3.22",
        "@smithy/util-defaults-mode-node": "^4.2.25",
        "@smithy/util-endpoints": "^3.2.8",
        "@smithy/util-middleware": "^4.2.8",
        "@smithy/util-retry": "^4.2.8",
        "@smithy/util-utf8": "^4.2.0",
        tslib: "^2.6.2"
      },
      devDependencies: {
        "@tsconfig/node20": "20.1.8",
        "@types/node": "^20.14.8",
        concurrently: "7.0.0",
        "downlevel-dts": "0.10.1",
        rimraf: "5.0.10",
        typescript: "~5.8.3"
      },
      engines: {
        node: ">=20.0.0"
      },
      typesVersions: {
        "<4.0": {
          "dist-types/*": [
            "dist-types/ts3.4/*"
          ]
        }
      },
      files: [
        "dist-*/**"
      ],
      author: {
        name: "AWS SDK for JavaScript Team",
        url: "https://aws.amazon.com/javascript/"
      },
      license: "Apache-2.0",
      browser: {
        "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
      },
      "react-native": {
        "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
      },
      homepage: "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sso",
      repository: {
        type: "git",
        url: "https://github.com/aws/aws-sdk-js-v3.git",
        directory: "clients/client-sso"
      }
    };
  }
});

// node_modules/.pnpm/@aws-sdk+client-sso@3.971.0/node_modules/@aws-sdk/client-sso/dist-cjs/endpoint/ruleset.js
var require_ruleset2 = __commonJS({
  "node_modules/.pnpm/@aws-sdk+client-sso@3.971.0/node_modules/@aws-sdk/client-sso/dist-cjs/endpoint/ruleset.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ruleSet = void 0;
    var u4 = "required";
    var v4 = "fn";
    var w4 = "argv";
    var x4 = "ref";
    var a4 = true;
    var b4 = "isSet";
    var c4 = "booleanEquals";
    var d4 = "error";
    var e4 = "endpoint";
    var f4 = "tree";
    var g4 = "PartitionResult";
    var h4 = "getAttr";
    var i4 = { [u4]: false, "type": "string" };
    var j4 = { [u4]: true, "default": false, "type": "boolean" };
    var k4 = { [x4]: "Endpoint" };
    var l4 = { [v4]: c4, [w4]: [{ [x4]: "UseFIPS" }, true] };
    var m4 = { [v4]: c4, [w4]: [{ [x4]: "UseDualStack" }, true] };
    var n4 = {};
    var o4 = { [v4]: h4, [w4]: [{ [x4]: g4 }, "supportsFIPS"] };
    var p4 = { [x4]: g4 };
    var q4 = { [v4]: c4, [w4]: [true, { [v4]: h4, [w4]: [p4, "supportsDualStack"] }] };
    var r4 = [l4];
    var s4 = [m4];
    var t4 = [{ [x4]: "Region" }];
    var _data4 = { version: "1.0", parameters: { Region: i4, UseDualStack: j4, UseFIPS: j4, Endpoint: i4 }, rules: [{ conditions: [{ [v4]: b4, [w4]: [k4] }], rules: [{ conditions: r4, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: d4 }, { conditions: s4, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: d4 }, { endpoint: { url: k4, properties: n4, headers: n4 }, type: e4 }], type: f4 }, { conditions: [{ [v4]: b4, [w4]: t4 }], rules: [{ conditions: [{ [v4]: "aws.partition", [w4]: t4, assign: g4 }], rules: [{ conditions: [l4, m4], rules: [{ conditions: [{ [v4]: c4, [w4]: [a4, o4] }, q4], rules: [{ endpoint: { url: "https://portal.sso-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: n4, headers: n4 }, type: e4 }], type: f4 }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: d4 }], type: f4 }, { conditions: r4, rules: [{ conditions: [{ [v4]: c4, [w4]: [o4, a4] }], rules: [{ conditions: [{ [v4]: "stringEquals", [w4]: [{ [v4]: h4, [w4]: [p4, "name"] }, "aws-us-gov"] }], endpoint: { url: "https://portal.sso.{Region}.amazonaws.com", properties: n4, headers: n4 }, type: e4 }, { endpoint: { url: "https://portal.sso-fips.{Region}.{PartitionResult#dnsSuffix}", properties: n4, headers: n4 }, type: e4 }], type: f4 }, { error: "FIPS is enabled but this partition does not support FIPS", type: d4 }], type: f4 }, { conditions: s4, rules: [{ conditions: [q4], rules: [{ endpoint: { url: "https://portal.sso.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: n4, headers: n4 }, type: e4 }], type: f4 }, { error: "DualStack is enabled but this partition does not support DualStack", type: d4 }], type: f4 }, { endpoint: { url: "https://portal.sso.{Region}.{PartitionResult#dnsSuffix}", properties: n4, headers: n4 }, type: e4 }], type: f4 }], type: f4 }, { error: "Invalid Configuration: Missing Region", type: d4 }] };
    exports2.ruleSet = _data4;
  }
});

// node_modules/.pnpm/@aws-sdk+client-sso@3.971.0/node_modules/@aws-sdk/client-sso/dist-cjs/endpoint/endpointResolver.js
var require_endpointResolver2 = __commonJS({
  "node_modules/.pnpm/@aws-sdk+client-sso@3.971.0/node_modules/@aws-sdk/client-sso/dist-cjs/endpoint/endpointResolver.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultEndpointResolver = void 0;
    var util_endpoints_1 = require_dist_cjs36();
    var util_endpoints_2 = require_dist_cjs33();
    var ruleset_1 = require_ruleset2();
    var cache5 = new util_endpoints_2.EndpointCache({
      size: 50,
      params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"]
    });
    var defaultEndpointResolver4 = (endpointParams, context = {}) => {
      return cache5.get(endpointParams, () => (0, util_endpoints_2.resolveEndpoint)(ruleset_1.ruleSet, {
        endpointParams,
        logger: context.logger
      }));
    };
    exports2.defaultEndpointResolver = defaultEndpointResolver4;
    util_endpoints_2.customEndpointFunctions.aws = util_endpoints_1.awsEndpointFunctions;
  }
});

// node_modules/.pnpm/@aws-sdk+client-sso@3.971.0/node_modules/@aws-sdk/client-sso/dist-cjs/runtimeConfig.shared.js
var require_runtimeConfig_shared = __commonJS({
  "node_modules/.pnpm/@aws-sdk+client-sso@3.971.0/node_modules/@aws-sdk/client-sso/dist-cjs/runtimeConfig.shared.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getRuntimeConfig = void 0;
    var core_1 = (init_dist_es2(), __toCommonJS(dist_es_exports2));
    var protocols_1 = (init_protocols2(), __toCommonJS(protocols_exports2));
    var core_2 = (init_dist_es(), __toCommonJS(dist_es_exports));
    var smithy_client_1 = require_dist_cjs20();
    var url_parser_1 = require_dist_cjs35();
    var util_base64_1 = require_dist_cjs9();
    var util_utf8_1 = require_dist_cjs8();
    var httpAuthSchemeProvider_1 = require_httpAuthSchemeProvider2();
    var endpointResolver_1 = require_endpointResolver2();
    var getRuntimeConfig7 = (config) => {
      return {
        apiVersion: "2019-06-10",
        base64Decoder: config?.base64Decoder ?? util_base64_1.fromBase64,
        base64Encoder: config?.base64Encoder ?? util_base64_1.toBase64,
        disableHostPrefix: config?.disableHostPrefix ?? false,
        endpointProvider: config?.endpointProvider ?? endpointResolver_1.defaultEndpointResolver,
        extensions: config?.extensions ?? [],
        httpAuthSchemeProvider: config?.httpAuthSchemeProvider ?? httpAuthSchemeProvider_1.defaultSSOHttpAuthSchemeProvider,
        httpAuthSchemes: config?.httpAuthSchemes ?? [
          {
            schemeId: "aws.auth#sigv4",
            identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
            signer: new core_1.AwsSdkSigV4Signer()
          },
          {
            schemeId: "smithy.api#noAuth",
            identityProvider: (ipc) => ipc.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
            signer: new core_2.NoAuthSigner()
          }
        ],
        logger: config?.logger ?? new smithy_client_1.NoOpLogger(),
        protocol: config?.protocol ?? protocols_1.AwsRestJsonProtocol,
        protocolSettings: config?.protocolSettings ?? {
          defaultNamespace: "com.amazonaws.sso",
          version: "2019-06-10",
          serviceTarget: "SWBPortalService"
        },
        serviceId: config?.serviceId ?? "SSO",
        urlParser: config?.urlParser ?? url_parser_1.parseUrl,
        utf8Decoder: config?.utf8Decoder ?? util_utf8_1.fromUtf8,
        utf8Encoder: config?.utf8Encoder ?? util_utf8_1.toUtf8
      };
    };
    exports2.getRuntimeConfig = getRuntimeConfig7;
  }
});

// node_modules/.pnpm/@aws-sdk+client-sso@3.971.0/node_modules/@aws-sdk/client-sso/dist-cjs/runtimeConfig.js
var require_runtimeConfig = __commonJS({
  "node_modules/.pnpm/@aws-sdk+client-sso@3.971.0/node_modules/@aws-sdk/client-sso/dist-cjs/runtimeConfig.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getRuntimeConfig = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var package_json_1 = tslib_1.__importDefault(require_package2());
    var core_1 = (init_dist_es2(), __toCommonJS(dist_es_exports2));
    var util_user_agent_node_1 = require_dist_cjs51();
    var config_resolver_1 = require_dist_cjs38();
    var hash_node_1 = require_dist_cjs52();
    var middleware_retry_1 = require_dist_cjs46();
    var node_config_provider_1 = require_dist_cjs42();
    var node_http_handler_1 = require_dist_cjs12();
    var smithy_client_1 = require_dist_cjs20();
    var util_body_length_node_1 = require_dist_cjs53();
    var util_defaults_mode_node_1 = require_dist_cjs54();
    var util_retry_1 = require_dist_cjs45();
    var runtimeConfig_shared_1 = require_runtimeConfig_shared();
    var getRuntimeConfig7 = (config) => {
      (0, smithy_client_1.emitWarningIfUnsupportedVersion)(process.version);
      const defaultsMode = (0, util_defaults_mode_node_1.resolveDefaultsModeConfig)(config);
      const defaultConfigProvider = () => defaultsMode().then(smithy_client_1.loadConfigsForDefaultMode);
      const clientSharedValues = (0, runtimeConfig_shared_1.getRuntimeConfig)(config);
      (0, core_1.emitWarningIfUnsupportedVersion)(process.version);
      const loaderConfig = {
        profile: config?.profile,
        logger: clientSharedValues.logger
      };
      return {
        ...clientSharedValues,
        ...config,
        runtime: "node",
        defaultsMode,
        authSchemePreference: config?.authSchemePreference ?? (0, node_config_provider_1.loadConfig)(core_1.NODE_AUTH_SCHEME_PREFERENCE_OPTIONS, loaderConfig),
        bodyLengthChecker: config?.bodyLengthChecker ?? util_body_length_node_1.calculateBodyLength,
        defaultUserAgentProvider: config?.defaultUserAgentProvider ?? (0, util_user_agent_node_1.createDefaultUserAgentProvider)({ serviceId: clientSharedValues.serviceId, clientVersion: package_json_1.default.version }),
        maxAttempts: config?.maxAttempts ?? (0, node_config_provider_1.loadConfig)(middleware_retry_1.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, config),
        region: config?.region ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_REGION_CONFIG_OPTIONS, { ...config_resolver_1.NODE_REGION_CONFIG_FILE_OPTIONS, ...loaderConfig }),
        requestHandler: node_http_handler_1.NodeHttpHandler.create(config?.requestHandler ?? defaultConfigProvider),
        retryMode: config?.retryMode ?? (0, node_config_provider_1.loadConfig)({
          ...middleware_retry_1.NODE_RETRY_MODE_CONFIG_OPTIONS,
          default: async () => (await defaultConfigProvider()).retryMode || util_retry_1.DEFAULT_RETRY_MODE
        }, config),
        sha256: config?.sha256 ?? hash_node_1.Hash.bind(null, "sha256"),
        streamCollector: config?.streamCollector ?? node_http_handler_1.streamCollector,
        useDualstackEndpoint: config?.useDualstackEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, loaderConfig),
        useFipsEndpoint: config?.useFipsEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, loaderConfig),
        userAgentAppId: config?.userAgentAppId ?? (0, node_config_provider_1.loadConfig)(util_user_agent_node_1.NODE_APP_ID_CONFIG_OPTIONS, loaderConfig)
      };
    };
    exports2.getRuntimeConfig = getRuntimeConfig7;
  }
});

// node_modules/.pnpm/@aws-sdk+client-sso@3.971.0/node_modules/@aws-sdk/client-sso/dist-cjs/index.js
var require_dist_cjs57 = __commonJS({
  "node_modules/.pnpm/@aws-sdk+client-sso@3.971.0/node_modules/@aws-sdk/client-sso/dist-cjs/index.js"(exports2) {
    "use strict";
    var middlewareHostHeader = require_dist_cjs27();
    var middlewareLogger = require_dist_cjs28();
    var middlewareRecursionDetection = require_dist_cjs29();
    var middlewareUserAgent = require_dist_cjs37();
    var configResolver = require_dist_cjs38();
    var core = (init_dist_es(), __toCommonJS(dist_es_exports));
    var schema = (init_schema(), __toCommonJS(schema_exports));
    var middlewareContentLength = require_dist_cjs40();
    var middlewareEndpoint = require_dist_cjs43();
    var middlewareRetry = require_dist_cjs46();
    var smithyClient = require_dist_cjs20();
    var httpAuthSchemeProvider = require_httpAuthSchemeProvider2();
    var runtimeConfig = require_runtimeConfig();
    var regionConfigResolver = require_dist_cjs55();
    var protocolHttp = require_dist_cjs2();
    var resolveClientEndpointParameters4 = (options) => {
      return Object.assign(options, {
        useDualstackEndpoint: options.useDualstackEndpoint ?? false,
        useFipsEndpoint: options.useFipsEndpoint ?? false,
        defaultSigningName: "awsssoportal"
      });
    };
    var commonParams4 = {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
    var getHttpAuthExtensionConfiguration4 = (runtimeConfig2) => {
      const _httpAuthSchemes = runtimeConfig2.httpAuthSchemes;
      let _httpAuthSchemeProvider = runtimeConfig2.httpAuthSchemeProvider;
      let _credentials = runtimeConfig2.credentials;
      return {
        setHttpAuthScheme(httpAuthScheme) {
          const index = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
          if (index === -1) {
            _httpAuthSchemes.push(httpAuthScheme);
          } else {
            _httpAuthSchemes.splice(index, 1, httpAuthScheme);
          }
        },
        httpAuthSchemes() {
          return _httpAuthSchemes;
        },
        setHttpAuthSchemeProvider(httpAuthSchemeProvider2) {
          _httpAuthSchemeProvider = httpAuthSchemeProvider2;
        },
        httpAuthSchemeProvider() {
          return _httpAuthSchemeProvider;
        },
        setCredentials(credentials) {
          _credentials = credentials;
        },
        credentials() {
          return _credentials;
        }
      };
    };
    var resolveHttpAuthRuntimeConfig4 = (config) => {
      return {
        httpAuthSchemes: config.httpAuthSchemes(),
        httpAuthSchemeProvider: config.httpAuthSchemeProvider(),
        credentials: config.credentials()
      };
    };
    var resolveRuntimeExtensions4 = (runtimeConfig2, extensions) => {
      const extensionConfiguration = Object.assign(regionConfigResolver.getAwsRegionExtensionConfiguration(runtimeConfig2), smithyClient.getDefaultExtensionConfiguration(runtimeConfig2), protocolHttp.getHttpHandlerExtensionConfiguration(runtimeConfig2), getHttpAuthExtensionConfiguration4(runtimeConfig2));
      extensions.forEach((extension) => extension.configure(extensionConfiguration));
      return Object.assign(runtimeConfig2, regionConfigResolver.resolveAwsRegionExtensionConfiguration(extensionConfiguration), smithyClient.resolveDefaultRuntimeConfig(extensionConfiguration), protocolHttp.resolveHttpHandlerRuntimeConfig(extensionConfiguration), resolveHttpAuthRuntimeConfig4(extensionConfiguration));
    };
    var SSOClient = class extends smithyClient.Client {
      config;
      constructor(...[configuration]) {
        const _config_0 = runtimeConfig.getRuntimeConfig(configuration || {});
        super(_config_0);
        this.initConfig = _config_0;
        const _config_1 = resolveClientEndpointParameters4(_config_0);
        const _config_2 = middlewareUserAgent.resolveUserAgentConfig(_config_1);
        const _config_3 = middlewareRetry.resolveRetryConfig(_config_2);
        const _config_4 = configResolver.resolveRegionConfig(_config_3);
        const _config_5 = middlewareHostHeader.resolveHostHeaderConfig(_config_4);
        const _config_6 = middlewareEndpoint.resolveEndpointConfig(_config_5);
        const _config_7 = httpAuthSchemeProvider.resolveHttpAuthSchemeConfig(_config_6);
        const _config_8 = resolveRuntimeExtensions4(_config_7, configuration?.extensions || []);
        this.config = _config_8;
        this.middlewareStack.use(schema.getSchemaSerdePlugin(this.config));
        this.middlewareStack.use(middlewareUserAgent.getUserAgentPlugin(this.config));
        this.middlewareStack.use(middlewareRetry.getRetryPlugin(this.config));
        this.middlewareStack.use(middlewareContentLength.getContentLengthPlugin(this.config));
        this.middlewareStack.use(middlewareHostHeader.getHostHeaderPlugin(this.config));
        this.middlewareStack.use(middlewareLogger.getLoggerPlugin(this.config));
        this.middlewareStack.use(middlewareRecursionDetection.getRecursionDetectionPlugin(this.config));
        this.middlewareStack.use(core.getHttpAuthSchemeEndpointRuleSetPlugin(this.config, {
          httpAuthSchemeParametersProvider: httpAuthSchemeProvider.defaultSSOHttpAuthSchemeParametersProvider,
          identityProviderConfigProvider: async (config) => new core.DefaultIdentityProviderConfig({
            "aws.auth#sigv4": config.credentials
          })
        }));
        this.middlewareStack.use(core.getHttpSigningPlugin(this.config));
      }
      destroy() {
        super.destroy();
      }
    };
    var SSOServiceException = class _SSOServiceException extends smithyClient.ServiceException {
      constructor(options) {
        super(options);
        Object.setPrototypeOf(this, _SSOServiceException.prototype);
      }
    };
    var InvalidRequestException2 = class _InvalidRequestException extends SSOServiceException {
      name = "InvalidRequestException";
      $fault = "client";
      constructor(opts) {
        super({
          name: "InvalidRequestException",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _InvalidRequestException.prototype);
      }
    };
    var ResourceNotFoundException = class _ResourceNotFoundException extends SSOServiceException {
      name = "ResourceNotFoundException";
      $fault = "client";
      constructor(opts) {
        super({
          name: "ResourceNotFoundException",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _ResourceNotFoundException.prototype);
      }
    };
    var TooManyRequestsException = class _TooManyRequestsException extends SSOServiceException {
      name = "TooManyRequestsException";
      $fault = "client";
      constructor(opts) {
        super({
          name: "TooManyRequestsException",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _TooManyRequestsException.prototype);
      }
    };
    var UnauthorizedException = class _UnauthorizedException extends SSOServiceException {
      name = "UnauthorizedException";
      $fault = "client";
      constructor(opts) {
        super({
          name: "UnauthorizedException",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _UnauthorizedException.prototype);
      }
    };
    var _AI = "AccountInfo";
    var _ALT = "AccountListType";
    var _ATT = "AccessTokenType";
    var _GRC = "GetRoleCredentials";
    var _GRCR = "GetRoleCredentialsRequest";
    var _GRCRe = "GetRoleCredentialsResponse";
    var _IRE2 = "InvalidRequestException";
    var _L = "Logout";
    var _LA = "ListAccounts";
    var _LAR = "ListAccountsRequest";
    var _LARR = "ListAccountRolesRequest";
    var _LARRi = "ListAccountRolesResponse";
    var _LARi = "ListAccountsResponse";
    var _LARis = "ListAccountRoles";
    var _LR = "LogoutRequest";
    var _RC = "RoleCredentials";
    var _RI = "RoleInfo";
    var _RLT = "RoleListType";
    var _RNFE = "ResourceNotFoundException";
    var _SAKT = "SecretAccessKeyType";
    var _STT = "SessionTokenType";
    var _TMRE2 = "TooManyRequestsException";
    var _UE = "UnauthorizedException";
    var _aI = "accountId";
    var _aKI2 = "accessKeyId";
    var _aL = "accountList";
    var _aN = "accountName";
    var _aT3 = "accessToken";
    var _ai = "account_id";
    var _c4 = "client";
    var _e4 = "error";
    var _eA = "emailAddress";
    var _ex = "expiration";
    var _h3 = "http";
    var _hE4 = "httpError";
    var _hH = "httpHeader";
    var _hQ = "httpQuery";
    var _m3 = "message";
    var _mR = "maxResults";
    var _mr = "max_result";
    var _nT = "nextToken";
    var _nt = "next_token";
    var _rC = "roleCredentials";
    var _rL = "roleList";
    var _rN = "roleName";
    var _rn = "role_name";
    var _s4 = "smithy.ts.sdk.synthetic.com.amazonaws.sso";
    var _sAK2 = "secretAccessKey";
    var _sT2 = "sessionToken";
    var _xasbt = "x-amz-sso_bearer_token";
    var n04 = "com.amazonaws.sso";
    var AccessTokenType = [0, n04, _ATT, 8, 0];
    var SecretAccessKeyType = [0, n04, _SAKT, 8, 0];
    var SessionTokenType = [0, n04, _STT, 8, 0];
    var AccountInfo$ = [
      3,
      n04,
      _AI,
      0,
      [_aI, _aN, _eA],
      [0, 0, 0]
    ];
    var GetRoleCredentialsRequest$ = [
      3,
      n04,
      _GRCR,
      0,
      [_rN, _aI, _aT3],
      [[0, { [_hQ]: _rn }], [0, { [_hQ]: _ai }], [() => AccessTokenType, { [_hH]: _xasbt }]],
      3
    ];
    var GetRoleCredentialsResponse$ = [
      3,
      n04,
      _GRCRe,
      0,
      [_rC],
      [[() => RoleCredentials$, 0]]
    ];
    var InvalidRequestException$2 = [
      -3,
      n04,
      _IRE2,
      { [_e4]: _c4, [_hE4]: 400 },
      [_m3],
      [0]
    ];
    schema.TypeRegistry.for(n04).registerError(InvalidRequestException$2, InvalidRequestException2);
    var ListAccountRolesRequest$ = [
      3,
      n04,
      _LARR,
      0,
      [_aT3, _aI, _nT, _mR],
      [[() => AccessTokenType, { [_hH]: _xasbt }], [0, { [_hQ]: _ai }], [0, { [_hQ]: _nt }], [1, { [_hQ]: _mr }]],
      2
    ];
    var ListAccountRolesResponse$ = [
      3,
      n04,
      _LARRi,
      0,
      [_nT, _rL],
      [0, () => RoleListType]
    ];
    var ListAccountsRequest$ = [
      3,
      n04,
      _LAR,
      0,
      [_aT3, _nT, _mR],
      [[() => AccessTokenType, { [_hH]: _xasbt }], [0, { [_hQ]: _nt }], [1, { [_hQ]: _mr }]],
      1
    ];
    var ListAccountsResponse$ = [
      3,
      n04,
      _LARi,
      0,
      [_nT, _aL],
      [0, () => AccountListType]
    ];
    var LogoutRequest$ = [
      3,
      n04,
      _LR,
      0,
      [_aT3],
      [[() => AccessTokenType, { [_hH]: _xasbt }]],
      1
    ];
    var ResourceNotFoundException$ = [
      -3,
      n04,
      _RNFE,
      { [_e4]: _c4, [_hE4]: 404 },
      [_m3],
      [0]
    ];
    schema.TypeRegistry.for(n04).registerError(ResourceNotFoundException$, ResourceNotFoundException);
    var RoleCredentials$ = [
      3,
      n04,
      _RC,
      0,
      [_aKI2, _sAK2, _sT2, _ex],
      [0, [() => SecretAccessKeyType, 0], [() => SessionTokenType, 0], 1]
    ];
    var RoleInfo$ = [
      3,
      n04,
      _RI,
      0,
      [_rN, _aI],
      [0, 0]
    ];
    var TooManyRequestsException$ = [
      -3,
      n04,
      _TMRE2,
      { [_e4]: _c4, [_hE4]: 429 },
      [_m3],
      [0]
    ];
    schema.TypeRegistry.for(n04).registerError(TooManyRequestsException$, TooManyRequestsException);
    var UnauthorizedException$ = [
      -3,
      n04,
      _UE,
      { [_e4]: _c4, [_hE4]: 401 },
      [_m3],
      [0]
    ];
    schema.TypeRegistry.for(n04).registerError(UnauthorizedException$, UnauthorizedException);
    var __Unit = "unit";
    var SSOServiceException$ = [-3, _s4, "SSOServiceException", 0, [], []];
    schema.TypeRegistry.for(_s4).registerError(SSOServiceException$, SSOServiceException);
    var AccountListType = [
      1,
      n04,
      _ALT,
      0,
      () => AccountInfo$
    ];
    var RoleListType = [
      1,
      n04,
      _RLT,
      0,
      () => RoleInfo$
    ];
    var GetRoleCredentials$ = [
      9,
      n04,
      _GRC,
      { [_h3]: ["GET", "/federation/credentials", 200] },
      () => GetRoleCredentialsRequest$,
      () => GetRoleCredentialsResponse$
    ];
    var ListAccountRoles$ = [
      9,
      n04,
      _LARis,
      { [_h3]: ["GET", "/assignment/roles", 200] },
      () => ListAccountRolesRequest$,
      () => ListAccountRolesResponse$
    ];
    var ListAccounts$ = [
      9,
      n04,
      _LA,
      { [_h3]: ["GET", "/assignment/accounts", 200] },
      () => ListAccountsRequest$,
      () => ListAccountsResponse$
    ];
    var Logout$ = [
      9,
      n04,
      _L,
      { [_h3]: ["POST", "/logout", 200] },
      () => LogoutRequest$,
      () => __Unit
    ];
    var GetRoleCredentialsCommand = class extends smithyClient.Command.classBuilder().ep(commonParams4).m(function(Command, cs, config, o4) {
      return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
    }).s("SWBPortalService", "GetRoleCredentials", {}).n("SSOClient", "GetRoleCredentialsCommand").sc(GetRoleCredentials$).build() {
    };
    var ListAccountRolesCommand = class extends smithyClient.Command.classBuilder().ep(commonParams4).m(function(Command, cs, config, o4) {
      return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
    }).s("SWBPortalService", "ListAccountRoles", {}).n("SSOClient", "ListAccountRolesCommand").sc(ListAccountRoles$).build() {
    };
    var ListAccountsCommand = class extends smithyClient.Command.classBuilder().ep(commonParams4).m(function(Command, cs, config, o4) {
      return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
    }).s("SWBPortalService", "ListAccounts", {}).n("SSOClient", "ListAccountsCommand").sc(ListAccounts$).build() {
    };
    var LogoutCommand = class extends smithyClient.Command.classBuilder().ep(commonParams4).m(function(Command, cs, config, o4) {
      return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
    }).s("SWBPortalService", "Logout", {}).n("SSOClient", "LogoutCommand").sc(Logout$).build() {
    };
    var commands4 = {
      GetRoleCredentialsCommand,
      ListAccountRolesCommand,
      ListAccountsCommand,
      LogoutCommand
    };
    var SSO = class extends SSOClient {
    };
    smithyClient.createAggregatedClient(commands4, SSO);
    var paginateListAccountRoles = core.createPaginator(SSOClient, ListAccountRolesCommand, "nextToken", "nextToken", "maxResults");
    var paginateListAccounts = core.createPaginator(SSOClient, ListAccountsCommand, "nextToken", "nextToken", "maxResults");
    Object.defineProperty(exports2, "$Command", {
      enumerable: true,
      get: function() {
        return smithyClient.Command;
      }
    });
    Object.defineProperty(exports2, "__Client", {
      enumerable: true,
      get: function() {
        return smithyClient.Client;
      }
    });
    exports2.AccountInfo$ = AccountInfo$;
    exports2.GetRoleCredentials$ = GetRoleCredentials$;
    exports2.GetRoleCredentialsCommand = GetRoleCredentialsCommand;
    exports2.GetRoleCredentialsRequest$ = GetRoleCredentialsRequest$;
    exports2.GetRoleCredentialsResponse$ = GetRoleCredentialsResponse$;
    exports2.InvalidRequestException = InvalidRequestException2;
    exports2.InvalidRequestException$ = InvalidRequestException$2;
    exports2.ListAccountRoles$ = ListAccountRoles$;
    exports2.ListAccountRolesCommand = ListAccountRolesCommand;
    exports2.ListAccountRolesRequest$ = ListAccountRolesRequest$;
    exports2.ListAccountRolesResponse$ = ListAccountRolesResponse$;
    exports2.ListAccounts$ = ListAccounts$;
    exports2.ListAccountsCommand = ListAccountsCommand;
    exports2.ListAccountsRequest$ = ListAccountsRequest$;
    exports2.ListAccountsResponse$ = ListAccountsResponse$;
    exports2.Logout$ = Logout$;
    exports2.LogoutCommand = LogoutCommand;
    exports2.LogoutRequest$ = LogoutRequest$;
    exports2.ResourceNotFoundException = ResourceNotFoundException;
    exports2.ResourceNotFoundException$ = ResourceNotFoundException$;
    exports2.RoleCredentials$ = RoleCredentials$;
    exports2.RoleInfo$ = RoleInfo$;
    exports2.SSO = SSO;
    exports2.SSOClient = SSOClient;
    exports2.SSOServiceException = SSOServiceException;
    exports2.SSOServiceException$ = SSOServiceException$;
    exports2.TooManyRequestsException = TooManyRequestsException;
    exports2.TooManyRequestsException$ = TooManyRequestsException$;
    exports2.UnauthorizedException = UnauthorizedException;
    exports2.UnauthorizedException$ = UnauthorizedException$;
    exports2.paginateListAccountRoles = paginateListAccountRoles;
    exports2.paginateListAccounts = paginateListAccounts;
  }
});

// node_modules/.pnpm/@aws-sdk+credential-provider-sso@3.971.0/node_modules/@aws-sdk/credential-provider-sso/dist-cjs/loadSso-CVy8iqsZ.js
var require_loadSso_CVy8iqsZ = __commonJS({
  "node_modules/.pnpm/@aws-sdk+credential-provider-sso@3.971.0/node_modules/@aws-sdk/credential-provider-sso/dist-cjs/loadSso-CVy8iqsZ.js"(exports2) {
    "use strict";
    var clientSso = require_dist_cjs57();
    Object.defineProperty(exports2, "GetRoleCredentialsCommand", {
      enumerable: true,
      get: function() {
        return clientSso.GetRoleCredentialsCommand;
      }
    });
    Object.defineProperty(exports2, "SSOClient", {
      enumerable: true,
      get: function() {
        return clientSso.SSOClient;
      }
    });
  }
});

// node_modules/.pnpm/@aws-sdk+credential-provider-sso@3.971.0/node_modules/@aws-sdk/credential-provider-sso/dist-cjs/index.js
var require_dist_cjs58 = __commonJS({
  "node_modules/.pnpm/@aws-sdk+credential-provider-sso@3.971.0/node_modules/@aws-sdk/credential-provider-sso/dist-cjs/index.js"(exports2) {
    "use strict";
    var propertyProvider = require_dist_cjs17();
    var sharedIniFileLoader = require_dist_cjs41();
    var client2 = (init_client(), __toCommonJS(client_exports));
    var tokenProviders = require_dist_cjs56();
    var isSsoProfile = (arg) => arg && (typeof arg.sso_start_url === "string" || typeof arg.sso_account_id === "string" || typeof arg.sso_session === "string" || typeof arg.sso_region === "string" || typeof arg.sso_role_name === "string");
    var SHOULD_FAIL_CREDENTIAL_CHAIN = false;
    var resolveSSOCredentials = async ({ ssoStartUrl, ssoSession, ssoAccountId, ssoRegion, ssoRoleName, ssoClient, clientConfig, parentClientConfig, callerClientConfig, profile, filepath, configFilepath, ignoreCache, logger: logger3 }) => {
      let token;
      const refreshMessage = `To refresh this SSO session run aws sso login with the corresponding profile.`;
      if (ssoSession) {
        try {
          const _token = await tokenProviders.fromSso({
            profile,
            filepath,
            configFilepath,
            ignoreCache
          })();
          token = {
            accessToken: _token.token,
            expiresAt: new Date(_token.expiration).toISOString()
          };
        } catch (e4) {
          throw new propertyProvider.CredentialsProviderError(e4.message, {
            tryNextLink: SHOULD_FAIL_CREDENTIAL_CHAIN,
            logger: logger3
          });
        }
      } else {
        try {
          token = await sharedIniFileLoader.getSSOTokenFromFile(ssoStartUrl);
        } catch (e4) {
          throw new propertyProvider.CredentialsProviderError(`The SSO session associated with this profile is invalid. ${refreshMessage}`, {
            tryNextLink: SHOULD_FAIL_CREDENTIAL_CHAIN,
            logger: logger3
          });
        }
      }
      if (new Date(token.expiresAt).getTime() - Date.now() <= 0) {
        throw new propertyProvider.CredentialsProviderError(`The SSO session associated with this profile has expired. ${refreshMessage}`, {
          tryNextLink: SHOULD_FAIL_CREDENTIAL_CHAIN,
          logger: logger3
        });
      }
      const { accessToken } = token;
      const { SSOClient, GetRoleCredentialsCommand } = await Promise.resolve().then(function() {
        return require_loadSso_CVy8iqsZ();
      });
      const sso = ssoClient || new SSOClient(Object.assign({}, clientConfig ?? {}, {
        logger: clientConfig?.logger ?? callerClientConfig?.logger ?? parentClientConfig?.logger,
        region: clientConfig?.region ?? ssoRegion,
        userAgentAppId: clientConfig?.userAgentAppId ?? callerClientConfig?.userAgentAppId ?? parentClientConfig?.userAgentAppId
      }));
      let ssoResp;
      try {
        ssoResp = await sso.send(new GetRoleCredentialsCommand({
          accountId: ssoAccountId,
          roleName: ssoRoleName,
          accessToken
        }));
      } catch (e4) {
        throw new propertyProvider.CredentialsProviderError(e4, {
          tryNextLink: SHOULD_FAIL_CREDENTIAL_CHAIN,
          logger: logger3
        });
      }
      const { roleCredentials: { accessKeyId, secretAccessKey, sessionToken, expiration, credentialScope, accountId } = {} } = ssoResp;
      if (!accessKeyId || !secretAccessKey || !sessionToken || !expiration) {
        throw new propertyProvider.CredentialsProviderError("SSO returns an invalid temporary credential.", {
          tryNextLink: SHOULD_FAIL_CREDENTIAL_CHAIN,
          logger: logger3
        });
      }
      const credentials = {
        accessKeyId,
        secretAccessKey,
        sessionToken,
        expiration: new Date(expiration),
        ...credentialScope && { credentialScope },
        ...accountId && { accountId }
      };
      if (ssoSession) {
        client2.setCredentialFeature(credentials, "CREDENTIALS_SSO", "s");
      } else {
        client2.setCredentialFeature(credentials, "CREDENTIALS_SSO_LEGACY", "u");
      }
      return credentials;
    };
    var validateSsoProfile = (profile, logger3) => {
      const { sso_start_url, sso_account_id, sso_region, sso_role_name } = profile;
      if (!sso_start_url || !sso_account_id || !sso_region || !sso_role_name) {
        throw new propertyProvider.CredentialsProviderError(`Profile is configured with invalid SSO credentials. Required parameters "sso_account_id", "sso_region", "sso_role_name", "sso_start_url". Got ${Object.keys(profile).join(", ")}
Reference: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-sso.html`, { tryNextLink: false, logger: logger3 });
      }
      return profile;
    };
    var fromSSO = (init = {}) => async ({ callerClientConfig } = {}) => {
      init.logger?.debug("@aws-sdk/credential-provider-sso - fromSSO");
      const { ssoStartUrl, ssoAccountId, ssoRegion, ssoRoleName, ssoSession } = init;
      const { ssoClient } = init;
      const profileName = sharedIniFileLoader.getProfileName({
        profile: init.profile ?? callerClientConfig?.profile
      });
      if (!ssoStartUrl && !ssoAccountId && !ssoRegion && !ssoRoleName && !ssoSession) {
        const profiles = await sharedIniFileLoader.parseKnownFiles(init);
        const profile = profiles[profileName];
        if (!profile) {
          throw new propertyProvider.CredentialsProviderError(`Profile ${profileName} was not found.`, { logger: init.logger });
        }
        if (!isSsoProfile(profile)) {
          throw new propertyProvider.CredentialsProviderError(`Profile ${profileName} is not configured with SSO credentials.`, {
            logger: init.logger
          });
        }
        if (profile?.sso_session) {
          const ssoSessions = await sharedIniFileLoader.loadSsoSessionData(init);
          const session = ssoSessions[profile.sso_session];
          const conflictMsg = ` configurations in profile ${profileName} and sso-session ${profile.sso_session}`;
          if (ssoRegion && ssoRegion !== session.sso_region) {
            throw new propertyProvider.CredentialsProviderError(`Conflicting SSO region` + conflictMsg, {
              tryNextLink: false,
              logger: init.logger
            });
          }
          if (ssoStartUrl && ssoStartUrl !== session.sso_start_url) {
            throw new propertyProvider.CredentialsProviderError(`Conflicting SSO start_url` + conflictMsg, {
              tryNextLink: false,
              logger: init.logger
            });
          }
          profile.sso_region = session.sso_region;
          profile.sso_start_url = session.sso_start_url;
        }
        const { sso_start_url, sso_account_id, sso_region, sso_role_name, sso_session } = validateSsoProfile(profile, init.logger);
        return resolveSSOCredentials({
          ssoStartUrl: sso_start_url,
          ssoSession: sso_session,
          ssoAccountId: sso_account_id,
          ssoRegion: sso_region,
          ssoRoleName: sso_role_name,
          ssoClient,
          clientConfig: init.clientConfig,
          parentClientConfig: init.parentClientConfig,
          callerClientConfig: init.callerClientConfig,
          profile: profileName,
          filepath: init.filepath,
          configFilepath: init.configFilepath,
          ignoreCache: init.ignoreCache,
          logger: init.logger
        });
      } else if (!ssoStartUrl || !ssoAccountId || !ssoRegion || !ssoRoleName) {
        throw new propertyProvider.CredentialsProviderError('Incomplete configuration. The fromSSO() argument hash must include "ssoStartUrl", "ssoAccountId", "ssoRegion", "ssoRoleName"', { tryNextLink: false, logger: init.logger });
      } else {
        return resolveSSOCredentials({
          ssoStartUrl,
          ssoSession,
          ssoAccountId,
          ssoRegion,
          ssoRoleName,
          ssoClient,
          clientConfig: init.clientConfig,
          parentClientConfig: init.parentClientConfig,
          callerClientConfig: init.callerClientConfig,
          profile: profileName,
          filepath: init.filepath,
          configFilepath: init.configFilepath,
          ignoreCache: init.ignoreCache,
          logger: init.logger
        });
      }
    };
    exports2.fromSSO = fromSSO;
    exports2.isSsoProfile = isSsoProfile;
    exports2.validateSsoProfile = validateSsoProfile;
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/signin/auth/httpAuthSchemeProvider.js
function createAwsAuthSigv4HttpAuthOption2(authParameters) {
  return {
    schemeId: "aws.auth#sigv4",
    signingProperties: {
      name: "signin",
      region: authParameters.region
    },
    propertiesExtractor: (config, context) => ({
      signingProperties: {
        config,
        context
      }
    })
  };
}
function createSmithyApiNoAuthHttpAuthOption2(authParameters) {
  return {
    schemeId: "smithy.api#noAuth"
  };
}
var import_util_middleware7, defaultSigninHttpAuthSchemeParametersProvider, defaultSigninHttpAuthSchemeProvider, resolveHttpAuthSchemeConfig2;
var init_httpAuthSchemeProvider2 = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/signin/auth/httpAuthSchemeProvider.js"() {
    init_dist_es2();
    import_util_middleware7 = __toESM(require_dist_cjs4());
    defaultSigninHttpAuthSchemeParametersProvider = async (config, context, input) => {
      return {
        operation: (0, import_util_middleware7.getSmithyContext)(context).operation,
        region: await (0, import_util_middleware7.normalizeProvider)(config.region)() || (() => {
          throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
        })()
      };
    };
    defaultSigninHttpAuthSchemeProvider = (authParameters) => {
      const options = [];
      switch (authParameters.operation) {
        case "CreateOAuth2Token": {
          options.push(createSmithyApiNoAuthHttpAuthOption2(authParameters));
          break;
        }
        default: {
          options.push(createAwsAuthSigv4HttpAuthOption2(authParameters));
        }
      }
      return options;
    };
    resolveHttpAuthSchemeConfig2 = (config) => {
      const config_0 = resolveAwsSdkSigV4Config(config);
      return Object.assign(config_0, {
        authSchemePreference: (0, import_util_middleware7.normalizeProvider)(config.authSchemePreference ?? [])
      });
    };
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/signin/endpoint/EndpointParameters.js
var resolveClientEndpointParameters2, commonParams2;
var init_EndpointParameters2 = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/signin/endpoint/EndpointParameters.js"() {
    resolveClientEndpointParameters2 = (options) => {
      return Object.assign(options, {
        useDualstackEndpoint: options.useDualstackEndpoint ?? false,
        useFipsEndpoint: options.useFipsEndpoint ?? false,
        defaultSigningName: "signin"
      });
    };
    commonParams2 = {
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/signin/endpoint/ruleset.js
var u2, v2, w2, x2, a2, b2, c2, d2, e2, f2, g2, h2, i2, j2, k2, l2, m2, n2, o2, p2, q2, r2, s2, t2, _data2, ruleSet2;
var init_ruleset2 = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/signin/endpoint/ruleset.js"() {
    u2 = "required";
    v2 = "fn";
    w2 = "argv";
    x2 = "ref";
    a2 = true;
    b2 = "isSet";
    c2 = "booleanEquals";
    d2 = "error";
    e2 = "endpoint";
    f2 = "tree";
    g2 = "PartitionResult";
    h2 = "stringEquals";
    i2 = { [u2]: true, "default": false, "type": "boolean" };
    j2 = { [u2]: false, "type": "string" };
    k2 = { [x2]: "Endpoint" };
    l2 = { [v2]: c2, [w2]: [{ [x2]: "UseFIPS" }, true] };
    m2 = { [v2]: c2, [w2]: [{ [x2]: "UseDualStack" }, true] };
    n2 = {};
    o2 = { [v2]: "getAttr", [w2]: [{ [x2]: g2 }, "name"] };
    p2 = { [v2]: c2, [w2]: [{ [x2]: "UseFIPS" }, false] };
    q2 = { [v2]: c2, [w2]: [{ [x2]: "UseDualStack" }, false] };
    r2 = { [v2]: "getAttr", [w2]: [{ [x2]: g2 }, "supportsFIPS"] };
    s2 = { [v2]: c2, [w2]: [true, { [v2]: "getAttr", [w2]: [{ [x2]: g2 }, "supportsDualStack"] }] };
    t2 = [{ [x2]: "Region" }];
    _data2 = { version: "1.0", parameters: { UseDualStack: i2, UseFIPS: i2, Endpoint: j2, Region: j2 }, rules: [{ conditions: [{ [v2]: b2, [w2]: [k2] }], rules: [{ conditions: [l2], error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: d2 }, { rules: [{ conditions: [m2], error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: d2 }, { endpoint: { url: k2, properties: n2, headers: n2 }, type: e2 }], type: f2 }], type: f2 }, { rules: [{ conditions: [{ [v2]: b2, [w2]: t2 }], rules: [{ conditions: [{ [v2]: "aws.partition", [w2]: t2, assign: g2 }], rules: [{ conditions: [{ [v2]: h2, [w2]: [o2, "aws"] }, p2, q2], endpoint: { url: "https://{Region}.signin.aws.amazon.com", properties: n2, headers: n2 }, type: e2 }, { conditions: [{ [v2]: h2, [w2]: [o2, "aws-cn"] }, p2, q2], endpoint: { url: "https://{Region}.signin.amazonaws.cn", properties: n2, headers: n2 }, type: e2 }, { conditions: [{ [v2]: h2, [w2]: [o2, "aws-us-gov"] }, p2, q2], endpoint: { url: "https://{Region}.signin.amazonaws-us-gov.com", properties: n2, headers: n2 }, type: e2 }, { conditions: [l2, m2], rules: [{ conditions: [{ [v2]: c2, [w2]: [a2, r2] }, s2], rules: [{ endpoint: { url: "https://signin-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: n2, headers: n2 }, type: e2 }], type: f2 }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: d2 }], type: f2 }, { conditions: [l2, q2], rules: [{ conditions: [{ [v2]: c2, [w2]: [r2, a2] }], rules: [{ endpoint: { url: "https://signin-fips.{Region}.{PartitionResult#dnsSuffix}", properties: n2, headers: n2 }, type: e2 }], type: f2 }, { error: "FIPS is enabled but this partition does not support FIPS", type: d2 }], type: f2 }, { conditions: [p2, m2], rules: [{ conditions: [s2], rules: [{ endpoint: { url: "https://signin.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: n2, headers: n2 }, type: e2 }], type: f2 }, { error: "DualStack is enabled but this partition does not support DualStack", type: d2 }], type: f2 }, { endpoint: { url: "https://signin.{Region}.{PartitionResult#dnsSuffix}", properties: n2, headers: n2 }, type: e2 }], type: f2 }], type: f2 }, { error: "Invalid Configuration: Missing Region", type: d2 }], type: f2 }] };
    ruleSet2 = _data2;
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/signin/endpoint/endpointResolver.js
var import_util_endpoints3, import_util_endpoints4, cache2, defaultEndpointResolver2;
var init_endpointResolver2 = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/signin/endpoint/endpointResolver.js"() {
    import_util_endpoints3 = __toESM(require_dist_cjs36());
    import_util_endpoints4 = __toESM(require_dist_cjs33());
    init_ruleset2();
    cache2 = new import_util_endpoints4.EndpointCache({
      size: 50,
      params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"]
    });
    defaultEndpointResolver2 = (endpointParams, context = {}) => {
      return cache2.get(endpointParams, () => (0, import_util_endpoints4.resolveEndpoint)(ruleSet2, {
        endpointParams,
        logger: context.logger
      }));
    };
    import_util_endpoints4.customEndpointFunctions.aws = import_util_endpoints3.awsEndpointFunctions;
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/signin/runtimeConfig.shared.js
var import_smithy_client15, import_url_parser2, import_util_base649, import_util_utf89, getRuntimeConfig3;
var init_runtimeConfig_shared2 = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/signin/runtimeConfig.shared.js"() {
    init_dist_es2();
    init_protocols2();
    init_dist_es();
    import_smithy_client15 = __toESM(require_dist_cjs20());
    import_url_parser2 = __toESM(require_dist_cjs35());
    import_util_base649 = __toESM(require_dist_cjs9());
    import_util_utf89 = __toESM(require_dist_cjs8());
    init_httpAuthSchemeProvider2();
    init_endpointResolver2();
    getRuntimeConfig3 = (config) => {
      return {
        apiVersion: "2023-01-01",
        base64Decoder: config?.base64Decoder ?? import_util_base649.fromBase64,
        base64Encoder: config?.base64Encoder ?? import_util_base649.toBase64,
        disableHostPrefix: config?.disableHostPrefix ?? false,
        endpointProvider: config?.endpointProvider ?? defaultEndpointResolver2,
        extensions: config?.extensions ?? [],
        httpAuthSchemeProvider: config?.httpAuthSchemeProvider ?? defaultSigninHttpAuthSchemeProvider,
        httpAuthSchemes: config?.httpAuthSchemes ?? [
          {
            schemeId: "aws.auth#sigv4",
            identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
            signer: new AwsSdkSigV4Signer()
          },
          {
            schemeId: "smithy.api#noAuth",
            identityProvider: (ipc) => ipc.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
            signer: new NoAuthSigner()
          }
        ],
        logger: config?.logger ?? new import_smithy_client15.NoOpLogger(),
        protocol: config?.protocol ?? AwsRestJsonProtocol,
        protocolSettings: config?.protocolSettings ?? {
          defaultNamespace: "com.amazonaws.signin",
          version: "2023-01-01",
          serviceTarget: "Signin"
        },
        serviceId: config?.serviceId ?? "Signin",
        urlParser: config?.urlParser ?? import_url_parser2.parseUrl,
        utf8Decoder: config?.utf8Decoder ?? import_util_utf89.fromUtf8,
        utf8Encoder: config?.utf8Encoder ?? import_util_utf89.toUtf8
      };
    };
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/signin/runtimeConfig.js
var import_util_user_agent_node2, import_config_resolver3, import_hash_node2, import_middleware_retry3, import_node_config_provider2, import_node_http_handler2, import_smithy_client16, import_util_body_length_node2, import_util_defaults_mode_node2, import_util_retry2, getRuntimeConfig4;
var init_runtimeConfig2 = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/signin/runtimeConfig.js"() {
    init_package();
    init_dist_es2();
    import_util_user_agent_node2 = __toESM(require_dist_cjs51());
    import_config_resolver3 = __toESM(require_dist_cjs38());
    import_hash_node2 = __toESM(require_dist_cjs52());
    import_middleware_retry3 = __toESM(require_dist_cjs46());
    import_node_config_provider2 = __toESM(require_dist_cjs42());
    import_node_http_handler2 = __toESM(require_dist_cjs12());
    import_smithy_client16 = __toESM(require_dist_cjs20());
    import_util_body_length_node2 = __toESM(require_dist_cjs53());
    import_util_defaults_mode_node2 = __toESM(require_dist_cjs54());
    import_util_retry2 = __toESM(require_dist_cjs45());
    init_runtimeConfig_shared2();
    getRuntimeConfig4 = (config) => {
      (0, import_smithy_client16.emitWarningIfUnsupportedVersion)(process.version);
      const defaultsMode = (0, import_util_defaults_mode_node2.resolveDefaultsModeConfig)(config);
      const defaultConfigProvider = () => defaultsMode().then(import_smithy_client16.loadConfigsForDefaultMode);
      const clientSharedValues = getRuntimeConfig3(config);
      emitWarningIfUnsupportedVersion(process.version);
      const loaderConfig = {
        profile: config?.profile,
        logger: clientSharedValues.logger
      };
      return {
        ...clientSharedValues,
        ...config,
        runtime: "node",
        defaultsMode,
        authSchemePreference: config?.authSchemePreference ?? (0, import_node_config_provider2.loadConfig)(NODE_AUTH_SCHEME_PREFERENCE_OPTIONS, loaderConfig),
        bodyLengthChecker: config?.bodyLengthChecker ?? import_util_body_length_node2.calculateBodyLength,
        defaultUserAgentProvider: config?.defaultUserAgentProvider ?? (0, import_util_user_agent_node2.createDefaultUserAgentProvider)({ serviceId: clientSharedValues.serviceId, clientVersion: package_default.version }),
        maxAttempts: config?.maxAttempts ?? (0, import_node_config_provider2.loadConfig)(import_middleware_retry3.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, config),
        region: config?.region ?? (0, import_node_config_provider2.loadConfig)(import_config_resolver3.NODE_REGION_CONFIG_OPTIONS, { ...import_config_resolver3.NODE_REGION_CONFIG_FILE_OPTIONS, ...loaderConfig }),
        requestHandler: import_node_http_handler2.NodeHttpHandler.create(config?.requestHandler ?? defaultConfigProvider),
        retryMode: config?.retryMode ?? (0, import_node_config_provider2.loadConfig)({
          ...import_middleware_retry3.NODE_RETRY_MODE_CONFIG_OPTIONS,
          default: async () => (await defaultConfigProvider()).retryMode || import_util_retry2.DEFAULT_RETRY_MODE
        }, config),
        sha256: config?.sha256 ?? import_hash_node2.Hash.bind(null, "sha256"),
        streamCollector: config?.streamCollector ?? import_node_http_handler2.streamCollector,
        useDualstackEndpoint: config?.useDualstackEndpoint ?? (0, import_node_config_provider2.loadConfig)(import_config_resolver3.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, loaderConfig),
        useFipsEndpoint: config?.useFipsEndpoint ?? (0, import_node_config_provider2.loadConfig)(import_config_resolver3.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, loaderConfig),
        userAgentAppId: config?.userAgentAppId ?? (0, import_node_config_provider2.loadConfig)(import_util_user_agent_node2.NODE_APP_ID_CONFIG_OPTIONS, loaderConfig)
      };
    };
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/signin/auth/httpAuthExtensionConfiguration.js
var getHttpAuthExtensionConfiguration2, resolveHttpAuthRuntimeConfig2;
var init_httpAuthExtensionConfiguration2 = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/signin/auth/httpAuthExtensionConfiguration.js"() {
    getHttpAuthExtensionConfiguration2 = (runtimeConfig) => {
      const _httpAuthSchemes = runtimeConfig.httpAuthSchemes;
      let _httpAuthSchemeProvider = runtimeConfig.httpAuthSchemeProvider;
      let _credentials = runtimeConfig.credentials;
      return {
        setHttpAuthScheme(httpAuthScheme) {
          const index = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
          if (index === -1) {
            _httpAuthSchemes.push(httpAuthScheme);
          } else {
            _httpAuthSchemes.splice(index, 1, httpAuthScheme);
          }
        },
        httpAuthSchemes() {
          return _httpAuthSchemes;
        },
        setHttpAuthSchemeProvider(httpAuthSchemeProvider) {
          _httpAuthSchemeProvider = httpAuthSchemeProvider;
        },
        httpAuthSchemeProvider() {
          return _httpAuthSchemeProvider;
        },
        setCredentials(credentials) {
          _credentials = credentials;
        },
        credentials() {
          return _credentials;
        }
      };
    };
    resolveHttpAuthRuntimeConfig2 = (config) => {
      return {
        httpAuthSchemes: config.httpAuthSchemes(),
        httpAuthSchemeProvider: config.httpAuthSchemeProvider(),
        credentials: config.credentials()
      };
    };
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/signin/runtimeExtensions.js
var import_region_config_resolver2, import_protocol_http13, import_smithy_client17, resolveRuntimeExtensions2;
var init_runtimeExtensions2 = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/signin/runtimeExtensions.js"() {
    import_region_config_resolver2 = __toESM(require_dist_cjs55());
    import_protocol_http13 = __toESM(require_dist_cjs2());
    import_smithy_client17 = __toESM(require_dist_cjs20());
    init_httpAuthExtensionConfiguration2();
    resolveRuntimeExtensions2 = (runtimeConfig, extensions) => {
      const extensionConfiguration = Object.assign((0, import_region_config_resolver2.getAwsRegionExtensionConfiguration)(runtimeConfig), (0, import_smithy_client17.getDefaultExtensionConfiguration)(runtimeConfig), (0, import_protocol_http13.getHttpHandlerExtensionConfiguration)(runtimeConfig), getHttpAuthExtensionConfiguration2(runtimeConfig));
      extensions.forEach((extension) => extension.configure(extensionConfiguration));
      return Object.assign(runtimeConfig, (0, import_region_config_resolver2.resolveAwsRegionExtensionConfiguration)(extensionConfiguration), (0, import_smithy_client17.resolveDefaultRuntimeConfig)(extensionConfiguration), (0, import_protocol_http13.resolveHttpHandlerRuntimeConfig)(extensionConfiguration), resolveHttpAuthRuntimeConfig2(extensionConfiguration));
    };
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/signin/SigninClient.js
var import_middleware_host_header2, import_middleware_logger2, import_middleware_recursion_detection2, import_middleware_user_agent2, import_config_resolver4, import_middleware_content_length2, import_middleware_endpoint3, import_middleware_retry4, import_smithy_client18, SigninClient;
var init_SigninClient = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/signin/SigninClient.js"() {
    import_middleware_host_header2 = __toESM(require_dist_cjs27());
    import_middleware_logger2 = __toESM(require_dist_cjs28());
    import_middleware_recursion_detection2 = __toESM(require_dist_cjs29());
    import_middleware_user_agent2 = __toESM(require_dist_cjs37());
    import_config_resolver4 = __toESM(require_dist_cjs38());
    init_dist_es();
    init_schema();
    import_middleware_content_length2 = __toESM(require_dist_cjs40());
    import_middleware_endpoint3 = __toESM(require_dist_cjs43());
    import_middleware_retry4 = __toESM(require_dist_cjs46());
    import_smithy_client18 = __toESM(require_dist_cjs20());
    init_httpAuthSchemeProvider2();
    init_EndpointParameters2();
    init_runtimeConfig2();
    init_runtimeExtensions2();
    SigninClient = class extends import_smithy_client18.Client {
      config;
      constructor(...[configuration]) {
        const _config_0 = getRuntimeConfig4(configuration || {});
        super(_config_0);
        this.initConfig = _config_0;
        const _config_1 = resolveClientEndpointParameters2(_config_0);
        const _config_2 = (0, import_middleware_user_agent2.resolveUserAgentConfig)(_config_1);
        const _config_3 = (0, import_middleware_retry4.resolveRetryConfig)(_config_2);
        const _config_4 = (0, import_config_resolver4.resolveRegionConfig)(_config_3);
        const _config_5 = (0, import_middleware_host_header2.resolveHostHeaderConfig)(_config_4);
        const _config_6 = (0, import_middleware_endpoint3.resolveEndpointConfig)(_config_5);
        const _config_7 = resolveHttpAuthSchemeConfig2(_config_6);
        const _config_8 = resolveRuntimeExtensions2(_config_7, configuration?.extensions || []);
        this.config = _config_8;
        this.middlewareStack.use(getSchemaSerdePlugin(this.config));
        this.middlewareStack.use((0, import_middleware_user_agent2.getUserAgentPlugin)(this.config));
        this.middlewareStack.use((0, import_middleware_retry4.getRetryPlugin)(this.config));
        this.middlewareStack.use((0, import_middleware_content_length2.getContentLengthPlugin)(this.config));
        this.middlewareStack.use((0, import_middleware_host_header2.getHostHeaderPlugin)(this.config));
        this.middlewareStack.use((0, import_middleware_logger2.getLoggerPlugin)(this.config));
        this.middlewareStack.use((0, import_middleware_recursion_detection2.getRecursionDetectionPlugin)(this.config));
        this.middlewareStack.use(getHttpAuthSchemeEndpointRuleSetPlugin(this.config, {
          httpAuthSchemeParametersProvider: defaultSigninHttpAuthSchemeParametersProvider,
          identityProviderConfigProvider: async (config) => new DefaultIdentityProviderConfig({
            "aws.auth#sigv4": config.credentials
          })
        }));
        this.middlewareStack.use(getHttpSigningPlugin(this.config));
      }
      destroy() {
        super.destroy();
      }
    };
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/signin/models/SigninServiceException.js
var import_smithy_client19, SigninServiceException;
var init_SigninServiceException = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/signin/models/SigninServiceException.js"() {
    import_smithy_client19 = __toESM(require_dist_cjs20());
    SigninServiceException = class _SigninServiceException extends import_smithy_client19.ServiceException {
      constructor(options) {
        super(options);
        Object.setPrototypeOf(this, _SigninServiceException.prototype);
      }
    };
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/signin/models/errors.js
var AccessDeniedException2, InternalServerException2, TooManyRequestsError, ValidationException;
var init_errors2 = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/signin/models/errors.js"() {
    init_SigninServiceException();
    AccessDeniedException2 = class _AccessDeniedException extends SigninServiceException {
      name = "AccessDeniedException";
      $fault = "client";
      error;
      constructor(opts) {
        super({
          name: "AccessDeniedException",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _AccessDeniedException.prototype);
        this.error = opts.error;
      }
    };
    InternalServerException2 = class _InternalServerException extends SigninServiceException {
      name = "InternalServerException";
      $fault = "server";
      error;
      constructor(opts) {
        super({
          name: "InternalServerException",
          $fault: "server",
          ...opts
        });
        Object.setPrototypeOf(this, _InternalServerException.prototype);
        this.error = opts.error;
      }
    };
    TooManyRequestsError = class _TooManyRequestsError extends SigninServiceException {
      name = "TooManyRequestsError";
      $fault = "client";
      error;
      constructor(opts) {
        super({
          name: "TooManyRequestsError",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _TooManyRequestsError.prototype);
        this.error = opts.error;
      }
    };
    ValidationException = class _ValidationException extends SigninServiceException {
      name = "ValidationException";
      $fault = "client";
      error;
      constructor(opts) {
        super({
          name: "ValidationException",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _ValidationException.prototype);
        this.error = opts.error;
      }
    };
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/signin/schemas/schemas_0.js
var _ADE2, _AT2, _COAT, _COATR, _COATRB, _COATRBr, _COATRr, _ISE2, _RT2, _TMRE, _VE, _aKI, _aT2, _c2, _cI2, _cV2, _co2, _e2, _eI2, _gT2, _h2, _hE2, _iT2, _jN, _m, _rT2, _rU2, _s2, _sAK, _sT, _sm2, _tI, _tO, _tT2, n02, RefreshToken2, AccessDeniedException$2, AccessToken$, CreateOAuth2TokenRequest$, CreateOAuth2TokenRequestBody$, CreateOAuth2TokenResponse$, CreateOAuth2TokenResponseBody$, InternalServerException$2, TooManyRequestsError$, ValidationException$, SigninServiceException$, CreateOAuth2Token$;
var init_schemas_02 = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/signin/schemas/schemas_0.js"() {
    init_schema();
    init_errors2();
    init_SigninServiceException();
    _ADE2 = "AccessDeniedException";
    _AT2 = "AccessToken";
    _COAT = "CreateOAuth2Token";
    _COATR = "CreateOAuth2TokenRequest";
    _COATRB = "CreateOAuth2TokenRequestBody";
    _COATRBr = "CreateOAuth2TokenResponseBody";
    _COATRr = "CreateOAuth2TokenResponse";
    _ISE2 = "InternalServerException";
    _RT2 = "RefreshToken";
    _TMRE = "TooManyRequestsError";
    _VE = "ValidationException";
    _aKI = "accessKeyId";
    _aT2 = "accessToken";
    _c2 = "client";
    _cI2 = "clientId";
    _cV2 = "codeVerifier";
    _co2 = "code";
    _e2 = "error";
    _eI2 = "expiresIn";
    _gT2 = "grantType";
    _h2 = "http";
    _hE2 = "httpError";
    _iT2 = "idToken";
    _jN = "jsonName";
    _m = "message";
    _rT2 = "refreshToken";
    _rU2 = "redirectUri";
    _s2 = "server";
    _sAK = "secretAccessKey";
    _sT = "sessionToken";
    _sm2 = "smithy.ts.sdk.synthetic.com.amazonaws.signin";
    _tI = "tokenInput";
    _tO = "tokenOutput";
    _tT2 = "tokenType";
    n02 = "com.amazonaws.signin";
    RefreshToken2 = [0, n02, _RT2, 8, 0];
    AccessDeniedException$2 = [-3, n02, _ADE2, { [_e2]: _c2 }, [_e2, _m], [0, 0], 2];
    TypeRegistry.for(n02).registerError(AccessDeniedException$2, AccessDeniedException2);
    AccessToken$ = [
      3,
      n02,
      _AT2,
      8,
      [_aKI, _sAK, _sT],
      [
        [0, { [_jN]: _aKI }],
        [0, { [_jN]: _sAK }],
        [0, { [_jN]: _sT }]
      ],
      3
    ];
    CreateOAuth2TokenRequest$ = [
      3,
      n02,
      _COATR,
      0,
      [_tI],
      [[() => CreateOAuth2TokenRequestBody$, 16]],
      1
    ];
    CreateOAuth2TokenRequestBody$ = [
      3,
      n02,
      _COATRB,
      0,
      [_cI2, _gT2, _co2, _rU2, _cV2, _rT2],
      [
        [0, { [_jN]: _cI2 }],
        [0, { [_jN]: _gT2 }],
        0,
        [0, { [_jN]: _rU2 }],
        [0, { [_jN]: _cV2 }],
        [() => RefreshToken2, { [_jN]: _rT2 }]
      ],
      2
    ];
    CreateOAuth2TokenResponse$ = [
      3,
      n02,
      _COATRr,
      0,
      [_tO],
      [[() => CreateOAuth2TokenResponseBody$, 16]],
      1
    ];
    CreateOAuth2TokenResponseBody$ = [
      3,
      n02,
      _COATRBr,
      0,
      [_aT2, _tT2, _eI2, _rT2, _iT2],
      [
        [() => AccessToken$, { [_jN]: _aT2 }],
        [0, { [_jN]: _tT2 }],
        [1, { [_jN]: _eI2 }],
        [() => RefreshToken2, { [_jN]: _rT2 }],
        [0, { [_jN]: _iT2 }]
      ],
      4
    ];
    InternalServerException$2 = [-3, n02, _ISE2, { [_e2]: _s2, [_hE2]: 500 }, [_e2, _m], [0, 0], 2];
    TypeRegistry.for(n02).registerError(InternalServerException$2, InternalServerException2);
    TooManyRequestsError$ = [-3, n02, _TMRE, { [_e2]: _c2, [_hE2]: 429 }, [_e2, _m], [0, 0], 2];
    TypeRegistry.for(n02).registerError(TooManyRequestsError$, TooManyRequestsError);
    ValidationException$ = [-3, n02, _VE, { [_e2]: _c2, [_hE2]: 400 }, [_e2, _m], [0, 0], 2];
    TypeRegistry.for(n02).registerError(ValidationException$, ValidationException);
    SigninServiceException$ = [-3, _sm2, "SigninServiceException", 0, [], []];
    TypeRegistry.for(_sm2).registerError(SigninServiceException$, SigninServiceException);
    CreateOAuth2Token$ = [
      9,
      n02,
      _COAT,
      { [_h2]: ["POST", "/v1/token", 200] },
      () => CreateOAuth2TokenRequest$,
      () => CreateOAuth2TokenResponse$
    ];
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/signin/commands/CreateOAuth2TokenCommand.js
var import_middleware_endpoint4, import_smithy_client20, CreateOAuth2TokenCommand;
var init_CreateOAuth2TokenCommand = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/signin/commands/CreateOAuth2TokenCommand.js"() {
    import_middleware_endpoint4 = __toESM(require_dist_cjs43());
    import_smithy_client20 = __toESM(require_dist_cjs20());
    init_EndpointParameters2();
    init_schemas_02();
    CreateOAuth2TokenCommand = class extends import_smithy_client20.Command.classBuilder().ep(commonParams2).m(function(Command, cs, config, o4) {
      return [(0, import_middleware_endpoint4.getEndpointPlugin)(config, Command.getEndpointParameterInstructions())];
    }).s("Signin", "CreateOAuth2Token", {}).n("SigninClient", "CreateOAuth2TokenCommand").sc(CreateOAuth2Token$).build() {
    };
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/signin/Signin.js
var import_smithy_client21, commands2, Signin;
var init_Signin = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/signin/Signin.js"() {
    import_smithy_client21 = __toESM(require_dist_cjs20());
    init_CreateOAuth2TokenCommand();
    init_SigninClient();
    commands2 = {
      CreateOAuth2TokenCommand
    };
    Signin = class extends SigninClient {
    };
    (0, import_smithy_client21.createAggregatedClient)(commands2, Signin);
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/signin/commands/index.js
var init_commands2 = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/signin/commands/index.js"() {
    init_CreateOAuth2TokenCommand();
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/signin/models/enums.js
var OAuth2ErrorCode;
var init_enums2 = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/signin/models/enums.js"() {
    OAuth2ErrorCode = {
      AUTHCODE_EXPIRED: "AUTHCODE_EXPIRED",
      INSUFFICIENT_PERMISSIONS: "INSUFFICIENT_PERMISSIONS",
      INVALID_REQUEST: "INVALID_REQUEST",
      SERVER_ERROR: "server_error",
      TOKEN_EXPIRED: "TOKEN_EXPIRED",
      USER_CREDENTIALS_CHANGED: "USER_CREDENTIALS_CHANGED"
    };
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/signin/models/models_0.js
var init_models_02 = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/signin/models/models_0.js"() {
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/signin/index.js
var signin_exports = {};
__export(signin_exports, {
  $Command: () => import_smithy_client20.Command,
  AccessDeniedException: () => AccessDeniedException2,
  AccessDeniedException$: () => AccessDeniedException$2,
  AccessToken$: () => AccessToken$,
  CreateOAuth2Token$: () => CreateOAuth2Token$,
  CreateOAuth2TokenCommand: () => CreateOAuth2TokenCommand,
  CreateOAuth2TokenRequest$: () => CreateOAuth2TokenRequest$,
  CreateOAuth2TokenRequestBody$: () => CreateOAuth2TokenRequestBody$,
  CreateOAuth2TokenResponse$: () => CreateOAuth2TokenResponse$,
  CreateOAuth2TokenResponseBody$: () => CreateOAuth2TokenResponseBody$,
  InternalServerException: () => InternalServerException2,
  InternalServerException$: () => InternalServerException$2,
  OAuth2ErrorCode: () => OAuth2ErrorCode,
  Signin: () => Signin,
  SigninClient: () => SigninClient,
  SigninServiceException: () => SigninServiceException,
  SigninServiceException$: () => SigninServiceException$,
  TooManyRequestsError: () => TooManyRequestsError,
  TooManyRequestsError$: () => TooManyRequestsError$,
  ValidationException: () => ValidationException,
  ValidationException$: () => ValidationException$,
  __Client: () => import_smithy_client18.Client
});
var init_signin = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/signin/index.js"() {
    init_SigninClient();
    init_Signin();
    init_commands2();
    init_schemas_02();
    init_enums2();
    init_errors2();
    init_models_02();
    init_SigninServiceException();
  }
});

// node_modules/.pnpm/@aws-sdk+credential-provider-login@3.971.0/node_modules/@aws-sdk/credential-provider-login/dist-cjs/index.js
var require_dist_cjs59 = __commonJS({
  "node_modules/.pnpm/@aws-sdk+credential-provider-login@3.971.0/node_modules/@aws-sdk/credential-provider-login/dist-cjs/index.js"(exports2) {
    "use strict";
    var client2 = (init_client(), __toCommonJS(client_exports));
    var propertyProvider = require_dist_cjs17();
    var sharedIniFileLoader = require_dist_cjs41();
    var protocolHttp = require_dist_cjs2();
    var node_crypto = require("node:crypto");
    var node_fs = require("node:fs");
    var node_os = require("node:os");
    var node_path = require("node:path");
    var LoginCredentialsFetcher = class _LoginCredentialsFetcher {
      profileData;
      init;
      callerClientConfig;
      static REFRESH_THRESHOLD = 5 * 60 * 1e3;
      constructor(profileData, init, callerClientConfig) {
        this.profileData = profileData;
        this.init = init;
        this.callerClientConfig = callerClientConfig;
      }
      async loadCredentials() {
        const token = await this.loadToken();
        if (!token) {
          throw new propertyProvider.CredentialsProviderError(`Failed to load a token for session ${this.loginSession}, please re-authenticate using aws login`, { tryNextLink: false, logger: this.logger });
        }
        const accessToken = token.accessToken;
        const now = Date.now();
        const expiryTime = new Date(accessToken.expiresAt).getTime();
        const timeUntilExpiry = expiryTime - now;
        if (timeUntilExpiry <= _LoginCredentialsFetcher.REFRESH_THRESHOLD) {
          return this.refresh(token);
        }
        return {
          accessKeyId: accessToken.accessKeyId,
          secretAccessKey: accessToken.secretAccessKey,
          sessionToken: accessToken.sessionToken,
          accountId: accessToken.accountId,
          expiration: new Date(accessToken.expiresAt)
        };
      }
      get logger() {
        return this.init?.logger;
      }
      get loginSession() {
        return this.profileData.login_session;
      }
      async refresh(token) {
        const { SigninClient: SigninClient2, CreateOAuth2TokenCommand: CreateOAuth2TokenCommand2 } = await Promise.resolve().then(() => (init_signin(), signin_exports));
        const { logger: logger3, userAgentAppId } = this.callerClientConfig ?? {};
        const isH22 = (requestHandler2) => {
          return requestHandler2?.metadata?.handlerProtocol === "h2";
        };
        const requestHandler = isH22(this.callerClientConfig?.requestHandler) ? void 0 : this.callerClientConfig?.requestHandler;
        const region = this.profileData.region ?? await this.callerClientConfig?.region?.() ?? process.env.AWS_REGION;
        const client3 = new SigninClient2({
          credentials: {
            accessKeyId: "",
            secretAccessKey: ""
          },
          region,
          requestHandler,
          logger: logger3,
          userAgentAppId,
          ...this.init?.clientConfig
        });
        this.createDPoPInterceptor(client3.middlewareStack);
        const commandInput = {
          tokenInput: {
            clientId: token.clientId,
            refreshToken: token.refreshToken,
            grantType: "refresh_token"
          }
        };
        try {
          const response2 = await client3.send(new CreateOAuth2TokenCommand2(commandInput));
          const { accessKeyId, secretAccessKey, sessionToken } = response2.tokenOutput?.accessToken ?? {};
          const { refreshToken, expiresIn } = response2.tokenOutput ?? {};
          if (!accessKeyId || !secretAccessKey || !sessionToken || !refreshToken) {
            throw new propertyProvider.CredentialsProviderError("Token refresh response missing required fields", {
              logger: this.logger,
              tryNextLink: false
            });
          }
          const expiresInMs = (expiresIn ?? 900) * 1e3;
          const expiration = new Date(Date.now() + expiresInMs);
          const updatedToken = {
            ...token,
            accessToken: {
              ...token.accessToken,
              accessKeyId,
              secretAccessKey,
              sessionToken,
              expiresAt: expiration.toISOString()
            },
            refreshToken
          };
          await this.saveToken(updatedToken);
          const newAccessToken = updatedToken.accessToken;
          return {
            accessKeyId: newAccessToken.accessKeyId,
            secretAccessKey: newAccessToken.secretAccessKey,
            sessionToken: newAccessToken.sessionToken,
            accountId: newAccessToken.accountId,
            expiration
          };
        } catch (error2) {
          if (error2.name === "AccessDeniedException") {
            const errorType = error2.error;
            let message;
            switch (errorType) {
              case "TOKEN_EXPIRED":
                message = "Your session has expired. Please reauthenticate.";
                break;
              case "USER_CREDENTIALS_CHANGED":
                message = "Unable to refresh credentials because of a change in your password. Please reauthenticate with your new password.";
                break;
              case "INSUFFICIENT_PERMISSIONS":
                message = "Unable to refresh credentials due to insufficient permissions. You may be missing permission for the 'CreateOAuth2Token' action.";
                break;
              default:
                message = `Failed to refresh token: ${String(error2)}. Please re-authenticate using \`aws login\``;
            }
            throw new propertyProvider.CredentialsProviderError(message, { logger: this.logger, tryNextLink: false });
          }
          throw new propertyProvider.CredentialsProviderError(`Failed to refresh token: ${String(error2)}. Please re-authenticate using aws login`, { logger: this.logger });
        }
      }
      async loadToken() {
        const tokenFilePath = this.getTokenFilePath();
        try {
          let tokenData;
          try {
            tokenData = await sharedIniFileLoader.readFile(tokenFilePath, { ignoreCache: this.init?.ignoreCache });
          } catch {
            tokenData = await node_fs.promises.readFile(tokenFilePath, "utf8");
          }
          const token = JSON.parse(tokenData);
          const missingFields = ["accessToken", "clientId", "refreshToken", "dpopKey"].filter((k4) => !token[k4]);
          if (!token.accessToken?.accountId) {
            missingFields.push("accountId");
          }
          if (missingFields.length > 0) {
            throw new propertyProvider.CredentialsProviderError(`Token validation failed, missing fields: ${missingFields.join(", ")}`, {
              logger: this.logger,
              tryNextLink: false
            });
          }
          return token;
        } catch (error2) {
          throw new propertyProvider.CredentialsProviderError(`Failed to load token from ${tokenFilePath}: ${String(error2)}`, {
            logger: this.logger,
            tryNextLink: false
          });
        }
      }
      async saveToken(token) {
        const tokenFilePath = this.getTokenFilePath();
        const directory = node_path.dirname(tokenFilePath);
        try {
          await node_fs.promises.mkdir(directory, { recursive: true });
        } catch (error2) {
        }
        await node_fs.promises.writeFile(tokenFilePath, JSON.stringify(token, null, 2), "utf8");
      }
      getTokenFilePath() {
        const directory = process.env.AWS_LOGIN_CACHE_DIRECTORY ?? node_path.join(node_os.homedir(), ".aws", "login", "cache");
        const loginSessionBytes = Buffer.from(this.loginSession, "utf8");
        const loginSessionSha256 = node_crypto.createHash("sha256").update(loginSessionBytes).digest("hex");
        return node_path.join(directory, `${loginSessionSha256}.json`);
      }
      derToRawSignature(derSignature) {
        let offset = 2;
        if (derSignature[offset] !== 2) {
          throw new Error("Invalid DER signature");
        }
        offset++;
        const rLength = derSignature[offset++];
        let r4 = derSignature.subarray(offset, offset + rLength);
        offset += rLength;
        if (derSignature[offset] !== 2) {
          throw new Error("Invalid DER signature");
        }
        offset++;
        const sLength = derSignature[offset++];
        let s4 = derSignature.subarray(offset, offset + sLength);
        r4 = r4[0] === 0 ? r4.subarray(1) : r4;
        s4 = s4[0] === 0 ? s4.subarray(1) : s4;
        const rPadded = Buffer.concat([Buffer.alloc(32 - r4.length), r4]);
        const sPadded = Buffer.concat([Buffer.alloc(32 - s4.length), s4]);
        return Buffer.concat([rPadded, sPadded]);
      }
      createDPoPInterceptor(middlewareStack) {
        middlewareStack.add((next) => async (args) => {
          if (protocolHttp.HttpRequest.isInstance(args.request)) {
            const request2 = args.request;
            const actualEndpoint = `${request2.protocol}//${request2.hostname}${request2.port ? `:${request2.port}` : ""}${request2.path}`;
            const dpop = await this.generateDpop(request2.method, actualEndpoint);
            request2.headers = {
              ...request2.headers,
              DPoP: dpop
            };
          }
          return next(args);
        }, {
          step: "finalizeRequest",
          name: "dpopInterceptor",
          override: true
        });
      }
      async generateDpop(method = "POST", endpoint) {
        const token = await this.loadToken();
        try {
          const privateKey = node_crypto.createPrivateKey({
            key: token.dpopKey,
            format: "pem",
            type: "sec1"
          });
          const publicKey = node_crypto.createPublicKey(privateKey);
          const publicDer = publicKey.export({ format: "der", type: "spki" });
          let pointStart = -1;
          for (let i4 = 0; i4 < publicDer.length; i4++) {
            if (publicDer[i4] === 4) {
              pointStart = i4;
              break;
            }
          }
          const x4 = publicDer.slice(pointStart + 1, pointStart + 33);
          const y2 = publicDer.slice(pointStart + 33, pointStart + 65);
          const header = {
            alg: "ES256",
            typ: "dpop+jwt",
            jwk: {
              kty: "EC",
              crv: "P-256",
              x: x4.toString("base64url"),
              y: y2.toString("base64url")
            }
          };
          const payload2 = {
            jti: crypto.randomUUID(),
            htm: method,
            htu: endpoint,
            iat: Math.floor(Date.now() / 1e3)
          };
          const headerB64 = Buffer.from(JSON.stringify(header)).toString("base64url");
          const payloadB64 = Buffer.from(JSON.stringify(payload2)).toString("base64url");
          const message = `${headerB64}.${payloadB64}`;
          const asn1Signature = node_crypto.sign("sha256", Buffer.from(message), privateKey);
          const rawSignature = this.derToRawSignature(asn1Signature);
          const signatureB64 = rawSignature.toString("base64url");
          return `${message}.${signatureB64}`;
        } catch (error2) {
          throw new propertyProvider.CredentialsProviderError(`Failed to generate Dpop proof: ${error2 instanceof Error ? error2.message : String(error2)}`, { logger: this.logger, tryNextLink: false });
        }
      }
    };
    var fromLoginCredentials = (init) => async ({ callerClientConfig } = {}) => {
      init?.logger?.debug?.("@aws-sdk/credential-providers - fromLoginCredentials");
      const profiles = await sharedIniFileLoader.parseKnownFiles(init || {});
      const profileName = sharedIniFileLoader.getProfileName({
        profile: init?.profile ?? callerClientConfig?.profile
      });
      const profile = profiles[profileName];
      if (!profile?.login_session) {
        throw new propertyProvider.CredentialsProviderError(`Profile ${profileName} does not contain login_session.`, {
          tryNextLink: true,
          logger: init?.logger
        });
      }
      const fetcher = new LoginCredentialsFetcher(profile, init, callerClientConfig);
      const credentials = await fetcher.loadCredentials();
      return client2.setCredentialFeature(credentials, "CREDENTIALS_LOGIN", "AD");
    };
    exports2.fromLoginCredentials = fromLoginCredentials;
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/auth/httpAuthSchemeProvider.js
function createAwsAuthSigv4HttpAuthOption3(authParameters) {
  return {
    schemeId: "aws.auth#sigv4",
    signingProperties: {
      name: "sts",
      region: authParameters.region
    },
    propertiesExtractor: (config, context) => ({
      signingProperties: {
        config,
        context
      }
    })
  };
}
function createSmithyApiNoAuthHttpAuthOption3(authParameters) {
  return {
    schemeId: "smithy.api#noAuth"
  };
}
var import_util_middleware8, defaultSTSHttpAuthSchemeParametersProvider, defaultSTSHttpAuthSchemeProvider, resolveStsAuthConfig, resolveHttpAuthSchemeConfig3;
var init_httpAuthSchemeProvider3 = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/auth/httpAuthSchemeProvider.js"() {
    init_dist_es2();
    import_util_middleware8 = __toESM(require_dist_cjs4());
    init_STSClient();
    defaultSTSHttpAuthSchemeParametersProvider = async (config, context, input) => {
      return {
        operation: (0, import_util_middleware8.getSmithyContext)(context).operation,
        region: await (0, import_util_middleware8.normalizeProvider)(config.region)() || (() => {
          throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
        })()
      };
    };
    defaultSTSHttpAuthSchemeProvider = (authParameters) => {
      const options = [];
      switch (authParameters.operation) {
        case "AssumeRoleWithWebIdentity": {
          options.push(createSmithyApiNoAuthHttpAuthOption3(authParameters));
          break;
        }
        default: {
          options.push(createAwsAuthSigv4HttpAuthOption3(authParameters));
        }
      }
      return options;
    };
    resolveStsAuthConfig = (input) => Object.assign(input, {
      stsClientCtor: STSClient
    });
    resolveHttpAuthSchemeConfig3 = (config) => {
      const config_0 = resolveStsAuthConfig(config);
      const config_1 = resolveAwsSdkSigV4Config(config_0);
      return Object.assign(config_1, {
        authSchemePreference: (0, import_util_middleware8.normalizeProvider)(config.authSchemePreference ?? [])
      });
    };
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/endpoint/EndpointParameters.js
var resolveClientEndpointParameters3, commonParams3;
var init_EndpointParameters3 = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/endpoint/EndpointParameters.js"() {
    resolveClientEndpointParameters3 = (options) => {
      return Object.assign(options, {
        useDualstackEndpoint: options.useDualstackEndpoint ?? false,
        useFipsEndpoint: options.useFipsEndpoint ?? false,
        useGlobalEndpoint: options.useGlobalEndpoint ?? false,
        defaultSigningName: "sts"
      });
    };
    commonParams3 = {
      UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/endpoint/ruleset.js
var F, G, H, I, J, a3, b3, c3, d3, e3, f3, g3, h3, i3, j3, k3, l3, m3, n3, o3, p3, q3, r3, s3, t3, u3, v3, w3, x3, y, z, A, B, C, D, E, _data3, ruleSet3;
var init_ruleset3 = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/endpoint/ruleset.js"() {
    F = "required";
    G = "type";
    H = "fn";
    I = "argv";
    J = "ref";
    a3 = false;
    b3 = true;
    c3 = "booleanEquals";
    d3 = "stringEquals";
    e3 = "sigv4";
    f3 = "sts";
    g3 = "us-east-1";
    h3 = "endpoint";
    i3 = "https://sts.{Region}.{PartitionResult#dnsSuffix}";
    j3 = "tree";
    k3 = "error";
    l3 = "getAttr";
    m3 = { [F]: false, [G]: "string" };
    n3 = { [F]: true, "default": false, [G]: "boolean" };
    o3 = { [J]: "Endpoint" };
    p3 = { [H]: "isSet", [I]: [{ [J]: "Region" }] };
    q3 = { [J]: "Region" };
    r3 = { [H]: "aws.partition", [I]: [q3], "assign": "PartitionResult" };
    s3 = { [J]: "UseFIPS" };
    t3 = { [J]: "UseDualStack" };
    u3 = { "url": "https://sts.amazonaws.com", "properties": { "authSchemes": [{ "name": e3, "signingName": f3, "signingRegion": g3 }] }, "headers": {} };
    v3 = {};
    w3 = { "conditions": [{ [H]: d3, [I]: [q3, "aws-global"] }], [h3]: u3, [G]: h3 };
    x3 = { [H]: c3, [I]: [s3, true] };
    y = { [H]: c3, [I]: [t3, true] };
    z = { [H]: l3, [I]: [{ [J]: "PartitionResult" }, "supportsFIPS"] };
    A = { [J]: "PartitionResult" };
    B = { [H]: c3, [I]: [true, { [H]: l3, [I]: [A, "supportsDualStack"] }] };
    C = [{ [H]: "isSet", [I]: [o3] }];
    D = [x3];
    E = [y];
    _data3 = { version: "1.0", parameters: { Region: m3, UseDualStack: n3, UseFIPS: n3, Endpoint: m3, UseGlobalEndpoint: n3 }, rules: [{ conditions: [{ [H]: c3, [I]: [{ [J]: "UseGlobalEndpoint" }, b3] }, { [H]: "not", [I]: C }, p3, r3, { [H]: c3, [I]: [s3, a3] }, { [H]: c3, [I]: [t3, a3] }], rules: [{ conditions: [{ [H]: d3, [I]: [q3, "ap-northeast-1"] }], endpoint: u3, [G]: h3 }, { conditions: [{ [H]: d3, [I]: [q3, "ap-south-1"] }], endpoint: u3, [G]: h3 }, { conditions: [{ [H]: d3, [I]: [q3, "ap-southeast-1"] }], endpoint: u3, [G]: h3 }, { conditions: [{ [H]: d3, [I]: [q3, "ap-southeast-2"] }], endpoint: u3, [G]: h3 }, w3, { conditions: [{ [H]: d3, [I]: [q3, "ca-central-1"] }], endpoint: u3, [G]: h3 }, { conditions: [{ [H]: d3, [I]: [q3, "eu-central-1"] }], endpoint: u3, [G]: h3 }, { conditions: [{ [H]: d3, [I]: [q3, "eu-north-1"] }], endpoint: u3, [G]: h3 }, { conditions: [{ [H]: d3, [I]: [q3, "eu-west-1"] }], endpoint: u3, [G]: h3 }, { conditions: [{ [H]: d3, [I]: [q3, "eu-west-2"] }], endpoint: u3, [G]: h3 }, { conditions: [{ [H]: d3, [I]: [q3, "eu-west-3"] }], endpoint: u3, [G]: h3 }, { conditions: [{ [H]: d3, [I]: [q3, "sa-east-1"] }], endpoint: u3, [G]: h3 }, { conditions: [{ [H]: d3, [I]: [q3, g3] }], endpoint: u3, [G]: h3 }, { conditions: [{ [H]: d3, [I]: [q3, "us-east-2"] }], endpoint: u3, [G]: h3 }, { conditions: [{ [H]: d3, [I]: [q3, "us-west-1"] }], endpoint: u3, [G]: h3 }, { conditions: [{ [H]: d3, [I]: [q3, "us-west-2"] }], endpoint: u3, [G]: h3 }, { endpoint: { url: i3, properties: { authSchemes: [{ name: e3, signingName: f3, signingRegion: "{Region}" }] }, headers: v3 }, [G]: h3 }], [G]: j3 }, { conditions: C, rules: [{ conditions: D, error: "Invalid Configuration: FIPS and custom endpoint are not supported", [G]: k3 }, { conditions: E, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", [G]: k3 }, { endpoint: { url: o3, properties: v3, headers: v3 }, [G]: h3 }], [G]: j3 }, { conditions: [p3], rules: [{ conditions: [r3], rules: [{ conditions: [x3, y], rules: [{ conditions: [{ [H]: c3, [I]: [b3, z] }, B], rules: [{ endpoint: { url: "https://sts-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: v3, headers: v3 }, [G]: h3 }], [G]: j3 }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", [G]: k3 }], [G]: j3 }, { conditions: D, rules: [{ conditions: [{ [H]: c3, [I]: [z, b3] }], rules: [{ conditions: [{ [H]: d3, [I]: [{ [H]: l3, [I]: [A, "name"] }, "aws-us-gov"] }], endpoint: { url: "https://sts.{Region}.amazonaws.com", properties: v3, headers: v3 }, [G]: h3 }, { endpoint: { url: "https://sts-fips.{Region}.{PartitionResult#dnsSuffix}", properties: v3, headers: v3 }, [G]: h3 }], [G]: j3 }, { error: "FIPS is enabled but this partition does not support FIPS", [G]: k3 }], [G]: j3 }, { conditions: E, rules: [{ conditions: [B], rules: [{ endpoint: { url: "https://sts.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: v3, headers: v3 }, [G]: h3 }], [G]: j3 }, { error: "DualStack is enabled but this partition does not support DualStack", [G]: k3 }], [G]: j3 }, w3, { endpoint: { url: i3, properties: v3, headers: v3 }, [G]: h3 }], [G]: j3 }], [G]: j3 }, { error: "Invalid Configuration: Missing Region", [G]: k3 }] };
    ruleSet3 = _data3;
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/endpoint/endpointResolver.js
var import_util_endpoints5, import_util_endpoints6, cache3, defaultEndpointResolver3;
var init_endpointResolver3 = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/endpoint/endpointResolver.js"() {
    import_util_endpoints5 = __toESM(require_dist_cjs36());
    import_util_endpoints6 = __toESM(require_dist_cjs33());
    init_ruleset3();
    cache3 = new import_util_endpoints6.EndpointCache({
      size: 50,
      params: ["Endpoint", "Region", "UseDualStack", "UseFIPS", "UseGlobalEndpoint"]
    });
    defaultEndpointResolver3 = (endpointParams, context = {}) => {
      return cache3.get(endpointParams, () => (0, import_util_endpoints6.resolveEndpoint)(ruleSet3, {
        endpointParams,
        logger: context.logger
      }));
    };
    import_util_endpoints6.customEndpointFunctions.aws = import_util_endpoints5.awsEndpointFunctions;
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/runtimeConfig.shared.js
var import_smithy_client22, import_url_parser3, import_util_base6410, import_util_utf810, getRuntimeConfig5;
var init_runtimeConfig_shared3 = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/runtimeConfig.shared.js"() {
    init_dist_es2();
    init_protocols2();
    init_dist_es();
    import_smithy_client22 = __toESM(require_dist_cjs20());
    import_url_parser3 = __toESM(require_dist_cjs35());
    import_util_base6410 = __toESM(require_dist_cjs9());
    import_util_utf810 = __toESM(require_dist_cjs8());
    init_httpAuthSchemeProvider3();
    init_endpointResolver3();
    getRuntimeConfig5 = (config) => {
      return {
        apiVersion: "2011-06-15",
        base64Decoder: config?.base64Decoder ?? import_util_base6410.fromBase64,
        base64Encoder: config?.base64Encoder ?? import_util_base6410.toBase64,
        disableHostPrefix: config?.disableHostPrefix ?? false,
        endpointProvider: config?.endpointProvider ?? defaultEndpointResolver3,
        extensions: config?.extensions ?? [],
        httpAuthSchemeProvider: config?.httpAuthSchemeProvider ?? defaultSTSHttpAuthSchemeProvider,
        httpAuthSchemes: config?.httpAuthSchemes ?? [
          {
            schemeId: "aws.auth#sigv4",
            identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
            signer: new AwsSdkSigV4Signer()
          },
          {
            schemeId: "smithy.api#noAuth",
            identityProvider: (ipc) => ipc.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
            signer: new NoAuthSigner()
          }
        ],
        logger: config?.logger ?? new import_smithy_client22.NoOpLogger(),
        protocol: config?.protocol ?? AwsQueryProtocol,
        protocolSettings: config?.protocolSettings ?? {
          defaultNamespace: "com.amazonaws.sts",
          xmlNamespace: "https://sts.amazonaws.com/doc/2011-06-15/",
          version: "2011-06-15",
          serviceTarget: "AWSSecurityTokenServiceV20110615"
        },
        serviceId: config?.serviceId ?? "STS",
        urlParser: config?.urlParser ?? import_url_parser3.parseUrl,
        utf8Decoder: config?.utf8Decoder ?? import_util_utf810.fromUtf8,
        utf8Encoder: config?.utf8Encoder ?? import_util_utf810.toUtf8
      };
    };
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/runtimeConfig.js
var import_util_user_agent_node3, import_config_resolver5, import_hash_node3, import_middleware_retry5, import_node_config_provider3, import_node_http_handler3, import_smithy_client23, import_util_body_length_node3, import_util_defaults_mode_node3, import_util_retry3, getRuntimeConfig6;
var init_runtimeConfig3 = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/runtimeConfig.js"() {
    init_package();
    init_dist_es2();
    import_util_user_agent_node3 = __toESM(require_dist_cjs51());
    import_config_resolver5 = __toESM(require_dist_cjs38());
    init_dist_es();
    import_hash_node3 = __toESM(require_dist_cjs52());
    import_middleware_retry5 = __toESM(require_dist_cjs46());
    import_node_config_provider3 = __toESM(require_dist_cjs42());
    import_node_http_handler3 = __toESM(require_dist_cjs12());
    import_smithy_client23 = __toESM(require_dist_cjs20());
    import_util_body_length_node3 = __toESM(require_dist_cjs53());
    import_util_defaults_mode_node3 = __toESM(require_dist_cjs54());
    import_util_retry3 = __toESM(require_dist_cjs45());
    init_runtimeConfig_shared3();
    getRuntimeConfig6 = (config) => {
      (0, import_smithy_client23.emitWarningIfUnsupportedVersion)(process.version);
      const defaultsMode = (0, import_util_defaults_mode_node3.resolveDefaultsModeConfig)(config);
      const defaultConfigProvider = () => defaultsMode().then(import_smithy_client23.loadConfigsForDefaultMode);
      const clientSharedValues = getRuntimeConfig5(config);
      emitWarningIfUnsupportedVersion(process.version);
      const loaderConfig = {
        profile: config?.profile,
        logger: clientSharedValues.logger
      };
      return {
        ...clientSharedValues,
        ...config,
        runtime: "node",
        defaultsMode,
        authSchemePreference: config?.authSchemePreference ?? (0, import_node_config_provider3.loadConfig)(NODE_AUTH_SCHEME_PREFERENCE_OPTIONS, loaderConfig),
        bodyLengthChecker: config?.bodyLengthChecker ?? import_util_body_length_node3.calculateBodyLength,
        defaultUserAgentProvider: config?.defaultUserAgentProvider ?? (0, import_util_user_agent_node3.createDefaultUserAgentProvider)({ serviceId: clientSharedValues.serviceId, clientVersion: package_default.version }),
        httpAuthSchemes: config?.httpAuthSchemes ?? [
          {
            schemeId: "aws.auth#sigv4",
            identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4") || (async (idProps) => await config.credentialDefaultProvider(idProps?.__config || {})()),
            signer: new AwsSdkSigV4Signer()
          },
          {
            schemeId: "smithy.api#noAuth",
            identityProvider: (ipc) => ipc.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
            signer: new NoAuthSigner()
          }
        ],
        maxAttempts: config?.maxAttempts ?? (0, import_node_config_provider3.loadConfig)(import_middleware_retry5.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, config),
        region: config?.region ?? (0, import_node_config_provider3.loadConfig)(import_config_resolver5.NODE_REGION_CONFIG_OPTIONS, { ...import_config_resolver5.NODE_REGION_CONFIG_FILE_OPTIONS, ...loaderConfig }),
        requestHandler: import_node_http_handler3.NodeHttpHandler.create(config?.requestHandler ?? defaultConfigProvider),
        retryMode: config?.retryMode ?? (0, import_node_config_provider3.loadConfig)({
          ...import_middleware_retry5.NODE_RETRY_MODE_CONFIG_OPTIONS,
          default: async () => (await defaultConfigProvider()).retryMode || import_util_retry3.DEFAULT_RETRY_MODE
        }, config),
        sha256: config?.sha256 ?? import_hash_node3.Hash.bind(null, "sha256"),
        streamCollector: config?.streamCollector ?? import_node_http_handler3.streamCollector,
        useDualstackEndpoint: config?.useDualstackEndpoint ?? (0, import_node_config_provider3.loadConfig)(import_config_resolver5.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, loaderConfig),
        useFipsEndpoint: config?.useFipsEndpoint ?? (0, import_node_config_provider3.loadConfig)(import_config_resolver5.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, loaderConfig),
        userAgentAppId: config?.userAgentAppId ?? (0, import_node_config_provider3.loadConfig)(import_util_user_agent_node3.NODE_APP_ID_CONFIG_OPTIONS, loaderConfig)
      };
    };
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/auth/httpAuthExtensionConfiguration.js
var getHttpAuthExtensionConfiguration3, resolveHttpAuthRuntimeConfig3;
var init_httpAuthExtensionConfiguration3 = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/auth/httpAuthExtensionConfiguration.js"() {
    getHttpAuthExtensionConfiguration3 = (runtimeConfig) => {
      const _httpAuthSchemes = runtimeConfig.httpAuthSchemes;
      let _httpAuthSchemeProvider = runtimeConfig.httpAuthSchemeProvider;
      let _credentials = runtimeConfig.credentials;
      return {
        setHttpAuthScheme(httpAuthScheme) {
          const index = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
          if (index === -1) {
            _httpAuthSchemes.push(httpAuthScheme);
          } else {
            _httpAuthSchemes.splice(index, 1, httpAuthScheme);
          }
        },
        httpAuthSchemes() {
          return _httpAuthSchemes;
        },
        setHttpAuthSchemeProvider(httpAuthSchemeProvider) {
          _httpAuthSchemeProvider = httpAuthSchemeProvider;
        },
        httpAuthSchemeProvider() {
          return _httpAuthSchemeProvider;
        },
        setCredentials(credentials) {
          _credentials = credentials;
        },
        credentials() {
          return _credentials;
        }
      };
    };
    resolveHttpAuthRuntimeConfig3 = (config) => {
      return {
        httpAuthSchemes: config.httpAuthSchemes(),
        httpAuthSchemeProvider: config.httpAuthSchemeProvider(),
        credentials: config.credentials()
      };
    };
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/runtimeExtensions.js
var import_region_config_resolver3, import_protocol_http14, import_smithy_client24, resolveRuntimeExtensions3;
var init_runtimeExtensions3 = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/runtimeExtensions.js"() {
    import_region_config_resolver3 = __toESM(require_dist_cjs55());
    import_protocol_http14 = __toESM(require_dist_cjs2());
    import_smithy_client24 = __toESM(require_dist_cjs20());
    init_httpAuthExtensionConfiguration3();
    resolveRuntimeExtensions3 = (runtimeConfig, extensions) => {
      const extensionConfiguration = Object.assign((0, import_region_config_resolver3.getAwsRegionExtensionConfiguration)(runtimeConfig), (0, import_smithy_client24.getDefaultExtensionConfiguration)(runtimeConfig), (0, import_protocol_http14.getHttpHandlerExtensionConfiguration)(runtimeConfig), getHttpAuthExtensionConfiguration3(runtimeConfig));
      extensions.forEach((extension) => extension.configure(extensionConfiguration));
      return Object.assign(runtimeConfig, (0, import_region_config_resolver3.resolveAwsRegionExtensionConfiguration)(extensionConfiguration), (0, import_smithy_client24.resolveDefaultRuntimeConfig)(extensionConfiguration), (0, import_protocol_http14.resolveHttpHandlerRuntimeConfig)(extensionConfiguration), resolveHttpAuthRuntimeConfig3(extensionConfiguration));
    };
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/STSClient.js
var import_middleware_host_header3, import_middleware_logger3, import_middleware_recursion_detection3, import_middleware_user_agent3, import_config_resolver6, import_middleware_content_length3, import_middleware_endpoint5, import_middleware_retry6, import_smithy_client25, STSClient;
var init_STSClient = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/STSClient.js"() {
    import_middleware_host_header3 = __toESM(require_dist_cjs27());
    import_middleware_logger3 = __toESM(require_dist_cjs28());
    import_middleware_recursion_detection3 = __toESM(require_dist_cjs29());
    import_middleware_user_agent3 = __toESM(require_dist_cjs37());
    import_config_resolver6 = __toESM(require_dist_cjs38());
    init_dist_es();
    init_schema();
    import_middleware_content_length3 = __toESM(require_dist_cjs40());
    import_middleware_endpoint5 = __toESM(require_dist_cjs43());
    import_middleware_retry6 = __toESM(require_dist_cjs46());
    import_smithy_client25 = __toESM(require_dist_cjs20());
    init_httpAuthSchemeProvider3();
    init_EndpointParameters3();
    init_runtimeConfig3();
    init_runtimeExtensions3();
    STSClient = class extends import_smithy_client25.Client {
      config;
      constructor(...[configuration]) {
        const _config_0 = getRuntimeConfig6(configuration || {});
        super(_config_0);
        this.initConfig = _config_0;
        const _config_1 = resolveClientEndpointParameters3(_config_0);
        const _config_2 = (0, import_middleware_user_agent3.resolveUserAgentConfig)(_config_1);
        const _config_3 = (0, import_middleware_retry6.resolveRetryConfig)(_config_2);
        const _config_4 = (0, import_config_resolver6.resolveRegionConfig)(_config_3);
        const _config_5 = (0, import_middleware_host_header3.resolveHostHeaderConfig)(_config_4);
        const _config_6 = (0, import_middleware_endpoint5.resolveEndpointConfig)(_config_5);
        const _config_7 = resolveHttpAuthSchemeConfig3(_config_6);
        const _config_8 = resolveRuntimeExtensions3(_config_7, configuration?.extensions || []);
        this.config = _config_8;
        this.middlewareStack.use(getSchemaSerdePlugin(this.config));
        this.middlewareStack.use((0, import_middleware_user_agent3.getUserAgentPlugin)(this.config));
        this.middlewareStack.use((0, import_middleware_retry6.getRetryPlugin)(this.config));
        this.middlewareStack.use((0, import_middleware_content_length3.getContentLengthPlugin)(this.config));
        this.middlewareStack.use((0, import_middleware_host_header3.getHostHeaderPlugin)(this.config));
        this.middlewareStack.use((0, import_middleware_logger3.getLoggerPlugin)(this.config));
        this.middlewareStack.use((0, import_middleware_recursion_detection3.getRecursionDetectionPlugin)(this.config));
        this.middlewareStack.use(getHttpAuthSchemeEndpointRuleSetPlugin(this.config, {
          httpAuthSchemeParametersProvider: defaultSTSHttpAuthSchemeParametersProvider,
          identityProviderConfigProvider: async (config) => new DefaultIdentityProviderConfig({
            "aws.auth#sigv4": config.credentials
          })
        }));
        this.middlewareStack.use(getHttpSigningPlugin(this.config));
      }
      destroy() {
        super.destroy();
      }
    };
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/models/STSServiceException.js
var import_smithy_client26, STSServiceException;
var init_STSServiceException = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/models/STSServiceException.js"() {
    import_smithy_client26 = __toESM(require_dist_cjs20());
    STSServiceException = class _STSServiceException extends import_smithy_client26.ServiceException {
      constructor(options) {
        super(options);
        Object.setPrototypeOf(this, _STSServiceException.prototype);
      }
    };
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/models/errors.js
var ExpiredTokenException2, MalformedPolicyDocumentException, PackedPolicyTooLargeException, RegionDisabledException, IDPRejectedClaimException, InvalidIdentityTokenException, IDPCommunicationErrorException;
var init_errors3 = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/models/errors.js"() {
    init_STSServiceException();
    ExpiredTokenException2 = class _ExpiredTokenException extends STSServiceException {
      name = "ExpiredTokenException";
      $fault = "client";
      constructor(opts) {
        super({
          name: "ExpiredTokenException",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _ExpiredTokenException.prototype);
      }
    };
    MalformedPolicyDocumentException = class _MalformedPolicyDocumentException extends STSServiceException {
      name = "MalformedPolicyDocumentException";
      $fault = "client";
      constructor(opts) {
        super({
          name: "MalformedPolicyDocumentException",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _MalformedPolicyDocumentException.prototype);
      }
    };
    PackedPolicyTooLargeException = class _PackedPolicyTooLargeException extends STSServiceException {
      name = "PackedPolicyTooLargeException";
      $fault = "client";
      constructor(opts) {
        super({
          name: "PackedPolicyTooLargeException",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _PackedPolicyTooLargeException.prototype);
      }
    };
    RegionDisabledException = class _RegionDisabledException extends STSServiceException {
      name = "RegionDisabledException";
      $fault = "client";
      constructor(opts) {
        super({
          name: "RegionDisabledException",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _RegionDisabledException.prototype);
      }
    };
    IDPRejectedClaimException = class _IDPRejectedClaimException extends STSServiceException {
      name = "IDPRejectedClaimException";
      $fault = "client";
      constructor(opts) {
        super({
          name: "IDPRejectedClaimException",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _IDPRejectedClaimException.prototype);
      }
    };
    InvalidIdentityTokenException = class _InvalidIdentityTokenException extends STSServiceException {
      name = "InvalidIdentityTokenException";
      $fault = "client";
      constructor(opts) {
        super({
          name: "InvalidIdentityTokenException",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _InvalidIdentityTokenException.prototype);
      }
    };
    IDPCommunicationErrorException = class _IDPCommunicationErrorException extends STSServiceException {
      name = "IDPCommunicationErrorException";
      $fault = "client";
      constructor(opts) {
        super({
          name: "IDPCommunicationErrorException",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _IDPCommunicationErrorException.prototype);
      }
    };
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/schemas/schemas_0.js
var _A, _AKI, _AR, _ARI, _ARR, _ARRs, _ARU, _ARWWI, _ARWWIR, _ARWWIRs, _Au, _C, _CA, _DS, _E, _EI, _ETE2, _IDPCEE, _IDPRCE, _IITE, _K, _MPDE, _P, _PA, _PAr, _PC, _PCLT, _PCr, _PDT, _PI, _PPS, _PPTLE, _Pr, _RA, _RDE, _RSN, _SAK, _SFWIT, _SI, _SN, _ST, _T, _TC, _TTK, _Ta, _V, _WIT, _a, _aKST, _aQE, _c3, _cTT, _e3, _hE3, _m2, _pDLT, _s3, _tLT, n03, accessKeySecretType, clientTokenType, AssumedRoleUser$, AssumeRoleRequest$, AssumeRoleResponse$, AssumeRoleWithWebIdentityRequest$, AssumeRoleWithWebIdentityResponse$, Credentials$, ExpiredTokenException$2, IDPCommunicationErrorException$, IDPRejectedClaimException$, InvalidIdentityTokenException$, MalformedPolicyDocumentException$, PackedPolicyTooLargeException$, PolicyDescriptorType$, ProvidedContext$, RegionDisabledException$, Tag$, STSServiceException$, policyDescriptorListType, ProvidedContextsListType, tagKeyListType, tagListType, AssumeRole$, AssumeRoleWithWebIdentity$;
var init_schemas_03 = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/schemas/schemas_0.js"() {
    init_schema();
    init_errors3();
    init_STSServiceException();
    _A = "Arn";
    _AKI = "AccessKeyId";
    _AR = "AssumeRole";
    _ARI = "AssumedRoleId";
    _ARR = "AssumeRoleRequest";
    _ARRs = "AssumeRoleResponse";
    _ARU = "AssumedRoleUser";
    _ARWWI = "AssumeRoleWithWebIdentity";
    _ARWWIR = "AssumeRoleWithWebIdentityRequest";
    _ARWWIRs = "AssumeRoleWithWebIdentityResponse";
    _Au = "Audience";
    _C = "Credentials";
    _CA = "ContextAssertion";
    _DS = "DurationSeconds";
    _E = "Expiration";
    _EI = "ExternalId";
    _ETE2 = "ExpiredTokenException";
    _IDPCEE = "IDPCommunicationErrorException";
    _IDPRCE = "IDPRejectedClaimException";
    _IITE = "InvalidIdentityTokenException";
    _K = "Key";
    _MPDE = "MalformedPolicyDocumentException";
    _P = "Policy";
    _PA = "PolicyArns";
    _PAr = "ProviderArn";
    _PC = "ProvidedContexts";
    _PCLT = "ProvidedContextsListType";
    _PCr = "ProvidedContext";
    _PDT = "PolicyDescriptorType";
    _PI = "ProviderId";
    _PPS = "PackedPolicySize";
    _PPTLE = "PackedPolicyTooLargeException";
    _Pr = "Provider";
    _RA = "RoleArn";
    _RDE = "RegionDisabledException";
    _RSN = "RoleSessionName";
    _SAK = "SecretAccessKey";
    _SFWIT = "SubjectFromWebIdentityToken";
    _SI = "SourceIdentity";
    _SN = "SerialNumber";
    _ST = "SessionToken";
    _T = "Tags";
    _TC = "TokenCode";
    _TTK = "TransitiveTagKeys";
    _Ta = "Tag";
    _V = "Value";
    _WIT = "WebIdentityToken";
    _a = "arn";
    _aKST = "accessKeySecretType";
    _aQE = "awsQueryError";
    _c3 = "client";
    _cTT = "clientTokenType";
    _e3 = "error";
    _hE3 = "httpError";
    _m2 = "message";
    _pDLT = "policyDescriptorListType";
    _s3 = "smithy.ts.sdk.synthetic.com.amazonaws.sts";
    _tLT = "tagListType";
    n03 = "com.amazonaws.sts";
    accessKeySecretType = [0, n03, _aKST, 8, 0];
    clientTokenType = [0, n03, _cTT, 8, 0];
    AssumedRoleUser$ = [3, n03, _ARU, 0, [_ARI, _A], [0, 0], 2];
    AssumeRoleRequest$ = [
      3,
      n03,
      _ARR,
      0,
      [_RA, _RSN, _PA, _P, _DS, _T, _TTK, _EI, _SN, _TC, _SI, _PC],
      [0, 0, () => policyDescriptorListType, 0, 1, () => tagListType, 64 | 0, 0, 0, 0, 0, () => ProvidedContextsListType],
      2
    ];
    AssumeRoleResponse$ = [
      3,
      n03,
      _ARRs,
      0,
      [_C, _ARU, _PPS, _SI],
      [[() => Credentials$, 0], () => AssumedRoleUser$, 1, 0]
    ];
    AssumeRoleWithWebIdentityRequest$ = [
      3,
      n03,
      _ARWWIR,
      0,
      [_RA, _RSN, _WIT, _PI, _PA, _P, _DS],
      [0, 0, [() => clientTokenType, 0], 0, () => policyDescriptorListType, 0, 1],
      3
    ];
    AssumeRoleWithWebIdentityResponse$ = [
      3,
      n03,
      _ARWWIRs,
      0,
      [_C, _SFWIT, _ARU, _PPS, _Pr, _Au, _SI],
      [[() => Credentials$, 0], 0, () => AssumedRoleUser$, 1, 0, 0, 0]
    ];
    Credentials$ = [
      3,
      n03,
      _C,
      0,
      [_AKI, _SAK, _ST, _E],
      [0, [() => accessKeySecretType, 0], 0, 4],
      4
    ];
    ExpiredTokenException$2 = [
      -3,
      n03,
      _ETE2,
      { [_aQE]: [`ExpiredTokenException`, 400], [_e3]: _c3, [_hE3]: 400 },
      [_m2],
      [0]
    ];
    TypeRegistry.for(n03).registerError(ExpiredTokenException$2, ExpiredTokenException2);
    IDPCommunicationErrorException$ = [
      -3,
      n03,
      _IDPCEE,
      { [_aQE]: [`IDPCommunicationError`, 400], [_e3]: _c3, [_hE3]: 400 },
      [_m2],
      [0]
    ];
    TypeRegistry.for(n03).registerError(IDPCommunicationErrorException$, IDPCommunicationErrorException);
    IDPRejectedClaimException$ = [
      -3,
      n03,
      _IDPRCE,
      { [_aQE]: [`IDPRejectedClaim`, 403], [_e3]: _c3, [_hE3]: 403 },
      [_m2],
      [0]
    ];
    TypeRegistry.for(n03).registerError(IDPRejectedClaimException$, IDPRejectedClaimException);
    InvalidIdentityTokenException$ = [
      -3,
      n03,
      _IITE,
      { [_aQE]: [`InvalidIdentityToken`, 400], [_e3]: _c3, [_hE3]: 400 },
      [_m2],
      [0]
    ];
    TypeRegistry.for(n03).registerError(InvalidIdentityTokenException$, InvalidIdentityTokenException);
    MalformedPolicyDocumentException$ = [
      -3,
      n03,
      _MPDE,
      { [_aQE]: [`MalformedPolicyDocument`, 400], [_e3]: _c3, [_hE3]: 400 },
      [_m2],
      [0]
    ];
    TypeRegistry.for(n03).registerError(MalformedPolicyDocumentException$, MalformedPolicyDocumentException);
    PackedPolicyTooLargeException$ = [
      -3,
      n03,
      _PPTLE,
      { [_aQE]: [`PackedPolicyTooLarge`, 400], [_e3]: _c3, [_hE3]: 400 },
      [_m2],
      [0]
    ];
    TypeRegistry.for(n03).registerError(PackedPolicyTooLargeException$, PackedPolicyTooLargeException);
    PolicyDescriptorType$ = [3, n03, _PDT, 0, [_a], [0]];
    ProvidedContext$ = [3, n03, _PCr, 0, [_PAr, _CA], [0, 0]];
    RegionDisabledException$ = [
      -3,
      n03,
      _RDE,
      { [_aQE]: [`RegionDisabledException`, 403], [_e3]: _c3, [_hE3]: 403 },
      [_m2],
      [0]
    ];
    TypeRegistry.for(n03).registerError(RegionDisabledException$, RegionDisabledException);
    Tag$ = [3, n03, _Ta, 0, [_K, _V], [0, 0], 2];
    STSServiceException$ = [-3, _s3, "STSServiceException", 0, [], []];
    TypeRegistry.for(_s3).registerError(STSServiceException$, STSServiceException);
    policyDescriptorListType = [1, n03, _pDLT, 0, () => PolicyDescriptorType$];
    ProvidedContextsListType = [1, n03, _PCLT, 0, () => ProvidedContext$];
    tagKeyListType = 64 | 0;
    tagListType = [1, n03, _tLT, 0, () => Tag$];
    AssumeRole$ = [9, n03, _AR, 0, () => AssumeRoleRequest$, () => AssumeRoleResponse$];
    AssumeRoleWithWebIdentity$ = [
      9,
      n03,
      _ARWWI,
      0,
      () => AssumeRoleWithWebIdentityRequest$,
      () => AssumeRoleWithWebIdentityResponse$
    ];
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/commands/AssumeRoleCommand.js
var import_middleware_endpoint6, import_smithy_client27, AssumeRoleCommand;
var init_AssumeRoleCommand = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/commands/AssumeRoleCommand.js"() {
    import_middleware_endpoint6 = __toESM(require_dist_cjs43());
    import_smithy_client27 = __toESM(require_dist_cjs20());
    init_EndpointParameters3();
    init_schemas_03();
    AssumeRoleCommand = class extends import_smithy_client27.Command.classBuilder().ep(commonParams3).m(function(Command, cs, config, o4) {
      return [(0, import_middleware_endpoint6.getEndpointPlugin)(config, Command.getEndpointParameterInstructions())];
    }).s("AWSSecurityTokenServiceV20110615", "AssumeRole", {}).n("STSClient", "AssumeRoleCommand").sc(AssumeRole$).build() {
    };
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/commands/AssumeRoleWithWebIdentityCommand.js
var import_middleware_endpoint7, import_smithy_client28, AssumeRoleWithWebIdentityCommand;
var init_AssumeRoleWithWebIdentityCommand = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/commands/AssumeRoleWithWebIdentityCommand.js"() {
    import_middleware_endpoint7 = __toESM(require_dist_cjs43());
    import_smithy_client28 = __toESM(require_dist_cjs20());
    init_EndpointParameters3();
    init_schemas_03();
    AssumeRoleWithWebIdentityCommand = class extends import_smithy_client28.Command.classBuilder().ep(commonParams3).m(function(Command, cs, config, o4) {
      return [(0, import_middleware_endpoint7.getEndpointPlugin)(config, Command.getEndpointParameterInstructions())];
    }).s("AWSSecurityTokenServiceV20110615", "AssumeRoleWithWebIdentity", {}).n("STSClient", "AssumeRoleWithWebIdentityCommand").sc(AssumeRoleWithWebIdentity$).build() {
    };
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/STS.js
var import_smithy_client29, commands3, STS;
var init_STS = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/STS.js"() {
    import_smithy_client29 = __toESM(require_dist_cjs20());
    init_AssumeRoleCommand();
    init_AssumeRoleWithWebIdentityCommand();
    init_STSClient();
    commands3 = {
      AssumeRoleCommand,
      AssumeRoleWithWebIdentityCommand
    };
    STS = class extends STSClient {
    };
    (0, import_smithy_client29.createAggregatedClient)(commands3, STS);
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/commands/index.js
var init_commands3 = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/commands/index.js"() {
    init_AssumeRoleCommand();
    init_AssumeRoleWithWebIdentityCommand();
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/models/models_0.js
var init_models_03 = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/models/models_0.js"() {
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/defaultStsRoleAssumers.js
var import_region_config_resolver4, getAccountIdFromAssumedRoleUser, resolveRegion, getDefaultRoleAssumer, getDefaultRoleAssumerWithWebIdentity, isH2;
var init_defaultStsRoleAssumers = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/defaultStsRoleAssumers.js"() {
    init_client();
    import_region_config_resolver4 = __toESM(require_dist_cjs55());
    init_AssumeRoleCommand();
    init_AssumeRoleWithWebIdentityCommand();
    getAccountIdFromAssumedRoleUser = (assumedRoleUser) => {
      if (typeof assumedRoleUser?.Arn === "string") {
        const arnComponents = assumedRoleUser.Arn.split(":");
        if (arnComponents.length > 4 && arnComponents[4] !== "") {
          return arnComponents[4];
        }
      }
      return void 0;
    };
    resolveRegion = async (_region, _parentRegion, credentialProviderLogger, loaderConfig = {}) => {
      const region = typeof _region === "function" ? await _region() : _region;
      const parentRegion = typeof _parentRegion === "function" ? await _parentRegion() : _parentRegion;
      let stsDefaultRegion = "";
      const resolvedRegion = region ?? parentRegion ?? (stsDefaultRegion = await (0, import_region_config_resolver4.stsRegionDefaultResolver)(loaderConfig)());
      credentialProviderLogger?.debug?.("@aws-sdk/client-sts::resolveRegion", "accepting first of:", `${region} (credential provider clientConfig)`, `${parentRegion} (contextual client)`, `${stsDefaultRegion} (STS default: AWS_REGION, profile region, or us-east-1)`);
      return resolvedRegion;
    };
    getDefaultRoleAssumer = (stsOptions, STSClient2) => {
      let stsClient;
      let closureSourceCreds;
      return async (sourceCreds, params) => {
        closureSourceCreds = sourceCreds;
        if (!stsClient) {
          const { logger: logger3 = stsOptions?.parentClientConfig?.logger, profile = stsOptions?.parentClientConfig?.profile, region, requestHandler = stsOptions?.parentClientConfig?.requestHandler, credentialProviderLogger, userAgentAppId = stsOptions?.parentClientConfig?.userAgentAppId } = stsOptions;
          const resolvedRegion = await resolveRegion(region, stsOptions?.parentClientConfig?.region, credentialProviderLogger, {
            logger: logger3,
            profile
          });
          const isCompatibleRequestHandler = !isH2(requestHandler);
          stsClient = new STSClient2({
            ...stsOptions,
            userAgentAppId,
            profile,
            credentialDefaultProvider: () => async () => closureSourceCreds,
            region: resolvedRegion,
            requestHandler: isCompatibleRequestHandler ? requestHandler : void 0,
            logger: logger3
          });
        }
        const { Credentials, AssumedRoleUser } = await stsClient.send(new AssumeRoleCommand(params));
        if (!Credentials || !Credentials.AccessKeyId || !Credentials.SecretAccessKey) {
          throw new Error(`Invalid response from STS.assumeRole call with role ${params.RoleArn}`);
        }
        const accountId = getAccountIdFromAssumedRoleUser(AssumedRoleUser);
        const credentials = {
          accessKeyId: Credentials.AccessKeyId,
          secretAccessKey: Credentials.SecretAccessKey,
          sessionToken: Credentials.SessionToken,
          expiration: Credentials.Expiration,
          ...Credentials.CredentialScope && { credentialScope: Credentials.CredentialScope },
          ...accountId && { accountId }
        };
        setCredentialFeature(credentials, "CREDENTIALS_STS_ASSUME_ROLE", "i");
        return credentials;
      };
    };
    getDefaultRoleAssumerWithWebIdentity = (stsOptions, STSClient2) => {
      let stsClient;
      return async (params) => {
        if (!stsClient) {
          const { logger: logger3 = stsOptions?.parentClientConfig?.logger, profile = stsOptions?.parentClientConfig?.profile, region, requestHandler = stsOptions?.parentClientConfig?.requestHandler, credentialProviderLogger, userAgentAppId = stsOptions?.parentClientConfig?.userAgentAppId } = stsOptions;
          const resolvedRegion = await resolveRegion(region, stsOptions?.parentClientConfig?.region, credentialProviderLogger, {
            logger: logger3,
            profile
          });
          const isCompatibleRequestHandler = !isH2(requestHandler);
          stsClient = new STSClient2({
            ...stsOptions,
            userAgentAppId,
            profile,
            region: resolvedRegion,
            requestHandler: isCompatibleRequestHandler ? requestHandler : void 0,
            logger: logger3
          });
        }
        const { Credentials, AssumedRoleUser } = await stsClient.send(new AssumeRoleWithWebIdentityCommand(params));
        if (!Credentials || !Credentials.AccessKeyId || !Credentials.SecretAccessKey) {
          throw new Error(`Invalid response from STS.assumeRoleWithWebIdentity call with role ${params.RoleArn}`);
        }
        const accountId = getAccountIdFromAssumedRoleUser(AssumedRoleUser);
        const credentials = {
          accessKeyId: Credentials.AccessKeyId,
          secretAccessKey: Credentials.SecretAccessKey,
          sessionToken: Credentials.SessionToken,
          expiration: Credentials.Expiration,
          ...Credentials.CredentialScope && { credentialScope: Credentials.CredentialScope },
          ...accountId && { accountId }
        };
        if (accountId) {
          setCredentialFeature(credentials, "RESOLVED_ACCOUNT_ID", "T");
        }
        setCredentialFeature(credentials, "CREDENTIALS_STS_ASSUME_ROLE_WEB_ID", "k");
        return credentials;
      };
    };
    isH2 = (requestHandler) => {
      return requestHandler?.metadata?.handlerProtocol === "h2";
    };
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/defaultRoleAssumers.js
var getCustomizableStsClientCtor, getDefaultRoleAssumer2, getDefaultRoleAssumerWithWebIdentity2, decorateDefaultCredentialProvider;
var init_defaultRoleAssumers = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/defaultRoleAssumers.js"() {
    init_defaultStsRoleAssumers();
    init_STSClient();
    getCustomizableStsClientCtor = (baseCtor, customizations) => {
      if (!customizations)
        return baseCtor;
      else
        return class CustomizableSTSClient extends baseCtor {
          constructor(config) {
            super(config);
            for (const customization of customizations) {
              this.middlewareStack.use(customization);
            }
          }
        };
    };
    getDefaultRoleAssumer2 = (stsOptions = {}, stsPlugins) => getDefaultRoleAssumer(stsOptions, getCustomizableStsClientCtor(STSClient, stsPlugins));
    getDefaultRoleAssumerWithWebIdentity2 = (stsOptions = {}, stsPlugins) => getDefaultRoleAssumerWithWebIdentity(stsOptions, getCustomizableStsClientCtor(STSClient, stsPlugins));
    decorateDefaultCredentialProvider = (provider) => (input) => provider({
      roleAssumer: getDefaultRoleAssumer2(input),
      roleAssumerWithWebIdentity: getDefaultRoleAssumerWithWebIdentity2(input),
      ...input
    });
  }
});

// node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/index.js
var sts_exports = {};
__export(sts_exports, {
  AssumeRole$: () => AssumeRole$,
  AssumeRoleCommand: () => AssumeRoleCommand,
  AssumeRoleRequest$: () => AssumeRoleRequest$,
  AssumeRoleResponse$: () => AssumeRoleResponse$,
  AssumeRoleWithWebIdentity$: () => AssumeRoleWithWebIdentity$,
  AssumeRoleWithWebIdentityCommand: () => AssumeRoleWithWebIdentityCommand,
  AssumeRoleWithWebIdentityRequest$: () => AssumeRoleWithWebIdentityRequest$,
  AssumeRoleWithWebIdentityResponse$: () => AssumeRoleWithWebIdentityResponse$,
  AssumedRoleUser$: () => AssumedRoleUser$,
  Credentials$: () => Credentials$,
  ExpiredTokenException: () => ExpiredTokenException2,
  ExpiredTokenException$: () => ExpiredTokenException$2,
  IDPCommunicationErrorException: () => IDPCommunicationErrorException,
  IDPCommunicationErrorException$: () => IDPCommunicationErrorException$,
  IDPRejectedClaimException: () => IDPRejectedClaimException,
  IDPRejectedClaimException$: () => IDPRejectedClaimException$,
  InvalidIdentityTokenException: () => InvalidIdentityTokenException,
  InvalidIdentityTokenException$: () => InvalidIdentityTokenException$,
  MalformedPolicyDocumentException: () => MalformedPolicyDocumentException,
  MalformedPolicyDocumentException$: () => MalformedPolicyDocumentException$,
  PackedPolicyTooLargeException: () => PackedPolicyTooLargeException,
  PackedPolicyTooLargeException$: () => PackedPolicyTooLargeException$,
  PolicyDescriptorType$: () => PolicyDescriptorType$,
  ProvidedContext$: () => ProvidedContext$,
  RegionDisabledException: () => RegionDisabledException,
  RegionDisabledException$: () => RegionDisabledException$,
  STS: () => STS,
  STSClient: () => STSClient,
  STSServiceException: () => STSServiceException,
  STSServiceException$: () => STSServiceException$,
  Tag$: () => Tag$,
  __Client: () => import_smithy_client25.Client,
  decorateDefaultCredentialProvider: () => decorateDefaultCredentialProvider,
  getDefaultRoleAssumer: () => getDefaultRoleAssumer2,
  getDefaultRoleAssumerWithWebIdentity: () => getDefaultRoleAssumerWithWebIdentity2
});
var init_sts = __esm({
  "node_modules/.pnpm/@aws-sdk+nested-clients@3.971.0/node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/index.js"() {
    init_STSClient();
    init_STS();
    init_commands3();
    init_schemas_03();
    init_errors3();
    init_models_03();
    init_defaultRoleAssumers();
    init_STSServiceException();
  }
});

// node_modules/.pnpm/@aws-sdk+credential-provider-process@3.970.0/node_modules/@aws-sdk/credential-provider-process/dist-cjs/index.js
var require_dist_cjs60 = __commonJS({
  "node_modules/.pnpm/@aws-sdk+credential-provider-process@3.970.0/node_modules/@aws-sdk/credential-provider-process/dist-cjs/index.js"(exports2) {
    "use strict";
    var sharedIniFileLoader = require_dist_cjs41();
    var propertyProvider = require_dist_cjs17();
    var child_process = require("child_process");
    var util2 = require("util");
    var client2 = (init_client(), __toCommonJS(client_exports));
    var getValidatedProcessCredentials = (profileName, data2, profiles) => {
      if (data2.Version !== 1) {
        throw Error(`Profile ${profileName} credential_process did not return Version 1.`);
      }
      if (data2.AccessKeyId === void 0 || data2.SecretAccessKey === void 0) {
        throw Error(`Profile ${profileName} credential_process returned invalid credentials.`);
      }
      if (data2.Expiration) {
        const currentTime = /* @__PURE__ */ new Date();
        const expireTime = new Date(data2.Expiration);
        if (expireTime < currentTime) {
          throw Error(`Profile ${profileName} credential_process returned expired credentials.`);
        }
      }
      let accountId = data2.AccountId;
      if (!accountId && profiles?.[profileName]?.aws_account_id) {
        accountId = profiles[profileName].aws_account_id;
      }
      const credentials = {
        accessKeyId: data2.AccessKeyId,
        secretAccessKey: data2.SecretAccessKey,
        ...data2.SessionToken && { sessionToken: data2.SessionToken },
        ...data2.Expiration && { expiration: new Date(data2.Expiration) },
        ...data2.CredentialScope && { credentialScope: data2.CredentialScope },
        ...accountId && { accountId }
      };
      client2.setCredentialFeature(credentials, "CREDENTIALS_PROCESS", "w");
      return credentials;
    };
    var resolveProcessCredentials = async (profileName, profiles, logger3) => {
      const profile = profiles[profileName];
      if (profiles[profileName]) {
        const credentialProcess = profile["credential_process"];
        if (credentialProcess !== void 0) {
          const execPromise = util2.promisify(sharedIniFileLoader.externalDataInterceptor?.getTokenRecord?.().exec ?? child_process.exec);
          try {
            const { stdout } = await execPromise(credentialProcess);
            let data2;
            try {
              data2 = JSON.parse(stdout.trim());
            } catch {
              throw Error(`Profile ${profileName} credential_process returned invalid JSON.`);
            }
            return getValidatedProcessCredentials(profileName, data2, profiles);
          } catch (error2) {
            throw new propertyProvider.CredentialsProviderError(error2.message, { logger: logger3 });
          }
        } else {
          throw new propertyProvider.CredentialsProviderError(`Profile ${profileName} did not contain credential_process.`, { logger: logger3 });
        }
      } else {
        throw new propertyProvider.CredentialsProviderError(`Profile ${profileName} could not be found in shared credentials file.`, {
          logger: logger3
        });
      }
    };
    var fromProcess = (init = {}) => async ({ callerClientConfig } = {}) => {
      init.logger?.debug("@aws-sdk/credential-provider-process - fromProcess");
      const profiles = await sharedIniFileLoader.parseKnownFiles(init);
      return resolveProcessCredentials(sharedIniFileLoader.getProfileName({
        profile: init.profile ?? callerClientConfig?.profile
      }), profiles, init.logger);
    };
    exports2.fromProcess = fromProcess;
  }
});

// node_modules/.pnpm/@aws-sdk+credential-provider-web-identity@3.971.0/node_modules/@aws-sdk/credential-provider-web-identity/dist-cjs/fromWebToken.js
var require_fromWebToken = __commonJS({
  "node_modules/.pnpm/@aws-sdk+credential-provider-web-identity@3.971.0/node_modules/@aws-sdk/credential-provider-web-identity/dist-cjs/fromWebToken.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? (function(o4, m4, k4, k22) {
      if (k22 === void 0) k22 = k4;
      var desc = Object.getOwnPropertyDescriptor(m4, k4);
      if (!desc || ("get" in desc ? !m4.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m4[k4];
        } };
      }
      Object.defineProperty(o4, k22, desc);
    }) : (function(o4, m4, k4, k22) {
      if (k22 === void 0) k22 = k4;
      o4[k22] = m4[k4];
    }));
    var __setModuleDefault2 = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o4, v4) {
      Object.defineProperty(o4, "default", { enumerable: true, value: v4 });
    }) : function(o4, v4) {
      o4["default"] = v4;
    });
    var __importStar2 = exports2 && exports2.__importStar || /* @__PURE__ */ (function() {
      var ownKeys2 = function(o4) {
        ownKeys2 = Object.getOwnPropertyNames || function(o5) {
          var ar = [];
          for (var k4 in o5) if (Object.prototype.hasOwnProperty.call(o5, k4)) ar[ar.length] = k4;
          return ar;
        };
        return ownKeys2(o4);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k4 = ownKeys2(mod), i4 = 0; i4 < k4.length; i4++) if (k4[i4] !== "default") __createBinding2(result, mod, k4[i4]);
        }
        __setModuleDefault2(result, mod);
        return result;
      };
    })();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fromWebToken = void 0;
    var fromWebToken = (init) => async (awsIdentityProperties) => {
      init.logger?.debug("@aws-sdk/credential-provider-web-identity - fromWebToken");
      const { roleArn, roleSessionName, webIdentityToken, providerId, policyArns, policy, durationSeconds } = init;
      let { roleAssumerWithWebIdentity } = init;
      if (!roleAssumerWithWebIdentity) {
        const { getDefaultRoleAssumerWithWebIdentity: getDefaultRoleAssumerWithWebIdentity3 } = await Promise.resolve().then(() => __importStar2((init_sts(), __toCommonJS(sts_exports))));
        roleAssumerWithWebIdentity = getDefaultRoleAssumerWithWebIdentity3({
          ...init.clientConfig,
          credentialProviderLogger: init.logger,
          parentClientConfig: {
            ...awsIdentityProperties?.callerClientConfig,
            ...init.parentClientConfig
          }
        }, init.clientPlugins);
      }
      return roleAssumerWithWebIdentity({
        RoleArn: roleArn,
        RoleSessionName: roleSessionName ?? `aws-sdk-js-session-${Date.now()}`,
        WebIdentityToken: webIdentityToken,
        ProviderId: providerId,
        PolicyArns: policyArns,
        Policy: policy,
        DurationSeconds: durationSeconds
      });
    };
    exports2.fromWebToken = fromWebToken;
  }
});

// node_modules/.pnpm/@aws-sdk+credential-provider-web-identity@3.971.0/node_modules/@aws-sdk/credential-provider-web-identity/dist-cjs/fromTokenFile.js
var require_fromTokenFile = __commonJS({
  "node_modules/.pnpm/@aws-sdk+credential-provider-web-identity@3.971.0/node_modules/@aws-sdk/credential-provider-web-identity/dist-cjs/fromTokenFile.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fromTokenFile = void 0;
    var client_1 = (init_client(), __toCommonJS(client_exports));
    var property_provider_1 = require_dist_cjs17();
    var shared_ini_file_loader_1 = require_dist_cjs41();
    var fs_1 = require("fs");
    var fromWebToken_1 = require_fromWebToken();
    var ENV_TOKEN_FILE = "AWS_WEB_IDENTITY_TOKEN_FILE";
    var ENV_ROLE_ARN = "AWS_ROLE_ARN";
    var ENV_ROLE_SESSION_NAME = "AWS_ROLE_SESSION_NAME";
    var fromTokenFile = (init = {}) => async (awsIdentityProperties) => {
      init.logger?.debug("@aws-sdk/credential-provider-web-identity - fromTokenFile");
      const webIdentityTokenFile = init?.webIdentityTokenFile ?? process.env[ENV_TOKEN_FILE];
      const roleArn = init?.roleArn ?? process.env[ENV_ROLE_ARN];
      const roleSessionName = init?.roleSessionName ?? process.env[ENV_ROLE_SESSION_NAME];
      if (!webIdentityTokenFile || !roleArn) {
        throw new property_provider_1.CredentialsProviderError("Web identity configuration not specified", {
          logger: init.logger
        });
      }
      const credentials = await (0, fromWebToken_1.fromWebToken)({
        ...init,
        webIdentityToken: shared_ini_file_loader_1.externalDataInterceptor?.getTokenRecord?.()[webIdentityTokenFile] ?? (0, fs_1.readFileSync)(webIdentityTokenFile, { encoding: "ascii" }),
        roleArn,
        roleSessionName
      })(awsIdentityProperties);
      if (webIdentityTokenFile === process.env[ENV_TOKEN_FILE]) {
        (0, client_1.setCredentialFeature)(credentials, "CREDENTIALS_ENV_VARS_STS_WEB_ID_TOKEN", "h");
      }
      return credentials;
    };
    exports2.fromTokenFile = fromTokenFile;
  }
});

// node_modules/.pnpm/@aws-sdk+credential-provider-web-identity@3.971.0/node_modules/@aws-sdk/credential-provider-web-identity/dist-cjs/index.js
var require_dist_cjs61 = __commonJS({
  "node_modules/.pnpm/@aws-sdk+credential-provider-web-identity@3.971.0/node_modules/@aws-sdk/credential-provider-web-identity/dist-cjs/index.js"(exports2) {
    "use strict";
    var fromTokenFile = require_fromTokenFile();
    var fromWebToken = require_fromWebToken();
    Object.keys(fromTokenFile).forEach(function(k4) {
      if (k4 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, k4)) Object.defineProperty(exports2, k4, {
        enumerable: true,
        get: function() {
          return fromTokenFile[k4];
        }
      });
    });
    Object.keys(fromWebToken).forEach(function(k4) {
      if (k4 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, k4)) Object.defineProperty(exports2, k4, {
        enumerable: true,
        get: function() {
          return fromWebToken[k4];
        }
      });
    });
  }
});

// node_modules/.pnpm/@aws-sdk+credential-provider-ini@3.971.0/node_modules/@aws-sdk/credential-provider-ini/dist-cjs/index.js
var require_dist_cjs62 = __commonJS({
  "node_modules/.pnpm/@aws-sdk+credential-provider-ini@3.971.0/node_modules/@aws-sdk/credential-provider-ini/dist-cjs/index.js"(exports2) {
    "use strict";
    var sharedIniFileLoader = require_dist_cjs41();
    var propertyProvider = require_dist_cjs17();
    var client2 = (init_client(), __toCommonJS(client_exports));
    var credentialProviderLogin = require_dist_cjs59();
    var resolveCredentialSource = (credentialSource, profileName, logger3) => {
      const sourceProvidersMap = {
        EcsContainer: async (options) => {
          const { fromHttp } = await Promise.resolve().then(() => __toESM(require_dist_cjs50()));
          const { fromContainerMetadata } = await Promise.resolve().then(() => __toESM(require_dist_cjs49()));
          logger3?.debug("@aws-sdk/credential-provider-ini - credential_source is EcsContainer");
          return async () => propertyProvider.chain(fromHttp(options ?? {}), fromContainerMetadata(options))().then(setNamedProvider);
        },
        Ec2InstanceMetadata: async (options) => {
          logger3?.debug("@aws-sdk/credential-provider-ini - credential_source is Ec2InstanceMetadata");
          const { fromInstanceMetadata } = await Promise.resolve().then(() => __toESM(require_dist_cjs49()));
          return async () => fromInstanceMetadata(options)().then(setNamedProvider);
        },
        Environment: async (options) => {
          logger3?.debug("@aws-sdk/credential-provider-ini - credential_source is Environment");
          const { fromEnv } = await Promise.resolve().then(() => __toESM(require_dist_cjs48()));
          return async () => fromEnv(options)().then(setNamedProvider);
        }
      };
      if (credentialSource in sourceProvidersMap) {
        return sourceProvidersMap[credentialSource];
      } else {
        throw new propertyProvider.CredentialsProviderError(`Unsupported credential source in profile ${profileName}. Got ${credentialSource}, expected EcsContainer or Ec2InstanceMetadata or Environment.`, { logger: logger3 });
      }
    };
    var setNamedProvider = (creds) => client2.setCredentialFeature(creds, "CREDENTIALS_PROFILE_NAMED_PROVIDER", "p");
    var isAssumeRoleProfile = (arg, { profile = "default", logger: logger3 } = {}) => {
      return Boolean(arg) && typeof arg === "object" && typeof arg.role_arn === "string" && ["undefined", "string"].indexOf(typeof arg.role_session_name) > -1 && ["undefined", "string"].indexOf(typeof arg.external_id) > -1 && ["undefined", "string"].indexOf(typeof arg.mfa_serial) > -1 && (isAssumeRoleWithSourceProfile(arg, { profile, logger: logger3 }) || isCredentialSourceProfile(arg, { profile, logger: logger3 }));
    };
    var isAssumeRoleWithSourceProfile = (arg, { profile, logger: logger3 }) => {
      const withSourceProfile = typeof arg.source_profile === "string" && typeof arg.credential_source === "undefined";
      if (withSourceProfile) {
        logger3?.debug?.(`    ${profile} isAssumeRoleWithSourceProfile source_profile=${arg.source_profile}`);
      }
      return withSourceProfile;
    };
    var isCredentialSourceProfile = (arg, { profile, logger: logger3 }) => {
      const withProviderProfile = typeof arg.credential_source === "string" && typeof arg.source_profile === "undefined";
      if (withProviderProfile) {
        logger3?.debug?.(`    ${profile} isCredentialSourceProfile credential_source=${arg.credential_source}`);
      }
      return withProviderProfile;
    };
    var resolveAssumeRoleCredentials = async (profileName, profiles, options, callerClientConfig, visitedProfiles = {}, resolveProfileData2) => {
      options.logger?.debug("@aws-sdk/credential-provider-ini - resolveAssumeRoleCredentials (STS)");
      const profileData = profiles[profileName];
      const { source_profile, region } = profileData;
      if (!options.roleAssumer) {
        const { getDefaultRoleAssumer: getDefaultRoleAssumer3 } = await Promise.resolve().then(() => (init_sts(), sts_exports));
        options.roleAssumer = getDefaultRoleAssumer3({
          ...options.clientConfig,
          credentialProviderLogger: options.logger,
          parentClientConfig: {
            ...callerClientConfig,
            ...options?.parentClientConfig,
            region: region ?? options?.parentClientConfig?.region ?? callerClientConfig?.region
          }
        }, options.clientPlugins);
      }
      if (source_profile && source_profile in visitedProfiles) {
        throw new propertyProvider.CredentialsProviderError(`Detected a cycle attempting to resolve credentials for profile ${sharedIniFileLoader.getProfileName(options)}. Profiles visited: ` + Object.keys(visitedProfiles).join(", "), { logger: options.logger });
      }
      options.logger?.debug(`@aws-sdk/credential-provider-ini - finding credential resolver using ${source_profile ? `source_profile=[${source_profile}]` : `profile=[${profileName}]`}`);
      const sourceCredsProvider = source_profile ? resolveProfileData2(source_profile, profiles, options, callerClientConfig, {
        ...visitedProfiles,
        [source_profile]: true
      }, isCredentialSourceWithoutRoleArn(profiles[source_profile] ?? {})) : (await resolveCredentialSource(profileData.credential_source, profileName, options.logger)(options))();
      if (isCredentialSourceWithoutRoleArn(profileData)) {
        return sourceCredsProvider.then((creds) => client2.setCredentialFeature(creds, "CREDENTIALS_PROFILE_SOURCE_PROFILE", "o"));
      } else {
        const params = {
          RoleArn: profileData.role_arn,
          RoleSessionName: profileData.role_session_name || `aws-sdk-js-${Date.now()}`,
          ExternalId: profileData.external_id,
          DurationSeconds: parseInt(profileData.duration_seconds || "3600", 10)
        };
        const { mfa_serial } = profileData;
        if (mfa_serial) {
          if (!options.mfaCodeProvider) {
            throw new propertyProvider.CredentialsProviderError(`Profile ${profileName} requires multi-factor authentication, but no MFA code callback was provided.`, { logger: options.logger, tryNextLink: false });
          }
          params.SerialNumber = mfa_serial;
          params.TokenCode = await options.mfaCodeProvider(mfa_serial);
        }
        const sourceCreds = await sourceCredsProvider;
        return options.roleAssumer(sourceCreds, params).then((creds) => client2.setCredentialFeature(creds, "CREDENTIALS_PROFILE_SOURCE_PROFILE", "o"));
      }
    };
    var isCredentialSourceWithoutRoleArn = (section) => {
      return !section.role_arn && !!section.credential_source;
    };
    var isLoginProfile = (data2) => {
      return Boolean(data2 && data2.login_session);
    };
    var resolveLoginCredentials = async (profileName, options, callerClientConfig) => {
      const credentials = await credentialProviderLogin.fromLoginCredentials({
        ...options,
        profile: profileName
      })({ callerClientConfig });
      return client2.setCredentialFeature(credentials, "CREDENTIALS_PROFILE_LOGIN", "AC");
    };
    var isProcessProfile = (arg) => Boolean(arg) && typeof arg === "object" && typeof arg.credential_process === "string";
    var resolveProcessCredentials = async (options, profile) => Promise.resolve().then(() => __toESM(require_dist_cjs60())).then(({ fromProcess }) => fromProcess({
      ...options,
      profile
    })().then((creds) => client2.setCredentialFeature(creds, "CREDENTIALS_PROFILE_PROCESS", "v")));
    var resolveSsoCredentials = async (profile, profileData, options = {}, callerClientConfig) => {
      const { fromSSO } = await Promise.resolve().then(() => __toESM(require_dist_cjs58()));
      return fromSSO({
        profile,
        logger: options.logger,
        parentClientConfig: options.parentClientConfig,
        clientConfig: options.clientConfig
      })({
        callerClientConfig
      }).then((creds) => {
        if (profileData.sso_session) {
          return client2.setCredentialFeature(creds, "CREDENTIALS_PROFILE_SSO", "r");
        } else {
          return client2.setCredentialFeature(creds, "CREDENTIALS_PROFILE_SSO_LEGACY", "t");
        }
      });
    };
    var isSsoProfile = (arg) => arg && (typeof arg.sso_start_url === "string" || typeof arg.sso_account_id === "string" || typeof arg.sso_session === "string" || typeof arg.sso_region === "string" || typeof arg.sso_role_name === "string");
    var isStaticCredsProfile = (arg) => Boolean(arg) && typeof arg === "object" && typeof arg.aws_access_key_id === "string" && typeof arg.aws_secret_access_key === "string" && ["undefined", "string"].indexOf(typeof arg.aws_session_token) > -1 && ["undefined", "string"].indexOf(typeof arg.aws_account_id) > -1;
    var resolveStaticCredentials = async (profile, options) => {
      options?.logger?.debug("@aws-sdk/credential-provider-ini - resolveStaticCredentials");
      const credentials = {
        accessKeyId: profile.aws_access_key_id,
        secretAccessKey: profile.aws_secret_access_key,
        sessionToken: profile.aws_session_token,
        ...profile.aws_credential_scope && { credentialScope: profile.aws_credential_scope },
        ...profile.aws_account_id && { accountId: profile.aws_account_id }
      };
      return client2.setCredentialFeature(credentials, "CREDENTIALS_PROFILE", "n");
    };
    var isWebIdentityProfile = (arg) => Boolean(arg) && typeof arg === "object" && typeof arg.web_identity_token_file === "string" && typeof arg.role_arn === "string" && ["undefined", "string"].indexOf(typeof arg.role_session_name) > -1;
    var resolveWebIdentityCredentials = async (profile, options, callerClientConfig) => Promise.resolve().then(() => __toESM(require_dist_cjs61())).then(({ fromTokenFile }) => fromTokenFile({
      webIdentityTokenFile: profile.web_identity_token_file,
      roleArn: profile.role_arn,
      roleSessionName: profile.role_session_name,
      roleAssumerWithWebIdentity: options.roleAssumerWithWebIdentity,
      logger: options.logger,
      parentClientConfig: options.parentClientConfig
    })({
      callerClientConfig
    }).then((creds) => client2.setCredentialFeature(creds, "CREDENTIALS_PROFILE_STS_WEB_ID_TOKEN", "q")));
    var resolveProfileData = async (profileName, profiles, options, callerClientConfig, visitedProfiles = {}, isAssumeRoleRecursiveCall = false) => {
      const data2 = profiles[profileName];
      if (Object.keys(visitedProfiles).length > 0 && isStaticCredsProfile(data2)) {
        return resolveStaticCredentials(data2, options);
      }
      if (isAssumeRoleRecursiveCall || isAssumeRoleProfile(data2, { profile: profileName, logger: options.logger })) {
        return resolveAssumeRoleCredentials(profileName, profiles, options, callerClientConfig, visitedProfiles, resolveProfileData);
      }
      if (isStaticCredsProfile(data2)) {
        return resolveStaticCredentials(data2, options);
      }
      if (isWebIdentityProfile(data2)) {
        return resolveWebIdentityCredentials(data2, options, callerClientConfig);
      }
      if (isProcessProfile(data2)) {
        return resolveProcessCredentials(options, profileName);
      }
      if (isSsoProfile(data2)) {
        return await resolveSsoCredentials(profileName, data2, options, callerClientConfig);
      }
      if (isLoginProfile(data2)) {
        return resolveLoginCredentials(profileName, options, callerClientConfig);
      }
      throw new propertyProvider.CredentialsProviderError(`Could not resolve credentials using profile: [${profileName}] in configuration/credentials file(s).`, { logger: options.logger });
    };
    var fromIni = (init = {}) => async ({ callerClientConfig } = {}) => {
      init.logger?.debug("@aws-sdk/credential-provider-ini - fromIni");
      const profiles = await sharedIniFileLoader.parseKnownFiles(init);
      return resolveProfileData(sharedIniFileLoader.getProfileName({
        profile: init.profile ?? callerClientConfig?.profile
      }), profiles, init, callerClientConfig);
    };
    exports2.fromIni = fromIni;
  }
});

// node_modules/.pnpm/@aws-sdk+credential-provider-node@3.971.0/node_modules/@aws-sdk/credential-provider-node/dist-cjs/index.js
var require_dist_cjs63 = __commonJS({
  "node_modules/.pnpm/@aws-sdk+credential-provider-node@3.971.0/node_modules/@aws-sdk/credential-provider-node/dist-cjs/index.js"(exports2) {
    "use strict";
    var credentialProviderEnv = require_dist_cjs48();
    var propertyProvider = require_dist_cjs17();
    var sharedIniFileLoader = require_dist_cjs41();
    var ENV_IMDS_DISABLED = "AWS_EC2_METADATA_DISABLED";
    var remoteProvider = async (init) => {
      const { ENV_CMDS_FULL_URI, ENV_CMDS_RELATIVE_URI, fromContainerMetadata, fromInstanceMetadata } = await Promise.resolve().then(() => __toESM(require_dist_cjs49()));
      if (process.env[ENV_CMDS_RELATIVE_URI] || process.env[ENV_CMDS_FULL_URI]) {
        init.logger?.debug("@aws-sdk/credential-provider-node - remoteProvider::fromHttp/fromContainerMetadata");
        const { fromHttp } = await Promise.resolve().then(() => __toESM(require_dist_cjs50()));
        return propertyProvider.chain(fromHttp(init), fromContainerMetadata(init));
      }
      if (process.env[ENV_IMDS_DISABLED] && process.env[ENV_IMDS_DISABLED] !== "false") {
        return async () => {
          throw new propertyProvider.CredentialsProviderError("EC2 Instance Metadata Service access disabled", { logger: init.logger });
        };
      }
      init.logger?.debug("@aws-sdk/credential-provider-node - remoteProvider::fromInstanceMetadata");
      return fromInstanceMetadata(init);
    };
    function memoizeChain(providers, treatAsExpired) {
      const chain = internalCreateChain(providers);
      let activeLock;
      let passiveLock;
      let credentials;
      const provider = async (options) => {
        if (options?.forceRefresh) {
          return await chain(options);
        }
        if (credentials?.expiration) {
          if (credentials?.expiration?.getTime() < Date.now()) {
            credentials = void 0;
          }
        }
        if (activeLock) {
          await activeLock;
        } else if (!credentials || treatAsExpired?.(credentials)) {
          if (credentials) {
            if (!passiveLock) {
              passiveLock = chain(options).then((c4) => {
                credentials = c4;
                passiveLock = void 0;
              });
            }
          } else {
            activeLock = chain(options).then((c4) => {
              credentials = c4;
              activeLock = void 0;
            });
            return provider(options);
          }
        }
        return credentials;
      };
      return provider;
    }
    var internalCreateChain = (providers) => async (awsIdentityProperties) => {
      let lastProviderError;
      for (const provider of providers) {
        try {
          return await provider(awsIdentityProperties);
        } catch (err) {
          lastProviderError = err;
          if (err?.tryNextLink) {
            continue;
          }
          throw err;
        }
      }
      throw lastProviderError;
    };
    var multipleCredentialSourceWarningEmitted = false;
    var defaultProvider = (init = {}) => memoizeChain([
      async () => {
        const profile = init.profile ?? process.env[sharedIniFileLoader.ENV_PROFILE];
        if (profile) {
          const envStaticCredentialsAreSet = process.env[credentialProviderEnv.ENV_KEY] && process.env[credentialProviderEnv.ENV_SECRET];
          if (envStaticCredentialsAreSet) {
            if (!multipleCredentialSourceWarningEmitted) {
              const warnFn = init.logger?.warn && init.logger?.constructor?.name !== "NoOpLogger" ? init.logger.warn.bind(init.logger) : console.warn;
              warnFn(`@aws-sdk/credential-provider-node - defaultProvider::fromEnv WARNING:
    Multiple credential sources detected: 
    Both AWS_PROFILE and the pair AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY static credentials are set.
    This SDK will proceed with the AWS_PROFILE value.
    
    However, a future version may change this behavior to prefer the ENV static credentials.
    Please ensure that your environment only sets either the AWS_PROFILE or the
    AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY pair.
`);
              multipleCredentialSourceWarningEmitted = true;
            }
          }
          throw new propertyProvider.CredentialsProviderError("AWS_PROFILE is set, skipping fromEnv provider.", {
            logger: init.logger,
            tryNextLink: true
          });
        }
        init.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromEnv");
        return credentialProviderEnv.fromEnv(init)();
      },
      async (awsIdentityProperties) => {
        init.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromSSO");
        const { ssoStartUrl, ssoAccountId, ssoRegion, ssoRoleName, ssoSession } = init;
        if (!ssoStartUrl && !ssoAccountId && !ssoRegion && !ssoRoleName && !ssoSession) {
          throw new propertyProvider.CredentialsProviderError("Skipping SSO provider in default chain (inputs do not include SSO fields).", { logger: init.logger });
        }
        const { fromSSO } = await Promise.resolve().then(() => __toESM(require_dist_cjs58()));
        return fromSSO(init)(awsIdentityProperties);
      },
      async (awsIdentityProperties) => {
        init.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromIni");
        const { fromIni } = await Promise.resolve().then(() => __toESM(require_dist_cjs62()));
        return fromIni(init)(awsIdentityProperties);
      },
      async (awsIdentityProperties) => {
        init.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromProcess");
        const { fromProcess } = await Promise.resolve().then(() => __toESM(require_dist_cjs60()));
        return fromProcess(init)(awsIdentityProperties);
      },
      async (awsIdentityProperties) => {
        init.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromTokenFile");
        const { fromTokenFile } = await Promise.resolve().then(() => __toESM(require_dist_cjs61()));
        return fromTokenFile(init)(awsIdentityProperties);
      },
      async () => {
        init.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::remoteProvider");
        return (await remoteProvider(init))();
      },
      async () => {
        throw new propertyProvider.CredentialsProviderError("Could not load credentials from any providers", {
          tryNextLink: false,
          logger: init.logger
        });
      }
    ], credentialsTreatedAsExpired);
    var credentialsWillNeedRefresh = (credentials) => credentials?.expiration !== void 0;
    var credentialsTreatedAsExpired = (credentials) => credentials?.expiration !== void 0 && credentials.expiration.getTime() - Date.now() < 3e5;
    exports2.credentialsTreatedAsExpired = credentialsTreatedAsExpired;
    exports2.credentialsWillNeedRefresh = credentialsWillNeedRefresh;
    exports2.defaultProvider = defaultProvider;
  }
});

// node_modules/.pnpm/@aws-sdk+middleware-bucket-endpoint@3.969.0/node_modules/@aws-sdk/middleware-bucket-endpoint/dist-cjs/index.js
var require_dist_cjs64 = __commonJS({
  "node_modules/.pnpm/@aws-sdk+middleware-bucket-endpoint@3.969.0/node_modules/@aws-sdk/middleware-bucket-endpoint/dist-cjs/index.js"(exports2) {
    "use strict";
    var utilConfigProvider = require_dist_cjs31();
    var utilArnParser = require_dist_cjs30();
    var protocolHttp = require_dist_cjs2();
    var NODE_DISABLE_MULTIREGION_ACCESS_POINT_ENV_NAME = "AWS_S3_DISABLE_MULTIREGION_ACCESS_POINTS";
    var NODE_DISABLE_MULTIREGION_ACCESS_POINT_INI_NAME = "s3_disable_multiregion_access_points";
    var NODE_DISABLE_MULTIREGION_ACCESS_POINT_CONFIG_OPTIONS = {
      environmentVariableSelector: (env) => utilConfigProvider.booleanSelector(env, NODE_DISABLE_MULTIREGION_ACCESS_POINT_ENV_NAME, utilConfigProvider.SelectorType.ENV),
      configFileSelector: (profile) => utilConfigProvider.booleanSelector(profile, NODE_DISABLE_MULTIREGION_ACCESS_POINT_INI_NAME, utilConfigProvider.SelectorType.CONFIG),
      default: false
    };
    var NODE_USE_ARN_REGION_ENV_NAME = "AWS_S3_USE_ARN_REGION";
    var NODE_USE_ARN_REGION_INI_NAME = "s3_use_arn_region";
    var NODE_USE_ARN_REGION_CONFIG_OPTIONS = {
      environmentVariableSelector: (env) => utilConfigProvider.booleanSelector(env, NODE_USE_ARN_REGION_ENV_NAME, utilConfigProvider.SelectorType.ENV),
      configFileSelector: (profile) => utilConfigProvider.booleanSelector(profile, NODE_USE_ARN_REGION_INI_NAME, utilConfigProvider.SelectorType.CONFIG),
      default: void 0
    };
    var DOMAIN_PATTERN = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/;
    var IP_ADDRESS_PATTERN = /(\d+\.){3}\d+/;
    var DOTS_PATTERN = /\.\./;
    var DOT_PATTERN = /\./;
    var S3_HOSTNAME_PATTERN = /^(.+\.)?s3(-fips)?(\.dualstack)?[.-]([a-z0-9-]+)\./;
    var S3_US_EAST_1_ALTNAME_PATTERN = /^s3(-external-1)?\.amazonaws\.com$/;
    var AWS_PARTITION_SUFFIX = "amazonaws.com";
    var isBucketNameOptions = (options) => typeof options.bucketName === "string";
    var isDnsCompatibleBucketName = (bucketName) => DOMAIN_PATTERN.test(bucketName) && !IP_ADDRESS_PATTERN.test(bucketName) && !DOTS_PATTERN.test(bucketName);
    var getRegionalSuffix = (hostname) => {
      const parts = hostname.match(S3_HOSTNAME_PATTERN);
      return [parts[4], hostname.replace(new RegExp(`^${parts[0]}`), "")];
    };
    var getSuffix = (hostname) => S3_US_EAST_1_ALTNAME_PATTERN.test(hostname) ? ["us-east-1", AWS_PARTITION_SUFFIX] : getRegionalSuffix(hostname);
    var getSuffixForArnEndpoint = (hostname) => S3_US_EAST_1_ALTNAME_PATTERN.test(hostname) ? [hostname.replace(`.${AWS_PARTITION_SUFFIX}`, ""), AWS_PARTITION_SUFFIX] : getRegionalSuffix(hostname);
    var validateArnEndpointOptions = (options) => {
      if (options.pathStyleEndpoint) {
        throw new Error("Path-style S3 endpoint is not supported when bucket is an ARN");
      }
      if (options.accelerateEndpoint) {
        throw new Error("Accelerate endpoint is not supported when bucket is an ARN");
      }
      if (!options.tlsCompatible) {
        throw new Error("HTTPS is required when bucket is an ARN");
      }
    };
    var validateService = (service) => {
      if (service !== "s3" && service !== "s3-outposts" && service !== "s3-object-lambda") {
        throw new Error("Expect 's3' or 's3-outposts' or 's3-object-lambda' in ARN service component");
      }
    };
    var validateS3Service = (service) => {
      if (service !== "s3") {
        throw new Error("Expect 's3' in Accesspoint ARN service component");
      }
    };
    var validateOutpostService = (service) => {
      if (service !== "s3-outposts") {
        throw new Error("Expect 's3-posts' in Outpost ARN service component");
      }
    };
    var validatePartition = (partition, options) => {
      if (partition !== options.clientPartition) {
        throw new Error(`Partition in ARN is incompatible, got "${partition}" but expected "${options.clientPartition}"`);
      }
    };
    var validateRegion = (region, options) => {
    };
    var validateRegionalClient = (region) => {
      if (["s3-external-1", "aws-global"].includes(region)) {
        throw new Error(`Client region ${region} is not regional`);
      }
    };
    var validateAccountId = (accountId) => {
      if (!/[0-9]{12}/.exec(accountId)) {
        throw new Error("Access point ARN accountID does not match regex '[0-9]{12}'");
      }
    };
    var validateDNSHostLabel = (label, options = { tlsCompatible: true }) => {
      if (label.length >= 64 || !/^[a-z0-9][a-z0-9.-]*[a-z0-9]$/.test(label) || /(\d+\.){3}\d+/.test(label) || /[.-]{2}/.test(label) || options?.tlsCompatible && DOT_PATTERN.test(label)) {
        throw new Error(`Invalid DNS label ${label}`);
      }
    };
    var validateCustomEndpoint = (options) => {
      if (options.isCustomEndpoint) {
        if (options.dualstackEndpoint)
          throw new Error("Dualstack endpoint is not supported with custom endpoint");
        if (options.accelerateEndpoint)
          throw new Error("Accelerate endpoint is not supported with custom endpoint");
      }
    };
    var getArnResources = (resource) => {
      const delimiter = resource.includes(":") ? ":" : "/";
      const [resourceType, ...rest] = resource.split(delimiter);
      if (resourceType === "accesspoint") {
        if (rest.length !== 1 || rest[0] === "") {
          throw new Error(`Access Point ARN should have one resource accesspoint${delimiter}{accesspointname}`);
        }
        return { accesspointName: rest[0] };
      } else if (resourceType === "outpost") {
        if (!rest[0] || rest[1] !== "accesspoint" || !rest[2] || rest.length !== 3) {
          throw new Error(`Outpost ARN should have resource outpost${delimiter}{outpostId}${delimiter}accesspoint${delimiter}{accesspointName}`);
        }
        const [outpostId, _, accesspointName] = rest;
        return { outpostId, accesspointName };
      } else {
        throw new Error(`ARN resource should begin with 'accesspoint${delimiter}' or 'outpost${delimiter}'`);
      }
    };
    var validateNoDualstack = (dualstackEndpoint) => {
    };
    var validateNoFIPS = (useFipsEndpoint) => {
      if (useFipsEndpoint)
        throw new Error(`FIPS region is not supported with Outpost.`);
    };
    var validateMrapAlias = (name) => {
      try {
        name.split(".").forEach((label) => {
          validateDNSHostLabel(label);
        });
      } catch (e4) {
        throw new Error(`"${name}" is not a DNS compatible name.`);
      }
    };
    var bucketHostname = (options) => {
      validateCustomEndpoint(options);
      return isBucketNameOptions(options) ? getEndpointFromBucketName(options) : getEndpointFromArn(options);
    };
    var getEndpointFromBucketName = ({ accelerateEndpoint = false, clientRegion: region, baseHostname, bucketName, dualstackEndpoint = false, fipsEndpoint = false, pathStyleEndpoint = false, tlsCompatible = true, isCustomEndpoint = false }) => {
      const [clientRegion, hostnameSuffix] = isCustomEndpoint ? [region, baseHostname] : getSuffix(baseHostname);
      if (pathStyleEndpoint || !isDnsCompatibleBucketName(bucketName) || tlsCompatible && DOT_PATTERN.test(bucketName)) {
        return {
          bucketEndpoint: false,
          hostname: dualstackEndpoint ? `s3.dualstack.${clientRegion}.${hostnameSuffix}` : baseHostname
        };
      }
      if (accelerateEndpoint) {
        baseHostname = `s3-accelerate${dualstackEndpoint ? ".dualstack" : ""}.${hostnameSuffix}`;
      } else if (dualstackEndpoint) {
        baseHostname = `s3.dualstack.${clientRegion}.${hostnameSuffix}`;
      }
      return {
        bucketEndpoint: true,
        hostname: `${bucketName}.${baseHostname}`
      };
    };
    var getEndpointFromArn = (options) => {
      const { isCustomEndpoint, baseHostname, clientRegion } = options;
      const hostnameSuffix = isCustomEndpoint ? baseHostname : getSuffixForArnEndpoint(baseHostname)[1];
      const { pathStyleEndpoint, accelerateEndpoint = false, fipsEndpoint = false, tlsCompatible = true, bucketName, clientPartition = "aws" } = options;
      validateArnEndpointOptions({ pathStyleEndpoint, accelerateEndpoint, tlsCompatible });
      const { service, partition, accountId, region, resource } = bucketName;
      validateService(service);
      validatePartition(partition, { clientPartition });
      validateAccountId(accountId);
      const { accesspointName, outpostId } = getArnResources(resource);
      if (service === "s3-object-lambda") {
        return getEndpointFromObjectLambdaArn({ ...options, tlsCompatible, bucketName, accesspointName, hostnameSuffix });
      }
      if (region === "") {
        return getEndpointFromMRAPArn({ ...options, mrapAlias: accesspointName, hostnameSuffix });
      }
      if (outpostId) {
        return getEndpointFromOutpostArn({ ...options, clientRegion, outpostId, accesspointName, hostnameSuffix });
      }
      return getEndpointFromAccessPointArn({ ...options, clientRegion, accesspointName, hostnameSuffix });
    };
    var getEndpointFromObjectLambdaArn = ({ dualstackEndpoint = false, fipsEndpoint = false, tlsCompatible = true, useArnRegion, clientRegion, clientSigningRegion = clientRegion, accesspointName, bucketName, hostnameSuffix }) => {
      const { accountId, region, service } = bucketName;
      validateRegionalClient(clientRegion);
      const DNSHostLabel = `${accesspointName}-${accountId}`;
      validateDNSHostLabel(DNSHostLabel, { tlsCompatible });
      const endpointRegion = useArnRegion ? region : clientRegion;
      const signingRegion = useArnRegion ? region : clientSigningRegion;
      return {
        bucketEndpoint: true,
        hostname: `${DNSHostLabel}.${service}${fipsEndpoint ? "-fips" : ""}.${endpointRegion}.${hostnameSuffix}`,
        signingRegion,
        signingService: service
      };
    };
    var getEndpointFromMRAPArn = ({ disableMultiregionAccessPoints, dualstackEndpoint = false, isCustomEndpoint, mrapAlias, hostnameSuffix }) => {
      if (disableMultiregionAccessPoints === true) {
        throw new Error("SDK is attempting to use a MRAP ARN. Please enable to feature.");
      }
      validateMrapAlias(mrapAlias);
      return {
        bucketEndpoint: true,
        hostname: `${mrapAlias}${isCustomEndpoint ? "" : `.accesspoint.s3-global`}.${hostnameSuffix}`,
        signingRegion: "*"
      };
    };
    var getEndpointFromOutpostArn = ({ useArnRegion, clientRegion, clientSigningRegion = clientRegion, bucketName, outpostId, dualstackEndpoint = false, fipsEndpoint = false, tlsCompatible = true, accesspointName, isCustomEndpoint, hostnameSuffix }) => {
      validateRegionalClient(clientRegion);
      const DNSHostLabel = `${accesspointName}-${bucketName.accountId}`;
      validateDNSHostLabel(DNSHostLabel, { tlsCompatible });
      const endpointRegion = useArnRegion ? bucketName.region : clientRegion;
      const signingRegion = useArnRegion ? bucketName.region : clientSigningRegion;
      validateOutpostService(bucketName.service);
      validateDNSHostLabel(outpostId, { tlsCompatible });
      validateNoFIPS(fipsEndpoint);
      const hostnamePrefix = `${DNSHostLabel}.${outpostId}`;
      return {
        bucketEndpoint: true,
        hostname: `${hostnamePrefix}${isCustomEndpoint ? "" : `.s3-outposts.${endpointRegion}`}.${hostnameSuffix}`,
        signingRegion,
        signingService: "s3-outposts"
      };
    };
    var getEndpointFromAccessPointArn = ({ useArnRegion, clientRegion, clientSigningRegion = clientRegion, bucketName, dualstackEndpoint = false, fipsEndpoint = false, tlsCompatible = true, accesspointName, isCustomEndpoint, hostnameSuffix }) => {
      validateRegionalClient(clientRegion);
      const hostnamePrefix = `${accesspointName}-${bucketName.accountId}`;
      validateDNSHostLabel(hostnamePrefix, { tlsCompatible });
      const endpointRegion = useArnRegion ? bucketName.region : clientRegion;
      const signingRegion = useArnRegion ? bucketName.region : clientSigningRegion;
      validateS3Service(bucketName.service);
      return {
        bucketEndpoint: true,
        hostname: `${hostnamePrefix}${isCustomEndpoint ? "" : `.s3-accesspoint${fipsEndpoint ? "-fips" : ""}${dualstackEndpoint ? ".dualstack" : ""}.${endpointRegion}`}.${hostnameSuffix}`,
        signingRegion
      };
    };
    var bucketEndpointMiddleware = (options) => (next, context) => async (args) => {
      const { Bucket: bucketName } = args.input;
      let replaceBucketInPath = options.bucketEndpoint;
      const request2 = args.request;
      if (protocolHttp.HttpRequest.isInstance(request2)) {
        if (options.bucketEndpoint) {
          request2.hostname = bucketName;
        } else if (utilArnParser.validate(bucketName)) {
          const bucketArn = utilArnParser.parse(bucketName);
          const clientRegion = await options.region();
          const useDualstackEndpoint = await options.useDualstackEndpoint();
          const useFipsEndpoint = await options.useFipsEndpoint();
          const { partition, signingRegion = clientRegion } = await options.regionInfoProvider(clientRegion, { useDualstackEndpoint, useFipsEndpoint }) || {};
          const useArnRegion = await options.useArnRegion();
          const { hostname, bucketEndpoint, signingRegion: modifiedSigningRegion, signingService } = bucketHostname({
            bucketName: bucketArn,
            baseHostname: request2.hostname,
            accelerateEndpoint: options.useAccelerateEndpoint,
            dualstackEndpoint: useDualstackEndpoint,
            fipsEndpoint: useFipsEndpoint,
            pathStyleEndpoint: options.forcePathStyle,
            tlsCompatible: request2.protocol === "https:",
            useArnRegion,
            clientPartition: partition,
            clientSigningRegion: signingRegion,
            clientRegion,
            isCustomEndpoint: options.isCustomEndpoint,
            disableMultiregionAccessPoints: await options.disableMultiregionAccessPoints()
          });
          if (modifiedSigningRegion && modifiedSigningRegion !== signingRegion) {
            context["signing_region"] = modifiedSigningRegion;
          }
          if (signingService && signingService !== "s3") {
            context["signing_service"] = signingService;
          }
          request2.hostname = hostname;
          replaceBucketInPath = bucketEndpoint;
        } else {
          const clientRegion = await options.region();
          const dualstackEndpoint = await options.useDualstackEndpoint();
          const fipsEndpoint = await options.useFipsEndpoint();
          const { hostname, bucketEndpoint } = bucketHostname({
            bucketName,
            clientRegion,
            baseHostname: request2.hostname,
            accelerateEndpoint: options.useAccelerateEndpoint,
            dualstackEndpoint,
            fipsEndpoint,
            pathStyleEndpoint: options.forcePathStyle,
            tlsCompatible: request2.protocol === "https:",
            isCustomEndpoint: options.isCustomEndpoint
          });
          request2.hostname = hostname;
          replaceBucketInPath = bucketEndpoint;
        }
        if (replaceBucketInPath) {
          request2.path = request2.path.replace(/^(\/)?[^\/]+/, "");
          if (request2.path === "") {
            request2.path = "/";
          }
        }
      }
      return next({ ...args, request: request2 });
    };
    var bucketEndpointMiddlewareOptions = {
      tags: ["BUCKET_ENDPOINT"],
      name: "bucketEndpointMiddleware",
      relation: "before",
      toMiddleware: "hostHeaderMiddleware",
      override: true
    };
    var getBucketEndpointPlugin = (options) => ({
      applyToStack: (clientStack) => {
        clientStack.addRelativeTo(bucketEndpointMiddleware(options), bucketEndpointMiddlewareOptions);
      }
    });
    function resolveBucketEndpointConfig(input) {
      const { bucketEndpoint = false, forcePathStyle = false, useAccelerateEndpoint = false, useArnRegion, disableMultiregionAccessPoints = false } = input;
      return Object.assign(input, {
        bucketEndpoint,
        forcePathStyle,
        useAccelerateEndpoint,
        useArnRegion: typeof useArnRegion === "function" ? useArnRegion : () => Promise.resolve(useArnRegion),
        disableMultiregionAccessPoints: typeof disableMultiregionAccessPoints === "function" ? disableMultiregionAccessPoints : () => Promise.resolve(disableMultiregionAccessPoints)
      });
    }
    exports2.NODE_DISABLE_MULTIREGION_ACCESS_POINT_CONFIG_OPTIONS = NODE_DISABLE_MULTIREGION_ACCESS_POINT_CONFIG_OPTIONS;
    exports2.NODE_DISABLE_MULTIREGION_ACCESS_POINT_ENV_NAME = NODE_DISABLE_MULTIREGION_ACCESS_POINT_ENV_NAME;
    exports2.NODE_DISABLE_MULTIREGION_ACCESS_POINT_INI_NAME = NODE_DISABLE_MULTIREGION_ACCESS_POINT_INI_NAME;
    exports2.NODE_USE_ARN_REGION_CONFIG_OPTIONS = NODE_USE_ARN_REGION_CONFIG_OPTIONS;
    exports2.NODE_USE_ARN_REGION_ENV_NAME = NODE_USE_ARN_REGION_ENV_NAME;
    exports2.NODE_USE_ARN_REGION_INI_NAME = NODE_USE_ARN_REGION_INI_NAME;
    exports2.bucketEndpointMiddleware = bucketEndpointMiddleware;
    exports2.bucketEndpointMiddlewareOptions = bucketEndpointMiddlewareOptions;
    exports2.bucketHostname = bucketHostname;
    exports2.getArnResources = getArnResources;
    exports2.getBucketEndpointPlugin = getBucketEndpointPlugin;
    exports2.getSuffixForArnEndpoint = getSuffixForArnEndpoint;
    exports2.resolveBucketEndpointConfig = resolveBucketEndpointConfig;
    exports2.validateAccountId = validateAccountId;
    exports2.validateDNSHostLabel = validateDNSHostLabel;
    exports2.validateNoDualstack = validateNoDualstack;
    exports2.validateNoFIPS = validateNoFIPS;
    exports2.validateOutpostService = validateOutpostService;
    exports2.validatePartition = validatePartition;
    exports2.validateRegion = validateRegion;
  }
});

// node_modules/.pnpm/@smithy+eventstream-codec@4.2.8/node_modules/@smithy/eventstream-codec/dist-cjs/index.js
var require_dist_cjs65 = __commonJS({
  "node_modules/.pnpm/@smithy+eventstream-codec@4.2.8/node_modules/@smithy/eventstream-codec/dist-cjs/index.js"(exports2) {
    "use strict";
    var crc32 = require_main3();
    var utilHexEncoding = require_dist_cjs14();
    var Int64 = class _Int64 {
      bytes;
      constructor(bytes) {
        this.bytes = bytes;
        if (bytes.byteLength !== 8) {
          throw new Error("Int64 buffers must be exactly 8 bytes");
        }
      }
      static fromNumber(number) {
        if (number > 9223372036854776e3 || number < -9223372036854776e3) {
          throw new Error(`${number} is too large (or, if negative, too small) to represent as an Int64`);
        }
        const bytes = new Uint8Array(8);
        for (let i4 = 7, remaining = Math.abs(Math.round(number)); i4 > -1 && remaining > 0; i4--, remaining /= 256) {
          bytes[i4] = remaining;
        }
        if (number < 0) {
          negate(bytes);
        }
        return new _Int64(bytes);
      }
      valueOf() {
        const bytes = this.bytes.slice(0);
        const negative = bytes[0] & 128;
        if (negative) {
          negate(bytes);
        }
        return parseInt(utilHexEncoding.toHex(bytes), 16) * (negative ? -1 : 1);
      }
      toString() {
        return String(this.valueOf());
      }
    };
    function negate(bytes) {
      for (let i4 = 0; i4 < 8; i4++) {
        bytes[i4] ^= 255;
      }
      for (let i4 = 7; i4 > -1; i4--) {
        bytes[i4]++;
        if (bytes[i4] !== 0)
          break;
      }
    }
    var HeaderMarshaller = class {
      toUtf8;
      fromUtf8;
      constructor(toUtf810, fromUtf87) {
        this.toUtf8 = toUtf810;
        this.fromUtf8 = fromUtf87;
      }
      format(headers2) {
        const chunks = [];
        for (const headerName of Object.keys(headers2)) {
          const bytes = this.fromUtf8(headerName);
          chunks.push(Uint8Array.from([bytes.byteLength]), bytes, this.formatHeaderValue(headers2[headerName]));
        }
        const out = new Uint8Array(chunks.reduce((carry, bytes) => carry + bytes.byteLength, 0));
        let position = 0;
        for (const chunk2 of chunks) {
          out.set(chunk2, position);
          position += chunk2.byteLength;
        }
        return out;
      }
      formatHeaderValue(header) {
        switch (header.type) {
          case "boolean":
            return Uint8Array.from([header.value ? 0 : 1]);
          case "byte":
            return Uint8Array.from([2, header.value]);
          case "short":
            const shortView = new DataView(new ArrayBuffer(3));
            shortView.setUint8(0, 3);
            shortView.setInt16(1, header.value, false);
            return new Uint8Array(shortView.buffer);
          case "integer":
            const intView = new DataView(new ArrayBuffer(5));
            intView.setUint8(0, 4);
            intView.setInt32(1, header.value, false);
            return new Uint8Array(intView.buffer);
          case "long":
            const longBytes = new Uint8Array(9);
            longBytes[0] = 5;
            longBytes.set(header.value.bytes, 1);
            return longBytes;
          case "binary":
            const binView = new DataView(new ArrayBuffer(3 + header.value.byteLength));
            binView.setUint8(0, 6);
            binView.setUint16(1, header.value.byteLength, false);
            const binBytes = new Uint8Array(binView.buffer);
            binBytes.set(header.value, 3);
            return binBytes;
          case "string":
            const utf8Bytes = this.fromUtf8(header.value);
            const strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));
            strView.setUint8(0, 7);
            strView.setUint16(1, utf8Bytes.byteLength, false);
            const strBytes = new Uint8Array(strView.buffer);
            strBytes.set(utf8Bytes, 3);
            return strBytes;
          case "timestamp":
            const tsBytes = new Uint8Array(9);
            tsBytes[0] = 8;
            tsBytes.set(Int64.fromNumber(header.value.valueOf()).bytes, 1);
            return tsBytes;
          case "uuid":
            if (!UUID_PATTERN.test(header.value)) {
              throw new Error(`Invalid UUID received: ${header.value}`);
            }
            const uuidBytes = new Uint8Array(17);
            uuidBytes[0] = 9;
            uuidBytes.set(utilHexEncoding.fromHex(header.value.replace(/\-/g, "")), 1);
            return uuidBytes;
        }
      }
      parse(headers2) {
        const out = {};
        let position = 0;
        while (position < headers2.byteLength) {
          const nameLength = headers2.getUint8(position++);
          const name = this.toUtf8(new Uint8Array(headers2.buffer, headers2.byteOffset + position, nameLength));
          position += nameLength;
          switch (headers2.getUint8(position++)) {
            case 0:
              out[name] = {
                type: BOOLEAN_TAG,
                value: true
              };
              break;
            case 1:
              out[name] = {
                type: BOOLEAN_TAG,
                value: false
              };
              break;
            case 2:
              out[name] = {
                type: BYTE_TAG,
                value: headers2.getInt8(position++)
              };
              break;
            case 3:
              out[name] = {
                type: SHORT_TAG,
                value: headers2.getInt16(position, false)
              };
              position += 2;
              break;
            case 4:
              out[name] = {
                type: INT_TAG,
                value: headers2.getInt32(position, false)
              };
              position += 4;
              break;
            case 5:
              out[name] = {
                type: LONG_TAG,
                value: new Int64(new Uint8Array(headers2.buffer, headers2.byteOffset + position, 8))
              };
              position += 8;
              break;
            case 6:
              const binaryLength = headers2.getUint16(position, false);
              position += 2;
              out[name] = {
                type: BINARY_TAG,
                value: new Uint8Array(headers2.buffer, headers2.byteOffset + position, binaryLength)
              };
              position += binaryLength;
              break;
            case 7:
              const stringLength = headers2.getUint16(position, false);
              position += 2;
              out[name] = {
                type: STRING_TAG,
                value: this.toUtf8(new Uint8Array(headers2.buffer, headers2.byteOffset + position, stringLength))
              };
              position += stringLength;
              break;
            case 8:
              out[name] = {
                type: TIMESTAMP_TAG,
                value: new Date(new Int64(new Uint8Array(headers2.buffer, headers2.byteOffset + position, 8)).valueOf())
              };
              position += 8;
              break;
            case 9:
              const uuidBytes = new Uint8Array(headers2.buffer, headers2.byteOffset + position, 16);
              position += 16;
              out[name] = {
                type: UUID_TAG,
                value: `${utilHexEncoding.toHex(uuidBytes.subarray(0, 4))}-${utilHexEncoding.toHex(uuidBytes.subarray(4, 6))}-${utilHexEncoding.toHex(uuidBytes.subarray(6, 8))}-${utilHexEncoding.toHex(uuidBytes.subarray(8, 10))}-${utilHexEncoding.toHex(uuidBytes.subarray(10))}`
              };
              break;
            default:
              throw new Error(`Unrecognized header type tag`);
          }
        }
        return out;
      }
    };
    var BOOLEAN_TAG = "boolean";
    var BYTE_TAG = "byte";
    var SHORT_TAG = "short";
    var INT_TAG = "integer";
    var LONG_TAG = "long";
    var BINARY_TAG = "binary";
    var STRING_TAG = "string";
    var TIMESTAMP_TAG = "timestamp";
    var UUID_TAG = "uuid";
    var UUID_PATTERN = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
    var PRELUDE_MEMBER_LENGTH = 4;
    var PRELUDE_LENGTH = PRELUDE_MEMBER_LENGTH * 2;
    var CHECKSUM_LENGTH = 4;
    var MINIMUM_MESSAGE_LENGTH = PRELUDE_LENGTH + CHECKSUM_LENGTH * 2;
    function splitMessage({ byteLength, byteOffset, buffer }) {
      if (byteLength < MINIMUM_MESSAGE_LENGTH) {
        throw new Error("Provided message too short to accommodate event stream message overhead");
      }
      const view = new DataView(buffer, byteOffset, byteLength);
      const messageLength = view.getUint32(0, false);
      if (byteLength !== messageLength) {
        throw new Error("Reported message length does not match received message length");
      }
      const headerLength = view.getUint32(PRELUDE_MEMBER_LENGTH, false);
      const expectedPreludeChecksum = view.getUint32(PRELUDE_LENGTH, false);
      const expectedMessageChecksum = view.getUint32(byteLength - CHECKSUM_LENGTH, false);
      const checksummer = new crc32.Crc32().update(new Uint8Array(buffer, byteOffset, PRELUDE_LENGTH));
      if (expectedPreludeChecksum !== checksummer.digest()) {
        throw new Error(`The prelude checksum specified in the message (${expectedPreludeChecksum}) does not match the calculated CRC32 checksum (${checksummer.digest()})`);
      }
      checksummer.update(new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH, byteLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH)));
      if (expectedMessageChecksum !== checksummer.digest()) {
        throw new Error(`The message checksum (${checksummer.digest()}) did not match the expected value of ${expectedMessageChecksum}`);
      }
      return {
        headers: new DataView(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH, headerLength),
        body: new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH + headerLength, messageLength - headerLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH + CHECKSUM_LENGTH))
      };
    }
    var EventStreamCodec = class {
      headerMarshaller;
      messageBuffer;
      isEndOfStream;
      constructor(toUtf810, fromUtf87) {
        this.headerMarshaller = new HeaderMarshaller(toUtf810, fromUtf87);
        this.messageBuffer = [];
        this.isEndOfStream = false;
      }
      feed(message) {
        this.messageBuffer.push(this.decode(message));
      }
      endOfStream() {
        this.isEndOfStream = true;
      }
      getMessage() {
        const message = this.messageBuffer.pop();
        const isEndOfStream = this.isEndOfStream;
        return {
          getMessage() {
            return message;
          },
          isEndOfStream() {
            return isEndOfStream;
          }
        };
      }
      getAvailableMessages() {
        const messages = this.messageBuffer;
        this.messageBuffer = [];
        const isEndOfStream = this.isEndOfStream;
        return {
          getMessages() {
            return messages;
          },
          isEndOfStream() {
            return isEndOfStream;
          }
        };
      }
      encode({ headers: rawHeaders, body: body2 }) {
        const headers2 = this.headerMarshaller.format(rawHeaders);
        const length = headers2.byteLength + body2.byteLength + 16;
        const out = new Uint8Array(length);
        const view = new DataView(out.buffer, out.byteOffset, out.byteLength);
        const checksum = new crc32.Crc32();
        view.setUint32(0, length, false);
        view.setUint32(4, headers2.byteLength, false);
        view.setUint32(8, checksum.update(out.subarray(0, 8)).digest(), false);
        out.set(headers2, 12);
        out.set(body2, headers2.byteLength + 12);
        view.setUint32(length - 4, checksum.update(out.subarray(8, length - 4)).digest(), false);
        return out;
      }
      decode(message) {
        const { headers: headers2, body: body2 } = splitMessage(message);
        return { headers: this.headerMarshaller.parse(headers2), body: body2 };
      }
      formatHeaders(rawHeaders) {
        return this.headerMarshaller.format(rawHeaders);
      }
    };
    var MessageDecoderStream = class {
      options;
      constructor(options) {
        this.options = options;
      }
      [Symbol.asyncIterator]() {
        return this.asyncIterator();
      }
      async *asyncIterator() {
        for await (const bytes of this.options.inputStream) {
          const decoded = this.options.decoder.decode(bytes);
          yield decoded;
        }
      }
    };
    var MessageEncoderStream = class {
      options;
      constructor(options) {
        this.options = options;
      }
      [Symbol.asyncIterator]() {
        return this.asyncIterator();
      }
      async *asyncIterator() {
        for await (const msg of this.options.messageStream) {
          const encoded = this.options.encoder.encode(msg);
          yield encoded;
        }
        if (this.options.includeEndFrame) {
          yield new Uint8Array(0);
        }
      }
    };
    var SmithyMessageDecoderStream = class {
      options;
      constructor(options) {
        this.options = options;
      }
      [Symbol.asyncIterator]() {
        return this.asyncIterator();
      }
      async *asyncIterator() {
        for await (const message of this.options.messageStream) {
          const deserialized = await this.options.deserializer(message);
          if (deserialized === void 0)
            continue;
          yield deserialized;
        }
      }
    };
    var SmithyMessageEncoderStream = class {
      options;
      constructor(options) {
        this.options = options;
      }
      [Symbol.asyncIterator]() {
        return this.asyncIterator();
      }
      async *asyncIterator() {
        for await (const chunk2 of this.options.inputStream) {
          const payloadBuf = this.options.serializer(chunk2);
          yield payloadBuf;
        }
      }
    };
    exports2.EventStreamCodec = EventStreamCodec;
    exports2.HeaderMarshaller = HeaderMarshaller;
    exports2.Int64 = Int64;
    exports2.MessageDecoderStream = MessageDecoderStream;
    exports2.MessageEncoderStream = MessageEncoderStream;
    exports2.SmithyMessageDecoderStream = SmithyMessageDecoderStream;
    exports2.SmithyMessageEncoderStream = SmithyMessageEncoderStream;
  }
});

// node_modules/.pnpm/@smithy+eventstream-serde-universal@4.2.8/node_modules/@smithy/eventstream-serde-universal/dist-cjs/index.js
var require_dist_cjs66 = __commonJS({
  "node_modules/.pnpm/@smithy+eventstream-serde-universal@4.2.8/node_modules/@smithy/eventstream-serde-universal/dist-cjs/index.js"(exports2) {
    "use strict";
    var eventstreamCodec = require_dist_cjs65();
    function getChunkedStream(source) {
      let currentMessageTotalLength = 0;
      let currentMessagePendingLength = 0;
      let currentMessage = null;
      let messageLengthBuffer = null;
      const allocateMessage = (size) => {
        if (typeof size !== "number") {
          throw new Error("Attempted to allocate an event message where size was not a number: " + size);
        }
        currentMessageTotalLength = size;
        currentMessagePendingLength = 4;
        currentMessage = new Uint8Array(size);
        const currentMessageView = new DataView(currentMessage.buffer);
        currentMessageView.setUint32(0, size, false);
      };
      const iterator = async function* () {
        const sourceIterator = source[Symbol.asyncIterator]();
        while (true) {
          const { value, done } = await sourceIterator.next();
          if (done) {
            if (!currentMessageTotalLength) {
              return;
            } else if (currentMessageTotalLength === currentMessagePendingLength) {
              yield currentMessage;
            } else {
              throw new Error("Truncated event message received.");
            }
            return;
          }
          const chunkLength = value.length;
          let currentOffset = 0;
          while (currentOffset < chunkLength) {
            if (!currentMessage) {
              const bytesRemaining = chunkLength - currentOffset;
              if (!messageLengthBuffer) {
                messageLengthBuffer = new Uint8Array(4);
              }
              const numBytesForTotal = Math.min(4 - currentMessagePendingLength, bytesRemaining);
              messageLengthBuffer.set(value.slice(currentOffset, currentOffset + numBytesForTotal), currentMessagePendingLength);
              currentMessagePendingLength += numBytesForTotal;
              currentOffset += numBytesForTotal;
              if (currentMessagePendingLength < 4) {
                break;
              }
              allocateMessage(new DataView(messageLengthBuffer.buffer).getUint32(0, false));
              messageLengthBuffer = null;
            }
            const numBytesToWrite = Math.min(currentMessageTotalLength - currentMessagePendingLength, chunkLength - currentOffset);
            currentMessage.set(value.slice(currentOffset, currentOffset + numBytesToWrite), currentMessagePendingLength);
            currentMessagePendingLength += numBytesToWrite;
            currentOffset += numBytesToWrite;
            if (currentMessageTotalLength && currentMessageTotalLength === currentMessagePendingLength) {
              yield currentMessage;
              currentMessage = null;
              currentMessageTotalLength = 0;
              currentMessagePendingLength = 0;
            }
          }
        }
      };
      return {
        [Symbol.asyncIterator]: iterator
      };
    }
    function getMessageUnmarshaller(deserializer, toUtf810) {
      return async function(message) {
        const { value: messageType } = message.headers[":message-type"];
        if (messageType === "error") {
          const unmodeledError = new Error(message.headers[":error-message"].value || "UnknownError");
          unmodeledError.name = message.headers[":error-code"].value;
          throw unmodeledError;
        } else if (messageType === "exception") {
          const code = message.headers[":exception-type"].value;
          const exception = { [code]: message };
          const deserializedException = await deserializer(exception);
          if (deserializedException.$unknown) {
            const error2 = new Error(toUtf810(message.body));
            error2.name = code;
            throw error2;
          }
          throw deserializedException[code];
        } else if (messageType === "event") {
          const event = {
            [message.headers[":event-type"].value]: message
          };
          const deserialized = await deserializer(event);
          if (deserialized.$unknown)
            return;
          return deserialized;
        } else {
          throw Error(`Unrecognizable event type: ${message.headers[":event-type"].value}`);
        }
      };
    }
    var EventStreamMarshaller = class {
      eventStreamCodec;
      utfEncoder;
      constructor({ utf8Encoder, utf8Decoder }) {
        this.eventStreamCodec = new eventstreamCodec.EventStreamCodec(utf8Encoder, utf8Decoder);
        this.utfEncoder = utf8Encoder;
      }
      deserialize(body2, deserializer) {
        const inputStream = getChunkedStream(body2);
        return new eventstreamCodec.SmithyMessageDecoderStream({
          messageStream: new eventstreamCodec.MessageDecoderStream({ inputStream, decoder: this.eventStreamCodec }),
          deserializer: getMessageUnmarshaller(deserializer, this.utfEncoder)
        });
      }
      serialize(inputStream, serializer) {
        return new eventstreamCodec.MessageEncoderStream({
          messageStream: new eventstreamCodec.SmithyMessageEncoderStream({ inputStream, serializer }),
          encoder: this.eventStreamCodec,
          includeEndFrame: true
        });
      }
    };
    var eventStreamSerdeProvider = (options) => new EventStreamMarshaller(options);
    exports2.EventStreamMarshaller = EventStreamMarshaller;
    exports2.eventStreamSerdeProvider = eventStreamSerdeProvider;
  }
});

// node_modules/.pnpm/@smithy+eventstream-serde-node@4.2.8/node_modules/@smithy/eventstream-serde-node/dist-cjs/index.js
var require_dist_cjs67 = __commonJS({
  "node_modules/.pnpm/@smithy+eventstream-serde-node@4.2.8/node_modules/@smithy/eventstream-serde-node/dist-cjs/index.js"(exports2) {
    "use strict";
    var eventstreamSerdeUniversal = require_dist_cjs66();
    var stream = require("stream");
    async function* readabletoIterable(readStream) {
      let streamEnded = false;
      let generationEnded = false;
      const records = new Array();
      readStream.on("error", (err) => {
        if (!streamEnded) {
          streamEnded = true;
        }
        if (err) {
          throw err;
        }
      });
      readStream.on("data", (data2) => {
        records.push(data2);
      });
      readStream.on("end", () => {
        streamEnded = true;
      });
      while (!generationEnded) {
        const value = await new Promise((resolve) => setTimeout(() => resolve(records.shift()), 0));
        if (value) {
          yield value;
        }
        generationEnded = streamEnded && records.length === 0;
      }
    }
    var EventStreamMarshaller = class {
      universalMarshaller;
      constructor({ utf8Encoder, utf8Decoder }) {
        this.universalMarshaller = new eventstreamSerdeUniversal.EventStreamMarshaller({
          utf8Decoder,
          utf8Encoder
        });
      }
      deserialize(body2, deserializer) {
        const bodyIterable = typeof body2[Symbol.asyncIterator] === "function" ? body2 : readabletoIterable(body2);
        return this.universalMarshaller.deserialize(bodyIterable, deserializer);
      }
      serialize(input, serializer) {
        return stream.Readable.from(this.universalMarshaller.serialize(input, serializer));
      }
    };
    var eventStreamSerdeProvider = (options) => new EventStreamMarshaller(options);
    exports2.EventStreamMarshaller = EventStreamMarshaller;
    exports2.eventStreamSerdeProvider = eventStreamSerdeProvider;
  }
});

// node_modules/.pnpm/@smithy+hash-stream-node@4.2.8/node_modules/@smithy/hash-stream-node/dist-cjs/index.js
var require_dist_cjs68 = __commonJS({
  "node_modules/.pnpm/@smithy+hash-stream-node@4.2.8/node_modules/@smithy/hash-stream-node/dist-cjs/index.js"(exports2) {
    "use strict";
    var fs3 = require("fs");
    var utilUtf8 = require_dist_cjs8();
    var stream = require("stream");
    var HashCalculator = class extends stream.Writable {
      hash;
      constructor(hash, options) {
        super(options);
        this.hash = hash;
      }
      _write(chunk2, encoding2, callback) {
        try {
          this.hash.update(utilUtf8.toUint8Array(chunk2));
        } catch (err) {
          return callback(err);
        }
        callback();
      }
    };
    var fileStreamHasher = (hashCtor, fileStream) => new Promise((resolve, reject) => {
      if (!isReadStream(fileStream)) {
        reject(new Error("Unable to calculate hash for non-file streams."));
        return;
      }
      const fileStreamTee = fs3.createReadStream(fileStream.path, {
        start: fileStream.start,
        end: fileStream.end
      });
      const hash = new hashCtor();
      const hashCalculator = new HashCalculator(hash);
      fileStreamTee.pipe(hashCalculator);
      fileStreamTee.on("error", (err) => {
        hashCalculator.end();
        reject(err);
      });
      hashCalculator.on("error", reject);
      hashCalculator.on("finish", function() {
        hash.digest().then(resolve).catch(reject);
      });
    });
    var isReadStream = (stream2) => typeof stream2.path === "string";
    var readableStreamHasher = (hashCtor, readableStream) => {
      if (readableStream.readableFlowing !== null) {
        throw new Error("Unable to calculate hash for flowing readable stream");
      }
      const hash = new hashCtor();
      const hashCalculator = new HashCalculator(hash);
      readableStream.pipe(hashCalculator);
      return new Promise((resolve, reject) => {
        readableStream.on("error", (err) => {
          hashCalculator.end();
          reject(err);
        });
        hashCalculator.on("error", reject);
        hashCalculator.on("finish", () => {
          hash.digest().then(resolve).catch(reject);
        });
      });
    };
    exports2.fileStreamHasher = fileStreamHasher;
    exports2.readableStreamHasher = readableStreamHasher;
  }
});

// node_modules/.pnpm/@aws-sdk+client-s3@3.971.0/node_modules/@aws-sdk/client-s3/dist-cjs/runtimeConfig.shared.js
var require_runtimeConfig_shared2 = __commonJS({
  "node_modules/.pnpm/@aws-sdk+client-s3@3.971.0/node_modules/@aws-sdk/client-s3/dist-cjs/runtimeConfig.shared.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getRuntimeConfig = void 0;
    var core_1 = (init_dist_es2(), __toCommonJS(dist_es_exports2));
    var protocols_1 = (init_protocols2(), __toCommonJS(protocols_exports2));
    var signature_v4_multi_region_1 = require_dist_cjs47();
    var smithy_client_1 = require_dist_cjs20();
    var url_parser_1 = require_dist_cjs35();
    var util_base64_1 = require_dist_cjs9();
    var util_stream_1 = require_dist_cjs15();
    var util_utf8_1 = require_dist_cjs8();
    var httpAuthSchemeProvider_1 = require_httpAuthSchemeProvider();
    var endpointResolver_1 = require_endpointResolver();
    var getRuntimeConfig7 = (config) => {
      return {
        apiVersion: "2006-03-01",
        base64Decoder: config?.base64Decoder ?? util_base64_1.fromBase64,
        base64Encoder: config?.base64Encoder ?? util_base64_1.toBase64,
        disableHostPrefix: config?.disableHostPrefix ?? false,
        endpointProvider: config?.endpointProvider ?? endpointResolver_1.defaultEndpointResolver,
        extensions: config?.extensions ?? [],
        getAwsChunkedEncodingStream: config?.getAwsChunkedEncodingStream ?? util_stream_1.getAwsChunkedEncodingStream,
        httpAuthSchemeProvider: config?.httpAuthSchemeProvider ?? httpAuthSchemeProvider_1.defaultS3HttpAuthSchemeProvider,
        httpAuthSchemes: config?.httpAuthSchemes ?? [
          {
            schemeId: "aws.auth#sigv4",
            identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
            signer: new core_1.AwsSdkSigV4Signer()
          },
          {
            schemeId: "aws.auth#sigv4a",
            identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4a"),
            signer: new core_1.AwsSdkSigV4ASigner()
          }
        ],
        logger: config?.logger ?? new smithy_client_1.NoOpLogger(),
        protocol: config?.protocol ?? protocols_1.AwsRestXmlProtocol,
        protocolSettings: config?.protocolSettings ?? {
          defaultNamespace: "com.amazonaws.s3",
          xmlNamespace: "http://s3.amazonaws.com/doc/2006-03-01/",
          version: "2006-03-01",
          serviceTarget: "AmazonS3"
        },
        sdkStreamMixin: config?.sdkStreamMixin ?? util_stream_1.sdkStreamMixin,
        serviceId: config?.serviceId ?? "S3",
        signerConstructor: config?.signerConstructor ?? signature_v4_multi_region_1.SignatureV4MultiRegion,
        signingEscapePath: config?.signingEscapePath ?? false,
        urlParser: config?.urlParser ?? url_parser_1.parseUrl,
        useArnRegion: config?.useArnRegion ?? void 0,
        utf8Decoder: config?.utf8Decoder ?? util_utf8_1.fromUtf8,
        utf8Encoder: config?.utf8Encoder ?? util_utf8_1.toUtf8
      };
    };
    exports2.getRuntimeConfig = getRuntimeConfig7;
  }
});

// node_modules/.pnpm/@aws-sdk+client-s3@3.971.0/node_modules/@aws-sdk/client-s3/dist-cjs/runtimeConfig.js
var require_runtimeConfig2 = __commonJS({
  "node_modules/.pnpm/@aws-sdk+client-s3@3.971.0/node_modules/@aws-sdk/client-s3/dist-cjs/runtimeConfig.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getRuntimeConfig = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var package_json_1 = tslib_1.__importDefault(require_package());
    var core_1 = (init_dist_es2(), __toCommonJS(dist_es_exports2));
    var credential_provider_node_1 = require_dist_cjs63();
    var middleware_bucket_endpoint_1 = require_dist_cjs64();
    var middleware_flexible_checksums_1 = require_dist_cjs26();
    var middleware_sdk_s3_1 = require_dist_cjs32();
    var util_user_agent_node_1 = require_dist_cjs51();
    var config_resolver_1 = require_dist_cjs38();
    var eventstream_serde_node_1 = require_dist_cjs67();
    var hash_node_1 = require_dist_cjs52();
    var hash_stream_node_1 = require_dist_cjs68();
    var middleware_retry_1 = require_dist_cjs46();
    var node_config_provider_1 = require_dist_cjs42();
    var node_http_handler_1 = require_dist_cjs12();
    var smithy_client_1 = require_dist_cjs20();
    var util_body_length_node_1 = require_dist_cjs53();
    var util_defaults_mode_node_1 = require_dist_cjs54();
    var util_retry_1 = require_dist_cjs45();
    var runtimeConfig_shared_1 = require_runtimeConfig_shared2();
    var getRuntimeConfig7 = (config) => {
      (0, smithy_client_1.emitWarningIfUnsupportedVersion)(process.version);
      const defaultsMode = (0, util_defaults_mode_node_1.resolveDefaultsModeConfig)(config);
      const defaultConfigProvider = () => defaultsMode().then(smithy_client_1.loadConfigsForDefaultMode);
      const clientSharedValues = (0, runtimeConfig_shared_1.getRuntimeConfig)(config);
      (0, core_1.emitWarningIfUnsupportedVersion)(process.version);
      const loaderConfig = {
        profile: config?.profile,
        logger: clientSharedValues.logger
      };
      return {
        ...clientSharedValues,
        ...config,
        runtime: "node",
        defaultsMode,
        authSchemePreference: config?.authSchemePreference ?? (0, node_config_provider_1.loadConfig)(core_1.NODE_AUTH_SCHEME_PREFERENCE_OPTIONS, loaderConfig),
        bodyLengthChecker: config?.bodyLengthChecker ?? util_body_length_node_1.calculateBodyLength,
        credentialDefaultProvider: config?.credentialDefaultProvider ?? credential_provider_node_1.defaultProvider,
        defaultUserAgentProvider: config?.defaultUserAgentProvider ?? (0, util_user_agent_node_1.createDefaultUserAgentProvider)({ serviceId: clientSharedValues.serviceId, clientVersion: package_json_1.default.version }),
        disableS3ExpressSessionAuth: config?.disableS3ExpressSessionAuth ?? (0, node_config_provider_1.loadConfig)(middleware_sdk_s3_1.NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_OPTIONS, loaderConfig),
        eventStreamSerdeProvider: config?.eventStreamSerdeProvider ?? eventstream_serde_node_1.eventStreamSerdeProvider,
        maxAttempts: config?.maxAttempts ?? (0, node_config_provider_1.loadConfig)(middleware_retry_1.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, config),
        md5: config?.md5 ?? hash_node_1.Hash.bind(null, "md5"),
        region: config?.region ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_REGION_CONFIG_OPTIONS, { ...config_resolver_1.NODE_REGION_CONFIG_FILE_OPTIONS, ...loaderConfig }),
        requestChecksumCalculation: config?.requestChecksumCalculation ?? (0, node_config_provider_1.loadConfig)(middleware_flexible_checksums_1.NODE_REQUEST_CHECKSUM_CALCULATION_CONFIG_OPTIONS, loaderConfig),
        requestHandler: node_http_handler_1.NodeHttpHandler.create(config?.requestHandler ?? defaultConfigProvider),
        responseChecksumValidation: config?.responseChecksumValidation ?? (0, node_config_provider_1.loadConfig)(middleware_flexible_checksums_1.NODE_RESPONSE_CHECKSUM_VALIDATION_CONFIG_OPTIONS, loaderConfig),
        retryMode: config?.retryMode ?? (0, node_config_provider_1.loadConfig)({
          ...middleware_retry_1.NODE_RETRY_MODE_CONFIG_OPTIONS,
          default: async () => (await defaultConfigProvider()).retryMode || util_retry_1.DEFAULT_RETRY_MODE
        }, config),
        sha1: config?.sha1 ?? hash_node_1.Hash.bind(null, "sha1"),
        sha256: config?.sha256 ?? hash_node_1.Hash.bind(null, "sha256"),
        sigv4aSigningRegionSet: config?.sigv4aSigningRegionSet ?? (0, node_config_provider_1.loadConfig)(core_1.NODE_SIGV4A_CONFIG_OPTIONS, loaderConfig),
        streamCollector: config?.streamCollector ?? node_http_handler_1.streamCollector,
        streamHasher: config?.streamHasher ?? hash_stream_node_1.readableStreamHasher,
        useArnRegion: config?.useArnRegion ?? (0, node_config_provider_1.loadConfig)(middleware_bucket_endpoint_1.NODE_USE_ARN_REGION_CONFIG_OPTIONS, loaderConfig),
        useDualstackEndpoint: config?.useDualstackEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, loaderConfig),
        useFipsEndpoint: config?.useFipsEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, loaderConfig),
        userAgentAppId: config?.userAgentAppId ?? (0, node_config_provider_1.loadConfig)(util_user_agent_node_1.NODE_APP_ID_CONFIG_OPTIONS, loaderConfig)
      };
    };
    exports2.getRuntimeConfig = getRuntimeConfig7;
  }
});

// node_modules/.pnpm/@aws-sdk+middleware-ssec@3.971.0/node_modules/@aws-sdk/middleware-ssec/dist-cjs/index.js
var require_dist_cjs69 = __commonJS({
  "node_modules/.pnpm/@aws-sdk+middleware-ssec@3.971.0/node_modules/@aws-sdk/middleware-ssec/dist-cjs/index.js"(exports2) {
    "use strict";
    function ssecMiddleware(options) {
      return (next) => async (args) => {
        const input = { ...args.input };
        const properties = [
          {
            target: "SSECustomerKey",
            hash: "SSECustomerKeyMD5"
          },
          {
            target: "CopySourceSSECustomerKey",
            hash: "CopySourceSSECustomerKeyMD5"
          }
        ];
        for (const prop of properties) {
          const value = input[prop.target];
          if (value) {
            let valueForHash;
            if (typeof value === "string") {
              if (isValidBase64EncodedSSECustomerKey(value, options)) {
                valueForHash = options.base64Decoder(value);
              } else {
                valueForHash = options.utf8Decoder(value);
                input[prop.target] = options.base64Encoder(valueForHash);
              }
            } else {
              valueForHash = ArrayBuffer.isView(value) ? new Uint8Array(value.buffer, value.byteOffset, value.byteLength) : new Uint8Array(value);
              input[prop.target] = options.base64Encoder(valueForHash);
            }
            const hash = new options.md5();
            hash.update(valueForHash);
            input[prop.hash] = options.base64Encoder(await hash.digest());
          }
        }
        return next({
          ...args,
          input
        });
      };
    }
    var ssecMiddlewareOptions = {
      name: "ssecMiddleware",
      step: "initialize",
      tags: ["SSE"],
      override: true
    };
    var getSsecPlugin = (config) => ({
      applyToStack: (clientStack) => {
        clientStack.add(ssecMiddleware(config), ssecMiddlewareOptions);
      }
    });
    function isValidBase64EncodedSSECustomerKey(str, options) {
      const base64Regex = /^(?:[A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;
      if (!base64Regex.test(str))
        return false;
      try {
        const decodedBytes = options.base64Decoder(str);
        return decodedBytes.length === 32;
      } catch {
        return false;
      }
    }
    exports2.getSsecPlugin = getSsecPlugin;
    exports2.isValidBase64EncodedSSECustomerKey = isValidBase64EncodedSSECustomerKey;
    exports2.ssecMiddleware = ssecMiddleware;
    exports2.ssecMiddlewareOptions = ssecMiddlewareOptions;
  }
});

// node_modules/.pnpm/@aws-sdk+middleware-location-constraint@3.969.0/node_modules/@aws-sdk/middleware-location-constraint/dist-cjs/index.js
var require_dist_cjs70 = __commonJS({
  "node_modules/.pnpm/@aws-sdk+middleware-location-constraint@3.969.0/node_modules/@aws-sdk/middleware-location-constraint/dist-cjs/index.js"(exports2) {
    "use strict";
    function locationConstraintMiddleware(options) {
      return (next) => async (args) => {
        const { CreateBucketConfiguration } = args.input;
        const region = await options.region();
        if (!CreateBucketConfiguration?.LocationConstraint && !CreateBucketConfiguration?.Location) {
          if (region !== "us-east-1") {
            args.input.CreateBucketConfiguration = args.input.CreateBucketConfiguration ?? {};
            args.input.CreateBucketConfiguration.LocationConstraint = region;
          }
        }
        return next(args);
      };
    }
    var locationConstraintMiddlewareOptions = {
      step: "initialize",
      tags: ["LOCATION_CONSTRAINT", "CREATE_BUCKET_CONFIGURATION"],
      name: "locationConstraintMiddleware",
      override: true
    };
    var getLocationConstraintPlugin = (config) => ({
      applyToStack: (clientStack) => {
        clientStack.add(locationConstraintMiddleware(config), locationConstraintMiddlewareOptions);
      }
    });
    exports2.getLocationConstraintPlugin = getLocationConstraintPlugin;
    exports2.locationConstraintMiddleware = locationConstraintMiddleware;
    exports2.locationConstraintMiddlewareOptions = locationConstraintMiddlewareOptions;
  }
});

// node_modules/.pnpm/@smithy+util-waiter@4.2.8/node_modules/@smithy/util-waiter/dist-cjs/index.js
var require_dist_cjs71 = __commonJS({
  "node_modules/.pnpm/@smithy+util-waiter@4.2.8/node_modules/@smithy/util-waiter/dist-cjs/index.js"(exports2) {
    "use strict";
    var getCircularReplacer = () => {
      const seen = /* @__PURE__ */ new WeakSet();
      return (key, value) => {
        if (typeof value === "object" && value !== null) {
          if (seen.has(value)) {
            return "[Circular]";
          }
          seen.add(value);
        }
        return value;
      };
    };
    var sleep2 = (seconds) => {
      return new Promise((resolve) => setTimeout(resolve, seconds * 1e3));
    };
    var waiterServiceDefaults = {
      minDelay: 2,
      maxDelay: 120
    };
    exports2.WaiterState = void 0;
    (function(WaiterState) {
      WaiterState["ABORTED"] = "ABORTED";
      WaiterState["FAILURE"] = "FAILURE";
      WaiterState["SUCCESS"] = "SUCCESS";
      WaiterState["RETRY"] = "RETRY";
      WaiterState["TIMEOUT"] = "TIMEOUT";
    })(exports2.WaiterState || (exports2.WaiterState = {}));
    var checkExceptions = (result) => {
      if (result.state === exports2.WaiterState.ABORTED) {
        const abortError = new Error(`${JSON.stringify({
          ...result,
          reason: "Request was aborted"
        }, getCircularReplacer())}`);
        abortError.name = "AbortError";
        throw abortError;
      } else if (result.state === exports2.WaiterState.TIMEOUT) {
        const timeoutError = new Error(`${JSON.stringify({
          ...result,
          reason: "Waiter has timed out"
        }, getCircularReplacer())}`);
        timeoutError.name = "TimeoutError";
        throw timeoutError;
      } else if (result.state !== exports2.WaiterState.SUCCESS) {
        throw new Error(`${JSON.stringify(result, getCircularReplacer())}`);
      }
      return result;
    };
    var exponentialBackoffWithJitter = (minDelay, maxDelay, attemptCeiling, attempt) => {
      if (attempt > attemptCeiling)
        return maxDelay;
      const delay = minDelay * 2 ** (attempt - 1);
      return randomInRange(minDelay, delay);
    };
    var randomInRange = (min, max) => min + Math.random() * (max - min);
    var runPolling = async ({ minDelay, maxDelay, maxWaitTime, abortController, client: client2, abortSignal: abortSignal2 }, input, acceptorChecks) => {
      const observedResponses = {};
      const { state: state2, reason } = await acceptorChecks(client2, input);
      if (reason) {
        const message = createMessageFromResponse(reason);
        observedResponses[message] |= 0;
        observedResponses[message] += 1;
      }
      if (state2 !== exports2.WaiterState.RETRY) {
        return { state: state2, reason, observedResponses };
      }
      let currentAttempt = 1;
      const waitUntil = Date.now() + maxWaitTime * 1e3;
      const attemptCeiling = Math.log(maxDelay / minDelay) / Math.log(2) + 1;
      while (true) {
        if (abortController?.signal?.aborted || abortSignal2?.aborted) {
          const message = "AbortController signal aborted.";
          observedResponses[message] |= 0;
          observedResponses[message] += 1;
          return { state: exports2.WaiterState.ABORTED, observedResponses };
        }
        const delay = exponentialBackoffWithJitter(minDelay, maxDelay, attemptCeiling, currentAttempt);
        if (Date.now() + delay * 1e3 > waitUntil) {
          return { state: exports2.WaiterState.TIMEOUT, observedResponses };
        }
        await sleep2(delay);
        const { state: state3, reason: reason2 } = await acceptorChecks(client2, input);
        if (reason2) {
          const message = createMessageFromResponse(reason2);
          observedResponses[message] |= 0;
          observedResponses[message] += 1;
        }
        if (state3 !== exports2.WaiterState.RETRY) {
          return { state: state3, reason: reason2, observedResponses };
        }
        currentAttempt += 1;
      }
    };
    var createMessageFromResponse = (reason) => {
      if (reason?.$responseBodyText) {
        return `Deserialization error for body: ${reason.$responseBodyText}`;
      }
      if (reason?.$metadata?.httpStatusCode) {
        if (reason.$response || reason.message) {
          return `${reason.$response.statusCode ?? reason.$metadata.httpStatusCode ?? "Unknown"}: ${reason.message}`;
        }
        return `${reason.$metadata.httpStatusCode}: OK`;
      }
      return String(reason?.message ?? JSON.stringify(reason, getCircularReplacer()) ?? "Unknown");
    };
    var validateWaiterOptions = (options) => {
      if (options.maxWaitTime <= 0) {
        throw new Error(`WaiterConfiguration.maxWaitTime must be greater than 0`);
      } else if (options.minDelay <= 0) {
        throw new Error(`WaiterConfiguration.minDelay must be greater than 0`);
      } else if (options.maxDelay <= 0) {
        throw new Error(`WaiterConfiguration.maxDelay must be greater than 0`);
      } else if (options.maxWaitTime <= options.minDelay) {
        throw new Error(`WaiterConfiguration.maxWaitTime [${options.maxWaitTime}] must be greater than WaiterConfiguration.minDelay [${options.minDelay}] for this waiter`);
      } else if (options.maxDelay < options.minDelay) {
        throw new Error(`WaiterConfiguration.maxDelay [${options.maxDelay}] must be greater than WaiterConfiguration.minDelay [${options.minDelay}] for this waiter`);
      }
    };
    var abortTimeout = (abortSignal2) => {
      let onAbort;
      const promise2 = new Promise((resolve) => {
        onAbort = () => resolve({ state: exports2.WaiterState.ABORTED });
        if (typeof abortSignal2.addEventListener === "function") {
          abortSignal2.addEventListener("abort", onAbort);
        } else {
          abortSignal2.onabort = onAbort;
        }
      });
      return {
        clearListener() {
          if (typeof abortSignal2.removeEventListener === "function") {
            abortSignal2.removeEventListener("abort", onAbort);
          }
        },
        aborted: promise2
      };
    };
    var createWaiter = async (options, input, acceptorChecks) => {
      const params = {
        ...waiterServiceDefaults,
        ...options
      };
      validateWaiterOptions(params);
      const exitConditions = [runPolling(params, input, acceptorChecks)];
      const finalize = [];
      if (options.abortSignal) {
        const { aborted, clearListener } = abortTimeout(options.abortSignal);
        finalize.push(clearListener);
        exitConditions.push(aborted);
      }
      if (options.abortController?.signal) {
        const { aborted, clearListener } = abortTimeout(options.abortController.signal);
        finalize.push(clearListener);
        exitConditions.push(aborted);
      }
      return Promise.race(exitConditions).then((result) => {
        for (const fn of finalize) {
          fn();
        }
        return result;
      });
    };
    exports2.checkExceptions = checkExceptions;
    exports2.createWaiter = createWaiter;
    exports2.waiterServiceDefaults = waiterServiceDefaults;
  }
});

// node_modules/.pnpm/@aws-sdk+client-s3@3.971.0/node_modules/@aws-sdk/client-s3/dist-cjs/index.js
var require_dist_cjs72 = __commonJS({
  "node_modules/.pnpm/@aws-sdk+client-s3@3.971.0/node_modules/@aws-sdk/client-s3/dist-cjs/index.js"(exports2) {
    "use strict";
    var middlewareExpectContinue = require_dist_cjs3();
    var middlewareFlexibleChecksums = require_dist_cjs26();
    var middlewareHostHeader = require_dist_cjs27();
    var middlewareLogger = require_dist_cjs28();
    var middlewareRecursionDetection = require_dist_cjs29();
    var middlewareSdkS3 = require_dist_cjs32();
    var middlewareUserAgent = require_dist_cjs37();
    var configResolver = require_dist_cjs38();
    var core = (init_dist_es(), __toCommonJS(dist_es_exports));
    var schema = (init_schema(), __toCommonJS(schema_exports));
    var eventstreamSerdeConfigResolver = require_dist_cjs39();
    var middlewareContentLength = require_dist_cjs40();
    var middlewareEndpoint = require_dist_cjs43();
    var middlewareRetry = require_dist_cjs46();
    var smithyClient = require_dist_cjs20();
    var httpAuthSchemeProvider = require_httpAuthSchemeProvider();
    var runtimeConfig = require_runtimeConfig2();
    var regionConfigResolver = require_dist_cjs55();
    var protocolHttp = require_dist_cjs2();
    var middlewareSsec = require_dist_cjs69();
    var middlewareLocationConstraint = require_dist_cjs70();
    var utilWaiter = require_dist_cjs71();
    var resolveClientEndpointParameters4 = (options) => {
      return Object.assign(options, {
        useFipsEndpoint: options.useFipsEndpoint ?? false,
        useDualstackEndpoint: options.useDualstackEndpoint ?? false,
        forcePathStyle: options.forcePathStyle ?? false,
        useAccelerateEndpoint: options.useAccelerateEndpoint ?? false,
        useGlobalEndpoint: options.useGlobalEndpoint ?? false,
        disableMultiregionAccessPoints: options.disableMultiregionAccessPoints ?? false,
        defaultSigningName: "s3",
        clientContextParams: options.clientContextParams ?? {}
      });
    };
    var commonParams4 = {
      ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
      UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
      DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
      Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
      DisableS3ExpressSessionAuth: { type: "clientContextParams", name: "disableS3ExpressSessionAuth" },
      UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
      UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
      Endpoint: { type: "builtInParams", name: "endpoint" },
      Region: { type: "builtInParams", name: "region" },
      UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
    };
    var S3ServiceException = class _S3ServiceException extends smithyClient.ServiceException {
      constructor(options) {
        super(options);
        Object.setPrototypeOf(this, _S3ServiceException.prototype);
      }
    };
    var NoSuchUpload = class _NoSuchUpload extends S3ServiceException {
      name = "NoSuchUpload";
      $fault = "client";
      constructor(opts) {
        super({
          name: "NoSuchUpload",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _NoSuchUpload.prototype);
      }
    };
    var ObjectNotInActiveTierError = class _ObjectNotInActiveTierError extends S3ServiceException {
      name = "ObjectNotInActiveTierError";
      $fault = "client";
      constructor(opts) {
        super({
          name: "ObjectNotInActiveTierError",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _ObjectNotInActiveTierError.prototype);
      }
    };
    var BucketAlreadyExists = class _BucketAlreadyExists extends S3ServiceException {
      name = "BucketAlreadyExists";
      $fault = "client";
      constructor(opts) {
        super({
          name: "BucketAlreadyExists",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _BucketAlreadyExists.prototype);
      }
    };
    var BucketAlreadyOwnedByYou = class _BucketAlreadyOwnedByYou extends S3ServiceException {
      name = "BucketAlreadyOwnedByYou";
      $fault = "client";
      constructor(opts) {
        super({
          name: "BucketAlreadyOwnedByYou",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _BucketAlreadyOwnedByYou.prototype);
      }
    };
    var NoSuchBucket2 = class _NoSuchBucket extends S3ServiceException {
      name = "NoSuchBucket";
      $fault = "client";
      constructor(opts) {
        super({
          name: "NoSuchBucket",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _NoSuchBucket.prototype);
      }
    };
    var InvalidObjectState = class _InvalidObjectState extends S3ServiceException {
      name = "InvalidObjectState";
      $fault = "client";
      StorageClass;
      AccessTier;
      constructor(opts) {
        super({
          name: "InvalidObjectState",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _InvalidObjectState.prototype);
        this.StorageClass = opts.StorageClass;
        this.AccessTier = opts.AccessTier;
      }
    };
    var NoSuchKey2 = class _NoSuchKey extends S3ServiceException {
      name = "NoSuchKey";
      $fault = "client";
      constructor(opts) {
        super({
          name: "NoSuchKey",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _NoSuchKey.prototype);
      }
    };
    var NotFound = class _NotFound extends S3ServiceException {
      name = "NotFound";
      $fault = "client";
      constructor(opts) {
        super({
          name: "NotFound",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _NotFound.prototype);
      }
    };
    var EncryptionTypeMismatch = class _EncryptionTypeMismatch extends S3ServiceException {
      name = "EncryptionTypeMismatch";
      $fault = "client";
      constructor(opts) {
        super({
          name: "EncryptionTypeMismatch",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _EncryptionTypeMismatch.prototype);
      }
    };
    var InvalidRequest = class _InvalidRequest extends S3ServiceException {
      name = "InvalidRequest";
      $fault = "client";
      constructor(opts) {
        super({
          name: "InvalidRequest",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _InvalidRequest.prototype);
      }
    };
    var InvalidWriteOffset = class _InvalidWriteOffset extends S3ServiceException {
      name = "InvalidWriteOffset";
      $fault = "client";
      constructor(opts) {
        super({
          name: "InvalidWriteOffset",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _InvalidWriteOffset.prototype);
      }
    };
    var TooManyParts = class _TooManyParts extends S3ServiceException {
      name = "TooManyParts";
      $fault = "client";
      constructor(opts) {
        super({
          name: "TooManyParts",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _TooManyParts.prototype);
      }
    };
    var IdempotencyParameterMismatch = class _IdempotencyParameterMismatch extends S3ServiceException {
      name = "IdempotencyParameterMismatch";
      $fault = "client";
      constructor(opts) {
        super({
          name: "IdempotencyParameterMismatch",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _IdempotencyParameterMismatch.prototype);
      }
    };
    var ObjectAlreadyInActiveTierError = class _ObjectAlreadyInActiveTierError extends S3ServiceException {
      name = "ObjectAlreadyInActiveTierError";
      $fault = "client";
      constructor(opts) {
        super({
          name: "ObjectAlreadyInActiveTierError",
          $fault: "client",
          ...opts
        });
        Object.setPrototypeOf(this, _ObjectAlreadyInActiveTierError.prototype);
      }
    };
    var _A2 = "Account";
    var _AAO = "AnalyticsAndOperator";
    var _AC = "AccelerateConfiguration";
    var _ACL = "AccessControlList";
    var _ACL_ = "ACL";
    var _ACLn = "AnalyticsConfigurationList";
    var _ACP = "AccessControlPolicy";
    var _ACT = "AccessControlTranslation";
    var _ACn = "AnalyticsConfiguration";
    var _AD = "AbortDate";
    var _AED = "AnalyticsExportDestination";
    var _AF = "AnalyticsFilter";
    var _AH = "AllowedHeaders";
    var _AHl = "AllowedHeader";
    var _AI = "AccountId";
    var _AIMU = "AbortIncompleteMultipartUpload";
    var _AKI2 = "AccessKeyId";
    var _AM = "AllowedMethods";
    var _AMU = "AbortMultipartUpload";
    var _AMUO = "AbortMultipartUploadOutput";
    var _AMUR = "AbortMultipartUploadRequest";
    var _AMl = "AllowedMethod";
    var _AO = "AllowedOrigins";
    var _AOl = "AllowedOrigin";
    var _APA = "AccessPointAlias";
    var _APAc = "AccessPointArn";
    var _AQRD = "AllowQuotedRecordDelimiter";
    var _AR2 = "AcceptRanges";
    var _ARI2 = "AbortRuleId";
    var _AS = "AbacStatus";
    var _ASBD = "AnalyticsS3BucketDestination";
    var _ASSEBD = "ApplyServerSideEncryptionByDefault";
    var _ASr = "ArchiveStatus";
    var _AT3 = "AccessTier";
    var _An = "And";
    var _B = "Bucket";
    var _BA = "BucketArn";
    var _BAE = "BucketAlreadyExists";
    var _BAI = "BucketAccountId";
    var _BAOBY = "BucketAlreadyOwnedByYou";
    var _BET = "BlockedEncryptionTypes";
    var _BGR = "BypassGovernanceRetention";
    var _BI = "BucketInfo";
    var _BKE = "BucketKeyEnabled";
    var _BLC = "BucketLifecycleConfiguration";
    var _BLN = "BucketLocationName";
    var _BLS = "BucketLoggingStatus";
    var _BLT = "BucketLocationType";
    var _BN = "BucketName";
    var _BP = "BytesProcessed";
    var _BPA = "BlockPublicAcls";
    var _BPP = "BlockPublicPolicy";
    var _BR = "BucketRegion";
    var _BRy = "BytesReturned";
    var _BS = "BytesScanned";
    var _Bo = "Body";
    var _Bu = "Buckets";
    var _C2 = "Checksum";
    var _CA2 = "ChecksumAlgorithm";
    var _CACL = "CannedACL";
    var _CB = "CreateBucket";
    var _CBC = "CreateBucketConfiguration";
    var _CBMC = "CreateBucketMetadataConfiguration";
    var _CBMCR = "CreateBucketMetadataConfigurationRequest";
    var _CBMTC = "CreateBucketMetadataTableConfiguration";
    var _CBMTCR = "CreateBucketMetadataTableConfigurationRequest";
    var _CBO = "CreateBucketOutput";
    var _CBR = "CreateBucketRequest";
    var _CC = "CacheControl";
    var _CCRC = "ChecksumCRC32";
    var _CCRCC = "ChecksumCRC32C";
    var _CCRCNVME = "ChecksumCRC64NVME";
    var _CC_ = "Cache-Control";
    var _CD = "CreationDate";
    var _CD_ = "Content-Disposition";
    var _CDo = "ContentDisposition";
    var _CE = "ContinuationEvent";
    var _CE_ = "Content-Encoding";
    var _CEo = "ContentEncoding";
    var _CF = "CloudFunction";
    var _CFC = "CloudFunctionConfiguration";
    var _CL = "ContentLanguage";
    var _CL_ = "Content-Language";
    var _CL__ = "Content-Length";
    var _CLo = "ContentLength";
    var _CM = "Content-MD5";
    var _CMD = "ContentMD5";
    var _CMU = "CompletedMultipartUpload";
    var _CMUO = "CompleteMultipartUploadOutput";
    var _CMUOr = "CreateMultipartUploadOutput";
    var _CMUR = "CompleteMultipartUploadResult";
    var _CMURo = "CompleteMultipartUploadRequest";
    var _CMURr = "CreateMultipartUploadRequest";
    var _CMUo = "CompleteMultipartUpload";
    var _CMUr = "CreateMultipartUpload";
    var _CMh = "ChecksumMode";
    var _CO = "CopyObject";
    var _COO = "CopyObjectOutput";
    var _COR = "CopyObjectResult";
    var _CORSC = "CORSConfiguration";
    var _CORSR = "CORSRules";
    var _CORSRu = "CORSRule";
    var _CORo = "CopyObjectRequest";
    var _CP = "CommonPrefix";
    var _CPL = "CommonPrefixList";
    var _CPLo = "CompletedPartList";
    var _CPR = "CopyPartResult";
    var _CPo = "CompletedPart";
    var _CPom = "CommonPrefixes";
    var _CR = "ContentRange";
    var _CRSBA = "ConfirmRemoveSelfBucketAccess";
    var _CR_ = "Content-Range";
    var _CS2 = "CopySource";
    var _CSHA = "ChecksumSHA1";
    var _CSHAh = "ChecksumSHA256";
    var _CSIM = "CopySourceIfMatch";
    var _CSIMS = "CopySourceIfModifiedSince";
    var _CSINM = "CopySourceIfNoneMatch";
    var _CSIUS = "CopySourceIfUnmodifiedSince";
    var _CSO = "CreateSessionOutput";
    var _CSR = "CreateSessionResult";
    var _CSRo = "CopySourceRange";
    var _CSRr = "CreateSessionRequest";
    var _CSSSECA = "CopySourceSSECustomerAlgorithm";
    var _CSSSECK = "CopySourceSSECustomerKey";
    var _CSSSECKMD = "CopySourceSSECustomerKeyMD5";
    var _CSV = "CSV";
    var _CSVI = "CopySourceVersionId";
    var _CSVIn = "CSVInput";
    var _CSVO = "CSVOutput";
    var _CSo = "ConfigurationState";
    var _CSr = "CreateSession";
    var _CT2 = "ChecksumType";
    var _CT_ = "Content-Type";
    var _CTl = "ClientToken";
    var _CTo = "ContentType";
    var _CTom = "CompressionType";
    var _CTon = "ContinuationToken";
    var _Co = "Condition";
    var _Cod = "Code";
    var _Com = "Comments";
    var _Con = "Contents";
    var _Cont = "Cont";
    var _Cr = "Credentials";
    var _D = "Days";
    var _DAI = "DaysAfterInitiation";
    var _DB = "DeleteBucket";
    var _DBAC = "DeleteBucketAnalyticsConfiguration";
    var _DBACR = "DeleteBucketAnalyticsConfigurationRequest";
    var _DBC = "DeleteBucketCors";
    var _DBCR = "DeleteBucketCorsRequest";
    var _DBE = "DeleteBucketEncryption";
    var _DBER = "DeleteBucketEncryptionRequest";
    var _DBIC = "DeleteBucketInventoryConfiguration";
    var _DBICR = "DeleteBucketInventoryConfigurationRequest";
    var _DBITC = "DeleteBucketIntelligentTieringConfiguration";
    var _DBITCR = "DeleteBucketIntelligentTieringConfigurationRequest";
    var _DBL = "DeleteBucketLifecycle";
    var _DBLR = "DeleteBucketLifecycleRequest";
    var _DBMC = "DeleteBucketMetadataConfiguration";
    var _DBMCR = "DeleteBucketMetadataConfigurationRequest";
    var _DBMCRe = "DeleteBucketMetricsConfigurationRequest";
    var _DBMCe = "DeleteBucketMetricsConfiguration";
    var _DBMTC = "DeleteBucketMetadataTableConfiguration";
    var _DBMTCR = "DeleteBucketMetadataTableConfigurationRequest";
    var _DBOC = "DeleteBucketOwnershipControls";
    var _DBOCR = "DeleteBucketOwnershipControlsRequest";
    var _DBP = "DeleteBucketPolicy";
    var _DBPR = "DeleteBucketPolicyRequest";
    var _DBR = "DeleteBucketRequest";
    var _DBRR = "DeleteBucketReplicationRequest";
    var _DBRe = "DeleteBucketReplication";
    var _DBT = "DeleteBucketTagging";
    var _DBTR = "DeleteBucketTaggingRequest";
    var _DBW = "DeleteBucketWebsite";
    var _DBWR = "DeleteBucketWebsiteRequest";
    var _DE = "DataExport";
    var _DIM = "DestinationIfMatch";
    var _DIMS = "DestinationIfModifiedSince";
    var _DINM = "DestinationIfNoneMatch";
    var _DIUS = "DestinationIfUnmodifiedSince";
    var _DM = "DeleteMarker";
    var _DME = "DeleteMarkerEntry";
    var _DMR = "DeleteMarkerReplication";
    var _DMVI = "DeleteMarkerVersionId";
    var _DMe = "DeleteMarkers";
    var _DN = "DisplayName";
    var _DO = "DeletedObject";
    var _DOO = "DeleteObjectOutput";
    var _DOOe = "DeleteObjectsOutput";
    var _DOR = "DeleteObjectRequest";
    var _DORe = "DeleteObjectsRequest";
    var _DOT = "DeleteObjectTagging";
    var _DOTO = "DeleteObjectTaggingOutput";
    var _DOTR = "DeleteObjectTaggingRequest";
    var _DOe = "DeletedObjects";
    var _DOel = "DeleteObject";
    var _DOele = "DeleteObjects";
    var _DPAB = "DeletePublicAccessBlock";
    var _DPABR = "DeletePublicAccessBlockRequest";
    var _DR = "DataRedundancy";
    var _DRe = "DefaultRetention";
    var _DRel = "DeleteResult";
    var _DRes = "DestinationResult";
    var _Da = "Date";
    var _De = "Delete";
    var _Del = "Deleted";
    var _Deli = "Delimiter";
    var _Des = "Destination";
    var _Desc = "Description";
    var _Det = "Details";
    var _E2 = "Expiration";
    var _EA = "EmailAddress";
    var _EBC = "EventBridgeConfiguration";
    var _EBO = "ExpectedBucketOwner";
    var _EC = "EncryptionConfiguration";
    var _ECr = "ErrorCode";
    var _ED = "ErrorDetails";
    var _EDr = "ErrorDocument";
    var _EE = "EndEvent";
    var _EH = "ExposeHeaders";
    var _EHx = "ExposeHeader";
    var _EM = "ErrorMessage";
    var _EODM = "ExpiredObjectDeleteMarker";
    var _EOR = "ExistingObjectReplication";
    var _ES = "ExpiresString";
    var _ESBO = "ExpectedSourceBucketOwner";
    var _ET = "EncryptionType";
    var _ETL = "EncryptionTypeList";
    var _ETM = "EncryptionTypeMismatch";
    var _ETa = "ETag";
    var _ETn = "EncodingType";
    var _ETv = "EventThreshold";
    var _ETx = "ExpressionType";
    var _En = "Encryption";
    var _Ena = "Enabled";
    var _End = "End";
    var _Er = "Errors";
    var _Err = "Error";
    var _Ev = "Events";
    var _Eve = "Event";
    var _Ex = "Expires";
    var _Exp = "Expression";
    var _F = "Filter";
    var _FD = "FieldDelimiter";
    var _FHI = "FileHeaderInfo";
    var _FO = "FetchOwner";
    var _FR = "FilterRule";
    var _FRL = "FilterRuleList";
    var _FRi = "FilterRules";
    var _Fi = "Field";
    var _Fo = "Format";
    var _Fr = "Frequency";
    var _G = "Grants";
    var _GBA = "GetBucketAbac";
    var _GBAC = "GetBucketAccelerateConfiguration";
    var _GBACO = "GetBucketAccelerateConfigurationOutput";
    var _GBACOe = "GetBucketAnalyticsConfigurationOutput";
    var _GBACR = "GetBucketAccelerateConfigurationRequest";
    var _GBACRe = "GetBucketAnalyticsConfigurationRequest";
    var _GBACe = "GetBucketAnalyticsConfiguration";
    var _GBAO = "GetBucketAbacOutput";
    var _GBAOe = "GetBucketAclOutput";
    var _GBAR = "GetBucketAbacRequest";
    var _GBARe = "GetBucketAclRequest";
    var _GBAe = "GetBucketAcl";
    var _GBC = "GetBucketCors";
    var _GBCO = "GetBucketCorsOutput";
    var _GBCR = "GetBucketCorsRequest";
    var _GBE = "GetBucketEncryption";
    var _GBEO = "GetBucketEncryptionOutput";
    var _GBER = "GetBucketEncryptionRequest";
    var _GBIC = "GetBucketInventoryConfiguration";
    var _GBICO = "GetBucketInventoryConfigurationOutput";
    var _GBICR = "GetBucketInventoryConfigurationRequest";
    var _GBITC = "GetBucketIntelligentTieringConfiguration";
    var _GBITCO = "GetBucketIntelligentTieringConfigurationOutput";
    var _GBITCR = "GetBucketIntelligentTieringConfigurationRequest";
    var _GBL = "GetBucketLocation";
    var _GBLC = "GetBucketLifecycleConfiguration";
    var _GBLCO = "GetBucketLifecycleConfigurationOutput";
    var _GBLCR = "GetBucketLifecycleConfigurationRequest";
    var _GBLO = "GetBucketLocationOutput";
    var _GBLOe = "GetBucketLoggingOutput";
    var _GBLR = "GetBucketLocationRequest";
    var _GBLRe = "GetBucketLoggingRequest";
    var _GBLe = "GetBucketLogging";
    var _GBMC = "GetBucketMetadataConfiguration";
    var _GBMCO = "GetBucketMetadataConfigurationOutput";
    var _GBMCOe = "GetBucketMetricsConfigurationOutput";
    var _GBMCR = "GetBucketMetadataConfigurationResult";
    var _GBMCRe = "GetBucketMetadataConfigurationRequest";
    var _GBMCRet = "GetBucketMetricsConfigurationRequest";
    var _GBMCe = "GetBucketMetricsConfiguration";
    var _GBMTC = "GetBucketMetadataTableConfiguration";
    var _GBMTCO = "GetBucketMetadataTableConfigurationOutput";
    var _GBMTCR = "GetBucketMetadataTableConfigurationResult";
    var _GBMTCRe = "GetBucketMetadataTableConfigurationRequest";
    var _GBNC = "GetBucketNotificationConfiguration";
    var _GBNCR = "GetBucketNotificationConfigurationRequest";
    var _GBOC = "GetBucketOwnershipControls";
    var _GBOCO = "GetBucketOwnershipControlsOutput";
    var _GBOCR = "GetBucketOwnershipControlsRequest";
    var _GBP = "GetBucketPolicy";
    var _GBPO = "GetBucketPolicyOutput";
    var _GBPR = "GetBucketPolicyRequest";
    var _GBPS = "GetBucketPolicyStatus";
    var _GBPSO = "GetBucketPolicyStatusOutput";
    var _GBPSR = "GetBucketPolicyStatusRequest";
    var _GBR = "GetBucketReplication";
    var _GBRO = "GetBucketReplicationOutput";
    var _GBRP = "GetBucketRequestPayment";
    var _GBRPO = "GetBucketRequestPaymentOutput";
    var _GBRPR = "GetBucketRequestPaymentRequest";
    var _GBRR = "GetBucketReplicationRequest";
    var _GBT = "GetBucketTagging";
    var _GBTO = "GetBucketTaggingOutput";
    var _GBTR = "GetBucketTaggingRequest";
    var _GBV = "GetBucketVersioning";
    var _GBVO = "GetBucketVersioningOutput";
    var _GBVR = "GetBucketVersioningRequest";
    var _GBW = "GetBucketWebsite";
    var _GBWO = "GetBucketWebsiteOutput";
    var _GBWR = "GetBucketWebsiteRequest";
    var _GFC = "GrantFullControl";
    var _GJP = "GlacierJobParameters";
    var _GO = "GetObject";
    var _GOA = "GetObjectAcl";
    var _GOAO = "GetObjectAclOutput";
    var _GOAOe = "GetObjectAttributesOutput";
    var _GOAP = "GetObjectAttributesParts";
    var _GOAR = "GetObjectAclRequest";
    var _GOARe = "GetObjectAttributesResponse";
    var _GOARet = "GetObjectAttributesRequest";
    var _GOAe = "GetObjectAttributes";
    var _GOLC = "GetObjectLockConfiguration";
    var _GOLCO = "GetObjectLockConfigurationOutput";
    var _GOLCR = "GetObjectLockConfigurationRequest";
    var _GOLH = "GetObjectLegalHold";
    var _GOLHO = "GetObjectLegalHoldOutput";
    var _GOLHR = "GetObjectLegalHoldRequest";
    var _GOO = "GetObjectOutput";
    var _GOR = "GetObjectRequest";
    var _GORO = "GetObjectRetentionOutput";
    var _GORR = "GetObjectRetentionRequest";
    var _GORe = "GetObjectRetention";
    var _GOT = "GetObjectTagging";
    var _GOTO = "GetObjectTaggingOutput";
    var _GOTOe = "GetObjectTorrentOutput";
    var _GOTR = "GetObjectTaggingRequest";
    var _GOTRe = "GetObjectTorrentRequest";
    var _GOTe = "GetObjectTorrent";
    var _GPAB = "GetPublicAccessBlock";
    var _GPABO = "GetPublicAccessBlockOutput";
    var _GPABR = "GetPublicAccessBlockRequest";
    var _GR = "GrantRead";
    var _GRACP = "GrantReadACP";
    var _GW = "GrantWrite";
    var _GWACP = "GrantWriteACP";
    var _Gr = "Grant";
    var _Gra = "Grantee";
    var _HB = "HeadBucket";
    var _HBO = "HeadBucketOutput";
    var _HBR = "HeadBucketRequest";
    var _HECRE = "HttpErrorCodeReturnedEquals";
    var _HN = "HostName";
    var _HO = "HeadObject";
    var _HOO = "HeadObjectOutput";
    var _HOR = "HeadObjectRequest";
    var _HRC = "HttpRedirectCode";
    var _I = "Id";
    var _IC = "InventoryConfiguration";
    var _ICL = "InventoryConfigurationList";
    var _ID = "ID";
    var _IDn = "IndexDocument";
    var _IDnv = "InventoryDestination";
    var _IE = "IsEnabled";
    var _IEn = "InventoryEncryption";
    var _IF = "InventoryFilter";
    var _IL = "IsLatest";
    var _IM = "IfMatch";
    var _IMIT = "IfMatchInitiatedTime";
    var _IMLMT = "IfMatchLastModifiedTime";
    var _IMS = "IfMatchSize";
    var _IMS_ = "If-Modified-Since";
    var _IMSf = "IfModifiedSince";
    var _IMUR = "InitiateMultipartUploadResult";
    var _IM_ = "If-Match";
    var _INM = "IfNoneMatch";
    var _INM_ = "If-None-Match";
    var _IOF = "InventoryOptionalFields";
    var _IOS = "InvalidObjectState";
    var _IOV = "IncludedObjectVersions";
    var _IP = "IsPublic";
    var _IPA = "IgnorePublicAcls";
    var _IPM = "IdempotencyParameterMismatch";
    var _IR = "InvalidRequest";
    var _IRIP = "IsRestoreInProgress";
    var _IS = "InputSerialization";
    var _ISBD = "InventoryS3BucketDestination";
    var _ISn = "InventorySchedule";
    var _IT2 = "IsTruncated";
    var _ITAO = "IntelligentTieringAndOperator";
    var _ITC = "IntelligentTieringConfiguration";
    var _ITCL = "IntelligentTieringConfigurationList";
    var _ITCR = "InventoryTableConfigurationResult";
    var _ITCU = "InventoryTableConfigurationUpdates";
    var _ITCn = "InventoryTableConfiguration";
    var _ITF = "IntelligentTieringFilter";
    var _IUS = "IfUnmodifiedSince";
    var _IUS_ = "If-Unmodified-Since";
    var _IWO = "InvalidWriteOffset";
    var _In = "Initiator";
    var _Ini = "Initiated";
    var _JSON = "JSON";
    var _JSONI = "JSONInput";
    var _JSONO = "JSONOutput";
    var _JTC = "JournalTableConfiguration";
    var _JTCR = "JournalTableConfigurationResult";
    var _JTCU = "JournalTableConfigurationUpdates";
    var _K2 = "Key";
    var _KC = "KeyCount";
    var _KI = "KeyId";
    var _KKA = "KmsKeyArn";
    var _KM = "KeyMarker";
    var _KMSC = "KMSContext";
    var _KMSKI = "KMSKeyId";
    var _KMSMKID = "KMSMasterKeyID";
    var _KPE = "KeyPrefixEquals";
    var _L = "Location";
    var _LAMBR = "ListAllMyBucketsResult";
    var _LAMDBR = "ListAllMyDirectoryBucketsResult";
    var _LB = "ListBuckets";
    var _LBAC = "ListBucketAnalyticsConfigurations";
    var _LBACO = "ListBucketAnalyticsConfigurationsOutput";
    var _LBACR = "ListBucketAnalyticsConfigurationResult";
    var _LBACRi = "ListBucketAnalyticsConfigurationsRequest";
    var _LBIC = "ListBucketInventoryConfigurations";
    var _LBICO = "ListBucketInventoryConfigurationsOutput";
    var _LBICR = "ListBucketInventoryConfigurationsRequest";
    var _LBITC = "ListBucketIntelligentTieringConfigurations";
    var _LBITCO = "ListBucketIntelligentTieringConfigurationsOutput";
    var _LBITCR = "ListBucketIntelligentTieringConfigurationsRequest";
    var _LBMC = "ListBucketMetricsConfigurations";
    var _LBMCO = "ListBucketMetricsConfigurationsOutput";
    var _LBMCR = "ListBucketMetricsConfigurationsRequest";
    var _LBO = "ListBucketsOutput";
    var _LBR = "ListBucketsRequest";
    var _LBRi = "ListBucketResult";
    var _LC = "LocationConstraint";
    var _LCi = "LifecycleConfiguration";
    var _LDB = "ListDirectoryBuckets";
    var _LDBO = "ListDirectoryBucketsOutput";
    var _LDBR = "ListDirectoryBucketsRequest";
    var _LE = "LoggingEnabled";
    var _LEi = "LifecycleExpiration";
    var _LFA = "LambdaFunctionArn";
    var _LFC = "LambdaFunctionConfiguration";
    var _LFCL = "LambdaFunctionConfigurationList";
    var _LFCa = "LambdaFunctionConfigurations";
    var _LH = "LegalHold";
    var _LI = "LocationInfo";
    var _LICR = "ListInventoryConfigurationsResult";
    var _LM = "LastModified";
    var _LMCR = "ListMetricsConfigurationsResult";
    var _LMT = "LastModifiedTime";
    var _LMU = "ListMultipartUploads";
    var _LMUO = "ListMultipartUploadsOutput";
    var _LMUR = "ListMultipartUploadsResult";
    var _LMURi = "ListMultipartUploadsRequest";
    var _LM_ = "Last-Modified";
    var _LO = "ListObjects";
    var _LOO = "ListObjectsOutput";
    var _LOR = "ListObjectsRequest";
    var _LOV = "ListObjectsV2";
    var _LOVO = "ListObjectsV2Output";
    var _LOVOi = "ListObjectVersionsOutput";
    var _LOVR = "ListObjectsV2Request";
    var _LOVRi = "ListObjectVersionsRequest";
    var _LOVi = "ListObjectVersions";
    var _LP = "ListParts";
    var _LPO = "ListPartsOutput";
    var _LPR = "ListPartsResult";
    var _LPRi = "ListPartsRequest";
    var _LR = "LifecycleRule";
    var _LRAO = "LifecycleRuleAndOperator";
    var _LRF = "LifecycleRuleFilter";
    var _LRi = "LifecycleRules";
    var _LVR = "ListVersionsResult";
    var _M = "Metadata";
    var _MAO = "MetricsAndOperator";
    var _MAS = "MaxAgeSeconds";
    var _MB = "MaxBuckets";
    var _MC = "MetadataConfiguration";
    var _MCL = "MetricsConfigurationList";
    var _MCR = "MetadataConfigurationResult";
    var _MCe = "MetricsConfiguration";
    var _MD = "MetadataDirective";
    var _MDB = "MaxDirectoryBuckets";
    var _MDf = "MfaDelete";
    var _ME = "MetadataEntry";
    var _MF = "MetricsFilter";
    var _MFA = "MFA";
    var _MFAD = "MFADelete";
    var _MK = "MaxKeys";
    var _MM = "MissingMeta";
    var _MOS = "MpuObjectSize";
    var _MP = "MaxParts";
    var _MTC = "MetadataTableConfiguration";
    var _MTCR = "MetadataTableConfigurationResult";
    var _MTEC = "MetadataTableEncryptionConfiguration";
    var _MU = "MultipartUpload";
    var _MUL = "MultipartUploadList";
    var _MUa = "MaxUploads";
    var _Ma = "Marker";
    var _Me = "Metrics";
    var _Mes = "Message";
    var _Mi = "Minutes";
    var _Mo = "Mode";
    var _N = "Name";
    var _NC = "NotificationConfiguration";
    var _NCF = "NotificationConfigurationFilter";
    var _NCT = "NextContinuationToken";
    var _ND = "NoncurrentDays";
    var _NF = "NotFound";
    var _NKM = "NextKeyMarker";
    var _NM = "NextMarker";
    var _NNV = "NewerNoncurrentVersions";
    var _NPNM = "NextPartNumberMarker";
    var _NSB = "NoSuchBucket";
    var _NSK = "NoSuchKey";
    var _NSU = "NoSuchUpload";
    var _NUIM = "NextUploadIdMarker";
    var _NVE = "NoncurrentVersionExpiration";
    var _NVIM = "NextVersionIdMarker";
    var _NVT = "NoncurrentVersionTransitions";
    var _NVTL = "NoncurrentVersionTransitionList";
    var _NVTo = "NoncurrentVersionTransition";
    var _O = "Owner";
    var _OA = "ObjectAttributes";
    var _OAIATE = "ObjectAlreadyInActiveTierError";
    var _OC = "OwnershipControls";
    var _OCR = "OwnershipControlsRule";
    var _OCRw = "OwnershipControlsRules";
    var _OF = "OptionalFields";
    var _OI = "ObjectIdentifier";
    var _OIL = "ObjectIdentifierList";
    var _OL = "OutputLocation";
    var _OLC = "ObjectLockConfiguration";
    var _OLE = "ObjectLockEnabled";
    var _OLEFB = "ObjectLockEnabledForBucket";
    var _OLLH = "ObjectLockLegalHold";
    var _OLLHS = "ObjectLockLegalHoldStatus";
    var _OLM = "ObjectLockMode";
    var _OLR = "ObjectLockRetention";
    var _OLRUD = "ObjectLockRetainUntilDate";
    var _OLRb = "ObjectLockRule";
    var _OLb = "ObjectList";
    var _ONIATE = "ObjectNotInActiveTierError";
    var _OO = "ObjectOwnership";
    var _OOA = "OptionalObjectAttributes";
    var _OP = "ObjectParts";
    var _OPb = "ObjectPart";
    var _OS = "ObjectSize";
    var _OSGT = "ObjectSizeGreaterThan";
    var _OSLT = "ObjectSizeLessThan";
    var _OSV = "OutputSchemaVersion";
    var _OSu = "OutputSerialization";
    var _OV = "ObjectVersion";
    var _OVL = "ObjectVersionList";
    var _Ob = "Objects";
    var _Obj = "Object";
    var _P2 = "Prefix";
    var _PABC = "PublicAccessBlockConfiguration";
    var _PBA = "PutBucketAbac";
    var _PBAC = "PutBucketAccelerateConfiguration";
    var _PBACR = "PutBucketAccelerateConfigurationRequest";
    var _PBACRu = "PutBucketAnalyticsConfigurationRequest";
    var _PBACu = "PutBucketAnalyticsConfiguration";
    var _PBAR = "PutBucketAbacRequest";
    var _PBARu = "PutBucketAclRequest";
    var _PBAu = "PutBucketAcl";
    var _PBC = "PutBucketCors";
    var _PBCR = "PutBucketCorsRequest";
    var _PBE = "PutBucketEncryption";
    var _PBER = "PutBucketEncryptionRequest";
    var _PBIC = "PutBucketInventoryConfiguration";
    var _PBICR = "PutBucketInventoryConfigurationRequest";
    var _PBITC = "PutBucketIntelligentTieringConfiguration";
    var _PBITCR = "PutBucketIntelligentTieringConfigurationRequest";
    var _PBL = "PutBucketLogging";
    var _PBLC = "PutBucketLifecycleConfiguration";
    var _PBLCO = "PutBucketLifecycleConfigurationOutput";
    var _PBLCR = "PutBucketLifecycleConfigurationRequest";
    var _PBLR = "PutBucketLoggingRequest";
    var _PBMC = "PutBucketMetricsConfiguration";
    var _PBMCR = "PutBucketMetricsConfigurationRequest";
    var _PBNC = "PutBucketNotificationConfiguration";
    var _PBNCR = "PutBucketNotificationConfigurationRequest";
    var _PBOC = "PutBucketOwnershipControls";
    var _PBOCR = "PutBucketOwnershipControlsRequest";
    var _PBP = "PutBucketPolicy";
    var _PBPR = "PutBucketPolicyRequest";
    var _PBR = "PutBucketReplication";
    var _PBRP = "PutBucketRequestPayment";
    var _PBRPR = "PutBucketRequestPaymentRequest";
    var _PBRR = "PutBucketReplicationRequest";
    var _PBT = "PutBucketTagging";
    var _PBTR = "PutBucketTaggingRequest";
    var _PBV = "PutBucketVersioning";
    var _PBVR = "PutBucketVersioningRequest";
    var _PBW = "PutBucketWebsite";
    var _PBWR = "PutBucketWebsiteRequest";
    var _PC2 = "PartsCount";
    var _PDS = "PartitionDateSource";
    var _PE = "ProgressEvent";
    var _PI2 = "ParquetInput";
    var _PL = "PartsList";
    var _PN = "PartNumber";
    var _PNM = "PartNumberMarker";
    var _PO = "PutObject";
    var _POA = "PutObjectAcl";
    var _POAO = "PutObjectAclOutput";
    var _POAR = "PutObjectAclRequest";
    var _POLC = "PutObjectLockConfiguration";
    var _POLCO = "PutObjectLockConfigurationOutput";
    var _POLCR = "PutObjectLockConfigurationRequest";
    var _POLH = "PutObjectLegalHold";
    var _POLHO = "PutObjectLegalHoldOutput";
    var _POLHR = "PutObjectLegalHoldRequest";
    var _POO = "PutObjectOutput";
    var _POR = "PutObjectRequest";
    var _PORO = "PutObjectRetentionOutput";
    var _PORR = "PutObjectRetentionRequest";
    var _PORu = "PutObjectRetention";
    var _POT = "PutObjectTagging";
    var _POTO = "PutObjectTaggingOutput";
    var _POTR = "PutObjectTaggingRequest";
    var _PP = "PartitionedPrefix";
    var _PPAB = "PutPublicAccessBlock";
    var _PPABR = "PutPublicAccessBlockRequest";
    var _PS = "PolicyStatus";
    var _Pa = "Parts";
    var _Par = "Part";
    var _Parq = "Parquet";
    var _Pay = "Payer";
    var _Payl = "Payload";
    var _Pe = "Permission";
    var _Po = "Policy";
    var _Pr2 = "Progress";
    var _Pri = "Priority";
    var _Pro = "Protocol";
    var _Q = "Quiet";
    var _QA = "QueueArn";
    var _QC = "QuoteCharacter";
    var _QCL = "QueueConfigurationList";
    var _QCu = "QueueConfigurations";
    var _QCue = "QueueConfiguration";
    var _QEC = "QuoteEscapeCharacter";
    var _QF = "QuoteFields";
    var _Qu = "Queue";
    var _R = "Rules";
    var _RART = "RedirectAllRequestsTo";
    var _RC = "RequestCharged";
    var _RCC = "ResponseCacheControl";
    var _RCD = "ResponseContentDisposition";
    var _RCE = "ResponseContentEncoding";
    var _RCL = "ResponseContentLanguage";
    var _RCT = "ResponseContentType";
    var _RCe = "ReplicationConfiguration";
    var _RD = "RecordDelimiter";
    var _RE = "ResponseExpires";
    var _RED = "RestoreExpiryDate";
    var _REe = "RecordExpiration";
    var _REec = "RecordsEvent";
    var _RKKID = "ReplicaKmsKeyID";
    var _RKPW = "ReplaceKeyPrefixWith";
    var _RKW = "ReplaceKeyWith";
    var _RM = "ReplicaModifications";
    var _RO = "RenameObject";
    var _ROO = "RenameObjectOutput";
    var _ROOe = "RestoreObjectOutput";
    var _ROP = "RestoreOutputPath";
    var _ROR = "RenameObjectRequest";
    var _RORe = "RestoreObjectRequest";
    var _ROe = "RestoreObject";
    var _RP = "RequestPayer";
    var _RPB = "RestrictPublicBuckets";
    var _RPC = "RequestPaymentConfiguration";
    var _RPe = "RequestProgress";
    var _RR = "RoutingRules";
    var _RRAO = "ReplicationRuleAndOperator";
    var _RRF = "ReplicationRuleFilter";
    var _RRe = "ReplicationRule";
    var _RRep = "ReplicationRules";
    var _RReq = "RequestRoute";
    var _RRes = "RestoreRequest";
    var _RRo = "RoutingRule";
    var _RS = "ReplicationStatus";
    var _RSe = "RestoreStatus";
    var _RSen = "RenameSource";
    var _RT3 = "ReplicationTime";
    var _RTV = "ReplicationTimeValue";
    var _RTe = "RequestToken";
    var _RUD = "RetainUntilDate";
    var _Ra = "Range";
    var _Re = "Restore";
    var _Rec = "Records";
    var _Red = "Redirect";
    var _Ret = "Retention";
    var _Ro = "Role";
    var _Ru = "Rule";
    var _S = "Status";
    var _SA = "StartAfter";
    var _SAK2 = "SecretAccessKey";
    var _SAs = "SseAlgorithm";
    var _SB = "StreamingBlob";
    var _SBD = "S3BucketDestination";
    var _SC = "StorageClass";
    var _SCA = "StorageClassAnalysis";
    var _SCADE = "StorageClassAnalysisDataExport";
    var _SCV = "SessionCredentialValue";
    var _SCe = "SessionCredentials";
    var _SCt = "StatusCode";
    var _SDV = "SkipDestinationValidation";
    var _SE = "StatsEvent";
    var _SIM = "SourceIfMatch";
    var _SIMS = "SourceIfModifiedSince";
    var _SINM = "SourceIfNoneMatch";
    var _SIUS = "SourceIfUnmodifiedSince";
    var _SK = "SSE-KMS";
    var _SKEO = "SseKmsEncryptedObjects";
    var _SKF = "S3KeyFilter";
    var _SKe = "S3Key";
    var _SL = "S3Location";
    var _SM = "SessionMode";
    var _SOC = "SelectObjectContent";
    var _SOCES = "SelectObjectContentEventStream";
    var _SOCO = "SelectObjectContentOutput";
    var _SOCR = "SelectObjectContentRequest";
    var _SP = "SelectParameters";
    var _SPi = "SimplePrefix";
    var _SR = "ScanRange";
    var _SS = "SSE-S3";
    var _SSC = "SourceSelectionCriteria";
    var _SSE = "ServerSideEncryption";
    var _SSEA = "SSEAlgorithm";
    var _SSEBD = "ServerSideEncryptionByDefault";
    var _SSEC = "ServerSideEncryptionConfiguration";
    var _SSECA = "SSECustomerAlgorithm";
    var _SSECK = "SSECustomerKey";
    var _SSECKMD = "SSECustomerKeyMD5";
    var _SSEKMS = "SSEKMS";
    var _SSEKMSEC = "SSEKMSEncryptionContext";
    var _SSEKMSKI = "SSEKMSKeyId";
    var _SSER = "ServerSideEncryptionRule";
    var _SSERe = "ServerSideEncryptionRules";
    var _SSES = "SSES3";
    var _ST2 = "SessionToken";
    var _STD = "S3TablesDestination";
    var _STDR = "S3TablesDestinationResult";
    var _S_ = "S3";
    var _Sc = "Schedule";
    var _Si = "Size";
    var _St = "Start";
    var _Sta = "Stats";
    var _Su = "Suffix";
    var _T2 = "Tags";
    var _TA = "TableArn";
    var _TAo = "TopicArn";
    var _TB = "TargetBucket";
    var _TBA = "TableBucketArn";
    var _TBT = "TableBucketType";
    var _TC2 = "TagCount";
    var _TCL = "TopicConfigurationList";
    var _TCo = "TopicConfigurations";
    var _TCop = "TopicConfiguration";
    var _TD = "TaggingDirective";
    var _TDMOS = "TransitionDefaultMinimumObjectSize";
    var _TG = "TargetGrants";
    var _TGa = "TargetGrant";
    var _TL = "TieringList";
    var _TLr = "TransitionList";
    var _TMP = "TooManyParts";
    var _TN = "TableNamespace";
    var _TNa = "TableName";
    var _TOKF = "TargetObjectKeyFormat";
    var _TP = "TargetPrefix";
    var _TPC = "TotalPartsCount";
    var _TS = "TagSet";
    var _TSa = "TableStatus";
    var _Ta2 = "Tag";
    var _Tag = "Tagging";
    var _Ti = "Tier";
    var _Tie = "Tierings";
    var _Tier = "Tiering";
    var _Tim = "Time";
    var _To = "Token";
    var _Top = "Topic";
    var _Tr = "Transitions";
    var _Tra = "Transition";
    var _Ty = "Type";
    var _U = "Uploads";
    var _UBMITC = "UpdateBucketMetadataInventoryTableConfiguration";
    var _UBMITCR = "UpdateBucketMetadataInventoryTableConfigurationRequest";
    var _UBMJTC = "UpdateBucketMetadataJournalTableConfiguration";
    var _UBMJTCR = "UpdateBucketMetadataJournalTableConfigurationRequest";
    var _UI = "UploadId";
    var _UIM = "UploadIdMarker";
    var _UM = "UserMetadata";
    var _UP = "UploadPart";
    var _UPC = "UploadPartCopy";
    var _UPCO = "UploadPartCopyOutput";
    var _UPCR = "UploadPartCopyRequest";
    var _UPO = "UploadPartOutput";
    var _UPR = "UploadPartRequest";
    var _URI = "URI";
    var _Up = "Upload";
    var _V2 = "Value";
    var _VC = "VersioningConfiguration";
    var _VI = "VersionId";
    var _VIM = "VersionIdMarker";
    var _Ve = "Versions";
    var _Ver = "Version";
    var _WC = "WebsiteConfiguration";
    var _WGOR = "WriteGetObjectResponse";
    var _WGORR = "WriteGetObjectResponseRequest";
    var _WOB = "WriteOffsetBytes";
    var _WRL = "WebsiteRedirectLocation";
    var _Y = "Years";
    var _ar = "accept-ranges";
    var _br = "bucket-region";
    var _c4 = "client";
    var _ct = "continuation-token";
    var _d = "delimiter";
    var _e4 = "error";
    var _eP = "eventPayload";
    var _en = "endpoint";
    var _et = "encoding-type";
    var _fo = "fetch-owner";
    var _h3 = "http";
    var _hC = "httpChecksum";
    var _hE4 = "httpError";
    var _hH = "httpHeader";
    var _hL = "hostLabel";
    var _hP = "httpPayload";
    var _hPH = "httpPrefixHeaders";
    var _hQ = "httpQuery";
    var _hi = "http://www.w3.org/2001/XMLSchema-instance";
    var _i = "id";
    var _iT3 = "idempotencyToken";
    var _km = "key-marker";
    var _m3 = "marker";
    var _mb = "max-buckets";
    var _mdb = "max-directory-buckets";
    var _mk = "max-keys";
    var _mp = "max-parts";
    var _mu = "max-uploads";
    var _p = "prefix";
    var _pN = "partNumber";
    var _pnm = "part-number-marker";
    var _rcc = "response-cache-control";
    var _rcd = "response-content-disposition";
    var _rce = "response-content-encoding";
    var _rcl = "response-content-language";
    var _rct = "response-content-type";
    var _re = "response-expires";
    var _s4 = "streaming";
    var _sa = "start-after";
    var _sm3 = "smithy.ts.sdk.synthetic.com.amazonaws.s3";
    var _uI = "uploadId";
    var _uim = "upload-id-marker";
    var _vI = "versionId";
    var _vim = "version-id-marker";
    var _x = "xsi";
    var _xA = "xmlAttribute";
    var _xF = "xmlFlattened";
    var _xN = "xmlName";
    var _xNm = "xmlNamespace";
    var _xaa = "x-amz-acl";
    var _xaad = "x-amz-abort-date";
    var _xaapa = "x-amz-access-point-alias";
    var _xaari = "x-amz-abort-rule-id";
    var _xaas = "x-amz-archive-status";
    var _xaba = "x-amz-bucket-arn";
    var _xabgr = "x-amz-bypass-governance-retention";
    var _xabln = "x-amz-bucket-location-name";
    var _xablt = "x-amz-bucket-location-type";
    var _xabole = "x-amz-bucket-object-lock-enabled";
    var _xabolt = "x-amz-bucket-object-lock-token";
    var _xabr = "x-amz-bucket-region";
    var _xaca = "x-amz-checksum-algorithm";
    var _xacc = "x-amz-checksum-crc32";
    var _xacc_ = "x-amz-checksum-crc32c";
    var _xacc__ = "x-amz-checksum-crc64nvme";
    var _xacm = "x-amz-checksum-mode";
    var _xacrsba = "x-amz-confirm-remove-self-bucket-access";
    var _xacs = "x-amz-checksum-sha1";
    var _xacs_ = "x-amz-checksum-sha256";
    var _xacs__ = "x-amz-copy-source";
    var _xacsim = "x-amz-copy-source-if-match";
    var _xacsims = "x-amz-copy-source-if-modified-since";
    var _xacsinm = "x-amz-copy-source-if-none-match";
    var _xacsius = "x-amz-copy-source-if-unmodified-since";
    var _xacsm = "x-amz-create-session-mode";
    var _xacsr = "x-amz-copy-source-range";
    var _xacssseca = "x-amz-copy-source-server-side-encryption-customer-algorithm";
    var _xacssseck = "x-amz-copy-source-server-side-encryption-customer-key";
    var _xacssseckM = "x-amz-copy-source-server-side-encryption-customer-key-MD5";
    var _xacsvi = "x-amz-copy-source-version-id";
    var _xact = "x-amz-checksum-type";
    var _xact_ = "x-amz-client-token";
    var _xadm = "x-amz-delete-marker";
    var _xae = "x-amz-expiration";
    var _xaebo = "x-amz-expected-bucket-owner";
    var _xafec = "x-amz-fwd-error-code";
    var _xafem = "x-amz-fwd-error-message";
    var _xafhCC = "x-amz-fwd-header-Cache-Control";
    var _xafhCD = "x-amz-fwd-header-Content-Disposition";
    var _xafhCE = "x-amz-fwd-header-Content-Encoding";
    var _xafhCL = "x-amz-fwd-header-Content-Language";
    var _xafhCR = "x-amz-fwd-header-Content-Range";
    var _xafhCT = "x-amz-fwd-header-Content-Type";
    var _xafhE = "x-amz-fwd-header-ETag";
    var _xafhE_ = "x-amz-fwd-header-Expires";
    var _xafhLM = "x-amz-fwd-header-Last-Modified";
    var _xafhar = "x-amz-fwd-header-accept-ranges";
    var _xafhxacc = "x-amz-fwd-header-x-amz-checksum-crc32";
    var _xafhxacc_ = "x-amz-fwd-header-x-amz-checksum-crc32c";
    var _xafhxacc__ = "x-amz-fwd-header-x-amz-checksum-crc64nvme";
    var _xafhxacs = "x-amz-fwd-header-x-amz-checksum-sha1";
    var _xafhxacs_ = "x-amz-fwd-header-x-amz-checksum-sha256";
    var _xafhxadm = "x-amz-fwd-header-x-amz-delete-marker";
    var _xafhxae = "x-amz-fwd-header-x-amz-expiration";
    var _xafhxamm = "x-amz-fwd-header-x-amz-missing-meta";
    var _xafhxampc = "x-amz-fwd-header-x-amz-mp-parts-count";
    var _xafhxaollh = "x-amz-fwd-header-x-amz-object-lock-legal-hold";
    var _xafhxaolm = "x-amz-fwd-header-x-amz-object-lock-mode";
    var _xafhxaolrud = "x-amz-fwd-header-x-amz-object-lock-retain-until-date";
    var _xafhxar = "x-amz-fwd-header-x-amz-restore";
    var _xafhxarc = "x-amz-fwd-header-x-amz-request-charged";
    var _xafhxars = "x-amz-fwd-header-x-amz-replication-status";
    var _xafhxasc = "x-amz-fwd-header-x-amz-storage-class";
    var _xafhxasse = "x-amz-fwd-header-x-amz-server-side-encryption";
    var _xafhxasseakki = "x-amz-fwd-header-x-amz-server-side-encryption-aws-kms-key-id";
    var _xafhxassebke = "x-amz-fwd-header-x-amz-server-side-encryption-bucket-key-enabled";
    var _xafhxasseca = "x-amz-fwd-header-x-amz-server-side-encryption-customer-algorithm";
    var _xafhxasseckM = "x-amz-fwd-header-x-amz-server-side-encryption-customer-key-MD5";
    var _xafhxatc = "x-amz-fwd-header-x-amz-tagging-count";
    var _xafhxavi = "x-amz-fwd-header-x-amz-version-id";
    var _xafs = "x-amz-fwd-status";
    var _xagfc = "x-amz-grant-full-control";
    var _xagr = "x-amz-grant-read";
    var _xagra = "x-amz-grant-read-acp";
    var _xagw = "x-amz-grant-write";
    var _xagwa = "x-amz-grant-write-acp";
    var _xaimit = "x-amz-if-match-initiated-time";
    var _xaimlmt = "x-amz-if-match-last-modified-time";
    var _xaims = "x-amz-if-match-size";
    var _xam = "x-amz-meta-";
    var _xam_ = "x-amz-mfa";
    var _xamd = "x-amz-metadata-directive";
    var _xamm = "x-amz-missing-meta";
    var _xamos = "x-amz-mp-object-size";
    var _xamp = "x-amz-max-parts";
    var _xampc = "x-amz-mp-parts-count";
    var _xaoa = "x-amz-object-attributes";
    var _xaollh = "x-amz-object-lock-legal-hold";
    var _xaolm = "x-amz-object-lock-mode";
    var _xaolrud = "x-amz-object-lock-retain-until-date";
    var _xaoo = "x-amz-object-ownership";
    var _xaooa = "x-amz-optional-object-attributes";
    var _xaos = "x-amz-object-size";
    var _xapnm = "x-amz-part-number-marker";
    var _xar = "x-amz-restore";
    var _xarc = "x-amz-request-charged";
    var _xarop = "x-amz-restore-output-path";
    var _xarp = "x-amz-request-payer";
    var _xarr = "x-amz-request-route";
    var _xars = "x-amz-replication-status";
    var _xars_ = "x-amz-rename-source";
    var _xarsim = "x-amz-rename-source-if-match";
    var _xarsims = "x-amz-rename-source-if-modified-since";
    var _xarsinm = "x-amz-rename-source-if-none-match";
    var _xarsius = "x-amz-rename-source-if-unmodified-since";
    var _xart = "x-amz-request-token";
    var _xasc = "x-amz-storage-class";
    var _xasca = "x-amz-sdk-checksum-algorithm";
    var _xasdv = "x-amz-skip-destination-validation";
    var _xasebo = "x-amz-source-expected-bucket-owner";
    var _xasse = "x-amz-server-side-encryption";
    var _xasseakki = "x-amz-server-side-encryption-aws-kms-key-id";
    var _xassebke = "x-amz-server-side-encryption-bucket-key-enabled";
    var _xassec = "x-amz-server-side-encryption-context";
    var _xasseca = "x-amz-server-side-encryption-customer-algorithm";
    var _xasseck = "x-amz-server-side-encryption-customer-key";
    var _xasseckM = "x-amz-server-side-encryption-customer-key-MD5";
    var _xat = "x-amz-tagging";
    var _xatc = "x-amz-tagging-count";
    var _xatd = "x-amz-tagging-directive";
    var _xatdmos = "x-amz-transition-default-minimum-object-size";
    var _xavi = "x-amz-version-id";
    var _xawob = "x-amz-write-offset-bytes";
    var _xawrl = "x-amz-website-redirect-location";
    var _xs = "xsi:type";
    var n04 = "com.amazonaws.s3";
    var CopySourceSSECustomerKey = [0, n04, _CSSSECK, 8, 0];
    var SessionCredentialValue = [0, n04, _SCV, 8, 0];
    var SSECustomerKey = [0, n04, _SSECK, 8, 0];
    var SSEKMSEncryptionContext = [0, n04, _SSEKMSEC, 8, 0];
    var SSEKMSKeyId = [0, n04, _SSEKMSKI, 8, 0];
    var StreamingBlob = [0, n04, _SB, { [_s4]: 1 }, 42];
    var AbacStatus$ = [
      3,
      n04,
      _AS,
      0,
      [_S],
      [0]
    ];
    var AbortIncompleteMultipartUpload$ = [
      3,
      n04,
      _AIMU,
      0,
      [_DAI],
      [1]
    ];
    var AbortMultipartUploadOutput$ = [
      3,
      n04,
      _AMUO,
      0,
      [_RC],
      [[0, { [_hH]: _xarc }]]
    ];
    var AbortMultipartUploadRequest$ = [
      3,
      n04,
      _AMUR,
      0,
      [_B, _K2, _UI, _RP, _EBO, _IMIT],
      [[0, 1], [0, 1], [0, { [_hQ]: _uI }], [0, { [_hH]: _xarp }], [0, { [_hH]: _xaebo }], [6, { [_hH]: _xaimit }]],
      3
    ];
    var AccelerateConfiguration$ = [
      3,
      n04,
      _AC,
      0,
      [_S],
      [0]
    ];
    var AccessControlPolicy$ = [
      3,
      n04,
      _ACP,
      0,
      [_G, _O],
      [[() => Grants, { [_xN]: _ACL }], () => Owner$]
    ];
    var AccessControlTranslation$ = [
      3,
      n04,
      _ACT,
      0,
      [_O],
      [0],
      1
    ];
    var AnalyticsAndOperator$ = [
      3,
      n04,
      _AAO,
      0,
      [_P2, _T2],
      [0, [() => TagSet, { [_xF]: 1, [_xN]: _Ta2 }]]
    ];
    var AnalyticsConfiguration$ = [
      3,
      n04,
      _ACn,
      0,
      [_I, _SCA, _F],
      [0, () => StorageClassAnalysis$, [() => AnalyticsFilter$, 0]],
      2
    ];
    var AnalyticsExportDestination$ = [
      3,
      n04,
      _AED,
      0,
      [_SBD],
      [() => AnalyticsS3BucketDestination$],
      1
    ];
    var AnalyticsS3BucketDestination$ = [
      3,
      n04,
      _ASBD,
      0,
      [_Fo, _B, _BAI, _P2],
      [0, 0, 0, 0],
      2
    ];
    var BlockedEncryptionTypes$ = [
      3,
      n04,
      _BET,
      0,
      [_ET],
      [[() => EncryptionTypeList, { [_xF]: 1 }]]
    ];
    var Bucket$ = [
      3,
      n04,
      _B,
      0,
      [_N, _CD, _BR, _BA],
      [0, 4, 0, 0]
    ];
    var BucketAlreadyExists$ = [
      -3,
      n04,
      _BAE,
      { [_e4]: _c4, [_hE4]: 409 },
      [],
      []
    ];
    schema.TypeRegistry.for(n04).registerError(BucketAlreadyExists$, BucketAlreadyExists);
    var BucketAlreadyOwnedByYou$ = [
      -3,
      n04,
      _BAOBY,
      { [_e4]: _c4, [_hE4]: 409 },
      [],
      []
    ];
    schema.TypeRegistry.for(n04).registerError(BucketAlreadyOwnedByYou$, BucketAlreadyOwnedByYou);
    var BucketInfo$ = [
      3,
      n04,
      _BI,
      0,
      [_DR, _Ty],
      [0, 0]
    ];
    var BucketLifecycleConfiguration$ = [
      3,
      n04,
      _BLC,
      0,
      [_R],
      [[() => LifecycleRules, { [_xF]: 1, [_xN]: _Ru }]],
      1
    ];
    var BucketLoggingStatus$ = [
      3,
      n04,
      _BLS,
      0,
      [_LE],
      [[() => LoggingEnabled$, 0]]
    ];
    var Checksum$ = [
      3,
      n04,
      _C2,
      0,
      [_CCRC, _CCRCC, _CCRCNVME, _CSHA, _CSHAh, _CT2],
      [0, 0, 0, 0, 0, 0]
    ];
    var CommonPrefix$ = [
      3,
      n04,
      _CP,
      0,
      [_P2],
      [0]
    ];
    var CompletedMultipartUpload$ = [
      3,
      n04,
      _CMU,
      0,
      [_Pa],
      [[() => CompletedPartList, { [_xF]: 1, [_xN]: _Par }]]
    ];
    var CompletedPart$ = [
      3,
      n04,
      _CPo,
      0,
      [_ETa, _CCRC, _CCRCC, _CCRCNVME, _CSHA, _CSHAh, _PN],
      [0, 0, 0, 0, 0, 0, 1]
    ];
    var CompleteMultipartUploadOutput$ = [
      3,
      n04,
      _CMUO,
      { [_xN]: _CMUR },
      [_L, _B, _K2, _E2, _ETa, _CCRC, _CCRCC, _CCRCNVME, _CSHA, _CSHAh, _CT2, _SSE, _VI, _SSEKMSKI, _BKE, _RC],
      [0, 0, 0, [0, { [_hH]: _xae }], 0, 0, 0, 0, 0, 0, 0, [0, { [_hH]: _xasse }], [0, { [_hH]: _xavi }], [() => SSEKMSKeyId, { [_hH]: _xasseakki }], [2, { [_hH]: _xassebke }], [0, { [_hH]: _xarc }]]
    ];
    var CompleteMultipartUploadRequest$ = [
      3,
      n04,
      _CMURo,
      0,
      [_B, _K2, _UI, _MU, _CCRC, _CCRCC, _CCRCNVME, _CSHA, _CSHAh, _CT2, _MOS, _RP, _EBO, _IM, _INM, _SSECA, _SSECK, _SSECKMD],
      [[0, 1], [0, 1], [0, { [_hQ]: _uI }], [() => CompletedMultipartUpload$, { [_hP]: 1, [_xN]: _CMUo }], [0, { [_hH]: _xacc }], [0, { [_hH]: _xacc_ }], [0, { [_hH]: _xacc__ }], [0, { [_hH]: _xacs }], [0, { [_hH]: _xacs_ }], [0, { [_hH]: _xact }], [1, { [_hH]: _xamos }], [0, { [_hH]: _xarp }], [0, { [_hH]: _xaebo }], [0, { [_hH]: _IM_ }], [0, { [_hH]: _INM_ }], [0, { [_hH]: _xasseca }], [() => SSECustomerKey, { [_hH]: _xasseck }], [0, { [_hH]: _xasseckM }]],
      3
    ];
    var Condition$ = [
      3,
      n04,
      _Co,
      0,
      [_HECRE, _KPE],
      [0, 0]
    ];
    var ContinuationEvent$ = [
      3,
      n04,
      _CE,
      0,
      [],
      []
    ];
    var CopyObjectOutput$ = [
      3,
      n04,
      _COO,
      0,
      [_COR, _E2, _CSVI, _VI, _SSE, _SSECA, _SSECKMD, _SSEKMSKI, _SSEKMSEC, _BKE, _RC],
      [[() => CopyObjectResult$, 16], [0, { [_hH]: _xae }], [0, { [_hH]: _xacsvi }], [0, { [_hH]: _xavi }], [0, { [_hH]: _xasse }], [0, { [_hH]: _xasseca }], [0, { [_hH]: _xasseckM }], [() => SSEKMSKeyId, { [_hH]: _xasseakki }], [() => SSEKMSEncryptionContext, { [_hH]: _xassec }], [2, { [_hH]: _xassebke }], [0, { [_hH]: _xarc }]]
    ];
    var CopyObjectRequest$ = [
      3,
      n04,
      _CORo,
      0,
      [_B, _CS2, _K2, _ACL_, _CC, _CA2, _CDo, _CEo, _CL, _CTo, _CSIM, _CSIMS, _CSINM, _CSIUS, _Ex, _GFC, _GR, _GRACP, _GWACP, _IM, _INM, _M, _MD, _TD, _SSE, _SC, _WRL, _SSECA, _SSECK, _SSECKMD, _SSEKMSKI, _SSEKMSEC, _BKE, _CSSSECA, _CSSSECK, _CSSSECKMD, _RP, _Tag, _OLM, _OLRUD, _OLLHS, _EBO, _ESBO],
      [[0, 1], [0, { [_hH]: _xacs__ }], [0, 1], [0, { [_hH]: _xaa }], [0, { [_hH]: _CC_ }], [0, { [_hH]: _xaca }], [0, { [_hH]: _CD_ }], [0, { [_hH]: _CE_ }], [0, { [_hH]: _CL_ }], [0, { [_hH]: _CT_ }], [0, { [_hH]: _xacsim }], [4, { [_hH]: _xacsims }], [0, { [_hH]: _xacsinm }], [4, { [_hH]: _xacsius }], [4, { [_hH]: _Ex }], [0, { [_hH]: _xagfc }], [0, { [_hH]: _xagr }], [0, { [_hH]: _xagra }], [0, { [_hH]: _xagwa }], [0, { [_hH]: _IM_ }], [0, { [_hH]: _INM_ }], [128 | 0, { [_hPH]: _xam }], [0, { [_hH]: _xamd }], [0, { [_hH]: _xatd }], [0, { [_hH]: _xasse }], [0, { [_hH]: _xasc }], [0, { [_hH]: _xawrl }], [0, { [_hH]: _xasseca }], [() => SSECustomerKey, { [_hH]: _xasseck }], [0, { [_hH]: _xasseckM }], [() => SSEKMSKeyId, { [_hH]: _xasseakki }], [() => SSEKMSEncryptionContext, { [_hH]: _xassec }], [2, { [_hH]: _xassebke }], [0, { [_hH]: _xacssseca }], [() => CopySourceSSECustomerKey, { [_hH]: _xacssseck }], [0, { [_hH]: _xacssseckM }], [0, { [_hH]: _xarp }], [0, { [_hH]: _xat }], [0, { [_hH]: _xaolm }], [5, { [_hH]: _xaolrud }], [0, { [_hH]: _xaollh }], [0, { [_hH]: _xaebo }], [0, { [_hH]: _xasebo }]],
      3
    ];
    var CopyObjectResult$ = [
      3,
      n04,
      _COR,
      0,
      [_ETa, _LM, _CT2, _CCRC, _CCRCC, _CCRCNVME, _CSHA, _CSHAh],
      [0, 4, 0, 0, 0, 0, 0, 0]
    ];
    var CopyPartResult$ = [
      3,
      n04,
      _CPR,
      0,
      [_ETa, _LM, _CCRC, _CCRCC, _CCRCNVME, _CSHA, _CSHAh],
      [0, 4, 0, 0, 0, 0, 0]
    ];
    var CORSConfiguration$ = [
      3,
      n04,
      _CORSC,
      0,
      [_CORSR],
      [[() => CORSRules, { [_xF]: 1, [_xN]: _CORSRu }]],
      1
    ];
    var CORSRule$ = [
      3,
      n04,
      _CORSRu,
      0,
      [_AM, _AO, _ID, _AH, _EH, _MAS],
      [[64 | 0, { [_xF]: 1, [_xN]: _AMl }], [64 | 0, { [_xF]: 1, [_xN]: _AOl }], 0, [64 | 0, { [_xF]: 1, [_xN]: _AHl }], [64 | 0, { [_xF]: 1, [_xN]: _EHx }], 1],
      2
    ];
    var CreateBucketConfiguration$ = [
      3,
      n04,
      _CBC,
      0,
      [_LC, _L, _B, _T2],
      [0, () => LocationInfo$, () => BucketInfo$, [() => TagSet, 0]]
    ];
    var CreateBucketMetadataConfigurationRequest$ = [
      3,
      n04,
      _CBMCR,
      0,
      [_B, _MC, _CMD, _CA2, _EBO],
      [[0, 1], [() => MetadataConfiguration$, { [_hP]: 1, [_xN]: _MC }], [0, { [_hH]: _CM }], [0, { [_hH]: _xasca }], [0, { [_hH]: _xaebo }]],
      2
    ];
    var CreateBucketMetadataTableConfigurationRequest$ = [
      3,
      n04,
      _CBMTCR,
      0,
      [_B, _MTC, _CMD, _CA2, _EBO],
      [[0, 1], [() => MetadataTableConfiguration$, { [_hP]: 1, [_xN]: _MTC }], [0, { [_hH]: _CM }], [0, { [_hH]: _xasca }], [0, { [_hH]: _xaebo }]],
      2
    ];
    var CreateBucketOutput$ = [
      3,
      n04,
      _CBO,
      0,
      [_L, _BA],
      [[0, { [_hH]: _L }], [0, { [_hH]: _xaba }]]
    ];
    var CreateBucketRequest$ = [
      3,
      n04,
      _CBR,
      0,
      [_B, _ACL_, _CBC, _GFC, _GR, _GRACP, _GW, _GWACP, _OLEFB, _OO],
      [[0, 1], [0, { [_hH]: _xaa }], [() => CreateBucketConfiguration$, { [_hP]: 1, [_xN]: _CBC }], [0, { [_hH]: _xagfc }], [0, { [_hH]: _xagr }], [0, { [_hH]: _xagra }], [0, { [_hH]: _xagw }], [0, { [_hH]: _xagwa }], [2, { [_hH]: _xabole }], [0, { [_hH]: _xaoo }]],
      1
    ];
    var CreateMultipartUploadOutput$ = [
      3,
      n04,
      _CMUOr,
      { [_xN]: _IMUR },
      [_AD, _ARI2, _B, _K2, _UI, _SSE, _SSECA, _SSECKMD, _SSEKMSKI, _SSEKMSEC, _BKE, _RC, _CA2, _CT2],
      [[4, { [_hH]: _xaad }], [0, { [_hH]: _xaari }], [0, { [_xN]: _B }], 0, 0, [0, { [_hH]: _xasse }], [0, { [_hH]: _xasseca }], [0, { [_hH]: _xasseckM }], [() => SSEKMSKeyId, { [_hH]: _xasseakki }], [() => SSEKMSEncryptionContext, { [_hH]: _xassec }], [2, { [_hH]: _xassebke }], [0, { [_hH]: _xarc }], [0, { [_hH]: _xaca }], [0, { [_hH]: _xact }]]
    ];
    var CreateMultipartUploadRequest$ = [
      3,
      n04,
      _CMURr,
      0,
      [_B, _K2, _ACL_, _CC, _CDo, _CEo, _CL, _CTo, _Ex, _GFC, _GR, _GRACP, _GWACP, _M, _SSE, _SC, _WRL, _SSECA, _SSECK, _SSECKMD, _SSEKMSKI, _SSEKMSEC, _BKE, _RP, _Tag, _OLM, _OLRUD, _OLLHS, _EBO, _CA2, _CT2],
      [[0, 1], [0, 1], [0, { [_hH]: _xaa }], [0, { [_hH]: _CC_ }], [0, { [_hH]: _CD_ }], [0, { [_hH]: _CE_ }], [0, { [_hH]: _CL_ }], [0, { [_hH]: _CT_ }], [4, { [_hH]: _Ex }], [0, { [_hH]: _xagfc }], [0, { [_hH]: _xagr }], [0, { [_hH]: _xagra }], [0, { [_hH]: _xagwa }], [128 | 0, { [_hPH]: _xam }], [0, { [_hH]: _xasse }], [0, { [_hH]: _xasc }], [0, { [_hH]: _xawrl }], [0, { [_hH]: _xasseca }], [() => SSECustomerKey, { [_hH]: _xasseck }], [0, { [_hH]: _xasseckM }], [() => SSEKMSKeyId, { [_hH]: _xasseakki }], [() => SSEKMSEncryptionContext, { [_hH]: _xassec }], [2, { [_hH]: _xassebke }], [0, { [_hH]: _xarp }], [0, { [_hH]: _xat }], [0, { [_hH]: _xaolm }], [5, { [_hH]: _xaolrud }], [0, { [_hH]: _xaollh }], [0, { [_hH]: _xaebo }], [0, { [_hH]: _xaca }], [0, { [_hH]: _xact }]],
      2
    ];
    var CreateSessionOutput$ = [
      3,
      n04,
      _CSO,
      { [_xN]: _CSR },
      [_Cr, _SSE, _SSEKMSKI, _SSEKMSEC, _BKE],
      [[() => SessionCredentials$, { [_xN]: _Cr }], [0, { [_hH]: _xasse }], [() => SSEKMSKeyId, { [_hH]: _xasseakki }], [() => SSEKMSEncryptionContext, { [_hH]: _xassec }], [2, { [_hH]: _xassebke }]],
      1
    ];
    var CreateSessionRequest$ = [
      3,
      n04,
      _CSRr,
      0,
      [_B, _SM, _SSE, _SSEKMSKI, _SSEKMSEC, _BKE],
      [[0, 1], [0, { [_hH]: _xacsm }], [0, { [_hH]: _xasse }], [() => SSEKMSKeyId, { [_hH]: _xasseakki }], [() => SSEKMSEncryptionContext, { [_hH]: _xassec }], [2, { [_hH]: _xassebke }]],
      1
    ];
    var CSVInput$ = [
      3,
      n04,
      _CSVIn,
      0,
      [_FHI, _Com, _QEC, _RD, _FD, _QC, _AQRD],
      [0, 0, 0, 0, 0, 0, 2]
    ];
    var CSVOutput$ = [
      3,
      n04,
      _CSVO,
      0,
      [_QF, _QEC, _RD, _FD, _QC],
      [0, 0, 0, 0, 0]
    ];
    var DefaultRetention$ = [
      3,
      n04,
      _DRe,
      0,
      [_Mo, _D, _Y],
      [0, 1, 1]
    ];
    var Delete$ = [
      3,
      n04,
      _De,
      0,
      [_Ob, _Q],
      [[() => ObjectIdentifierList, { [_xF]: 1, [_xN]: _Obj }], 2],
      1
    ];
    var DeleteBucketAnalyticsConfigurationRequest$ = [
      3,
      n04,
      _DBACR,
      0,
      [_B, _I, _EBO],
      [[0, 1], [0, { [_hQ]: _i }], [0, { [_hH]: _xaebo }]],
      2
    ];
    var DeleteBucketCorsRequest$ = [
      3,
      n04,
      _DBCR,
      0,
      [_B, _EBO],
      [[0, 1], [0, { [_hH]: _xaebo }]],
      1
    ];
    var DeleteBucketEncryptionRequest$ = [
      3,
      n04,
      _DBER,
      0,
      [_B, _EBO],
      [[0, 1], [0, { [_hH]: _xaebo }]],
      1
    ];
    var DeleteBucketIntelligentTieringConfigurationRequest$ = [
      3,
      n04,
      _DBITCR,
      0,
      [_B, _I, _EBO],
      [[0, 1], [0, { [_hQ]: _i }], [0, { [_hH]: _xaebo }]],
      2
    ];
    var DeleteBucketInventoryConfigurationRequest$ = [
      3,
      n04,
      _DBICR,
      0,
      [_B, _I, _EBO],
      [[0, 1], [0, { [_hQ]: _i }], [0, { [_hH]: _xaebo }]],
      2
    ];
    var DeleteBucketLifecycleRequest$ = [
      3,
      n04,
      _DBLR,
      0,
      [_B, _EBO],
      [[0, 1], [0, { [_hH]: _xaebo }]],
      1
    ];
    var DeleteBucketMetadataConfigurationRequest$ = [
      3,
      n04,
      _DBMCR,
      0,
      [_B, _EBO],
      [[0, 1], [0, { [_hH]: _xaebo }]],
      1
    ];
    var DeleteBucketMetadataTableConfigurationRequest$ = [
      3,
      n04,
      _DBMTCR,
      0,
      [_B, _EBO],
      [[0, 1], [0, { [_hH]: _xaebo }]],
      1
    ];
    var DeleteBucketMetricsConfigurationRequest$ = [
      3,
      n04,
      _DBMCRe,
      0,
      [_B, _I, _EBO],
      [[0, 1], [0, { [_hQ]: _i }], [0, { [_hH]: _xaebo }]],
      2
    ];
    var DeleteBucketOwnershipControlsRequest$ = [
      3,
      n04,
      _DBOCR,
      0,
      [_B, _EBO],
      [[0, 1], [0, { [_hH]: _xaebo }]],
      1
    ];
    var DeleteBucketPolicyRequest$ = [
      3,
      n04,
      _DBPR,
      0,
      [_B, _EBO],
      [[0, 1], [0, { [_hH]: _xaebo }]],
      1
    ];
    var DeleteBucketReplicationRequest$ = [
      3,
      n04,
      _DBRR,
      0,
      [_B, _EBO],
      [[0, 1], [0, { [_hH]: _xaebo }]],
      1
    ];
    var DeleteBucketRequest$ = [
      3,
      n04,
      _DBR,
      0,
      [_B, _EBO],
      [[0, 1], [0, { [_hH]: _xaebo }]],
      1
    ];
    var DeleteBucketTaggingRequest$ = [
      3,
      n04,
      _DBTR,
      0,
      [_B, _EBO],
      [[0, 1], [0, { [_hH]: _xaebo }]],
      1
    ];
    var DeleteBucketWebsiteRequest$ = [
      3,
      n04,
      _DBWR,
      0,
      [_B, _EBO],
      [[0, 1], [0, { [_hH]: _xaebo }]],
      1
    ];
    var DeletedObject$ = [
      3,
      n04,
      _DO,
      0,
      [_K2, _VI, _DM, _DMVI],
      [0, 0, 2, 0]
    ];
    var DeleteMarkerEntry$ = [
      3,
      n04,
      _DME,
      0,
      [_O, _K2, _VI, _IL, _LM],
      [() => Owner$, 0, 0, 2, 4]
    ];
    var DeleteMarkerReplication$ = [
      3,
      n04,
      _DMR,
      0,
      [_S],
      [0]
    ];
    var DeleteObjectOutput$ = [
      3,
      n04,
      _DOO,
      0,
      [_DM, _VI, _RC],
      [[2, { [_hH]: _xadm }], [0, { [_hH]: _xavi }], [0, { [_hH]: _xarc }]]
    ];
    var DeleteObjectRequest$ = [
      3,
      n04,
      _DOR,
      0,
      [_B, _K2, _MFA, _VI, _RP, _BGR, _EBO, _IM, _IMLMT, _IMS],
      [[0, 1], [0, 1], [0, { [_hH]: _xam_ }], [0, { [_hQ]: _vI }], [0, { [_hH]: _xarp }], [2, { [_hH]: _xabgr }], [0, { [_hH]: _xaebo }], [0, { [_hH]: _IM_ }], [6, { [_hH]: _xaimlmt }], [1, { [_hH]: _xaims }]],
      2
    ];
    var DeleteObjectsOutput$ = [
      3,
      n04,
      _DOOe,
      { [_xN]: _DRel },
      [_Del, _RC, _Er],
      [[() => DeletedObjects, { [_xF]: 1 }], [0, { [_hH]: _xarc }], [() => Errors, { [_xF]: 1, [_xN]: _Err }]]
    ];
    var DeleteObjectsRequest$ = [
      3,
      n04,
      _DORe,
      0,
      [_B, _De, _MFA, _RP, _BGR, _EBO, _CA2],
      [[0, 1], [() => Delete$, { [_hP]: 1, [_xN]: _De }], [0, { [_hH]: _xam_ }], [0, { [_hH]: _xarp }], [2, { [_hH]: _xabgr }], [0, { [_hH]: _xaebo }], [0, { [_hH]: _xasca }]],
      2
    ];
    var DeleteObjectTaggingOutput$ = [
      3,
      n04,
      _DOTO,
      0,
      [_VI],
      [[0, { [_hH]: _xavi }]]
    ];
    var DeleteObjectTaggingRequest$ = [
      3,
      n04,
      _DOTR,
      0,
      [_B, _K2, _VI, _EBO],
      [[0, 1], [0, 1], [0, { [_hQ]: _vI }], [0, { [_hH]: _xaebo }]],
      2
    ];
    var DeletePublicAccessBlockRequest$ = [
      3,
      n04,
      _DPABR,
      0,
      [_B, _EBO],
      [[0, 1], [0, { [_hH]: _xaebo }]],
      1
    ];
    var Destination$ = [
      3,
      n04,
      _Des,
      0,
      [_B, _A2, _SC, _ACT, _EC, _RT3, _Me],
      [0, 0, 0, () => AccessControlTranslation$, () => EncryptionConfiguration$, () => ReplicationTime$, () => Metrics$],
      1
    ];
    var DestinationResult$ = [
      3,
      n04,
      _DRes,
      0,
      [_TBT, _TBA, _TN],
      [0, 0, 0]
    ];
    var Encryption$ = [
      3,
      n04,
      _En,
      0,
      [_ET, _KMSKI, _KMSC],
      [0, [() => SSEKMSKeyId, 0], 0],
      1
    ];
    var EncryptionConfiguration$ = [
      3,
      n04,
      _EC,
      0,
      [_RKKID],
      [0]
    ];
    var EncryptionTypeMismatch$ = [
      -3,
      n04,
      _ETM,
      { [_e4]: _c4, [_hE4]: 400 },
      [],
      []
    ];
    schema.TypeRegistry.for(n04).registerError(EncryptionTypeMismatch$, EncryptionTypeMismatch);
    var EndEvent$ = [
      3,
      n04,
      _EE,
      0,
      [],
      []
    ];
    var _Error$ = [
      3,
      n04,
      _Err,
      0,
      [_K2, _VI, _Cod, _Mes],
      [0, 0, 0, 0]
    ];
    var ErrorDetails$ = [
      3,
      n04,
      _ED,
      0,
      [_ECr, _EM],
      [0, 0]
    ];
    var ErrorDocument$ = [
      3,
      n04,
      _EDr,
      0,
      [_K2],
      [0],
      1
    ];
    var EventBridgeConfiguration$ = [
      3,
      n04,
      _EBC,
      0,
      [],
      []
    ];
    var ExistingObjectReplication$ = [
      3,
      n04,
      _EOR,
      0,
      [_S],
      [0],
      1
    ];
    var FilterRule$ = [
      3,
      n04,
      _FR,
      0,
      [_N, _V2],
      [0, 0]
    ];
    var GetBucketAbacOutput$ = [
      3,
      n04,
      _GBAO,
      0,
      [_AS],
      [[() => AbacStatus$, 16]]
    ];
    var GetBucketAbacRequest$ = [
      3,
      n04,
      _GBAR,
      0,
      [_B, _EBO],
      [[0, 1], [0, { [_hH]: _xaebo }]],
      1
    ];
    var GetBucketAccelerateConfigurationOutput$ = [
      3,
      n04,
      _GBACO,
      { [_xN]: _AC },
      [_S, _RC],
      [0, [0, { [_hH]: _xarc }]]
    ];
    var GetBucketAccelerateConfigurationRequest$ = [
      3,
      n04,
      _GBACR,
      0,
      [_B, _EBO, _RP],
      [[0, 1], [0, { [_hH]: _xaebo }], [0, { [_hH]: _xarp }]],
      1
    ];
    var GetBucketAclOutput$ = [
      3,
      n04,
      _GBAOe,
      { [_xN]: _ACP },
      [_O, _G],
      [() => Owner$, [() => Grants, { [_xN]: _ACL }]]
    ];
    var GetBucketAclRequest$ = [
      3,
      n04,
      _GBARe,
      0,
      [_B, _EBO],
      [[0, 1], [0, { [_hH]: _xaebo }]],
      1
    ];
    var GetBucketAnalyticsConfigurationOutput$ = [
      3,
      n04,
      _GBACOe,
      0,
      [_ACn],
      [[() => AnalyticsConfiguration$, 16]]
    ];
    var GetBucketAnalyticsConfigurationRequest$ = [
      3,
      n04,
      _GBACRe,
      0,
      [_B, _I, _EBO],
      [[0, 1], [0, { [_hQ]: _i }], [0, { [_hH]: _xaebo }]],
      2
    ];
    var GetBucketCorsOutput$ = [
      3,
      n04,
      _GBCO,
      { [_xN]: _CORSC },
      [_CORSR],
      [[() => CORSRules, { [_xF]: 1, [_xN]: _CORSRu }]]
    ];
    var GetBucketCorsRequest$ = [
      3,
      n04,
      _GBCR,
      0,
      [_B, _EBO],
      [[0, 1], [0, { [_hH]: _xaebo }]],
      1
    ];
    var GetBucketEncryptionOutput$ = [
      3,
      n04,
      _GBEO,
      0,
      [_SSEC],
      [[() => ServerSideEncryptionConfiguration$, 16]]
    ];
    var GetBucketEncryptionRequest$ = [
      3,
      n04,
      _GBER,
      0,
      [_B, _EBO],
      [[0, 1], [0, { [_hH]: _xaebo }]],
      1
    ];
    var GetBucketIntelligentTieringConfigurationOutput$ = [
      3,
      n04,
      _GBITCO,
      0,
      [_ITC],
      [[() => IntelligentTieringConfiguration$, 16]]
    ];
    var GetBucketIntelligentTieringConfigurationRequest$ = [
      3,
      n04,
      _GBITCR,
      0,
      [_B, _I, _EBO],
      [[0, 1], [0, { [_hQ]: _i }], [0, { [_hH]: _xaebo }]],
      2
    ];
    var GetBucketInventoryConfigurationOutput$ = [
      3,
      n04,
      _GBICO,
      0,
      [_IC],
      [[() => InventoryConfiguration$, 16]]
    ];
    var GetBucketInventoryConfigurationRequest$ = [
      3,
      n04,
      _GBICR,
      0,
      [_B, _I, _EBO],
      [[0, 1], [0, { [_hQ]: _i }], [0, { [_hH]: _xaebo }]],
      2
    ];
    var GetBucketLifecycleConfigurationOutput$ = [
      3,
      n04,
      _GBLCO,
      { [_xN]: _LCi },
      [_R, _TDMOS],
      [[() => LifecycleRules, { [_xF]: 1, [_xN]: _Ru }], [0, { [_hH]: _xatdmos }]]
    ];
    var GetBucketLifecycleConfigurationRequest$ = [
      3,
      n04,
      _GBLCR,
      0,
      [_B, _EBO],
      [[0, 1], [0, { [_hH]: _xaebo }]],
      1
    ];
    var GetBucketLocationOutput$ = [
      3,
      n04,
      _GBLO,
      { [_xN]: _LC },
      [_LC],
      [0]
    ];
    var GetBucketLocationRequest$ = [
      3,
      n04,
      _GBLR,
      0,
      [_B, _EBO],
      [[0, 1], [0, { [_hH]: _xaebo }]],
      1
    ];
    var GetBucketLoggingOutput$ = [
      3,
      n04,
      _GBLOe,
      { [_xN]: _BLS },
      [_LE],
      [[() => LoggingEnabled$, 0]]
    ];
    var GetBucketLoggingRequest$ = [
      3,
      n04,
      _GBLRe,
      0,
      [_B, _EBO],
      [[0, 1], [0, { [_hH]: _xaebo }]],
      1
    ];
    var GetBucketMetadataConfigurationOutput$ = [
      3,
      n04,
      _GBMCO,
      0,
      [_GBMCR],
      [[() => GetBucketMetadataConfigurationResult$, 16]]
    ];
    var GetBucketMetadataConfigurationRequest$ = [
      3,
      n04,
      _GBMCRe,
      0,
      [_B, _EBO],
      [[0, 1], [0, { [_hH]: _xaebo }]],
      1
    ];
    var GetBucketMetadataConfigurationResult$ = [
      3,
      n04,
      _GBMCR,
      0,
      [_MCR],
      [() => MetadataConfigurationResult$],
      1
    ];
    var GetBucketMetadataTableConfigurationOutput$ = [
      3,
      n04,
      _GBMTCO,
      0,
      [_GBMTCR],
      [[() => GetBucketMetadataTableConfigurationResult$, 16]]
    ];
    var GetBucketMetadataTableConfigurationRequest$ = [
      3,
      n04,
      _GBMTCRe,
      0,
      [_B, _EBO],
      [[0, 1], [0, { [_hH]: _xaebo }]],
      1
    ];
    var GetBucketMetadataTableConfigurationResult$ = [
      3,
      n04,
      _GBMTCR,
      0,
      [_MTCR, _S, _Err],
      [() => MetadataTableConfigurationResult$, 0, () => ErrorDetails$],
      2
    ];
    var GetBucketMetricsConfigurationOutput$ = [
      3,
      n04,
      _GBMCOe,
      0,
      [_MCe],
      [[() => MetricsConfiguration$, 16]]
    ];
    var GetBucketMetricsConfigurationRequest$ = [
      3,
      n04,
      _GBMCRet,
      0,
      [_B, _I, _EBO],
      [[0, 1], [0, { [_hQ]: _i }], [0, { [_hH]: _xaebo }]],
      2
    ];
    var GetBucketNotificationConfigurationRequest$ = [
      3,
      n04,
      _GBNCR,
      0,
      [_B, _EBO],
      [[0, 1], [0, { [_hH]: _xaebo }]],
      1
    ];
    var GetBucketOwnershipControlsOutput$ = [
      3,
      n04,
      _GBOCO,
      0,
      [_OC],
      [[() => OwnershipControls$, 16]]
    ];
    var GetBucketOwnershipControlsRequest$ = [
      3,
      n04,
      _GBOCR,
      0,
      [_B, _EBO],
      [[0, 1], [0, { [_hH]: _xaebo }]],
      1
    ];
    var GetBucketPolicyOutput$ = [
      3,
      n04,
      _GBPO,
      0,
      [_Po],
      [[0, 16]]
    ];
    var GetBucketPolicyRequest$ = [
      3,
      n04,
      _GBPR,
      0,
      [_B, _EBO],
      [[0, 1], [0, { [_hH]: _xaebo }]],
      1
    ];
    var GetBucketPolicyStatusOutput$ = [
      3,
      n04,
      _GBPSO,
      0,
      [_PS],
      [[() => PolicyStatus$, 16]]
    ];
    var GetBucketPolicyStatusRequest$ = [
      3,
      n04,
      _GBPSR,
      0,
      [_B, _EBO],
      [[0, 1], [0, { [_hH]: _xaebo }]],
      1
    ];
    var GetBucketReplicationOutput$ = [
      3,
      n04,
      _GBRO,
      0,
      [_RCe],
      [[() => ReplicationConfiguration$, 16]]
    ];
    var GetBucketReplicationRequest$ = [
      3,
      n04,
      _GBRR,
      0,
      [_B, _EBO],
      [[0, 1], [0, { [_hH]: _xaebo }]],
      1
    ];
    var GetBucketRequestPaymentOutput$ = [
      3,
      n04,
      _GBRPO,
      { [_xN]: _RPC },
      [_Pay],
      [0]
    ];
    var GetBucketRequestPaymentRequest$ = [
      3,
      n04,
      _GBRPR,
      0,
      [_B, _EBO],
      [[0, 1], [0, { [_hH]: _xaebo }]],
      1
    ];
    var GetBucketTaggingOutput$ = [
      3,
      n04,
      _GBTO,
      { [_xN]: _Tag },
      [_TS],
      [[() => TagSet, 0]],
      1
    ];
    var GetBucketTaggingRequest$ = [
      3,
      n04,
      _GBTR,
      0,
      [_B, _EBO],
      [[0, 1], [0, { [_hH]: _xaebo }]],
      1
    ];
    var GetBucketVersioningOutput$ = [
      3,
      n04,
      _GBVO,
      { [_xN]: _VC },
      [_S, _MFAD],
      [0, [0, { [_xN]: _MDf }]]
    ];
    var GetBucketVersioningRequest$ = [
      3,
      n04,
      _GBVR,
      0,
      [_B, _EBO],
      [[0, 1], [0, { [_hH]: _xaebo }]],
      1
    ];
    var GetBucketWebsiteOutput$ = [
      3,
      n04,
      _GBWO,
      { [_xN]: _WC },
      [_RART, _IDn, _EDr, _RR],
      [() => RedirectAllRequestsTo$, () => IndexDocument$, () => ErrorDocument$, [() => RoutingRules, 0]]
    ];
    var GetBucketWebsiteRequest$ = [
      3,
      n04,
      _GBWR,
      0,
      [_B, _EBO],
      [[0, 1], [0, { [_hH]: _xaebo }]],
      1
    ];
    var GetObjectAclOutput$ = [
      3,
      n04,
      _GOAO,
      { [_xN]: _ACP },
      [_O, _G, _RC],
      [() => Owner$, [() => Grants, { [_xN]: _ACL }], [0, { [_hH]: _xarc }]]
    ];
    var GetObjectAclRequest$ = [
      3,
      n04,
      _GOAR,
      0,
      [_B, _K2, _VI, _RP, _EBO],
      [[0, 1], [0, 1], [0, { [_hQ]: _vI }], [0, { [_hH]: _xarp }], [0, { [_hH]: _xaebo }]],
      2
    ];
    var GetObjectAttributesOutput$ = [
      3,
      n04,
      _GOAOe,
      { [_xN]: _GOARe },
      [_DM, _LM, _VI, _RC, _ETa, _C2, _OP, _SC, _OS],
      [[2, { [_hH]: _xadm }], [4, { [_hH]: _LM_ }], [0, { [_hH]: _xavi }], [0, { [_hH]: _xarc }], 0, () => Checksum$, [() => GetObjectAttributesParts$, 0], 0, 1]
    ];
    var GetObjectAttributesParts$ = [
      3,
      n04,
      _GOAP,
      0,
      [_TPC, _PNM, _NPNM, _MP, _IT2, _Pa],
      [[1, { [_xN]: _PC2 }], 0, 0, 1, 2, [() => PartsList, { [_xF]: 1, [_xN]: _Par }]]
    ];
    var GetObjectAttributesRequest$ = [
      3,
      n04,
      _GOARet,
      0,
      [_B, _K2, _OA, _VI, _MP, _PNM, _SSECA, _SSECK, _SSECKMD, _RP, _EBO],
      [[0, 1], [0, 1], [64 | 0, { [_hH]: _xaoa }], [0, { [_hQ]: _vI }], [1, { [_hH]: _xamp }], [0, { [_hH]: _xapnm }], [0, { [_hH]: _xasseca }], [() => SSECustomerKey, { [_hH]: _xasseck }], [0, { [_hH]: _xasseckM }], [0, { [_hH]: _xarp }], [0, { [_hH]: _xaebo }]],
      3
    ];
    var GetObjectLegalHoldOutput$ = [
      3,
      n04,
      _GOLHO,
      0,
      [_LH],
      [[() => ObjectLockLegalHold$, { [_hP]: 1, [_xN]: _LH }]]
    ];
    var GetObjectLegalHoldRequest$ = [
      3,
      n04,
      _GOLHR,
      0,
      [_B, _K2, _VI, _RP, _EBO],
      [[0, 1], [0, 1], [0, { [_hQ]: _vI }], [0, { [_hH]: _xarp }], [0, { [_hH]: _xaebo }]],
      2
    ];
    var GetObjectLockConfigurationOutput$ = [
      3,
      n04,
      _GOLCO,
      0,
      [_OLC],
      [[() => ObjectLockConfiguration$, 16]]
    ];
    var GetObjectLockConfigurationRequest$ = [
      3,
      n04,
      _GOLCR,
      0,
      [_B, _EBO],
      [[0, 1], [0, { [_hH]: _xaebo }]],
      1
    ];
    var GetObjectOutput$ = [
      3,
      n04,
      _GOO,
      0,
      [_Bo, _DM, _AR2, _E2, _Re, _LM, _CLo, _ETa, _CCRC, _CCRCC, _CCRCNVME, _CSHA, _CSHAh, _CT2, _MM, _VI, _CC, _CDo, _CEo, _CL, _CR, _CTo, _Ex, _ES, _WRL, _SSE, _M, _SSECA, _SSECKMD, _SSEKMSKI, _BKE, _SC, _RC, _RS, _PC2, _TC2, _OLM, _OLRUD, _OLLHS],
      [[() => StreamingBlob, 16], [2, { [_hH]: _xadm }], [0, { [_hH]: _ar }], [0, { [_hH]: _xae }], [0, { [_hH]: _xar }], [4, { [_hH]: _LM_ }], [1, { [_hH]: _CL__ }], [0, { [_hH]: _ETa }], [0, { [_hH]: _xacc }], [0, { [_hH]: _xacc_ }], [0, { [_hH]: _xacc__ }], [0, { [_hH]: _xacs }], [0, { [_hH]: _xacs_ }], [0, { [_hH]: _xact }], [1, { [_hH]: _xamm }], [0, { [_hH]: _xavi }], [0, { [_hH]: _CC_ }], [0, { [_hH]: _CD_ }], [0, { [_hH]: _CE_ }], [0, { [_hH]: _CL_ }], [0, { [_hH]: _CR_ }], [0, { [_hH]: _CT_ }], [4, { [_hH]: _Ex }], [0, { [_hH]: _ES }], [0, { [_hH]: _xawrl }], [0, { [_hH]: _xasse }], [128 | 0, { [_hPH]: _xam }], [0, { [_hH]: _xasseca }], [0, { [_hH]: _xasseckM }], [() => SSEKMSKeyId, { [_hH]: _xasseakki }], [2, { [_hH]: _xassebke }], [0, { [_hH]: _xasc }], [0, { [_hH]: _xarc }], [0, { [_hH]: _xars }], [1, { [_hH]: _xampc }], [1, { [_hH]: _xatc }], [0, { [_hH]: _xaolm }], [5, { [_hH]: _xaolrud }], [0, { [_hH]: _xaollh }]]
    ];
    var GetObjectRequest$ = [
      3,
      n04,
      _GOR,
      0,
      [_B, _K2, _IM, _IMSf, _INM, _IUS, _Ra, _RCC, _RCD, _RCE, _RCL, _RCT, _RE, _VI, _SSECA, _SSECK, _SSECKMD, _RP, _PN, _EBO, _CMh],
      [[0, 1], [0, 1], [0, { [_hH]: _IM_ }], [4, { [_hH]: _IMS_ }], [0, { [_hH]: _INM_ }], [4, { [_hH]: _IUS_ }], [0, { [_hH]: _Ra }], [0, { [_hQ]: _rcc }], [0, { [_hQ]: _rcd }], [0, { [_hQ]: _rce }], [0, { [_hQ]: _rcl }], [0, { [_hQ]: _rct }], [6, { [_hQ]: _re }], [0, { [_hQ]: _vI }], [0, { [_hH]: _xasseca }], [() => SSECustomerKey, { [_hH]: _xasseck }], [0, { [_hH]: _xasseckM }], [0, { [_hH]: _xarp }], [1, { [_hQ]: _pN }], [0, { [_hH]: _xaebo }], [0, { [_hH]: _xacm }]],
      2
    ];
    var GetObjectRetentionOutput$ = [
      3,
      n04,
      _GORO,
      0,
      [_Ret],
      [[() => ObjectLockRetention$, { [_hP]: 1, [_xN]: _Ret }]]
    ];
    var GetObjectRetentionRequest$ = [
      3,
      n04,
      _GORR,
      0,
      [_B, _K2, _VI, _RP, _EBO],
      [[0, 1], [0, 1], [0, { [_hQ]: _vI }], [0, { [_hH]: _xarp }], [0, { [_hH]: _xaebo }]],
      2
    ];
    var GetObjectTaggingOutput$ = [
      3,
      n04,
      _GOTO,
      { [_xN]: _Tag },
      [_TS, _VI],
      [[() => TagSet, 0], [0, { [_hH]: _xavi }]],
      1
    ];
    var GetObjectTaggingRequest$ = [
      3,
      n04,
      _GOTR,
      0,
      [_B, _K2, _VI, _EBO, _RP],
      [[0, 1], [0, 1], [0, { [_hQ]: _vI }], [0, { [_hH]: _xaebo }], [0, { [_hH]: _xarp }]],
      2
    ];
    var GetObjectTorrentOutput$ = [
      3,
      n04,
      _GOTOe,
      0,
      [_Bo, _RC],
      [[() => StreamingBlob, 16], [0, { [_hH]: _xarc }]]
    ];
    var GetObjectTorrentRequest$ = [
      3,
      n04,
      _GOTRe,
      0,
      [_B, _K2, _RP, _EBO],
      [[0, 1], [0, 1], [0, { [_hH]: _xarp }], [0, { [_hH]: _xaebo }]],
      2
    ];
    var GetPublicAccessBlockOutput$ = [
      3,
      n04,
      _GPABO,
      0,
      [_PABC],
      [[() => PublicAccessBlockConfiguration$, 16]]
    ];
    var GetPublicAccessBlockRequest$ = [
      3,
      n04,
      _GPABR,
      0,
      [_B, _EBO],
      [[0, 1], [0, { [_hH]: _xaebo }]],
      1
    ];
    var GlacierJobParameters$ = [
      3,
      n04,
      _GJP,
      0,
      [_Ti],
      [0],
      1
    ];
    var Grant$ = [
      3,
      n04,
      _Gr,
      0,
      [_Gra, _Pe],
      [[() => Grantee$, { [_xNm]: [_x, _hi] }], 0]
    ];
    var Grantee$ = [
      3,
      n04,
      _Gra,
      0,
      [_Ty, _DN, _EA, _ID, _URI],
      [[0, { [_xA]: 1, [_xN]: _xs }], 0, 0, 0, 0],
      1
    ];
    var HeadBucketOutput$ = [
      3,
      n04,
      _HBO,
      0,
      [_BA, _BLT, _BLN, _BR, _APA],
      [[0, { [_hH]: _xaba }], [0, { [_hH]: _xablt }], [0, { [_hH]: _xabln }], [0, { [_hH]: _xabr }], [2, { [_hH]: _xaapa }]]
    ];
    var HeadBucketRequest$ = [
      3,
      n04,
      _HBR,
      0,
      [_B, _EBO],
      [[0, 1], [0, { [_hH]: _xaebo }]],
      1
    ];
    var HeadObjectOutput$ = [
      3,
      n04,
      _HOO,
      0,
      [_DM, _AR2, _E2, _Re, _ASr, _LM, _CLo, _CCRC, _CCRCC, _CCRCNVME, _CSHA, _CSHAh, _CT2, _ETa, _MM, _VI, _CC, _CDo, _CEo, _CL, _CTo, _CR, _Ex, _ES, _WRL, _SSE, _M, _SSECA, _SSECKMD, _SSEKMSKI, _BKE, _SC, _RC, _RS, _PC2, _TC2, _OLM, _OLRUD, _OLLHS],
      [[2, { [_hH]: _xadm }], [0, { [_hH]: _ar }], [0, { [_hH]: _xae }], [0, { [_hH]: _xar }], [0, { [_hH]: _xaas }], [4, { [_hH]: _LM_ }], [1, { [_hH]: _CL__ }], [0, { [_hH]: _xacc }], [0, { [_hH]: _xacc_ }], [0, { [_hH]: _xacc__ }], [0, { [_hH]: _xacs }], [0, { [_hH]: _xacs_ }], [0, { [_hH]: _xact }], [0, { [_hH]: _ETa }], [1, { [_hH]: _xamm }], [0, { [_hH]: _xavi }], [0, { [_hH]: _CC_ }], [0, { [_hH]: _CD_ }], [0, { [_hH]: _CE_ }], [0, { [_hH]: _CL_ }], [0, { [_hH]: _CT_ }], [0, { [_hH]: _CR_ }], [4, { [_hH]: _Ex }], [0, { [_hH]: _ES }], [0, { [_hH]: _xawrl }], [0, { [_hH]: _xasse }], [128 | 0, { [_hPH]: _xam }], [0, { [_hH]: _xasseca }], [0, { [_hH]: _xasseckM }], [() => SSEKMSKeyId, { [_hH]: _xasseakki }], [2, { [_hH]: _xassebke }], [0, { [_hH]: _xasc }], [0, { [_hH]: _xarc }], [0, { [_hH]: _xars }], [1, { [_hH]: _xampc }], [1, { [_hH]: _xatc }], [0, { [_hH]: _xaolm }], [5, { [_hH]: _xaolrud }], [0, { [_hH]: _xaollh }]]
    ];
    var HeadObjectRequest$ = [
      3,
      n04,
      _HOR,
      0,
      [_B, _K2, _IM, _IMSf, _INM, _IUS, _Ra, _RCC, _RCD, _RCE, _RCL, _RCT, _RE, _VI, _SSECA, _SSECK, _SSECKMD, _RP, _PN, _EBO, _CMh],
      [[0, 1], [0, 1], [0, { [_hH]: _IM_ }], [4, { [_hH]: _IMS_ }], [0, { [_hH]: _INM_ }], [4, { [_hH]: _IUS_ }], [0, { [_hH]: _Ra }], [0, { [_hQ]: _rcc }], [0, { [_hQ]: _rcd }], [0, { [_hQ]: _rce }], [0, { [_hQ]: _rcl }], [0, { [_hQ]: _rct }], [6, { [_hQ]: _re }], [0, { [_hQ]: _vI }], [0, { [_hH]: _xasseca }], [() => SSECustomerKey, { [_hH]: _xasseck }], [0, { [_hH]: _xasseckM }], [0, { [_hH]: _xarp }], [1, { [_hQ]: _pN }], [0, { [_hH]: _xaebo }], [0, { [_hH]: _xacm }]],
      2
    ];
    var IdempotencyParameterMismatch$ = [
      -3,
      n04,
      _IPM,
      { [_e4]: _c4, [_hE4]: 400 },
      [],
      []
    ];
    schema.TypeRegistry.for(n04).registerError(IdempotencyParameterMismatch$, IdempotencyParameterMismatch);
    var IndexDocument$ = [
      3,
      n04,
      _IDn,
      0,
      [_Su],
      [0],
      1
    ];
    var Initiator$ = [
      3,
      n04,
      _In,
      0,
      [_ID, _DN],
      [0, 0]
    ];
    var InputSerialization$ = [
      3,
      n04,
      _IS,
      0,
      [_CSV, _CTom, _JSON, _Parq],
      [() => CSVInput$, 0, () => JSONInput$, () => ParquetInput$]
    ];
    var IntelligentTieringAndOperator$ = [
      3,
      n04,
      _ITAO,
      0,
      [_P2, _T2],
      [0, [() => TagSet, { [_xF]: 1, [_xN]: _Ta2 }]]
    ];
    var IntelligentTieringConfiguration$ = [
      3,
      n04,
      _ITC,
      0,
      [_I, _S, _Tie, _F],
      [0, 0, [() => TieringList, { [_xF]: 1, [_xN]: _Tier }], [() => IntelligentTieringFilter$, 0]],
      3
    ];
    var IntelligentTieringFilter$ = [
      3,
      n04,
      _ITF,
      0,
      [_P2, _Ta2, _An],
      [0, () => Tag$2, [() => IntelligentTieringAndOperator$, 0]]
    ];
    var InvalidObjectState$ = [
      -3,
      n04,
      _IOS,
      { [_e4]: _c4, [_hE4]: 403 },
      [_SC, _AT3],
      [0, 0]
    ];
    schema.TypeRegistry.for(n04).registerError(InvalidObjectState$, InvalidObjectState);
    var InvalidRequest$ = [
      -3,
      n04,
      _IR,
      { [_e4]: _c4, [_hE4]: 400 },
      [],
      []
    ];
    schema.TypeRegistry.for(n04).registerError(InvalidRequest$, InvalidRequest);
    var InvalidWriteOffset$ = [
      -3,
      n04,
      _IWO,
      { [_e4]: _c4, [_hE4]: 400 },
      [],
      []
    ];
    schema.TypeRegistry.for(n04).registerError(InvalidWriteOffset$, InvalidWriteOffset);
    var InventoryConfiguration$ = [
      3,
      n04,
      _IC,
      0,
      [_Des, _IE, _I, _IOV, _Sc, _F, _OF],
      [[() => InventoryDestination$, 0], 2, 0, 0, () => InventorySchedule$, () => InventoryFilter$, [() => InventoryOptionalFields, 0]],
      5
    ];
    var InventoryDestination$ = [
      3,
      n04,
      _IDnv,
      0,
      [_SBD],
      [[() => InventoryS3BucketDestination$, 0]],
      1
    ];
    var InventoryEncryption$ = [
      3,
      n04,
      _IEn,
      0,
      [_SSES, _SSEKMS],
      [[() => SSES3$, { [_xN]: _SS }], [() => SSEKMS$, { [_xN]: _SK }]]
    ];
    var InventoryFilter$ = [
      3,
      n04,
      _IF,
      0,
      [_P2],
      [0],
      1
    ];
    var InventoryS3BucketDestination$ = [
      3,
      n04,
      _ISBD,
      0,
      [_B, _Fo, _AI, _P2, _En],
      [0, 0, 0, 0, [() => InventoryEncryption$, 0]],
      2
    ];
    var InventorySchedule$ = [
      3,
      n04,
      _ISn,
      0,
      [_Fr],
      [0],
      1
    ];
    var InventoryTableConfiguration$ = [
      3,
      n04,
      _ITCn,
      0,
      [_CSo, _EC],
      [0, () => MetadataTableEncryptionConfiguration$],
      1
    ];
    var InventoryTableConfigurationResult$ = [
      3,
      n04,
      _ITCR,
      0,
      [_CSo, _TSa, _Err, _TNa, _TA],
      [0, 0, () => ErrorDetails$, 0, 0],
      1
    ];
    var InventoryTableConfigurationUpdates$ = [
      3,
      n04,
      _ITCU,
      0,
      [_CSo, _EC],
      [0, () => MetadataTableEncryptionConfiguration$],
      1
    ];
    var JournalTableConfiguration$ = [
      3,
      n04,
      _JTC,
      0,
      [_REe, _EC],
      [() => RecordExpiration$, () => MetadataTableEncryptionConfiguration$],
      1
    ];
    var JournalTableConfigurationResult$ = [
      3,
      n04,
      _JTCR,
      0,
      [_TSa, _TNa, _REe, _Err, _TA],
      [0, 0, () => RecordExpiration$, () => ErrorDetails$, 0],
      3
    ];
    var JournalTableConfigurationUpdates$ = [
      3,
      n04,
      _JTCU,
      0,
      [_REe],
      [() => RecordExpiration$],
      1
    ];
    var JSONInput$ = [
      3,
      n04,
      _JSONI,
      0,
      [_Ty],
      [0]
    ];
    var JSONOutput$ = [
      3,
      n04,
      _JSONO,
      0,
      [_RD],
      [0]
    ];
    var LambdaFunctionConfiguration$ = [
      3,
      n04,
      _LFC,
      0,
      [_LFA, _Ev, _I, _F],
      [[0, { [_xN]: _CF }], [64 | 0, { [_xF]: 1, [_xN]: _Eve }], 0, [() => NotificationConfigurationFilter$, 0]],
      2
    ];
    var LifecycleExpiration$ = [
      3,
      n04,
      _LEi,
      0,
      [_Da, _D, _EODM],
      [5, 1, 2]
    ];
    var LifecycleRule$ = [
      3,
      n04,
      _LR,
      0,
      [_S, _E2, _ID, _P2, _F, _Tr, _NVT, _NVE, _AIMU],
      [0, () => LifecycleExpiration$, 0, 0, [() => LifecycleRuleFilter$, 0], [() => TransitionList, { [_xF]: 1, [_xN]: _Tra }], [() => NoncurrentVersionTransitionList, { [_xF]: 1, [_xN]: _NVTo }], () => NoncurrentVersionExpiration$, () => AbortIncompleteMultipartUpload$],
      1
    ];
    var LifecycleRuleAndOperator$ = [
      3,
      n04,
      _LRAO,
      0,
      [_P2, _T2, _OSGT, _OSLT],
      [0, [() => TagSet, { [_xF]: 1, [_xN]: _Ta2 }], 1, 1]
    ];
    var LifecycleRuleFilter$ = [
      3,
      n04,
      _LRF,
      0,
      [_P2, _Ta2, _OSGT, _OSLT, _An],
      [0, () => Tag$2, 1, 1, [() => LifecycleRuleAndOperator$, 0]]
    ];
    var ListBucketAnalyticsConfigurationsOutput$ = [
      3,
      n04,
      _LBACO,
      { [_xN]: _LBACR },
      [_IT2, _CTon, _NCT, _ACLn],
      [2, 0, 0, [() => AnalyticsConfigurationList, { [_xF]: 1, [_xN]: _ACn }]]
    ];
    var ListBucketAnalyticsConfigurationsRequest$ = [
      3,
      n04,
      _LBACRi,
      0,
      [_B, _CTon, _EBO],
      [[0, 1], [0, { [_hQ]: _ct }], [0, { [_hH]: _xaebo }]],
      1
    ];
    var ListBucketIntelligentTieringConfigurationsOutput$ = [
      3,
      n04,
      _LBITCO,
      0,
      [_IT2, _CTon, _NCT, _ITCL],
      [2, 0, 0, [() => IntelligentTieringConfigurationList, { [_xF]: 1, [_xN]: _ITC }]]
    ];
    var ListBucketIntelligentTieringConfigurationsRequest$ = [
      3,
      n04,
      _LBITCR,
      0,
      [_B, _CTon, _EBO],
      [[0, 1], [0, { [_hQ]: _ct }], [0, { [_hH]: _xaebo }]],
      1
    ];
    var ListBucketInventoryConfigurationsOutput$ = [
      3,
      n04,
      _LBICO,
      { [_xN]: _LICR },
      [_CTon, _ICL, _IT2, _NCT],
      [0, [() => InventoryConfigurationList, { [_xF]: 1, [_xN]: _IC }], 2, 0]
    ];
    var ListBucketInventoryConfigurationsRequest$ = [
      3,
      n04,
      _LBICR,
      0,
      [_B, _CTon, _EBO],
      [[0, 1], [0, { [_hQ]: _ct }], [0, { [_hH]: _xaebo }]],
      1
    ];
    var ListBucketMetricsConfigurationsOutput$ = [
      3,
      n04,
      _LBMCO,
      { [_xN]: _LMCR },
      [_IT2, _CTon, _NCT, _MCL],
      [2, 0, 0, [() => MetricsConfigurationList, { [_xF]: 1, [_xN]: _MCe }]]
    ];
    var ListBucketMetricsConfigurationsRequest$ = [
      3,
      n04,
      _LBMCR,
      0,
      [_B, _CTon, _EBO],
      [[0, 1], [0, { [_hQ]: _ct }], [0, { [_hH]: _xaebo }]],
      1
    ];
    var ListBucketsOutput$ = [
      3,
      n04,
      _LBO,
      { [_xN]: _LAMBR },
      [_Bu, _O, _CTon, _P2],
      [[() => Buckets, 0], () => Owner$, 0, 0]
    ];
    var ListBucketsRequest$ = [
      3,
      n04,
      _LBR,
      0,
      [_MB, _CTon, _P2, _BR],
      [[1, { [_hQ]: _mb }], [0, { [_hQ]: _ct }], [0, { [_hQ]: _p }], [0, { [_hQ]: _br }]]
    ];
    var ListDirectoryBucketsOutput$ = [
      3,
      n04,
      _LDBO,
      { [_xN]: _LAMDBR },
      [_Bu, _CTon],
      [[() => Buckets, 0], 0]
    ];
    var ListDirectoryBucketsRequest$ = [
      3,
      n04,
      _LDBR,
      0,
      [_CTon, _MDB],
      [[0, { [_hQ]: _ct }], [1, { [_hQ]: _mdb }]]
    ];
    var ListMultipartUploadsOutput$ = [
      3,
      n04,
      _LMUO,
      { [_xN]: _LMUR },
      [_B, _KM, _UIM, _NKM, _P2, _Deli, _NUIM, _MUa, _IT2, _U, _CPom, _ETn, _RC],
      [0, 0, 0, 0, 0, 0, 0, 1, 2, [() => MultipartUploadList, { [_xF]: 1, [_xN]: _Up }], [() => CommonPrefixList, { [_xF]: 1 }], 0, [0, { [_hH]: _xarc }]]
    ];
    var ListMultipartUploadsRequest$ = [
      3,
      n04,
      _LMURi,
      0,
      [_B, _Deli, _ETn, _KM, _MUa, _P2, _UIM, _EBO, _RP],
      [[0, 1], [0, { [_hQ]: _d }], [0, { [_hQ]: _et }], [0, { [_hQ]: _km }], [1, { [_hQ]: _mu }], [0, { [_hQ]: _p }], [0, { [_hQ]: _uim }], [0, { [_hH]: _xaebo }], [0, { [_hH]: _xarp }]],
      1
    ];
    var ListObjectsOutput$ = [
      3,
      n04,
      _LOO,
      { [_xN]: _LBRi },
      [_IT2, _Ma, _NM, _Con, _N, _P2, _Deli, _MK, _CPom, _ETn, _RC],
      [2, 0, 0, [() => ObjectList, { [_xF]: 1 }], 0, 0, 0, 1, [() => CommonPrefixList, { [_xF]: 1 }], 0, [0, { [_hH]: _xarc }]]
    ];
    var ListObjectsRequest$ = [
      3,
      n04,
      _LOR,
      0,
      [_B, _Deli, _ETn, _Ma, _MK, _P2, _RP, _EBO, _OOA],
      [[0, 1], [0, { [_hQ]: _d }], [0, { [_hQ]: _et }], [0, { [_hQ]: _m3 }], [1, { [_hQ]: _mk }], [0, { [_hQ]: _p }], [0, { [_hH]: _xarp }], [0, { [_hH]: _xaebo }], [64 | 0, { [_hH]: _xaooa }]],
      1
    ];
    var ListObjectsV2Output$ = [
      3,
      n04,
      _LOVO,
      { [_xN]: _LBRi },
      [_IT2, _Con, _N, _P2, _Deli, _MK, _CPom, _ETn, _KC, _CTon, _NCT, _SA, _RC],
      [2, [() => ObjectList, { [_xF]: 1 }], 0, 0, 0, 1, [() => CommonPrefixList, { [_xF]: 1 }], 0, 1, 0, 0, 0, [0, { [_hH]: _xarc }]]
    ];
    var ListObjectsV2Request$ = [
      3,
      n04,
      _LOVR,
      0,
      [_B, _Deli, _ETn, _MK, _P2, _CTon, _FO, _SA, _RP, _EBO, _OOA],
      [[0, 1], [0, { [_hQ]: _d }], [0, { [_hQ]: _et }], [1, { [_hQ]: _mk }], [0, { [_hQ]: _p }], [0, { [_hQ]: _ct }], [2, { [_hQ]: _fo }], [0, { [_hQ]: _sa }], [0, { [_hH]: _xarp }], [0, { [_hH]: _xaebo }], [64 | 0, { [_hH]: _xaooa }]],
      1
    ];
    var ListObjectVersionsOutput$ = [
      3,
      n04,
      _LOVOi,
      { [_xN]: _LVR },
      [_IT2, _KM, _VIM, _NKM, _NVIM, _Ve, _DMe, _N, _P2, _Deli, _MK, _CPom, _ETn, _RC],
      [2, 0, 0, 0, 0, [() => ObjectVersionList, { [_xF]: 1, [_xN]: _Ver }], [() => DeleteMarkers, { [_xF]: 1, [_xN]: _DM }], 0, 0, 0, 1, [() => CommonPrefixList, { [_xF]: 1 }], 0, [0, { [_hH]: _xarc }]]
    ];
    var ListObjectVersionsRequest$ = [
      3,
      n04,
      _LOVRi,
      0,
      [_B, _Deli, _ETn, _KM, _MK, _P2, _VIM, _EBO, _RP, _OOA],
      [[0, 1], [0, { [_hQ]: _d }], [0, { [_hQ]: _et }], [0, { [_hQ]: _km }], [1, { [_hQ]: _mk }], [0, { [_hQ]: _p }], [0, { [_hQ]: _vim }], [0, { [_hH]: _xaebo }], [0, { [_hH]: _xarp }], [64 | 0, { [_hH]: _xaooa }]],
      1
    ];
    var ListPartsOutput$ = [
      3,
      n04,
      _LPO,
      { [_xN]: _LPR },
      [_AD, _ARI2, _B, _K2, _UI, _PNM, _NPNM, _MP, _IT2, _Pa, _In, _O, _SC, _RC, _CA2, _CT2],
      [[4, { [_hH]: _xaad }], [0, { [_hH]: _xaari }], 0, 0, 0, 0, 0, 1, 2, [() => Parts, { [_xF]: 1, [_xN]: _Par }], () => Initiator$, () => Owner$, 0, [0, { [_hH]: _xarc }], 0, 0]
    ];
    var ListPartsRequest$ = [
      3,
      n04,
      _LPRi,
      0,
      [_B, _K2, _UI, _MP, _PNM, _RP, _EBO, _SSECA, _SSECK, _SSECKMD],
      [[0, 1], [0, 1], [0, { [_hQ]: _uI }], [1, { [_hQ]: _mp }], [0, { [_hQ]: _pnm }], [0, { [_hH]: _xarp }], [0, { [_hH]: _xaebo }], [0, { [_hH]: _xasseca }], [() => SSECustomerKey, { [_hH]: _xasseck }], [0, { [_hH]: _xasseckM }]],
      3
    ];
    var LocationInfo$ = [
      3,
      n04,
      _LI,
      0,
      [_Ty, _N],
      [0, 0]
    ];
    var LoggingEnabled$ = [
      3,
      n04,
      _LE,
      0,
      [_TB, _TP, _TG, _TOKF],
      [0, 0, [() => TargetGrants, 0], [() => TargetObjectKeyFormat$, 0]],
      2
    ];
    var MetadataConfiguration$ = [
      3,
      n04,
      _MC,
      0,
      [_JTC, _ITCn],
      [() => JournalTableConfiguration$, () => InventoryTableConfiguration$],
      1
    ];
    var MetadataConfigurationResult$ = [
      3,
      n04,
      _MCR,
      0,
      [_DRes, _JTCR, _ITCR],
      [() => DestinationResult$, () => JournalTableConfigurationResult$, () => InventoryTableConfigurationResult$],
      1
    ];
    var MetadataEntry$ = [
      3,
      n04,
      _ME,
      0,
      [_N, _V2],
      [0, 0]
    ];
    var MetadataTableConfiguration$ = [
      3,
      n04,
      _MTC,
      0,
      [_STD],
      [() => S3TablesDestination$],
      1
    ];
    var MetadataTableConfigurationResult$ = [
      3,
      n04,
      _MTCR,
      0,
      [_STDR],
      [() => S3TablesDestinationResult$],
      1
    ];
    var MetadataTableEncryptionConfiguration$ = [
      3,
      n04,
      _MTEC,
      0,
      [_SAs, _KKA],
      [0, 0],
      1
    ];
    var Metrics$ = [
      3,
      n04,
      _Me,
      0,
      [_S, _ETv],
      [0, () => ReplicationTimeValue$],
      1
    ];
    var MetricsAndOperator$ = [
      3,
      n04,
      _MAO,
      0,
      [_P2, _T2, _APAc],
      [0, [() => TagSet, { [_xF]: 1, [_xN]: _Ta2 }], 0]
    ];
    var MetricsConfiguration$ = [
      3,
      n04,
      _MCe,
      0,
      [_I, _F],
      [0, [() => MetricsFilter$, 0]],
      1
    ];
    var MultipartUpload$ = [
      3,
      n04,
      _MU,
      0,
      [_UI, _K2, _Ini, _SC, _O, _In, _CA2, _CT2],
      [0, 0, 4, 0, () => Owner$, () => Initiator$, 0, 0]
    ];
    var NoncurrentVersionExpiration$ = [
      3,
      n04,
      _NVE,
      0,
      [_ND, _NNV],
      [1, 1]
    ];
    var NoncurrentVersionTransition$ = [
      3,
      n04,
      _NVTo,
      0,
      [_ND, _SC, _NNV],
      [1, 0, 1]
    ];
    var NoSuchBucket$ = [
      -3,
      n04,
      _NSB,
      { [_e4]: _c4, [_hE4]: 404 },
      [],
      []
    ];
    schema.TypeRegistry.for(n04).registerError(NoSuchBucket$, NoSuchBucket2);
    var NoSuchKey$ = [
      -3,
      n04,
      _NSK,
      { [_e4]: _c4, [_hE4]: 404 },
      [],
      []
    ];
    schema.TypeRegistry.for(n04).registerError(NoSuchKey$, NoSuchKey2);
    var NoSuchUpload$ = [
      -3,
      n04,
      _NSU,
      { [_e4]: _c4, [_hE4]: 404 },
      [],
      []
    ];
    schema.TypeRegistry.for(n04).registerError(NoSuchUpload$, NoSuchUpload);
    var NotFound$ = [
      -3,
      n04,
      _NF,
      { [_e4]: _c4 },
      [],
      []
    ];
    schema.TypeRegistry.for(n04).registerError(NotFound$, NotFound);
    var NotificationConfiguration$ = [
      3,
      n04,
      _NC,
      0,
      [_TCo, _QCu, _LFCa, _EBC],
      [[() => TopicConfigurationList, { [_xF]: 1, [_xN]: _TCop }], [() => QueueConfigurationList, { [_xF]: 1, [_xN]: _QCue }], [() => LambdaFunctionConfigurationList, { [_xF]: 1, [_xN]: _CFC }], () => EventBridgeConfiguration$]
    ];
    var NotificationConfigurationFilter$ = [
      3,
      n04,
      _NCF,
      0,
      [_K2],
      [[() => S3KeyFilter$, { [_xN]: _SKe }]]
    ];
    var _Object$ = [
      3,
      n04,
      _Obj,
      0,
      [_K2, _LM, _ETa, _CA2, _CT2, _Si, _SC, _O, _RSe],
      [0, 4, 0, [64 | 0, { [_xF]: 1 }], 0, 1, 0, () => Owner$, () => RestoreStatus$]
    ];
    var ObjectAlreadyInActiveTierError$ = [
      -3,
      n04,
      _OAIATE,
      { [_e4]: _c4, [_hE4]: 403 },
      [],
      []
    ];
    schema.TypeRegistry.for(n04).registerError(ObjectAlreadyInActiveTierError$, ObjectAlreadyInActiveTierError);
    var ObjectIdentifier$ = [
      3,
      n04,
      _OI,
      0,
      [_K2, _VI, _ETa, _LMT, _Si],
      [0, 0, 0, 6, 1],
      1
    ];
    var ObjectLockConfiguration$ = [
      3,
      n04,
      _OLC,
      0,
      [_OLE, _Ru],
      [0, () => ObjectLockRule$]
    ];
    var ObjectLockLegalHold$ = [
      3,
      n04,
      _OLLH,
      0,
      [_S],
      [0]
    ];
    var ObjectLockRetention$ = [
      3,
      n04,
      _OLR,
      0,
      [_Mo, _RUD],
      [0, 5]
    ];
    var ObjectLockRule$ = [
      3,
      n04,
      _OLRb,
      0,
      [_DRe],
      [() => DefaultRetention$]
    ];
    var ObjectNotInActiveTierError$ = [
      -3,
      n04,
      _ONIATE,
      { [_e4]: _c4, [_hE4]: 403 },
      [],
      []
    ];
    schema.TypeRegistry.for(n04).registerError(ObjectNotInActiveTierError$, ObjectNotInActiveTierError);
    var ObjectPart$ = [
      3,
      n04,
      _OPb,
      0,
      [_PN, _Si, _CCRC, _CCRCC, _CCRCNVME, _CSHA, _CSHAh],
      [1, 1, 0, 0, 0, 0, 0]
    ];
    var ObjectVersion$ = [
      3,
      n04,
      _OV,
      0,
      [_ETa, _CA2, _CT2, _Si, _SC, _K2, _VI, _IL, _LM, _O, _RSe],
      [0, [64 | 0, { [_xF]: 1 }], 0, 1, 0, 0, 0, 2, 4, () => Owner$, () => RestoreStatus$]
    ];
    var OutputLocation$ = [
      3,
      n04,
      _OL,
      0,
      [_S_],
      [[() => S3Location$, 0]]
    ];
    var OutputSerialization$ = [
      3,
      n04,
      _OSu,
      0,
      [_CSV, _JSON],
      [() => CSVOutput$, () => JSONOutput$]
    ];
    var Owner$ = [
      3,
      n04,
      _O,
      0,
      [_DN, _ID],
      [0, 0]
    ];
    var OwnershipControls$ = [
      3,
      n04,
      _OC,
      0,
      [_R],
      [[() => OwnershipControlsRules, { [_xF]: 1, [_xN]: _Ru }]],
      1
    ];
    var OwnershipControlsRule$ = [
      3,
      n04,
      _OCR,
      0,
      [_OO],
      [0],
      1
    ];
    var ParquetInput$ = [
      3,
      n04,
      _PI2,
      0,
      [],
      []
    ];
    var Part$ = [
      3,
      n04,
      _Par,
      0,
      [_PN, _LM, _ETa, _Si, _CCRC, _CCRCC, _CCRCNVME, _CSHA, _CSHAh],
      [1, 4, 0, 1, 0, 0, 0, 0, 0]
    ];
    var PartitionedPrefix$ = [
      3,
      n04,
      _PP,
      { [_xN]: _PP },
      [_PDS],
      [0]
    ];
    var PolicyStatus$ = [
      3,
      n04,
      _PS,
      0,
      [_IP],
      [[2, { [_xN]: _IP }]]
    ];
    var Progress$ = [
      3,
      n04,
      _Pr2,
      0,
      [_BS, _BP, _BRy],
      [1, 1, 1]
    ];
    var ProgressEvent$ = [
      3,
      n04,
      _PE,
      0,
      [_Det],
      [[() => Progress$, { [_eP]: 1 }]]
    ];
    var PublicAccessBlockConfiguration$ = [
      3,
      n04,
      _PABC,
      0,
      [_BPA, _IPA, _BPP, _RPB],
      [[2, { [_xN]: _BPA }], [2, { [_xN]: _IPA }], [2, { [_xN]: _BPP }], [2, { [_xN]: _RPB }]]
    ];
    var PutBucketAbacRequest$ = [
      3,
      n04,
      _PBAR,
      0,
      [_B, _AS, _CMD, _CA2, _EBO],
      [[0, 1], [() => AbacStatus$, { [_hP]: 1, [_xN]: _AS }], [0, { [_hH]: _CM }], [0, { [_hH]: _xasca }], [0, { [_hH]: _xaebo }]],
      2
    ];
    var PutBucketAccelerateConfigurationRequest$ = [
      3,
      n04,
      _PBACR,
      0,
      [_B, _AC, _EBO, _CA2],
      [[0, 1], [() => AccelerateConfiguration$, { [_hP]: 1, [_xN]: _AC }], [0, { [_hH]: _xaebo }], [0, { [_hH]: _xasca }]],
      2
    ];
    var PutBucketAclRequest$ = [
      3,
      n04,
      _PBARu,
      0,
      [_B, _ACL_, _ACP, _CMD, _CA2, _GFC, _GR, _GRACP, _GW, _GWACP, _EBO],
      [[0, 1], [0, { [_hH]: _xaa }], [() => AccessControlPolicy$, { [_hP]: 1, [_xN]: _ACP }], [0, { [_hH]: _CM }], [0, { [_hH]: _xasca }], [0, { [_hH]: _xagfc }], [0, { [_hH]: _xagr }], [0, { [_hH]: _xagra }], [0, { [_hH]: _xagw }], [0, { [_hH]: _xagwa }], [0, { [_hH]: _xaebo }]],
      1
    ];
    var PutBucketAnalyticsConfigurationRequest$ = [
      3,
      n04,
      _PBACRu,
      0,
      [_B, _I, _ACn, _EBO],
      [[0, 1], [0, { [_hQ]: _i }], [() => AnalyticsConfiguration$, { [_hP]: 1, [_xN]: _ACn }], [0, { [_hH]: _xaebo }]],
      3
    ];
    var PutBucketCorsRequest$ = [
      3,
      n04,
      _PBCR,
      0,
      [_B, _CORSC, _CMD, _CA2, _EBO],
      [[0, 1], [() => CORSConfiguration$, { [_hP]: 1, [_xN]: _CORSC }], [0, { [_hH]: _CM }], [0, { [_hH]: _xasca }], [0, { [_hH]: _xaebo }]],
      2
    ];
    var PutBucketEncryptionRequest$ = [
      3,
      n04,
      _PBER,
      0,
      [_B, _SSEC, _CMD, _CA2, _EBO],
      [[0, 1], [() => ServerSideEncryptionConfiguration$, { [_hP]: 1, [_xN]: _SSEC }], [0, { [_hH]: _CM }], [0, { [_hH]: _xasca }], [0, { [_hH]: _xaebo }]],
      2
    ];
    var PutBucketIntelligentTieringConfigurationRequest$ = [
      3,
      n04,
      _PBITCR,
      0,
      [_B, _I, _ITC, _EBO],
      [[0, 1], [0, { [_hQ]: _i }], [() => IntelligentTieringConfiguration$, { [_hP]: 1, [_xN]: _ITC }], [0, { [_hH]: _xaebo }]],
      3
    ];
    var PutBucketInventoryConfigurationRequest$ = [
      3,
      n04,
      _PBICR,
      0,
      [_B, _I, _IC, _EBO],
      [[0, 1], [0, { [_hQ]: _i }], [() => InventoryConfiguration$, { [_hP]: 1, [_xN]: _IC }], [0, { [_hH]: _xaebo }]],
      3
    ];
    var PutBucketLifecycleConfigurationOutput$ = [
      3,
      n04,
      _PBLCO,
      0,
      [_TDMOS],
      [[0, { [_hH]: _xatdmos }]]
    ];
    var PutBucketLifecycleConfigurationRequest$ = [
      3,
      n04,
      _PBLCR,
      0,
      [_B, _CA2, _LCi, _EBO, _TDMOS],
      [[0, 1], [0, { [_hH]: _xasca }], [() => BucketLifecycleConfiguration$, { [_hP]: 1, [_xN]: _LCi }], [0, { [_hH]: _xaebo }], [0, { [_hH]: _xatdmos }]],
      1
    ];
    var PutBucketLoggingRequest$ = [
      3,
      n04,
      _PBLR,
      0,
      [_B, _BLS, _CMD, _CA2, _EBO],
      [[0, 1], [() => BucketLoggingStatus$, { [_hP]: 1, [_xN]: _BLS }], [0, { [_hH]: _CM }], [0, { [_hH]: _xasca }], [0, { [_hH]: _xaebo }]],
      2
    ];
    var PutBucketMetricsConfigurationRequest$ = [
      3,
      n04,
      _PBMCR,
      0,
      [_B, _I, _MCe, _EBO],
      [[0, 1], [0, { [_hQ]: _i }], [() => MetricsConfiguration$, { [_hP]: 1, [_xN]: _MCe }], [0, { [_hH]: _xaebo }]],
      3
    ];
    var PutBucketNotificationConfigurationRequest$ = [
      3,
      n04,
      _PBNCR,
      0,
      [_B, _NC, _EBO, _SDV],
      [[0, 1], [() => NotificationConfiguration$, { [_hP]: 1, [_xN]: _NC }], [0, { [_hH]: _xaebo }], [2, { [_hH]: _xasdv }]],
      2
    ];
    var PutBucketOwnershipControlsRequest$ = [
      3,
      n04,
      _PBOCR,
      0,
      [_B, _OC, _CMD, _EBO, _CA2],
      [[0, 1], [() => OwnershipControls$, { [_hP]: 1, [_xN]: _OC }], [0, { [_hH]: _CM }], [0, { [_hH]: _xaebo }], [0, { [_hH]: _xasca }]],
      2
    ];
    var PutBucketPolicyRequest$ = [
      3,
      n04,
      _PBPR,
      0,
      [_B, _Po, _CMD, _CA2, _CRSBA, _EBO],
      [[0, 1], [0, 16], [0, { [_hH]: _CM }], [0, { [_hH]: _xasca }], [2, { [_hH]: _xacrsba }], [0, { [_hH]: _xaebo }]],
      2
    ];
    var PutBucketReplicationRequest$ = [
      3,
      n04,
      _PBRR,
      0,
      [_B, _RCe, _CMD, _CA2, _To, _EBO],
      [[0, 1], [() => ReplicationConfiguration$, { [_hP]: 1, [_xN]: _RCe }], [0, { [_hH]: _CM }], [0, { [_hH]: _xasca }], [0, { [_hH]: _xabolt }], [0, { [_hH]: _xaebo }]],
      2
    ];
    var PutBucketRequestPaymentRequest$ = [
      3,
      n04,
      _PBRPR,
      0,
      [_B, _RPC, _CMD, _CA2, _EBO],
      [[0, 1], [() => RequestPaymentConfiguration$, { [_hP]: 1, [_xN]: _RPC }], [0, { [_hH]: _CM }], [0, { [_hH]: _xasca }], [0, { [_hH]: _xaebo }]],
      2
    ];
    var PutBucketTaggingRequest$ = [
      3,
      n04,
      _PBTR,
      0,
      [_B, _Tag, _CMD, _CA2, _EBO],
      [[0, 1], [() => Tagging$, { [_hP]: 1, [_xN]: _Tag }], [0, { [_hH]: _CM }], [0, { [_hH]: _xasca }], [0, { [_hH]: _xaebo }]],
      2
    ];
    var PutBucketVersioningRequest$ = [
      3,
      n04,
      _PBVR,
      0,
      [_B, _VC, _CMD, _CA2, _MFA, _EBO],
      [[0, 1], [() => VersioningConfiguration$, { [_hP]: 1, [_xN]: _VC }], [0, { [_hH]: _CM }], [0, { [_hH]: _xasca }], [0, { [_hH]: _xam_ }], [0, { [_hH]: _xaebo }]],
      2
    ];
    var PutBucketWebsiteRequest$ = [
      3,
      n04,
      _PBWR,
      0,
      [_B, _WC, _CMD, _CA2, _EBO],
      [[0, 1], [() => WebsiteConfiguration$, { [_hP]: 1, [_xN]: _WC }], [0, { [_hH]: _CM }], [0, { [_hH]: _xasca }], [0, { [_hH]: _xaebo }]],
      2
    ];
    var PutObjectAclOutput$ = [
      3,
      n04,
      _POAO,
      0,
      [_RC],
      [[0, { [_hH]: _xarc }]]
    ];
    var PutObjectAclRequest$ = [
      3,
      n04,
      _POAR,
      0,
      [_B, _K2, _ACL_, _ACP, _CMD, _CA2, _GFC, _GR, _GRACP, _GW, _GWACP, _RP, _VI, _EBO],
      [[0, 1], [0, 1], [0, { [_hH]: _xaa }], [() => AccessControlPolicy$, { [_hP]: 1, [_xN]: _ACP }], [0, { [_hH]: _CM }], [0, { [_hH]: _xasca }], [0, { [_hH]: _xagfc }], [0, { [_hH]: _xagr }], [0, { [_hH]: _xagra }], [0, { [_hH]: _xagw }], [0, { [_hH]: _xagwa }], [0, { [_hH]: _xarp }], [0, { [_hQ]: _vI }], [0, { [_hH]: _xaebo }]],
      2
    ];
    var PutObjectLegalHoldOutput$ = [
      3,
      n04,
      _POLHO,
      0,
      [_RC],
      [[0, { [_hH]: _xarc }]]
    ];
    var PutObjectLegalHoldRequest$ = [
      3,
      n04,
      _POLHR,
      0,
      [_B, _K2, _LH, _RP, _VI, _CMD, _CA2, _EBO],
      [[0, 1], [0, 1], [() => ObjectLockLegalHold$, { [_hP]: 1, [_xN]: _LH }], [0, { [_hH]: _xarp }], [0, { [_hQ]: _vI }], [0, { [_hH]: _CM }], [0, { [_hH]: _xasca }], [0, { [_hH]: _xaebo }]],
      2
    ];
    var PutObjectLockConfigurationOutput$ = [
      3,
      n04,
      _POLCO,
      0,
      [_RC],
      [[0, { [_hH]: _xarc }]]
    ];
    var PutObjectLockConfigurationRequest$ = [
      3,
      n04,
      _POLCR,
      0,
      [_B, _OLC, _RP, _To, _CMD, _CA2, _EBO],
      [[0, 1], [() => ObjectLockConfiguration$, { [_hP]: 1, [_xN]: _OLC }], [0, { [_hH]: _xarp }], [0, { [_hH]: _xabolt }], [0, { [_hH]: _CM }], [0, { [_hH]: _xasca }], [0, { [_hH]: _xaebo }]],
      1
    ];
    var PutObjectOutput$ = [
      3,
      n04,
      _POO,
      0,
      [_E2, _ETa, _CCRC, _CCRCC, _CCRCNVME, _CSHA, _CSHAh, _CT2, _SSE, _VI, _SSECA, _SSECKMD, _SSEKMSKI, _SSEKMSEC, _BKE, _Si, _RC],
      [[0, { [_hH]: _xae }], [0, { [_hH]: _ETa }], [0, { [_hH]: _xacc }], [0, { [_hH]: _xacc_ }], [0, { [_hH]: _xacc__ }], [0, { [_hH]: _xacs }], [0, { [_hH]: _xacs_ }], [0, { [_hH]: _xact }], [0, { [_hH]: _xasse }], [0, { [_hH]: _xavi }], [0, { [_hH]: _xasseca }], [0, { [_hH]: _xasseckM }], [() => SSEKMSKeyId, { [_hH]: _xasseakki }], [() => SSEKMSEncryptionContext, { [_hH]: _xassec }], [2, { [_hH]: _xassebke }], [1, { [_hH]: _xaos }], [0, { [_hH]: _xarc }]]
    ];
    var PutObjectRequest$ = [
      3,
      n04,
      _POR,
      0,
      [_B, _K2, _ACL_, _Bo, _CC, _CDo, _CEo, _CL, _CLo, _CMD, _CTo, _CA2, _CCRC, _CCRCC, _CCRCNVME, _CSHA, _CSHAh, _Ex, _IM, _INM, _GFC, _GR, _GRACP, _GWACP, _WOB, _M, _SSE, _SC, _WRL, _SSECA, _SSECK, _SSECKMD, _SSEKMSKI, _SSEKMSEC, _BKE, _RP, _Tag, _OLM, _OLRUD, _OLLHS, _EBO],
      [[0, 1], [0, 1], [0, { [_hH]: _xaa }], [() => StreamingBlob, 16], [0, { [_hH]: _CC_ }], [0, { [_hH]: _CD_ }], [0, { [_hH]: _CE_ }], [0, { [_hH]: _CL_ }], [1, { [_hH]: _CL__ }], [0, { [_hH]: _CM }], [0, { [_hH]: _CT_ }], [0, { [_hH]: _xasca }], [0, { [_hH]: _xacc }], [0, { [_hH]: _xacc_ }], [0, { [_hH]: _xacc__ }], [0, { [_hH]: _xacs }], [0, { [_hH]: _xacs_ }], [4, { [_hH]: _Ex }], [0, { [_hH]: _IM_ }], [0, { [_hH]: _INM_ }], [0, { [_hH]: _xagfc }], [0, { [_hH]: _xagr }], [0, { [_hH]: _xagra }], [0, { [_hH]: _xagwa }], [1, { [_hH]: _xawob }], [128 | 0, { [_hPH]: _xam }], [0, { [_hH]: _xasse }], [0, { [_hH]: _xasc }], [0, { [_hH]: _xawrl }], [0, { [_hH]: _xasseca }], [() => SSECustomerKey, { [_hH]: _xasseck }], [0, { [_hH]: _xasseckM }], [() => SSEKMSKeyId, { [_hH]: _xasseakki }], [() => SSEKMSEncryptionContext, { [_hH]: _xassec }], [2, { [_hH]: _xassebke }], [0, { [_hH]: _xarp }], [0, { [_hH]: _xat }], [0, { [_hH]: _xaolm }], [5, { [_hH]: _xaolrud }], [0, { [_hH]: _xaollh }], [0, { [_hH]: _xaebo }]],
      2
    ];
    var PutObjectRetentionOutput$ = [
      3,
      n04,
      _PORO,
      0,
      [_RC],
      [[0, { [_hH]: _xarc }]]
    ];
    var PutObjectRetentionRequest$ = [
      3,
      n04,
      _PORR,
      0,
      [_B, _K2, _Ret, _RP, _VI, _BGR, _CMD, _CA2, _EBO],
      [[0, 1], [0, 1], [() => ObjectLockRetention$, { [_hP]: 1, [_xN]: _Ret }], [0, { [_hH]: _xarp }], [0, { [_hQ]: _vI }], [2, { [_hH]: _xabgr }], [0, { [_hH]: _CM }], [0, { [_hH]: _xasca }], [0, { [_hH]: _xaebo }]],
      2
    ];
    var PutObjectTaggingOutput$ = [
      3,
      n04,
      _POTO,
      0,
      [_VI],
      [[0, { [_hH]: _xavi }]]
    ];
    var PutObjectTaggingRequest$ = [
      3,
      n04,
      _POTR,
      0,
      [_B, _K2, _Tag, _VI, _CMD, _CA2, _EBO, _RP],
      [[0, 1], [0, 1], [() => Tagging$, { [_hP]: 1, [_xN]: _Tag }], [0, { [_hQ]: _vI }], [0, { [_hH]: _CM }], [0, { [_hH]: _xasca }], [0, { [_hH]: _xaebo }], [0, { [_hH]: _xarp }]],
      3
    ];
    var PutPublicAccessBlockRequest$ = [
      3,
      n04,
      _PPABR,
      0,
      [_B, _PABC, _CMD, _CA2, _EBO],
      [[0, 1], [() => PublicAccessBlockConfiguration$, { [_hP]: 1, [_xN]: _PABC }], [0, { [_hH]: _CM }], [0, { [_hH]: _xasca }], [0, { [_hH]: _xaebo }]],
      2
    ];
    var QueueConfiguration$ = [
      3,
      n04,
      _QCue,
      0,
      [_QA, _Ev, _I, _F],
      [[0, { [_xN]: _Qu }], [64 | 0, { [_xF]: 1, [_xN]: _Eve }], 0, [() => NotificationConfigurationFilter$, 0]],
      2
    ];
    var RecordExpiration$ = [
      3,
      n04,
      _REe,
      0,
      [_E2, _D],
      [0, 1],
      1
    ];
    var RecordsEvent$ = [
      3,
      n04,
      _REec,
      0,
      [_Payl],
      [[21, { [_eP]: 1 }]]
    ];
    var Redirect$ = [
      3,
      n04,
      _Red,
      0,
      [_HN, _HRC, _Pro, _RKPW, _RKW],
      [0, 0, 0, 0, 0]
    ];
    var RedirectAllRequestsTo$ = [
      3,
      n04,
      _RART,
      0,
      [_HN, _Pro],
      [0, 0],
      1
    ];
    var RenameObjectOutput$ = [
      3,
      n04,
      _ROO,
      0,
      [],
      []
    ];
    var RenameObjectRequest$ = [
      3,
      n04,
      _ROR,
      0,
      [_B, _K2, _RSen, _DIM, _DINM, _DIMS, _DIUS, _SIM, _SINM, _SIMS, _SIUS, _CTl],
      [[0, 1], [0, 1], [0, { [_hH]: _xars_ }], [0, { [_hH]: _IM_ }], [0, { [_hH]: _INM_ }], [4, { [_hH]: _IMS_ }], [4, { [_hH]: _IUS_ }], [0, { [_hH]: _xarsim }], [0, { [_hH]: _xarsinm }], [6, { [_hH]: _xarsims }], [6, { [_hH]: _xarsius }], [0, { [_hH]: _xact_, [_iT3]: 1 }]],
      3
    ];
    var ReplicaModifications$ = [
      3,
      n04,
      _RM,
      0,
      [_S],
      [0],
      1
    ];
    var ReplicationConfiguration$ = [
      3,
      n04,
      _RCe,
      0,
      [_Ro, _R],
      [0, [() => ReplicationRules, { [_xF]: 1, [_xN]: _Ru }]],
      2
    ];
    var ReplicationRule$ = [
      3,
      n04,
      _RRe,
      0,
      [_S, _Des, _ID, _Pri, _P2, _F, _SSC, _EOR, _DMR],
      [0, () => Destination$, 0, 1, 0, [() => ReplicationRuleFilter$, 0], () => SourceSelectionCriteria$, () => ExistingObjectReplication$, () => DeleteMarkerReplication$],
      2
    ];
    var ReplicationRuleAndOperator$ = [
      3,
      n04,
      _RRAO,
      0,
      [_P2, _T2],
      [0, [() => TagSet, { [_xF]: 1, [_xN]: _Ta2 }]]
    ];
    var ReplicationRuleFilter$ = [
      3,
      n04,
      _RRF,
      0,
      [_P2, _Ta2, _An],
      [0, () => Tag$2, [() => ReplicationRuleAndOperator$, 0]]
    ];
    var ReplicationTime$ = [
      3,
      n04,
      _RT3,
      0,
      [_S, _Tim],
      [0, () => ReplicationTimeValue$],
      2
    ];
    var ReplicationTimeValue$ = [
      3,
      n04,
      _RTV,
      0,
      [_Mi],
      [1]
    ];
    var RequestPaymentConfiguration$ = [
      3,
      n04,
      _RPC,
      0,
      [_Pay],
      [0],
      1
    ];
    var RequestProgress$ = [
      3,
      n04,
      _RPe,
      0,
      [_Ena],
      [2]
    ];
    var RestoreObjectOutput$ = [
      3,
      n04,
      _ROOe,
      0,
      [_RC, _ROP],
      [[0, { [_hH]: _xarc }], [0, { [_hH]: _xarop }]]
    ];
    var RestoreObjectRequest$ = [
      3,
      n04,
      _RORe,
      0,
      [_B, _K2, _VI, _RRes, _RP, _CA2, _EBO],
      [[0, 1], [0, 1], [0, { [_hQ]: _vI }], [() => RestoreRequest$, { [_hP]: 1, [_xN]: _RRes }], [0, { [_hH]: _xarp }], [0, { [_hH]: _xasca }], [0, { [_hH]: _xaebo }]],
      2
    ];
    var RestoreRequest$ = [
      3,
      n04,
      _RRes,
      0,
      [_D, _GJP, _Ty, _Ti, _Desc, _SP, _OL],
      [1, () => GlacierJobParameters$, 0, 0, 0, () => SelectParameters$, [() => OutputLocation$, 0]]
    ];
    var RestoreStatus$ = [
      3,
      n04,
      _RSe,
      0,
      [_IRIP, _RED],
      [2, 4]
    ];
    var RoutingRule$ = [
      3,
      n04,
      _RRo,
      0,
      [_Red, _Co],
      [() => Redirect$, () => Condition$],
      1
    ];
    var S3KeyFilter$ = [
      3,
      n04,
      _SKF,
      0,
      [_FRi],
      [[() => FilterRuleList, { [_xF]: 1, [_xN]: _FR }]]
    ];
    var S3Location$ = [
      3,
      n04,
      _SL,
      0,
      [_BN, _P2, _En, _CACL, _ACL, _Tag, _UM, _SC],
      [0, 0, [() => Encryption$, 0], 0, [() => Grants, 0], [() => Tagging$, 0], [() => UserMetadata, 0], 0],
      2
    ];
    var S3TablesDestination$ = [
      3,
      n04,
      _STD,
      0,
      [_TBA, _TNa],
      [0, 0],
      2
    ];
    var S3TablesDestinationResult$ = [
      3,
      n04,
      _STDR,
      0,
      [_TBA, _TNa, _TA, _TN],
      [0, 0, 0, 0],
      4
    ];
    var ScanRange$ = [
      3,
      n04,
      _SR,
      0,
      [_St, _End],
      [1, 1]
    ];
    var SelectObjectContentOutput$ = [
      3,
      n04,
      _SOCO,
      0,
      [_Payl],
      [[() => SelectObjectContentEventStream$, 16]]
    ];
    var SelectObjectContentRequest$ = [
      3,
      n04,
      _SOCR,
      0,
      [_B, _K2, _Exp, _ETx, _IS, _OSu, _SSECA, _SSECK, _SSECKMD, _RPe, _SR, _EBO],
      [[0, 1], [0, 1], 0, 0, () => InputSerialization$, () => OutputSerialization$, [0, { [_hH]: _xasseca }], [() => SSECustomerKey, { [_hH]: _xasseck }], [0, { [_hH]: _xasseckM }], () => RequestProgress$, () => ScanRange$, [0, { [_hH]: _xaebo }]],
      6
    ];
    var SelectParameters$ = [
      3,
      n04,
      _SP,
      0,
      [_IS, _ETx, _Exp, _OSu],
      [() => InputSerialization$, 0, 0, () => OutputSerialization$],
      4
    ];
    var ServerSideEncryptionByDefault$ = [
      3,
      n04,
      _SSEBD,
      0,
      [_SSEA, _KMSMKID],
      [0, [() => SSEKMSKeyId, 0]],
      1
    ];
    var ServerSideEncryptionConfiguration$ = [
      3,
      n04,
      _SSEC,
      0,
      [_R],
      [[() => ServerSideEncryptionRules, { [_xF]: 1, [_xN]: _Ru }]],
      1
    ];
    var ServerSideEncryptionRule$ = [
      3,
      n04,
      _SSER,
      0,
      [_ASSEBD, _BKE, _BET],
      [[() => ServerSideEncryptionByDefault$, 0], 2, [() => BlockedEncryptionTypes$, 0]]
    ];
    var SessionCredentials$ = [
      3,
      n04,
      _SCe,
      0,
      [_AKI2, _SAK2, _ST2, _E2],
      [[0, { [_xN]: _AKI2 }], [() => SessionCredentialValue, { [_xN]: _SAK2 }], [() => SessionCredentialValue, { [_xN]: _ST2 }], [4, { [_xN]: _E2 }]],
      4
    ];
    var SimplePrefix$ = [
      3,
      n04,
      _SPi,
      { [_xN]: _SPi },
      [],
      []
    ];
    var SourceSelectionCriteria$ = [
      3,
      n04,
      _SSC,
      0,
      [_SKEO, _RM],
      [() => SseKmsEncryptedObjects$, () => ReplicaModifications$]
    ];
    var SSEKMS$ = [
      3,
      n04,
      _SSEKMS,
      { [_xN]: _SK },
      [_KI],
      [[() => SSEKMSKeyId, 0]],
      1
    ];
    var SseKmsEncryptedObjects$ = [
      3,
      n04,
      _SKEO,
      0,
      [_S],
      [0],
      1
    ];
    var SSES3$ = [
      3,
      n04,
      _SSES,
      { [_xN]: _SS },
      [],
      []
    ];
    var Stats$ = [
      3,
      n04,
      _Sta,
      0,
      [_BS, _BP, _BRy],
      [1, 1, 1]
    ];
    var StatsEvent$ = [
      3,
      n04,
      _SE,
      0,
      [_Det],
      [[() => Stats$, { [_eP]: 1 }]]
    ];
    var StorageClassAnalysis$ = [
      3,
      n04,
      _SCA,
      0,
      [_DE],
      [() => StorageClassAnalysisDataExport$]
    ];
    var StorageClassAnalysisDataExport$ = [
      3,
      n04,
      _SCADE,
      0,
      [_OSV, _Des],
      [0, () => AnalyticsExportDestination$],
      2
    ];
    var Tag$2 = [
      3,
      n04,
      _Ta2,
      0,
      [_K2, _V2],
      [0, 0],
      2
    ];
    var Tagging$ = [
      3,
      n04,
      _Tag,
      0,
      [_TS],
      [[() => TagSet, 0]],
      1
    ];
    var TargetGrant$ = [
      3,
      n04,
      _TGa,
      0,
      [_Gra, _Pe],
      [[() => Grantee$, { [_xNm]: [_x, _hi] }], 0]
    ];
    var TargetObjectKeyFormat$ = [
      3,
      n04,
      _TOKF,
      0,
      [_SPi, _PP],
      [[() => SimplePrefix$, { [_xN]: _SPi }], [() => PartitionedPrefix$, { [_xN]: _PP }]]
    ];
    var Tiering$ = [
      3,
      n04,
      _Tier,
      0,
      [_D, _AT3],
      [1, 0],
      2
    ];
    var TooManyParts$ = [
      -3,
      n04,
      _TMP,
      { [_e4]: _c4, [_hE4]: 400 },
      [],
      []
    ];
    schema.TypeRegistry.for(n04).registerError(TooManyParts$, TooManyParts);
    var TopicConfiguration$ = [
      3,
      n04,
      _TCop,
      0,
      [_TAo, _Ev, _I, _F],
      [[0, { [_xN]: _Top }], [64 | 0, { [_xF]: 1, [_xN]: _Eve }], 0, [() => NotificationConfigurationFilter$, 0]],
      2
    ];
    var Transition$ = [
      3,
      n04,
      _Tra,
      0,
      [_Da, _D, _SC],
      [5, 1, 0]
    ];
    var UpdateBucketMetadataInventoryTableConfigurationRequest$ = [
      3,
      n04,
      _UBMITCR,
      0,
      [_B, _ITCn, _CMD, _CA2, _EBO],
      [[0, 1], [() => InventoryTableConfigurationUpdates$, { [_hP]: 1, [_xN]: _ITCn }], [0, { [_hH]: _CM }], [0, { [_hH]: _xasca }], [0, { [_hH]: _xaebo }]],
      2
    ];
    var UpdateBucketMetadataJournalTableConfigurationRequest$ = [
      3,
      n04,
      _UBMJTCR,
      0,
      [_B, _JTC, _CMD, _CA2, _EBO],
      [[0, 1], [() => JournalTableConfigurationUpdates$, { [_hP]: 1, [_xN]: _JTC }], [0, { [_hH]: _CM }], [0, { [_hH]: _xasca }], [0, { [_hH]: _xaebo }]],
      2
    ];
    var UploadPartCopyOutput$ = [
      3,
      n04,
      _UPCO,
      0,
      [_CSVI, _CPR, _SSE, _SSECA, _SSECKMD, _SSEKMSKI, _BKE, _RC],
      [[0, { [_hH]: _xacsvi }], [() => CopyPartResult$, 16], [0, { [_hH]: _xasse }], [0, { [_hH]: _xasseca }], [0, { [_hH]: _xasseckM }], [() => SSEKMSKeyId, { [_hH]: _xasseakki }], [2, { [_hH]: _xassebke }], [0, { [_hH]: _xarc }]]
    ];
    var UploadPartCopyRequest$ = [
      3,
      n04,
      _UPCR,
      0,
      [_B, _CS2, _K2, _PN, _UI, _CSIM, _CSIMS, _CSINM, _CSIUS, _CSRo, _SSECA, _SSECK, _SSECKMD, _CSSSECA, _CSSSECK, _CSSSECKMD, _RP, _EBO, _ESBO],
      [[0, 1], [0, { [_hH]: _xacs__ }], [0, 1], [1, { [_hQ]: _pN }], [0, { [_hQ]: _uI }], [0, { [_hH]: _xacsim }], [4, { [_hH]: _xacsims }], [0, { [_hH]: _xacsinm }], [4, { [_hH]: _xacsius }], [0, { [_hH]: _xacsr }], [0, { [_hH]: _xasseca }], [() => SSECustomerKey, { [_hH]: _xasseck }], [0, { [_hH]: _xasseckM }], [0, { [_hH]: _xacssseca }], [() => CopySourceSSECustomerKey, { [_hH]: _xacssseck }], [0, { [_hH]: _xacssseckM }], [0, { [_hH]: _xarp }], [0, { [_hH]: _xaebo }], [0, { [_hH]: _xasebo }]],
      5
    ];
    var UploadPartOutput$ = [
      3,
      n04,
      _UPO,
      0,
      [_SSE, _ETa, _CCRC, _CCRCC, _CCRCNVME, _CSHA, _CSHAh, _SSECA, _SSECKMD, _SSEKMSKI, _BKE, _RC],
      [[0, { [_hH]: _xasse }], [0, { [_hH]: _ETa }], [0, { [_hH]: _xacc }], [0, { [_hH]: _xacc_ }], [0, { [_hH]: _xacc__ }], [0, { [_hH]: _xacs }], [0, { [_hH]: _xacs_ }], [0, { [_hH]: _xasseca }], [0, { [_hH]: _xasseckM }], [() => SSEKMSKeyId, { [_hH]: _xasseakki }], [2, { [_hH]: _xassebke }], [0, { [_hH]: _xarc }]]
    ];
    var UploadPartRequest$ = [
      3,
      n04,
      _UPR,
      0,
      [_B, _K2, _PN, _UI, _Bo, _CLo, _CMD, _CA2, _CCRC, _CCRCC, _CCRCNVME, _CSHA, _CSHAh, _SSECA, _SSECK, _SSECKMD, _RP, _EBO],
      [[0, 1], [0, 1], [1, { [_hQ]: _pN }], [0, { [_hQ]: _uI }], [() => StreamingBlob, 16], [1, { [_hH]: _CL__ }], [0, { [_hH]: _CM }], [0, { [_hH]: _xasca }], [0, { [_hH]: _xacc }], [0, { [_hH]: _xacc_ }], [0, { [_hH]: _xacc__ }], [0, { [_hH]: _xacs }], [0, { [_hH]: _xacs_ }], [0, { [_hH]: _xasseca }], [() => SSECustomerKey, { [_hH]: _xasseck }], [0, { [_hH]: _xasseckM }], [0, { [_hH]: _xarp }], [0, { [_hH]: _xaebo }]],
      4
    ];
    var VersioningConfiguration$ = [
      3,
      n04,
      _VC,
      0,
      [_MFAD, _S],
      [[0, { [_xN]: _MDf }], 0]
    ];
    var WebsiteConfiguration$ = [
      3,
      n04,
      _WC,
      0,
      [_EDr, _IDn, _RART, _RR],
      [() => ErrorDocument$, () => IndexDocument$, () => RedirectAllRequestsTo$, [() => RoutingRules, 0]]
    ];
    var WriteGetObjectResponseRequest$ = [
      3,
      n04,
      _WGORR,
      0,
      [_RReq, _RTe, _Bo, _SCt, _ECr, _EM, _AR2, _CC, _CDo, _CEo, _CL, _CLo, _CR, _CTo, _CCRC, _CCRCC, _CCRCNVME, _CSHA, _CSHAh, _DM, _ETa, _Ex, _E2, _LM, _MM, _M, _OLM, _OLLHS, _OLRUD, _PC2, _RS, _RC, _Re, _SSE, _SSECA, _SSEKMSKI, _SSECKMD, _SC, _TC2, _VI, _BKE],
      [[0, { [_hL]: 1, [_hH]: _xarr }], [0, { [_hH]: _xart }], [() => StreamingBlob, 16], [1, { [_hH]: _xafs }], [0, { [_hH]: _xafec }], [0, { [_hH]: _xafem }], [0, { [_hH]: _xafhar }], [0, { [_hH]: _xafhCC }], [0, { [_hH]: _xafhCD }], [0, { [_hH]: _xafhCE }], [0, { [_hH]: _xafhCL }], [1, { [_hH]: _CL__ }], [0, { [_hH]: _xafhCR }], [0, { [_hH]: _xafhCT }], [0, { [_hH]: _xafhxacc }], [0, { [_hH]: _xafhxacc_ }], [0, { [_hH]: _xafhxacc__ }], [0, { [_hH]: _xafhxacs }], [0, { [_hH]: _xafhxacs_ }], [2, { [_hH]: _xafhxadm }], [0, { [_hH]: _xafhE }], [4, { [_hH]: _xafhE_ }], [0, { [_hH]: _xafhxae }], [4, { [_hH]: _xafhLM }], [1, { [_hH]: _xafhxamm }], [128 | 0, { [_hPH]: _xam }], [0, { [_hH]: _xafhxaolm }], [0, { [_hH]: _xafhxaollh }], [5, { [_hH]: _xafhxaolrud }], [1, { [_hH]: _xafhxampc }], [0, { [_hH]: _xafhxars }], [0, { [_hH]: _xafhxarc }], [0, { [_hH]: _xafhxar }], [0, { [_hH]: _xafhxasse }], [0, { [_hH]: _xafhxasseca }], [() => SSEKMSKeyId, { [_hH]: _xafhxasseakki }], [0, { [_hH]: _xafhxasseckM }], [0, { [_hH]: _xafhxasc }], [1, { [_hH]: _xafhxatc }], [0, { [_hH]: _xafhxavi }], [2, { [_hH]: _xafhxassebke }]],
      2
    ];
    var __Unit = "unit";
    var S3ServiceException$ = [-3, _sm3, "S3ServiceException", 0, [], []];
    schema.TypeRegistry.for(_sm3).registerError(S3ServiceException$, S3ServiceException);
    var AnalyticsConfigurationList = [
      1,
      n04,
      _ACLn,
      0,
      [
        () => AnalyticsConfiguration$,
        0
      ]
    ];
    var Buckets = [
      1,
      n04,
      _Bu,
      0,
      [
        () => Bucket$,
        { [_xN]: _B }
      ]
    ];
    var CommonPrefixList = [
      1,
      n04,
      _CPL,
      0,
      () => CommonPrefix$
    ];
    var CompletedPartList = [
      1,
      n04,
      _CPLo,
      0,
      () => CompletedPart$
    ];
    var CORSRules = [
      1,
      n04,
      _CORSR,
      0,
      [
        () => CORSRule$,
        0
      ]
    ];
    var DeletedObjects = [
      1,
      n04,
      _DOe,
      0,
      () => DeletedObject$
    ];
    var DeleteMarkers = [
      1,
      n04,
      _DMe,
      0,
      () => DeleteMarkerEntry$
    ];
    var EncryptionTypeList = [
      1,
      n04,
      _ETL,
      0,
      [
        0,
        { [_xN]: _ET }
      ]
    ];
    var Errors = [
      1,
      n04,
      _Er,
      0,
      () => _Error$
    ];
    var FilterRuleList = [
      1,
      n04,
      _FRL,
      0,
      () => FilterRule$
    ];
    var Grants = [
      1,
      n04,
      _G,
      0,
      [
        () => Grant$,
        { [_xN]: _Gr }
      ]
    ];
    var IntelligentTieringConfigurationList = [
      1,
      n04,
      _ITCL,
      0,
      [
        () => IntelligentTieringConfiguration$,
        0
      ]
    ];
    var InventoryConfigurationList = [
      1,
      n04,
      _ICL,
      0,
      [
        () => InventoryConfiguration$,
        0
      ]
    ];
    var InventoryOptionalFields = [
      1,
      n04,
      _IOF,
      0,
      [
        0,
        { [_xN]: _Fi }
      ]
    ];
    var LambdaFunctionConfigurationList = [
      1,
      n04,
      _LFCL,
      0,
      [
        () => LambdaFunctionConfiguration$,
        0
      ]
    ];
    var LifecycleRules = [
      1,
      n04,
      _LRi,
      0,
      [
        () => LifecycleRule$,
        0
      ]
    ];
    var MetricsConfigurationList = [
      1,
      n04,
      _MCL,
      0,
      [
        () => MetricsConfiguration$,
        0
      ]
    ];
    var MultipartUploadList = [
      1,
      n04,
      _MUL,
      0,
      () => MultipartUpload$
    ];
    var NoncurrentVersionTransitionList = [
      1,
      n04,
      _NVTL,
      0,
      () => NoncurrentVersionTransition$
    ];
    var ObjectIdentifierList = [
      1,
      n04,
      _OIL,
      0,
      () => ObjectIdentifier$
    ];
    var ObjectList = [
      1,
      n04,
      _OLb,
      0,
      [
        () => _Object$,
        0
      ]
    ];
    var ObjectVersionList = [
      1,
      n04,
      _OVL,
      0,
      [
        () => ObjectVersion$,
        0
      ]
    ];
    var OwnershipControlsRules = [
      1,
      n04,
      _OCRw,
      0,
      () => OwnershipControlsRule$
    ];
    var Parts = [
      1,
      n04,
      _Pa,
      0,
      () => Part$
    ];
    var PartsList = [
      1,
      n04,
      _PL,
      0,
      () => ObjectPart$
    ];
    var QueueConfigurationList = [
      1,
      n04,
      _QCL,
      0,
      [
        () => QueueConfiguration$,
        0
      ]
    ];
    var ReplicationRules = [
      1,
      n04,
      _RRep,
      0,
      [
        () => ReplicationRule$,
        0
      ]
    ];
    var RoutingRules = [
      1,
      n04,
      _RR,
      0,
      [
        () => RoutingRule$,
        { [_xN]: _RRo }
      ]
    ];
    var ServerSideEncryptionRules = [
      1,
      n04,
      _SSERe,
      0,
      [
        () => ServerSideEncryptionRule$,
        0
      ]
    ];
    var TagSet = [
      1,
      n04,
      _TS,
      0,
      [
        () => Tag$2,
        { [_xN]: _Ta2 }
      ]
    ];
    var TargetGrants = [
      1,
      n04,
      _TG,
      0,
      [
        () => TargetGrant$,
        { [_xN]: _Gr }
      ]
    ];
    var TieringList = [
      1,
      n04,
      _TL,
      0,
      () => Tiering$
    ];
    var TopicConfigurationList = [
      1,
      n04,
      _TCL,
      0,
      [
        () => TopicConfiguration$,
        0
      ]
    ];
    var TransitionList = [
      1,
      n04,
      _TLr,
      0,
      () => Transition$
    ];
    var UserMetadata = [
      1,
      n04,
      _UM,
      0,
      [
        () => MetadataEntry$,
        { [_xN]: _ME }
      ]
    ];
    var AnalyticsFilter$ = [
      4,
      n04,
      _AF,
      0,
      [_P2, _Ta2, _An],
      [0, () => Tag$2, [() => AnalyticsAndOperator$, 0]]
    ];
    var MetricsFilter$ = [
      4,
      n04,
      _MF,
      0,
      [_P2, _Ta2, _APAc, _An],
      [0, () => Tag$2, 0, [() => MetricsAndOperator$, 0]]
    ];
    var SelectObjectContentEventStream$ = [
      4,
      n04,
      _SOCES,
      { [_s4]: 1 },
      [_Rec, _Sta, _Pr2, _Cont, _End],
      [[() => RecordsEvent$, 0], [() => StatsEvent$, 0], [() => ProgressEvent$, 0], () => ContinuationEvent$, () => EndEvent$]
    ];
    var AbortMultipartUpload$ = [
      9,
      n04,
      _AMU,
      { [_h3]: ["DELETE", "/{Key+}?x-id=AbortMultipartUpload", 204] },
      () => AbortMultipartUploadRequest$,
      () => AbortMultipartUploadOutput$
    ];
    var CompleteMultipartUpload$ = [
      9,
      n04,
      _CMUo,
      { [_h3]: ["POST", "/{Key+}", 200] },
      () => CompleteMultipartUploadRequest$,
      () => CompleteMultipartUploadOutput$
    ];
    var CopyObject$ = [
      9,
      n04,
      _CO,
      { [_h3]: ["PUT", "/{Key+}?x-id=CopyObject", 200] },
      () => CopyObjectRequest$,
      () => CopyObjectOutput$
    ];
    var CreateBucket$ = [
      9,
      n04,
      _CB,
      { [_h3]: ["PUT", "/", 200] },
      () => CreateBucketRequest$,
      () => CreateBucketOutput$
    ];
    var CreateBucketMetadataConfiguration$ = [
      9,
      n04,
      _CBMC,
      { [_hC]: "-", [_h3]: ["POST", "/?metadataConfiguration", 200] },
      () => CreateBucketMetadataConfigurationRequest$,
      () => __Unit
    ];
    var CreateBucketMetadataTableConfiguration$ = [
      9,
      n04,
      _CBMTC,
      { [_hC]: "-", [_h3]: ["POST", "/?metadataTable", 200] },
      () => CreateBucketMetadataTableConfigurationRequest$,
      () => __Unit
    ];
    var CreateMultipartUpload$ = [
      9,
      n04,
      _CMUr,
      { [_h3]: ["POST", "/{Key+}?uploads", 200] },
      () => CreateMultipartUploadRequest$,
      () => CreateMultipartUploadOutput$
    ];
    var CreateSession$ = [
      9,
      n04,
      _CSr,
      { [_h3]: ["GET", "/?session", 200] },
      () => CreateSessionRequest$,
      () => CreateSessionOutput$
    ];
    var DeleteBucket$ = [
      9,
      n04,
      _DB,
      { [_h3]: ["DELETE", "/", 204] },
      () => DeleteBucketRequest$,
      () => __Unit
    ];
    var DeleteBucketAnalyticsConfiguration$ = [
      9,
      n04,
      _DBAC,
      { [_h3]: ["DELETE", "/?analytics", 204] },
      () => DeleteBucketAnalyticsConfigurationRequest$,
      () => __Unit
    ];
    var DeleteBucketCors$ = [
      9,
      n04,
      _DBC,
      { [_h3]: ["DELETE", "/?cors", 204] },
      () => DeleteBucketCorsRequest$,
      () => __Unit
    ];
    var DeleteBucketEncryption$ = [
      9,
      n04,
      _DBE,
      { [_h3]: ["DELETE", "/?encryption", 204] },
      () => DeleteBucketEncryptionRequest$,
      () => __Unit
    ];
    var DeleteBucketIntelligentTieringConfiguration$ = [
      9,
      n04,
      _DBITC,
      { [_h3]: ["DELETE", "/?intelligent-tiering", 204] },
      () => DeleteBucketIntelligentTieringConfigurationRequest$,
      () => __Unit
    ];
    var DeleteBucketInventoryConfiguration$ = [
      9,
      n04,
      _DBIC,
      { [_h3]: ["DELETE", "/?inventory", 204] },
      () => DeleteBucketInventoryConfigurationRequest$,
      () => __Unit
    ];
    var DeleteBucketLifecycle$ = [
      9,
      n04,
      _DBL,
      { [_h3]: ["DELETE", "/?lifecycle", 204] },
      () => DeleteBucketLifecycleRequest$,
      () => __Unit
    ];
    var DeleteBucketMetadataConfiguration$ = [
      9,
      n04,
      _DBMC,
      { [_h3]: ["DELETE", "/?metadataConfiguration", 204] },
      () => DeleteBucketMetadataConfigurationRequest$,
      () => __Unit
    ];
    var DeleteBucketMetadataTableConfiguration$ = [
      9,
      n04,
      _DBMTC,
      { [_h3]: ["DELETE", "/?metadataTable", 204] },
      () => DeleteBucketMetadataTableConfigurationRequest$,
      () => __Unit
    ];
    var DeleteBucketMetricsConfiguration$ = [
      9,
      n04,
      _DBMCe,
      { [_h3]: ["DELETE", "/?metrics", 204] },
      () => DeleteBucketMetricsConfigurationRequest$,
      () => __Unit
    ];
    var DeleteBucketOwnershipControls$ = [
      9,
      n04,
      _DBOC,
      { [_h3]: ["DELETE", "/?ownershipControls", 204] },
      () => DeleteBucketOwnershipControlsRequest$,
      () => __Unit
    ];
    var DeleteBucketPolicy$ = [
      9,
      n04,
      _DBP,
      { [_h3]: ["DELETE", "/?policy", 204] },
      () => DeleteBucketPolicyRequest$,
      () => __Unit
    ];
    var DeleteBucketReplication$ = [
      9,
      n04,
      _DBRe,
      { [_h3]: ["DELETE", "/?replication", 204] },
      () => DeleteBucketReplicationRequest$,
      () => __Unit
    ];
    var DeleteBucketTagging$ = [
      9,
      n04,
      _DBT,
      { [_h3]: ["DELETE", "/?tagging", 204] },
      () => DeleteBucketTaggingRequest$,
      () => __Unit
    ];
    var DeleteBucketWebsite$ = [
      9,
      n04,
      _DBW,
      { [_h3]: ["DELETE", "/?website", 204] },
      () => DeleteBucketWebsiteRequest$,
      () => __Unit
    ];
    var DeleteObject$ = [
      9,
      n04,
      _DOel,
      { [_h3]: ["DELETE", "/{Key+}?x-id=DeleteObject", 204] },
      () => DeleteObjectRequest$,
      () => DeleteObjectOutput$
    ];
    var DeleteObjects$ = [
      9,
      n04,
      _DOele,
      { [_hC]: "-", [_h3]: ["POST", "/?delete", 200] },
      () => DeleteObjectsRequest$,
      () => DeleteObjectsOutput$
    ];
    var DeleteObjectTagging$ = [
      9,
      n04,
      _DOT,
      { [_h3]: ["DELETE", "/{Key+}?tagging", 204] },
      () => DeleteObjectTaggingRequest$,
      () => DeleteObjectTaggingOutput$
    ];
    var DeletePublicAccessBlock$ = [
      9,
      n04,
      _DPAB,
      { [_h3]: ["DELETE", "/?publicAccessBlock", 204] },
      () => DeletePublicAccessBlockRequest$,
      () => __Unit
    ];
    var GetBucketAbac$ = [
      9,
      n04,
      _GBA,
      { [_h3]: ["GET", "/?abac", 200] },
      () => GetBucketAbacRequest$,
      () => GetBucketAbacOutput$
    ];
    var GetBucketAccelerateConfiguration$ = [
      9,
      n04,
      _GBAC,
      { [_h3]: ["GET", "/?accelerate", 200] },
      () => GetBucketAccelerateConfigurationRequest$,
      () => GetBucketAccelerateConfigurationOutput$
    ];
    var GetBucketAcl$ = [
      9,
      n04,
      _GBAe,
      { [_h3]: ["GET", "/?acl", 200] },
      () => GetBucketAclRequest$,
      () => GetBucketAclOutput$
    ];
    var GetBucketAnalyticsConfiguration$ = [
      9,
      n04,
      _GBACe,
      { [_h3]: ["GET", "/?analytics&x-id=GetBucketAnalyticsConfiguration", 200] },
      () => GetBucketAnalyticsConfigurationRequest$,
      () => GetBucketAnalyticsConfigurationOutput$
    ];
    var GetBucketCors$ = [
      9,
      n04,
      _GBC,
      { [_h3]: ["GET", "/?cors", 200] },
      () => GetBucketCorsRequest$,
      () => GetBucketCorsOutput$
    ];
    var GetBucketEncryption$ = [
      9,
      n04,
      _GBE,
      { [_h3]: ["GET", "/?encryption", 200] },
      () => GetBucketEncryptionRequest$,
      () => GetBucketEncryptionOutput$
    ];
    var GetBucketIntelligentTieringConfiguration$ = [
      9,
      n04,
      _GBITC,
      { [_h3]: ["GET", "/?intelligent-tiering&x-id=GetBucketIntelligentTieringConfiguration", 200] },
      () => GetBucketIntelligentTieringConfigurationRequest$,
      () => GetBucketIntelligentTieringConfigurationOutput$
    ];
    var GetBucketInventoryConfiguration$ = [
      9,
      n04,
      _GBIC,
      { [_h3]: ["GET", "/?inventory&x-id=GetBucketInventoryConfiguration", 200] },
      () => GetBucketInventoryConfigurationRequest$,
      () => GetBucketInventoryConfigurationOutput$
    ];
    var GetBucketLifecycleConfiguration$ = [
      9,
      n04,
      _GBLC,
      { [_h3]: ["GET", "/?lifecycle", 200] },
      () => GetBucketLifecycleConfigurationRequest$,
      () => GetBucketLifecycleConfigurationOutput$
    ];
    var GetBucketLocation$ = [
      9,
      n04,
      _GBL,
      { [_h3]: ["GET", "/?location", 200] },
      () => GetBucketLocationRequest$,
      () => GetBucketLocationOutput$
    ];
    var GetBucketLogging$ = [
      9,
      n04,
      _GBLe,
      { [_h3]: ["GET", "/?logging", 200] },
      () => GetBucketLoggingRequest$,
      () => GetBucketLoggingOutput$
    ];
    var GetBucketMetadataConfiguration$ = [
      9,
      n04,
      _GBMC,
      { [_h3]: ["GET", "/?metadataConfiguration", 200] },
      () => GetBucketMetadataConfigurationRequest$,
      () => GetBucketMetadataConfigurationOutput$
    ];
    var GetBucketMetadataTableConfiguration$ = [
      9,
      n04,
      _GBMTC,
      { [_h3]: ["GET", "/?metadataTable", 200] },
      () => GetBucketMetadataTableConfigurationRequest$,
      () => GetBucketMetadataTableConfigurationOutput$
    ];
    var GetBucketMetricsConfiguration$ = [
      9,
      n04,
      _GBMCe,
      { [_h3]: ["GET", "/?metrics&x-id=GetBucketMetricsConfiguration", 200] },
      () => GetBucketMetricsConfigurationRequest$,
      () => GetBucketMetricsConfigurationOutput$
    ];
    var GetBucketNotificationConfiguration$ = [
      9,
      n04,
      _GBNC,
      { [_h3]: ["GET", "/?notification", 200] },
      () => GetBucketNotificationConfigurationRequest$,
      () => NotificationConfiguration$
    ];
    var GetBucketOwnershipControls$ = [
      9,
      n04,
      _GBOC,
      { [_h3]: ["GET", "/?ownershipControls", 200] },
      () => GetBucketOwnershipControlsRequest$,
      () => GetBucketOwnershipControlsOutput$
    ];
    var GetBucketPolicy$ = [
      9,
      n04,
      _GBP,
      { [_h3]: ["GET", "/?policy", 200] },
      () => GetBucketPolicyRequest$,
      () => GetBucketPolicyOutput$
    ];
    var GetBucketPolicyStatus$ = [
      9,
      n04,
      _GBPS,
      { [_h3]: ["GET", "/?policyStatus", 200] },
      () => GetBucketPolicyStatusRequest$,
      () => GetBucketPolicyStatusOutput$
    ];
    var GetBucketReplication$ = [
      9,
      n04,
      _GBR,
      { [_h3]: ["GET", "/?replication", 200] },
      () => GetBucketReplicationRequest$,
      () => GetBucketReplicationOutput$
    ];
    var GetBucketRequestPayment$ = [
      9,
      n04,
      _GBRP,
      { [_h3]: ["GET", "/?requestPayment", 200] },
      () => GetBucketRequestPaymentRequest$,
      () => GetBucketRequestPaymentOutput$
    ];
    var GetBucketTagging$ = [
      9,
      n04,
      _GBT,
      { [_h3]: ["GET", "/?tagging", 200] },
      () => GetBucketTaggingRequest$,
      () => GetBucketTaggingOutput$
    ];
    var GetBucketVersioning$ = [
      9,
      n04,
      _GBV,
      { [_h3]: ["GET", "/?versioning", 200] },
      () => GetBucketVersioningRequest$,
      () => GetBucketVersioningOutput$
    ];
    var GetBucketWebsite$ = [
      9,
      n04,
      _GBW,
      { [_h3]: ["GET", "/?website", 200] },
      () => GetBucketWebsiteRequest$,
      () => GetBucketWebsiteOutput$
    ];
    var GetObject$ = [
      9,
      n04,
      _GO,
      { [_hC]: "-", [_h3]: ["GET", "/{Key+}?x-id=GetObject", 200] },
      () => GetObjectRequest$,
      () => GetObjectOutput$
    ];
    var GetObjectAcl$ = [
      9,
      n04,
      _GOA,
      { [_h3]: ["GET", "/{Key+}?acl", 200] },
      () => GetObjectAclRequest$,
      () => GetObjectAclOutput$
    ];
    var GetObjectAttributes$ = [
      9,
      n04,
      _GOAe,
      { [_h3]: ["GET", "/{Key+}?attributes", 200] },
      () => GetObjectAttributesRequest$,
      () => GetObjectAttributesOutput$
    ];
    var GetObjectLegalHold$ = [
      9,
      n04,
      _GOLH,
      { [_h3]: ["GET", "/{Key+}?legal-hold", 200] },
      () => GetObjectLegalHoldRequest$,
      () => GetObjectLegalHoldOutput$
    ];
    var GetObjectLockConfiguration$ = [
      9,
      n04,
      _GOLC,
      { [_h3]: ["GET", "/?object-lock", 200] },
      () => GetObjectLockConfigurationRequest$,
      () => GetObjectLockConfigurationOutput$
    ];
    var GetObjectRetention$ = [
      9,
      n04,
      _GORe,
      { [_h3]: ["GET", "/{Key+}?retention", 200] },
      () => GetObjectRetentionRequest$,
      () => GetObjectRetentionOutput$
    ];
    var GetObjectTagging$ = [
      9,
      n04,
      _GOT,
      { [_h3]: ["GET", "/{Key+}?tagging", 200] },
      () => GetObjectTaggingRequest$,
      () => GetObjectTaggingOutput$
    ];
    var GetObjectTorrent$ = [
      9,
      n04,
      _GOTe,
      { [_h3]: ["GET", "/{Key+}?torrent", 200] },
      () => GetObjectTorrentRequest$,
      () => GetObjectTorrentOutput$
    ];
    var GetPublicAccessBlock$ = [
      9,
      n04,
      _GPAB,
      { [_h3]: ["GET", "/?publicAccessBlock", 200] },
      () => GetPublicAccessBlockRequest$,
      () => GetPublicAccessBlockOutput$
    ];
    var HeadBucket$ = [
      9,
      n04,
      _HB,
      { [_h3]: ["HEAD", "/", 200] },
      () => HeadBucketRequest$,
      () => HeadBucketOutput$
    ];
    var HeadObject$ = [
      9,
      n04,
      _HO,
      { [_h3]: ["HEAD", "/{Key+}", 200] },
      () => HeadObjectRequest$,
      () => HeadObjectOutput$
    ];
    var ListBucketAnalyticsConfigurations$ = [
      9,
      n04,
      _LBAC,
      { [_h3]: ["GET", "/?analytics&x-id=ListBucketAnalyticsConfigurations", 200] },
      () => ListBucketAnalyticsConfigurationsRequest$,
      () => ListBucketAnalyticsConfigurationsOutput$
    ];
    var ListBucketIntelligentTieringConfigurations$ = [
      9,
      n04,
      _LBITC,
      { [_h3]: ["GET", "/?intelligent-tiering&x-id=ListBucketIntelligentTieringConfigurations", 200] },
      () => ListBucketIntelligentTieringConfigurationsRequest$,
      () => ListBucketIntelligentTieringConfigurationsOutput$
    ];
    var ListBucketInventoryConfigurations$ = [
      9,
      n04,
      _LBIC,
      { [_h3]: ["GET", "/?inventory&x-id=ListBucketInventoryConfigurations", 200] },
      () => ListBucketInventoryConfigurationsRequest$,
      () => ListBucketInventoryConfigurationsOutput$
    ];
    var ListBucketMetricsConfigurations$ = [
      9,
      n04,
      _LBMC,
      { [_h3]: ["GET", "/?metrics&x-id=ListBucketMetricsConfigurations", 200] },
      () => ListBucketMetricsConfigurationsRequest$,
      () => ListBucketMetricsConfigurationsOutput$
    ];
    var ListBuckets$ = [
      9,
      n04,
      _LB,
      { [_h3]: ["GET", "/?x-id=ListBuckets", 200] },
      () => ListBucketsRequest$,
      () => ListBucketsOutput$
    ];
    var ListDirectoryBuckets$ = [
      9,
      n04,
      _LDB,
      { [_h3]: ["GET", "/?x-id=ListDirectoryBuckets", 200] },
      () => ListDirectoryBucketsRequest$,
      () => ListDirectoryBucketsOutput$
    ];
    var ListMultipartUploads$ = [
      9,
      n04,
      _LMU,
      { [_h3]: ["GET", "/?uploads", 200] },
      () => ListMultipartUploadsRequest$,
      () => ListMultipartUploadsOutput$
    ];
    var ListObjects$ = [
      9,
      n04,
      _LO,
      { [_h3]: ["GET", "/", 200] },
      () => ListObjectsRequest$,
      () => ListObjectsOutput$
    ];
    var ListObjectsV2$ = [
      9,
      n04,
      _LOV,
      { [_h3]: ["GET", "/?list-type=2", 200] },
      () => ListObjectsV2Request$,
      () => ListObjectsV2Output$
    ];
    var ListObjectVersions$ = [
      9,
      n04,
      _LOVi,
      { [_h3]: ["GET", "/?versions", 200] },
      () => ListObjectVersionsRequest$,
      () => ListObjectVersionsOutput$
    ];
    var ListParts$ = [
      9,
      n04,
      _LP,
      { [_h3]: ["GET", "/{Key+}?x-id=ListParts", 200] },
      () => ListPartsRequest$,
      () => ListPartsOutput$
    ];
    var PutBucketAbac$ = [
      9,
      n04,
      _PBA,
      { [_hC]: "-", [_h3]: ["PUT", "/?abac", 200] },
      () => PutBucketAbacRequest$,
      () => __Unit
    ];
    var PutBucketAccelerateConfiguration$ = [
      9,
      n04,
      _PBAC,
      { [_hC]: "-", [_h3]: ["PUT", "/?accelerate", 200] },
      () => PutBucketAccelerateConfigurationRequest$,
      () => __Unit
    ];
    var PutBucketAcl$ = [
      9,
      n04,
      _PBAu,
      { [_hC]: "-", [_h3]: ["PUT", "/?acl", 200] },
      () => PutBucketAclRequest$,
      () => __Unit
    ];
    var PutBucketAnalyticsConfiguration$ = [
      9,
      n04,
      _PBACu,
      { [_h3]: ["PUT", "/?analytics", 200] },
      () => PutBucketAnalyticsConfigurationRequest$,
      () => __Unit
    ];
    var PutBucketCors$ = [
      9,
      n04,
      _PBC,
      { [_hC]: "-", [_h3]: ["PUT", "/?cors", 200] },
      () => PutBucketCorsRequest$,
      () => __Unit
    ];
    var PutBucketEncryption$ = [
      9,
      n04,
      _PBE,
      { [_hC]: "-", [_h3]: ["PUT", "/?encryption", 200] },
      () => PutBucketEncryptionRequest$,
      () => __Unit
    ];
    var PutBucketIntelligentTieringConfiguration$ = [
      9,
      n04,
      _PBITC,
      { [_h3]: ["PUT", "/?intelligent-tiering", 200] },
      () => PutBucketIntelligentTieringConfigurationRequest$,
      () => __Unit
    ];
    var PutBucketInventoryConfiguration$ = [
      9,
      n04,
      _PBIC,
      { [_h3]: ["PUT", "/?inventory", 200] },
      () => PutBucketInventoryConfigurationRequest$,
      () => __Unit
    ];
    var PutBucketLifecycleConfiguration$ = [
      9,
      n04,
      _PBLC,
      { [_hC]: "-", [_h3]: ["PUT", "/?lifecycle", 200] },
      () => PutBucketLifecycleConfigurationRequest$,
      () => PutBucketLifecycleConfigurationOutput$
    ];
    var PutBucketLogging$ = [
      9,
      n04,
      _PBL,
      { [_hC]: "-", [_h3]: ["PUT", "/?logging", 200] },
      () => PutBucketLoggingRequest$,
      () => __Unit
    ];
    var PutBucketMetricsConfiguration$ = [
      9,
      n04,
      _PBMC,
      { [_h3]: ["PUT", "/?metrics", 200] },
      () => PutBucketMetricsConfigurationRequest$,
      () => __Unit
    ];
    var PutBucketNotificationConfiguration$ = [
      9,
      n04,
      _PBNC,
      { [_h3]: ["PUT", "/?notification", 200] },
      () => PutBucketNotificationConfigurationRequest$,
      () => __Unit
    ];
    var PutBucketOwnershipControls$ = [
      9,
      n04,
      _PBOC,
      { [_hC]: "-", [_h3]: ["PUT", "/?ownershipControls", 200] },
      () => PutBucketOwnershipControlsRequest$,
      () => __Unit
    ];
    var PutBucketPolicy$ = [
      9,
      n04,
      _PBP,
      { [_hC]: "-", [_h3]: ["PUT", "/?policy", 200] },
      () => PutBucketPolicyRequest$,
      () => __Unit
    ];
    var PutBucketReplication$ = [
      9,
      n04,
      _PBR,
      { [_hC]: "-", [_h3]: ["PUT", "/?replication", 200] },
      () => PutBucketReplicationRequest$,
      () => __Unit
    ];
    var PutBucketRequestPayment$ = [
      9,
      n04,
      _PBRP,
      { [_hC]: "-", [_h3]: ["PUT", "/?requestPayment", 200] },
      () => PutBucketRequestPaymentRequest$,
      () => __Unit
    ];
    var PutBucketTagging$ = [
      9,
      n04,
      _PBT,
      { [_hC]: "-", [_h3]: ["PUT", "/?tagging", 200] },
      () => PutBucketTaggingRequest$,
      () => __Unit
    ];
    var PutBucketVersioning$ = [
      9,
      n04,
      _PBV,
      { [_hC]: "-", [_h3]: ["PUT", "/?versioning", 200] },
      () => PutBucketVersioningRequest$,
      () => __Unit
    ];
    var PutBucketWebsite$ = [
      9,
      n04,
      _PBW,
      { [_hC]: "-", [_h3]: ["PUT", "/?website", 200] },
      () => PutBucketWebsiteRequest$,
      () => __Unit
    ];
    var PutObject$ = [
      9,
      n04,
      _PO,
      { [_hC]: "-", [_h3]: ["PUT", "/{Key+}?x-id=PutObject", 200] },
      () => PutObjectRequest$,
      () => PutObjectOutput$
    ];
    var PutObjectAcl$ = [
      9,
      n04,
      _POA,
      { [_hC]: "-", [_h3]: ["PUT", "/{Key+}?acl", 200] },
      () => PutObjectAclRequest$,
      () => PutObjectAclOutput$
    ];
    var PutObjectLegalHold$ = [
      9,
      n04,
      _POLH,
      { [_hC]: "-", [_h3]: ["PUT", "/{Key+}?legal-hold", 200] },
      () => PutObjectLegalHoldRequest$,
      () => PutObjectLegalHoldOutput$
    ];
    var PutObjectLockConfiguration$ = [
      9,
      n04,
      _POLC,
      { [_hC]: "-", [_h3]: ["PUT", "/?object-lock", 200] },
      () => PutObjectLockConfigurationRequest$,
      () => PutObjectLockConfigurationOutput$
    ];
    var PutObjectRetention$ = [
      9,
      n04,
      _PORu,
      { [_hC]: "-", [_h3]: ["PUT", "/{Key+}?retention", 200] },
      () => PutObjectRetentionRequest$,
      () => PutObjectRetentionOutput$
    ];
    var PutObjectTagging$ = [
      9,
      n04,
      _POT,
      { [_hC]: "-", [_h3]: ["PUT", "/{Key+}?tagging", 200] },
      () => PutObjectTaggingRequest$,
      () => PutObjectTaggingOutput$
    ];
    var PutPublicAccessBlock$ = [
      9,
      n04,
      _PPAB,
      { [_hC]: "-", [_h3]: ["PUT", "/?publicAccessBlock", 200] },
      () => PutPublicAccessBlockRequest$,
      () => __Unit
    ];
    var RenameObject$ = [
      9,
      n04,
      _RO,
      { [_h3]: ["PUT", "/{Key+}?renameObject", 200] },
      () => RenameObjectRequest$,
      () => RenameObjectOutput$
    ];
    var RestoreObject$ = [
      9,
      n04,
      _ROe,
      { [_hC]: "-", [_h3]: ["POST", "/{Key+}?restore", 200] },
      () => RestoreObjectRequest$,
      () => RestoreObjectOutput$
    ];
    var SelectObjectContent$ = [
      9,
      n04,
      _SOC,
      { [_h3]: ["POST", "/{Key+}?select&select-type=2", 200] },
      () => SelectObjectContentRequest$,
      () => SelectObjectContentOutput$
    ];
    var UpdateBucketMetadataInventoryTableConfiguration$ = [
      9,
      n04,
      _UBMITC,
      { [_hC]: "-", [_h3]: ["PUT", "/?metadataInventoryTable", 200] },
      () => UpdateBucketMetadataInventoryTableConfigurationRequest$,
      () => __Unit
    ];
    var UpdateBucketMetadataJournalTableConfiguration$ = [
      9,
      n04,
      _UBMJTC,
      { [_hC]: "-", [_h3]: ["PUT", "/?metadataJournalTable", 200] },
      () => UpdateBucketMetadataJournalTableConfigurationRequest$,
      () => __Unit
    ];
    var UploadPart$ = [
      9,
      n04,
      _UP,
      { [_hC]: "-", [_h3]: ["PUT", "/{Key+}?x-id=UploadPart", 200] },
      () => UploadPartRequest$,
      () => UploadPartOutput$
    ];
    var UploadPartCopy$ = [
      9,
      n04,
      _UPC,
      { [_h3]: ["PUT", "/{Key+}?x-id=UploadPartCopy", 200] },
      () => UploadPartCopyRequest$,
      () => UploadPartCopyOutput$
    ];
    var WriteGetObjectResponse$ = [
      9,
      n04,
      _WGOR,
      { [_en]: ["{RequestRoute}."], [_h3]: ["POST", "/WriteGetObjectResponse", 200] },
      () => WriteGetObjectResponseRequest$,
      () => __Unit
    ];
    var CreateSessionCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      DisableS3ExpressSessionAuth: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "CreateSession", {}).n("S3Client", "CreateSessionCommand").sc(CreateSession$).build() {
    };
    var getHttpAuthExtensionConfiguration4 = (runtimeConfig2) => {
      const _httpAuthSchemes = runtimeConfig2.httpAuthSchemes;
      let _httpAuthSchemeProvider = runtimeConfig2.httpAuthSchemeProvider;
      let _credentials = runtimeConfig2.credentials;
      return {
        setHttpAuthScheme(httpAuthScheme) {
          const index = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
          if (index === -1) {
            _httpAuthSchemes.push(httpAuthScheme);
          } else {
            _httpAuthSchemes.splice(index, 1, httpAuthScheme);
          }
        },
        httpAuthSchemes() {
          return _httpAuthSchemes;
        },
        setHttpAuthSchemeProvider(httpAuthSchemeProvider2) {
          _httpAuthSchemeProvider = httpAuthSchemeProvider2;
        },
        httpAuthSchemeProvider() {
          return _httpAuthSchemeProvider;
        },
        setCredentials(credentials) {
          _credentials = credentials;
        },
        credentials() {
          return _credentials;
        }
      };
    };
    var resolveHttpAuthRuntimeConfig4 = (config) => {
      return {
        httpAuthSchemes: config.httpAuthSchemes(),
        httpAuthSchemeProvider: config.httpAuthSchemeProvider(),
        credentials: config.credentials()
      };
    };
    var resolveRuntimeExtensions4 = (runtimeConfig2, extensions) => {
      const extensionConfiguration = Object.assign(regionConfigResolver.getAwsRegionExtensionConfiguration(runtimeConfig2), smithyClient.getDefaultExtensionConfiguration(runtimeConfig2), protocolHttp.getHttpHandlerExtensionConfiguration(runtimeConfig2), getHttpAuthExtensionConfiguration4(runtimeConfig2));
      extensions.forEach((extension) => extension.configure(extensionConfiguration));
      return Object.assign(runtimeConfig2, regionConfigResolver.resolveAwsRegionExtensionConfiguration(extensionConfiguration), smithyClient.resolveDefaultRuntimeConfig(extensionConfiguration), protocolHttp.resolveHttpHandlerRuntimeConfig(extensionConfiguration), resolveHttpAuthRuntimeConfig4(extensionConfiguration));
    };
    var S3Client2 = class extends smithyClient.Client {
      config;
      constructor(...[configuration]) {
        const _config_0 = runtimeConfig.getRuntimeConfig(configuration || {});
        super(_config_0);
        this.initConfig = _config_0;
        const _config_1 = resolveClientEndpointParameters4(_config_0);
        const _config_2 = middlewareUserAgent.resolveUserAgentConfig(_config_1);
        const _config_3 = middlewareFlexibleChecksums.resolveFlexibleChecksumsConfig(_config_2);
        const _config_4 = middlewareRetry.resolveRetryConfig(_config_3);
        const _config_5 = configResolver.resolveRegionConfig(_config_4);
        const _config_6 = middlewareHostHeader.resolveHostHeaderConfig(_config_5);
        const _config_7 = middlewareEndpoint.resolveEndpointConfig(_config_6);
        const _config_8 = eventstreamSerdeConfigResolver.resolveEventStreamSerdeConfig(_config_7);
        const _config_9 = httpAuthSchemeProvider.resolveHttpAuthSchemeConfig(_config_8);
        const _config_10 = middlewareSdkS3.resolveS3Config(_config_9, { session: [() => this, CreateSessionCommand] });
        const _config_11 = resolveRuntimeExtensions4(_config_10, configuration?.extensions || []);
        this.config = _config_11;
        this.middlewareStack.use(schema.getSchemaSerdePlugin(this.config));
        this.middlewareStack.use(middlewareUserAgent.getUserAgentPlugin(this.config));
        this.middlewareStack.use(middlewareRetry.getRetryPlugin(this.config));
        this.middlewareStack.use(middlewareContentLength.getContentLengthPlugin(this.config));
        this.middlewareStack.use(middlewareHostHeader.getHostHeaderPlugin(this.config));
        this.middlewareStack.use(middlewareLogger.getLoggerPlugin(this.config));
        this.middlewareStack.use(middlewareRecursionDetection.getRecursionDetectionPlugin(this.config));
        this.middlewareStack.use(core.getHttpAuthSchemeEndpointRuleSetPlugin(this.config, {
          httpAuthSchemeParametersProvider: httpAuthSchemeProvider.defaultS3HttpAuthSchemeParametersProvider,
          identityProviderConfigProvider: async (config) => new core.DefaultIdentityProviderConfig({
            "aws.auth#sigv4": config.credentials,
            "aws.auth#sigv4a": config.credentials
          })
        }));
        this.middlewareStack.use(core.getHttpSigningPlugin(this.config));
        this.middlewareStack.use(middlewareSdkS3.getValidateBucketNamePlugin(this.config));
        this.middlewareStack.use(middlewareExpectContinue.getAddExpectContinuePlugin(this.config));
        this.middlewareStack.use(middlewareSdkS3.getRegionRedirectMiddlewarePlugin(this.config));
        this.middlewareStack.use(middlewareSdkS3.getS3ExpressPlugin(this.config));
        this.middlewareStack.use(middlewareSdkS3.getS3ExpressHttpSigningPlugin(this.config));
      }
      destroy() {
        super.destroy();
      }
    };
    var AbortMultipartUploadCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      Bucket: { type: "contextParams", name: "Bucket" },
      Key: { type: "contextParams", name: "Key" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "AbortMultipartUpload", {}).n("S3Client", "AbortMultipartUploadCommand").sc(AbortMultipartUpload$).build() {
    };
    var CompleteMultipartUploadCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      Bucket: { type: "contextParams", name: "Bucket" },
      Key: { type: "contextParams", name: "Key" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config),
        middlewareSsec.getSsecPlugin(config)
      ];
    }).s("AmazonS3", "CompleteMultipartUpload", {}).n("S3Client", "CompleteMultipartUploadCommand").sc(CompleteMultipartUpload$).build() {
    };
    var CopyObjectCommand2 = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      DisableS3ExpressSessionAuth: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" },
      Key: { type: "contextParams", name: "Key" },
      CopySource: { type: "contextParams", name: "CopySource" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config),
        middlewareSsec.getSsecPlugin(config)
      ];
    }).s("AmazonS3", "CopyObject", {}).n("S3Client", "CopyObjectCommand").sc(CopyObject$).build() {
    };
    var CreateBucketCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      DisableAccessPoints: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config),
        middlewareLocationConstraint.getLocationConstraintPlugin(config)
      ];
    }).s("AmazonS3", "CreateBucket", {}).n("S3Client", "CreateBucketCommand").sc(CreateBucket$).build() {
    };
    var CreateBucketMetadataConfigurationCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { "httpHeader": "x-amz-sdk-checksum-algorithm", "name": "ChecksumAlgorithm" },
          requestChecksumRequired: true
        })
      ];
    }).s("AmazonS3", "CreateBucketMetadataConfiguration", {}).n("S3Client", "CreateBucketMetadataConfigurationCommand").sc(CreateBucketMetadataConfiguration$).build() {
    };
    var CreateBucketMetadataTableConfigurationCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { "httpHeader": "x-amz-sdk-checksum-algorithm", "name": "ChecksumAlgorithm" },
          requestChecksumRequired: true
        })
      ];
    }).s("AmazonS3", "CreateBucketMetadataTableConfiguration", {}).n("S3Client", "CreateBucketMetadataTableConfigurationCommand").sc(CreateBucketMetadataTableConfiguration$).build() {
    };
    var CreateMultipartUploadCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      Bucket: { type: "contextParams", name: "Bucket" },
      Key: { type: "contextParams", name: "Key" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config),
        middlewareSsec.getSsecPlugin(config)
      ];
    }).s("AmazonS3", "CreateMultipartUpload", {}).n("S3Client", "CreateMultipartUploadCommand").sc(CreateMultipartUpload$).build() {
    };
    var DeleteBucketAnalyticsConfigurationCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
    }).s("AmazonS3", "DeleteBucketAnalyticsConfiguration", {}).n("S3Client", "DeleteBucketAnalyticsConfigurationCommand").sc(DeleteBucketAnalyticsConfiguration$).build() {
    };
    var DeleteBucketCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
    }).s("AmazonS3", "DeleteBucket", {}).n("S3Client", "DeleteBucketCommand").sc(DeleteBucket$).build() {
    };
    var DeleteBucketCorsCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
    }).s("AmazonS3", "DeleteBucketCors", {}).n("S3Client", "DeleteBucketCorsCommand").sc(DeleteBucketCors$).build() {
    };
    var DeleteBucketEncryptionCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
    }).s("AmazonS3", "DeleteBucketEncryption", {}).n("S3Client", "DeleteBucketEncryptionCommand").sc(DeleteBucketEncryption$).build() {
    };
    var DeleteBucketIntelligentTieringConfigurationCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
    }).s("AmazonS3", "DeleteBucketIntelligentTieringConfiguration", {}).n("S3Client", "DeleteBucketIntelligentTieringConfigurationCommand").sc(DeleteBucketIntelligentTieringConfiguration$).build() {
    };
    var DeleteBucketInventoryConfigurationCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
    }).s("AmazonS3", "DeleteBucketInventoryConfiguration", {}).n("S3Client", "DeleteBucketInventoryConfigurationCommand").sc(DeleteBucketInventoryConfiguration$).build() {
    };
    var DeleteBucketLifecycleCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
    }).s("AmazonS3", "DeleteBucketLifecycle", {}).n("S3Client", "DeleteBucketLifecycleCommand").sc(DeleteBucketLifecycle$).build() {
    };
    var DeleteBucketMetadataConfigurationCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
    }).s("AmazonS3", "DeleteBucketMetadataConfiguration", {}).n("S3Client", "DeleteBucketMetadataConfigurationCommand").sc(DeleteBucketMetadataConfiguration$).build() {
    };
    var DeleteBucketMetadataTableConfigurationCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
    }).s("AmazonS3", "DeleteBucketMetadataTableConfiguration", {}).n("S3Client", "DeleteBucketMetadataTableConfigurationCommand").sc(DeleteBucketMetadataTableConfiguration$).build() {
    };
    var DeleteBucketMetricsConfigurationCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
    }).s("AmazonS3", "DeleteBucketMetricsConfiguration", {}).n("S3Client", "DeleteBucketMetricsConfigurationCommand").sc(DeleteBucketMetricsConfiguration$).build() {
    };
    var DeleteBucketOwnershipControlsCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
    }).s("AmazonS3", "DeleteBucketOwnershipControls", {}).n("S3Client", "DeleteBucketOwnershipControlsCommand").sc(DeleteBucketOwnershipControls$).build() {
    };
    var DeleteBucketPolicyCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
    }).s("AmazonS3", "DeleteBucketPolicy", {}).n("S3Client", "DeleteBucketPolicyCommand").sc(DeleteBucketPolicy$).build() {
    };
    var DeleteBucketReplicationCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
    }).s("AmazonS3", "DeleteBucketReplication", {}).n("S3Client", "DeleteBucketReplicationCommand").sc(DeleteBucketReplication$).build() {
    };
    var DeleteBucketTaggingCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
    }).s("AmazonS3", "DeleteBucketTagging", {}).n("S3Client", "DeleteBucketTaggingCommand").sc(DeleteBucketTagging$).build() {
    };
    var DeleteBucketWebsiteCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
    }).s("AmazonS3", "DeleteBucketWebsite", {}).n("S3Client", "DeleteBucketWebsiteCommand").sc(DeleteBucketWebsite$).build() {
    };
    var DeleteObjectCommand2 = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      Bucket: { type: "contextParams", name: "Bucket" },
      Key: { type: "contextParams", name: "Key" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "DeleteObject", {}).n("S3Client", "DeleteObjectCommand").sc(DeleteObject$).build() {
    };
    var DeleteObjectsCommand2 = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { "httpHeader": "x-amz-sdk-checksum-algorithm", "name": "ChecksumAlgorithm" },
          requestChecksumRequired: true
        }),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "DeleteObjects", {}).n("S3Client", "DeleteObjectsCommand").sc(DeleteObjects$).build() {
    };
    var DeleteObjectTaggingCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "DeleteObjectTagging", {}).n("S3Client", "DeleteObjectTaggingCommand").sc(DeleteObjectTagging$).build() {
    };
    var DeletePublicAccessBlockCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
    }).s("AmazonS3", "DeletePublicAccessBlock", {}).n("S3Client", "DeletePublicAccessBlockCommand").sc(DeletePublicAccessBlock$).build() {
    };
    var GetBucketAbacCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetBucketAbac", {}).n("S3Client", "GetBucketAbacCommand").sc(GetBucketAbac$).build() {
    };
    var GetBucketAccelerateConfigurationCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetBucketAccelerateConfiguration", {}).n("S3Client", "GetBucketAccelerateConfigurationCommand").sc(GetBucketAccelerateConfiguration$).build() {
    };
    var GetBucketAclCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetBucketAcl", {}).n("S3Client", "GetBucketAclCommand").sc(GetBucketAcl$).build() {
    };
    var GetBucketAnalyticsConfigurationCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetBucketAnalyticsConfiguration", {}).n("S3Client", "GetBucketAnalyticsConfigurationCommand").sc(GetBucketAnalyticsConfiguration$).build() {
    };
    var GetBucketCorsCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetBucketCors", {}).n("S3Client", "GetBucketCorsCommand").sc(GetBucketCors$).build() {
    };
    var GetBucketEncryptionCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetBucketEncryption", {}).n("S3Client", "GetBucketEncryptionCommand").sc(GetBucketEncryption$).build() {
    };
    var GetBucketIntelligentTieringConfigurationCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetBucketIntelligentTieringConfiguration", {}).n("S3Client", "GetBucketIntelligentTieringConfigurationCommand").sc(GetBucketIntelligentTieringConfiguration$).build() {
    };
    var GetBucketInventoryConfigurationCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetBucketInventoryConfiguration", {}).n("S3Client", "GetBucketInventoryConfigurationCommand").sc(GetBucketInventoryConfiguration$).build() {
    };
    var GetBucketLifecycleConfigurationCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetBucketLifecycleConfiguration", {}).n("S3Client", "GetBucketLifecycleConfigurationCommand").sc(GetBucketLifecycleConfiguration$).build() {
    };
    var GetBucketLocationCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetBucketLocation", {}).n("S3Client", "GetBucketLocationCommand").sc(GetBucketLocation$).build() {
    };
    var GetBucketLoggingCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetBucketLogging", {}).n("S3Client", "GetBucketLoggingCommand").sc(GetBucketLogging$).build() {
    };
    var GetBucketMetadataConfigurationCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetBucketMetadataConfiguration", {}).n("S3Client", "GetBucketMetadataConfigurationCommand").sc(GetBucketMetadataConfiguration$).build() {
    };
    var GetBucketMetadataTableConfigurationCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetBucketMetadataTableConfiguration", {}).n("S3Client", "GetBucketMetadataTableConfigurationCommand").sc(GetBucketMetadataTableConfiguration$).build() {
    };
    var GetBucketMetricsConfigurationCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetBucketMetricsConfiguration", {}).n("S3Client", "GetBucketMetricsConfigurationCommand").sc(GetBucketMetricsConfiguration$).build() {
    };
    var GetBucketNotificationConfigurationCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetBucketNotificationConfiguration", {}).n("S3Client", "GetBucketNotificationConfigurationCommand").sc(GetBucketNotificationConfiguration$).build() {
    };
    var GetBucketOwnershipControlsCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetBucketOwnershipControls", {}).n("S3Client", "GetBucketOwnershipControlsCommand").sc(GetBucketOwnershipControls$).build() {
    };
    var GetBucketPolicyCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetBucketPolicy", {}).n("S3Client", "GetBucketPolicyCommand").sc(GetBucketPolicy$).build() {
    };
    var GetBucketPolicyStatusCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetBucketPolicyStatus", {}).n("S3Client", "GetBucketPolicyStatusCommand").sc(GetBucketPolicyStatus$).build() {
    };
    var GetBucketReplicationCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetBucketReplication", {}).n("S3Client", "GetBucketReplicationCommand").sc(GetBucketReplication$).build() {
    };
    var GetBucketRequestPaymentCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetBucketRequestPayment", {}).n("S3Client", "GetBucketRequestPaymentCommand").sc(GetBucketRequestPayment$).build() {
    };
    var GetBucketTaggingCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetBucketTagging", {}).n("S3Client", "GetBucketTaggingCommand").sc(GetBucketTagging$).build() {
    };
    var GetBucketVersioningCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetBucketVersioning", {}).n("S3Client", "GetBucketVersioningCommand").sc(GetBucketVersioning$).build() {
    };
    var GetBucketWebsiteCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetBucketWebsite", {}).n("S3Client", "GetBucketWebsiteCommand").sc(GetBucketWebsite$).build() {
    };
    var GetObjectAclCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      Bucket: { type: "contextParams", name: "Bucket" },
      Key: { type: "contextParams", name: "Key" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetObjectAcl", {}).n("S3Client", "GetObjectAclCommand").sc(GetObjectAcl$).build() {
    };
    var GetObjectAttributesCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config),
        middlewareSsec.getSsecPlugin(config)
      ];
    }).s("AmazonS3", "GetObjectAttributes", {}).n("S3Client", "GetObjectAttributesCommand").sc(GetObjectAttributes$).build() {
    };
    var GetObjectCommand2 = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      Bucket: { type: "contextParams", name: "Bucket" },
      Key: { type: "contextParams", name: "Key" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
          requestChecksumRequired: false,
          requestValidationModeMember: "ChecksumMode",
          "responseAlgorithms": ["CRC64NVME", "CRC32", "CRC32C", "SHA256", "SHA1"]
        }),
        middlewareSsec.getSsecPlugin(config),
        middlewareSdkS3.getS3ExpiresMiddlewarePlugin(config)
      ];
    }).s("AmazonS3", "GetObject", {}).n("S3Client", "GetObjectCommand").sc(GetObject$).build() {
    };
    var GetObjectLegalHoldCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetObjectLegalHold", {}).n("S3Client", "GetObjectLegalHoldCommand").sc(GetObjectLegalHold$).build() {
    };
    var GetObjectLockConfigurationCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetObjectLockConfiguration", {}).n("S3Client", "GetObjectLockConfigurationCommand").sc(GetObjectLockConfiguration$).build() {
    };
    var GetObjectRetentionCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetObjectRetention", {}).n("S3Client", "GetObjectRetentionCommand").sc(GetObjectRetention$).build() {
    };
    var GetObjectTaggingCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetObjectTagging", {}).n("S3Client", "GetObjectTaggingCommand").sc(GetObjectTagging$).build() {
    };
    var GetObjectTorrentCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
    }).s("AmazonS3", "GetObjectTorrent", {}).n("S3Client", "GetObjectTorrentCommand").sc(GetObjectTorrent$).build() {
    };
    var GetPublicAccessBlockCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "GetPublicAccessBlock", {}).n("S3Client", "GetPublicAccessBlockCommand").sc(GetPublicAccessBlock$).build() {
    };
    var HeadBucketCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "HeadBucket", {}).n("S3Client", "HeadBucketCommand").sc(HeadBucket$).build() {
    };
    var HeadObjectCommand2 = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      Bucket: { type: "contextParams", name: "Bucket" },
      Key: { type: "contextParams", name: "Key" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config),
        middlewareSsec.getSsecPlugin(config),
        middlewareSdkS3.getS3ExpiresMiddlewarePlugin(config)
      ];
    }).s("AmazonS3", "HeadObject", {}).n("S3Client", "HeadObjectCommand").sc(HeadObject$).build() {
    };
    var ListBucketAnalyticsConfigurationsCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "ListBucketAnalyticsConfigurations", {}).n("S3Client", "ListBucketAnalyticsConfigurationsCommand").sc(ListBucketAnalyticsConfigurations$).build() {
    };
    var ListBucketIntelligentTieringConfigurationsCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "ListBucketIntelligentTieringConfigurations", {}).n("S3Client", "ListBucketIntelligentTieringConfigurationsCommand").sc(ListBucketIntelligentTieringConfigurations$).build() {
    };
    var ListBucketInventoryConfigurationsCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "ListBucketInventoryConfigurations", {}).n("S3Client", "ListBucketInventoryConfigurationsCommand").sc(ListBucketInventoryConfigurations$).build() {
    };
    var ListBucketMetricsConfigurationsCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "ListBucketMetricsConfigurations", {}).n("S3Client", "ListBucketMetricsConfigurationsCommand").sc(ListBucketMetricsConfigurations$).build() {
    };
    var ListBucketsCommand = class extends smithyClient.Command.classBuilder().ep(commonParams4).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "ListBuckets", {}).n("S3Client", "ListBucketsCommand").sc(ListBuckets$).build() {
    };
    var ListDirectoryBucketsCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "ListDirectoryBuckets", {}).n("S3Client", "ListDirectoryBucketsCommand").sc(ListDirectoryBuckets$).build() {
    };
    var ListMultipartUploadsCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      Bucket: { type: "contextParams", name: "Bucket" },
      Prefix: { type: "contextParams", name: "Prefix" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "ListMultipartUploads", {}).n("S3Client", "ListMultipartUploadsCommand").sc(ListMultipartUploads$).build() {
    };
    var ListObjectsCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      Bucket: { type: "contextParams", name: "Bucket" },
      Prefix: { type: "contextParams", name: "Prefix" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "ListObjects", {}).n("S3Client", "ListObjectsCommand").sc(ListObjects$).build() {
    };
    var ListObjectsV2Command2 = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      Bucket: { type: "contextParams", name: "Bucket" },
      Prefix: { type: "contextParams", name: "Prefix" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "ListObjectsV2", {}).n("S3Client", "ListObjectsV2Command").sc(ListObjectsV2$).build() {
    };
    var ListObjectVersionsCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      Bucket: { type: "contextParams", name: "Bucket" },
      Prefix: { type: "contextParams", name: "Prefix" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "ListObjectVersions", {}).n("S3Client", "ListObjectVersionsCommand").sc(ListObjectVersions$).build() {
    };
    var ListPartsCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      Bucket: { type: "contextParams", name: "Bucket" },
      Key: { type: "contextParams", name: "Key" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config),
        middlewareSsec.getSsecPlugin(config)
      ];
    }).s("AmazonS3", "ListParts", {}).n("S3Client", "ListPartsCommand").sc(ListParts$).build() {
    };
    var PutBucketAbacCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { "httpHeader": "x-amz-sdk-checksum-algorithm", "name": "ChecksumAlgorithm" },
          requestChecksumRequired: false
        })
      ];
    }).s("AmazonS3", "PutBucketAbac", {}).n("S3Client", "PutBucketAbacCommand").sc(PutBucketAbac$).build() {
    };
    var PutBucketAccelerateConfigurationCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { "httpHeader": "x-amz-sdk-checksum-algorithm", "name": "ChecksumAlgorithm" },
          requestChecksumRequired: false
        })
      ];
    }).s("AmazonS3", "PutBucketAccelerateConfiguration", {}).n("S3Client", "PutBucketAccelerateConfigurationCommand").sc(PutBucketAccelerateConfiguration$).build() {
    };
    var PutBucketAclCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { "httpHeader": "x-amz-sdk-checksum-algorithm", "name": "ChecksumAlgorithm" },
          requestChecksumRequired: true
        })
      ];
    }).s("AmazonS3", "PutBucketAcl", {}).n("S3Client", "PutBucketAclCommand").sc(PutBucketAcl$).build() {
    };
    var PutBucketAnalyticsConfigurationCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
    }).s("AmazonS3", "PutBucketAnalyticsConfiguration", {}).n("S3Client", "PutBucketAnalyticsConfigurationCommand").sc(PutBucketAnalyticsConfiguration$).build() {
    };
    var PutBucketCorsCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { "httpHeader": "x-amz-sdk-checksum-algorithm", "name": "ChecksumAlgorithm" },
          requestChecksumRequired: true
        })
      ];
    }).s("AmazonS3", "PutBucketCors", {}).n("S3Client", "PutBucketCorsCommand").sc(PutBucketCors$).build() {
    };
    var PutBucketEncryptionCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { "httpHeader": "x-amz-sdk-checksum-algorithm", "name": "ChecksumAlgorithm" },
          requestChecksumRequired: true
        })
      ];
    }).s("AmazonS3", "PutBucketEncryption", {}).n("S3Client", "PutBucketEncryptionCommand").sc(PutBucketEncryption$).build() {
    };
    var PutBucketIntelligentTieringConfigurationCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
    }).s("AmazonS3", "PutBucketIntelligentTieringConfiguration", {}).n("S3Client", "PutBucketIntelligentTieringConfigurationCommand").sc(PutBucketIntelligentTieringConfiguration$).build() {
    };
    var PutBucketInventoryConfigurationCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
    }).s("AmazonS3", "PutBucketInventoryConfiguration", {}).n("S3Client", "PutBucketInventoryConfigurationCommand").sc(PutBucketInventoryConfiguration$).build() {
    };
    var PutBucketLifecycleConfigurationCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { "httpHeader": "x-amz-sdk-checksum-algorithm", "name": "ChecksumAlgorithm" },
          requestChecksumRequired: true
        }),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "PutBucketLifecycleConfiguration", {}).n("S3Client", "PutBucketLifecycleConfigurationCommand").sc(PutBucketLifecycleConfiguration$).build() {
    };
    var PutBucketLoggingCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { "httpHeader": "x-amz-sdk-checksum-algorithm", "name": "ChecksumAlgorithm" },
          requestChecksumRequired: true
        })
      ];
    }).s("AmazonS3", "PutBucketLogging", {}).n("S3Client", "PutBucketLoggingCommand").sc(PutBucketLogging$).build() {
    };
    var PutBucketMetricsConfigurationCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
    }).s("AmazonS3", "PutBucketMetricsConfiguration", {}).n("S3Client", "PutBucketMetricsConfigurationCommand").sc(PutBucketMetricsConfiguration$).build() {
    };
    var PutBucketNotificationConfigurationCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
    }).s("AmazonS3", "PutBucketNotificationConfiguration", {}).n("S3Client", "PutBucketNotificationConfigurationCommand").sc(PutBucketNotificationConfiguration$).build() {
    };
    var PutBucketOwnershipControlsCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { "httpHeader": "x-amz-sdk-checksum-algorithm", "name": "ChecksumAlgorithm" },
          requestChecksumRequired: true
        })
      ];
    }).s("AmazonS3", "PutBucketOwnershipControls", {}).n("S3Client", "PutBucketOwnershipControlsCommand").sc(PutBucketOwnershipControls$).build() {
    };
    var PutBucketPolicyCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { "httpHeader": "x-amz-sdk-checksum-algorithm", "name": "ChecksumAlgorithm" },
          requestChecksumRequired: true
        })
      ];
    }).s("AmazonS3", "PutBucketPolicy", {}).n("S3Client", "PutBucketPolicyCommand").sc(PutBucketPolicy$).build() {
    };
    var PutBucketReplicationCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { "httpHeader": "x-amz-sdk-checksum-algorithm", "name": "ChecksumAlgorithm" },
          requestChecksumRequired: true
        })
      ];
    }).s("AmazonS3", "PutBucketReplication", {}).n("S3Client", "PutBucketReplicationCommand").sc(PutBucketReplication$).build() {
    };
    var PutBucketRequestPaymentCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { "httpHeader": "x-amz-sdk-checksum-algorithm", "name": "ChecksumAlgorithm" },
          requestChecksumRequired: true
        })
      ];
    }).s("AmazonS3", "PutBucketRequestPayment", {}).n("S3Client", "PutBucketRequestPaymentCommand").sc(PutBucketRequestPayment$).build() {
    };
    var PutBucketTaggingCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { "httpHeader": "x-amz-sdk-checksum-algorithm", "name": "ChecksumAlgorithm" },
          requestChecksumRequired: true
        })
      ];
    }).s("AmazonS3", "PutBucketTagging", {}).n("S3Client", "PutBucketTaggingCommand").sc(PutBucketTagging$).build() {
    };
    var PutBucketVersioningCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { "httpHeader": "x-amz-sdk-checksum-algorithm", "name": "ChecksumAlgorithm" },
          requestChecksumRequired: true
        })
      ];
    }).s("AmazonS3", "PutBucketVersioning", {}).n("S3Client", "PutBucketVersioningCommand").sc(PutBucketVersioning$).build() {
    };
    var PutBucketWebsiteCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { "httpHeader": "x-amz-sdk-checksum-algorithm", "name": "ChecksumAlgorithm" },
          requestChecksumRequired: true
        })
      ];
    }).s("AmazonS3", "PutBucketWebsite", {}).n("S3Client", "PutBucketWebsiteCommand").sc(PutBucketWebsite$).build() {
    };
    var PutObjectAclCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      Bucket: { type: "contextParams", name: "Bucket" },
      Key: { type: "contextParams", name: "Key" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { "httpHeader": "x-amz-sdk-checksum-algorithm", "name": "ChecksumAlgorithm" },
          requestChecksumRequired: true
        }),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "PutObjectAcl", {}).n("S3Client", "PutObjectAclCommand").sc(PutObjectAcl$).build() {
    };
    var PutObjectCommand2 = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      Bucket: { type: "contextParams", name: "Bucket" },
      Key: { type: "contextParams", name: "Key" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { "httpHeader": "x-amz-sdk-checksum-algorithm", "name": "ChecksumAlgorithm" },
          requestChecksumRequired: false
        }),
        middlewareSdkS3.getCheckContentLengthHeaderPlugin(config),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config),
        middlewareSsec.getSsecPlugin(config)
      ];
    }).s("AmazonS3", "PutObject", {}).n("S3Client", "PutObjectCommand").sc(PutObject$).build() {
    };
    var PutObjectLegalHoldCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { "httpHeader": "x-amz-sdk-checksum-algorithm", "name": "ChecksumAlgorithm" },
          requestChecksumRequired: true
        }),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "PutObjectLegalHold", {}).n("S3Client", "PutObjectLegalHoldCommand").sc(PutObjectLegalHold$).build() {
    };
    var PutObjectLockConfigurationCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { "httpHeader": "x-amz-sdk-checksum-algorithm", "name": "ChecksumAlgorithm" },
          requestChecksumRequired: true
        }),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "PutObjectLockConfiguration", {}).n("S3Client", "PutObjectLockConfigurationCommand").sc(PutObjectLockConfiguration$).build() {
    };
    var PutObjectRetentionCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { "httpHeader": "x-amz-sdk-checksum-algorithm", "name": "ChecksumAlgorithm" },
          requestChecksumRequired: true
        }),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "PutObjectRetention", {}).n("S3Client", "PutObjectRetentionCommand").sc(PutObjectRetention$).build() {
    };
    var PutObjectTaggingCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { "httpHeader": "x-amz-sdk-checksum-algorithm", "name": "ChecksumAlgorithm" },
          requestChecksumRequired: true
        }),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "PutObjectTagging", {}).n("S3Client", "PutObjectTaggingCommand").sc(PutObjectTagging$).build() {
    };
    var PutPublicAccessBlockCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { "httpHeader": "x-amz-sdk-checksum-algorithm", "name": "ChecksumAlgorithm" },
          requestChecksumRequired: true
        })
      ];
    }).s("AmazonS3", "PutPublicAccessBlock", {}).n("S3Client", "PutPublicAccessBlockCommand").sc(PutPublicAccessBlock$).build() {
    };
    var RenameObjectCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      Bucket: { type: "contextParams", name: "Bucket" },
      Key: { type: "contextParams", name: "Key" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "RenameObject", {}).n("S3Client", "RenameObjectCommand").sc(RenameObject$).build() {
    };
    var RestoreObjectCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { "httpHeader": "x-amz-sdk-checksum-algorithm", "name": "ChecksumAlgorithm" },
          requestChecksumRequired: false
        }),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config)
      ];
    }).s("AmazonS3", "RestoreObject", {}).n("S3Client", "RestoreObjectCommand").sc(RestoreObject$).build() {
    };
    var SelectObjectContentCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config),
        middlewareSsec.getSsecPlugin(config)
      ];
    }).s("AmazonS3", "SelectObjectContent", {
      eventStream: {
        output: true
      }
    }).n("S3Client", "SelectObjectContentCommand").sc(SelectObjectContent$).build() {
    };
    var UpdateBucketMetadataInventoryTableConfigurationCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { "httpHeader": "x-amz-sdk-checksum-algorithm", "name": "ChecksumAlgorithm" },
          requestChecksumRequired: true
        })
      ];
    }).s("AmazonS3", "UpdateBucketMetadataInventoryTableConfiguration", {}).n("S3Client", "UpdateBucketMetadataInventoryTableConfigurationCommand").sc(UpdateBucketMetadataInventoryTableConfiguration$).build() {
    };
    var UpdateBucketMetadataJournalTableConfigurationCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseS3ExpressControlEndpoint: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { "httpHeader": "x-amz-sdk-checksum-algorithm", "name": "ChecksumAlgorithm" },
          requestChecksumRequired: true
        })
      ];
    }).s("AmazonS3", "UpdateBucketMetadataJournalTableConfiguration", {}).n("S3Client", "UpdateBucketMetadataJournalTableConfigurationCommand").sc(UpdateBucketMetadataJournalTableConfiguration$).build() {
    };
    var UploadPartCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      Bucket: { type: "contextParams", name: "Bucket" },
      Key: { type: "contextParams", name: "Key" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareFlexibleChecksums.getFlexibleChecksumsPlugin(config, {
          requestAlgorithmMember: { "httpHeader": "x-amz-sdk-checksum-algorithm", "name": "ChecksumAlgorithm" },
          requestChecksumRequired: false
        }),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config),
        middlewareSsec.getSsecPlugin(config)
      ];
    }).s("AmazonS3", "UploadPart", {}).n("S3Client", "UploadPartCommand").sc(UploadPart$).build() {
    };
    var UploadPartCopyCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      DisableS3ExpressSessionAuth: { type: "staticContextParams", value: true },
      Bucket: { type: "contextParams", name: "Bucket" }
    }).m(function(Command, cs, config, o4) {
      return [
        middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions()),
        middlewareSdkS3.getThrow200ExceptionsPlugin(config),
        middlewareSsec.getSsecPlugin(config)
      ];
    }).s("AmazonS3", "UploadPartCopy", {}).n("S3Client", "UploadPartCopyCommand").sc(UploadPartCopy$).build() {
    };
    var WriteGetObjectResponseCommand = class extends smithyClient.Command.classBuilder().ep({
      ...commonParams4,
      UseObjectLambdaEndpoint: { type: "staticContextParams", value: true }
    }).m(function(Command, cs, config, o4) {
      return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
    }).s("AmazonS3", "WriteGetObjectResponse", {}).n("S3Client", "WriteGetObjectResponseCommand").sc(WriteGetObjectResponse$).build() {
    };
    var commands4 = {
      AbortMultipartUploadCommand,
      CompleteMultipartUploadCommand,
      CopyObjectCommand: CopyObjectCommand2,
      CreateBucketCommand,
      CreateBucketMetadataConfigurationCommand,
      CreateBucketMetadataTableConfigurationCommand,
      CreateMultipartUploadCommand,
      CreateSessionCommand,
      DeleteBucketCommand,
      DeleteBucketAnalyticsConfigurationCommand,
      DeleteBucketCorsCommand,
      DeleteBucketEncryptionCommand,
      DeleteBucketIntelligentTieringConfigurationCommand,
      DeleteBucketInventoryConfigurationCommand,
      DeleteBucketLifecycleCommand,
      DeleteBucketMetadataConfigurationCommand,
      DeleteBucketMetadataTableConfigurationCommand,
      DeleteBucketMetricsConfigurationCommand,
      DeleteBucketOwnershipControlsCommand,
      DeleteBucketPolicyCommand,
      DeleteBucketReplicationCommand,
      DeleteBucketTaggingCommand,
      DeleteBucketWebsiteCommand,
      DeleteObjectCommand: DeleteObjectCommand2,
      DeleteObjectsCommand: DeleteObjectsCommand2,
      DeleteObjectTaggingCommand,
      DeletePublicAccessBlockCommand,
      GetBucketAbacCommand,
      GetBucketAccelerateConfigurationCommand,
      GetBucketAclCommand,
      GetBucketAnalyticsConfigurationCommand,
      GetBucketCorsCommand,
      GetBucketEncryptionCommand,
      GetBucketIntelligentTieringConfigurationCommand,
      GetBucketInventoryConfigurationCommand,
      GetBucketLifecycleConfigurationCommand,
      GetBucketLocationCommand,
      GetBucketLoggingCommand,
      GetBucketMetadataConfigurationCommand,
      GetBucketMetadataTableConfigurationCommand,
      GetBucketMetricsConfigurationCommand,
      GetBucketNotificationConfigurationCommand,
      GetBucketOwnershipControlsCommand,
      GetBucketPolicyCommand,
      GetBucketPolicyStatusCommand,
      GetBucketReplicationCommand,
      GetBucketRequestPaymentCommand,
      GetBucketTaggingCommand,
      GetBucketVersioningCommand,
      GetBucketWebsiteCommand,
      GetObjectCommand: GetObjectCommand2,
      GetObjectAclCommand,
      GetObjectAttributesCommand,
      GetObjectLegalHoldCommand,
      GetObjectLockConfigurationCommand,
      GetObjectRetentionCommand,
      GetObjectTaggingCommand,
      GetObjectTorrentCommand,
      GetPublicAccessBlockCommand,
      HeadBucketCommand,
      HeadObjectCommand: HeadObjectCommand2,
      ListBucketAnalyticsConfigurationsCommand,
      ListBucketIntelligentTieringConfigurationsCommand,
      ListBucketInventoryConfigurationsCommand,
      ListBucketMetricsConfigurationsCommand,
      ListBucketsCommand,
      ListDirectoryBucketsCommand,
      ListMultipartUploadsCommand,
      ListObjectsCommand,
      ListObjectsV2Command: ListObjectsV2Command2,
      ListObjectVersionsCommand,
      ListPartsCommand,
      PutBucketAbacCommand,
      PutBucketAccelerateConfigurationCommand,
      PutBucketAclCommand,
      PutBucketAnalyticsConfigurationCommand,
      PutBucketCorsCommand,
      PutBucketEncryptionCommand,
      PutBucketIntelligentTieringConfigurationCommand,
      PutBucketInventoryConfigurationCommand,
      PutBucketLifecycleConfigurationCommand,
      PutBucketLoggingCommand,
      PutBucketMetricsConfigurationCommand,
      PutBucketNotificationConfigurationCommand,
      PutBucketOwnershipControlsCommand,
      PutBucketPolicyCommand,
      PutBucketReplicationCommand,
      PutBucketRequestPaymentCommand,
      PutBucketTaggingCommand,
      PutBucketVersioningCommand,
      PutBucketWebsiteCommand,
      PutObjectCommand: PutObjectCommand2,
      PutObjectAclCommand,
      PutObjectLegalHoldCommand,
      PutObjectLockConfigurationCommand,
      PutObjectRetentionCommand,
      PutObjectTaggingCommand,
      PutPublicAccessBlockCommand,
      RenameObjectCommand,
      RestoreObjectCommand,
      SelectObjectContentCommand,
      UpdateBucketMetadataInventoryTableConfigurationCommand,
      UpdateBucketMetadataJournalTableConfigurationCommand,
      UploadPartCommand,
      UploadPartCopyCommand,
      WriteGetObjectResponseCommand
    };
    var S3 = class extends S3Client2 {
    };
    smithyClient.createAggregatedClient(commands4, S3);
    var paginateListBuckets = core.createPaginator(S3Client2, ListBucketsCommand, "ContinuationToken", "ContinuationToken", "MaxBuckets");
    var paginateListDirectoryBuckets = core.createPaginator(S3Client2, ListDirectoryBucketsCommand, "ContinuationToken", "ContinuationToken", "MaxDirectoryBuckets");
    var paginateListObjectsV2 = core.createPaginator(S3Client2, ListObjectsV2Command2, "ContinuationToken", "NextContinuationToken", "MaxKeys");
    var paginateListParts = core.createPaginator(S3Client2, ListPartsCommand, "PartNumberMarker", "NextPartNumberMarker", "MaxParts");
    var checkState$3 = async (client2, input) => {
      let reason;
      try {
        let result = await client2.send(new HeadBucketCommand(input));
        reason = result;
        return { state: utilWaiter.WaiterState.SUCCESS, reason };
      } catch (exception) {
        reason = exception;
        if (exception.name && exception.name == "NotFound") {
          return { state: utilWaiter.WaiterState.RETRY, reason };
        }
      }
      return { state: utilWaiter.WaiterState.RETRY, reason };
    };
    var waitForBucketExists = async (params, input) => {
      const serviceDefaults = { minDelay: 5, maxDelay: 120 };
      return utilWaiter.createWaiter({ ...serviceDefaults, ...params }, input, checkState$3);
    };
    var waitUntilBucketExists = async (params, input) => {
      const serviceDefaults = { minDelay: 5, maxDelay: 120 };
      const result = await utilWaiter.createWaiter({ ...serviceDefaults, ...params }, input, checkState$3);
      return utilWaiter.checkExceptions(result);
    };
    var checkState$2 = async (client2, input) => {
      let reason;
      try {
        let result = await client2.send(new HeadBucketCommand(input));
        reason = result;
      } catch (exception) {
        reason = exception;
        if (exception.name && exception.name == "NotFound") {
          return { state: utilWaiter.WaiterState.SUCCESS, reason };
        }
      }
      return { state: utilWaiter.WaiterState.RETRY, reason };
    };
    var waitForBucketNotExists = async (params, input) => {
      const serviceDefaults = { minDelay: 5, maxDelay: 120 };
      return utilWaiter.createWaiter({ ...serviceDefaults, ...params }, input, checkState$2);
    };
    var waitUntilBucketNotExists = async (params, input) => {
      const serviceDefaults = { minDelay: 5, maxDelay: 120 };
      const result = await utilWaiter.createWaiter({ ...serviceDefaults, ...params }, input, checkState$2);
      return utilWaiter.checkExceptions(result);
    };
    var checkState$1 = async (client2, input) => {
      let reason;
      try {
        let result = await client2.send(new HeadObjectCommand2(input));
        reason = result;
        return { state: utilWaiter.WaiterState.SUCCESS, reason };
      } catch (exception) {
        reason = exception;
        if (exception.name && exception.name == "NotFound") {
          return { state: utilWaiter.WaiterState.RETRY, reason };
        }
      }
      return { state: utilWaiter.WaiterState.RETRY, reason };
    };
    var waitForObjectExists = async (params, input) => {
      const serviceDefaults = { minDelay: 5, maxDelay: 120 };
      return utilWaiter.createWaiter({ ...serviceDefaults, ...params }, input, checkState$1);
    };
    var waitUntilObjectExists = async (params, input) => {
      const serviceDefaults = { minDelay: 5, maxDelay: 120 };
      const result = await utilWaiter.createWaiter({ ...serviceDefaults, ...params }, input, checkState$1);
      return utilWaiter.checkExceptions(result);
    };
    var checkState = async (client2, input) => {
      let reason;
      try {
        let result = await client2.send(new HeadObjectCommand2(input));
        reason = result;
      } catch (exception) {
        reason = exception;
        if (exception.name && exception.name == "NotFound") {
          return { state: utilWaiter.WaiterState.SUCCESS, reason };
        }
      }
      return { state: utilWaiter.WaiterState.RETRY, reason };
    };
    var waitForObjectNotExists = async (params, input) => {
      const serviceDefaults = { minDelay: 5, maxDelay: 120 };
      return utilWaiter.createWaiter({ ...serviceDefaults, ...params }, input, checkState);
    };
    var waitUntilObjectNotExists = async (params, input) => {
      const serviceDefaults = { minDelay: 5, maxDelay: 120 };
      const result = await utilWaiter.createWaiter({ ...serviceDefaults, ...params }, input, checkState);
      return utilWaiter.checkExceptions(result);
    };
    var BucketAbacStatus = {
      Disabled: "Disabled",
      Enabled: "Enabled"
    };
    var RequestCharged = {
      requester: "requester"
    };
    var RequestPayer = {
      requester: "requester"
    };
    var BucketAccelerateStatus = {
      Enabled: "Enabled",
      Suspended: "Suspended"
    };
    var Type = {
      AmazonCustomerByEmail: "AmazonCustomerByEmail",
      CanonicalUser: "CanonicalUser",
      Group: "Group"
    };
    var Permission = {
      FULL_CONTROL: "FULL_CONTROL",
      READ: "READ",
      READ_ACP: "READ_ACP",
      WRITE: "WRITE",
      WRITE_ACP: "WRITE_ACP"
    };
    var OwnerOverride = {
      Destination: "Destination"
    };
    var ChecksumType = {
      COMPOSITE: "COMPOSITE",
      FULL_OBJECT: "FULL_OBJECT"
    };
    var ServerSideEncryption = {
      AES256: "AES256",
      aws_fsx: "aws:fsx",
      aws_kms: "aws:kms",
      aws_kms_dsse: "aws:kms:dsse"
    };
    var ObjectCannedACL = {
      authenticated_read: "authenticated-read",
      aws_exec_read: "aws-exec-read",
      bucket_owner_full_control: "bucket-owner-full-control",
      bucket_owner_read: "bucket-owner-read",
      private: "private",
      public_read: "public-read",
      public_read_write: "public-read-write"
    };
    var ChecksumAlgorithm = {
      CRC32: "CRC32",
      CRC32C: "CRC32C",
      CRC64NVME: "CRC64NVME",
      SHA1: "SHA1",
      SHA256: "SHA256"
    };
    var MetadataDirective = {
      COPY: "COPY",
      REPLACE: "REPLACE"
    };
    var ObjectLockLegalHoldStatus = {
      OFF: "OFF",
      ON: "ON"
    };
    var ObjectLockMode = {
      COMPLIANCE: "COMPLIANCE",
      GOVERNANCE: "GOVERNANCE"
    };
    var StorageClass = {
      DEEP_ARCHIVE: "DEEP_ARCHIVE",
      EXPRESS_ONEZONE: "EXPRESS_ONEZONE",
      FSX_ONTAP: "FSX_ONTAP",
      FSX_OPENZFS: "FSX_OPENZFS",
      GLACIER: "GLACIER",
      GLACIER_IR: "GLACIER_IR",
      INTELLIGENT_TIERING: "INTELLIGENT_TIERING",
      ONEZONE_IA: "ONEZONE_IA",
      OUTPOSTS: "OUTPOSTS",
      REDUCED_REDUNDANCY: "REDUCED_REDUNDANCY",
      SNOW: "SNOW",
      STANDARD: "STANDARD",
      STANDARD_IA: "STANDARD_IA"
    };
    var TaggingDirective = {
      COPY: "COPY",
      REPLACE: "REPLACE"
    };
    var BucketCannedACL = {
      authenticated_read: "authenticated-read",
      private: "private",
      public_read: "public-read",
      public_read_write: "public-read-write"
    };
    var DataRedundancy = {
      SingleAvailabilityZone: "SingleAvailabilityZone",
      SingleLocalZone: "SingleLocalZone"
    };
    var BucketType = {
      Directory: "Directory"
    };
    var LocationType = {
      AvailabilityZone: "AvailabilityZone",
      LocalZone: "LocalZone"
    };
    var BucketLocationConstraint = {
      EU: "EU",
      af_south_1: "af-south-1",
      ap_east_1: "ap-east-1",
      ap_northeast_1: "ap-northeast-1",
      ap_northeast_2: "ap-northeast-2",
      ap_northeast_3: "ap-northeast-3",
      ap_south_1: "ap-south-1",
      ap_south_2: "ap-south-2",
      ap_southeast_1: "ap-southeast-1",
      ap_southeast_2: "ap-southeast-2",
      ap_southeast_3: "ap-southeast-3",
      ap_southeast_4: "ap-southeast-4",
      ap_southeast_5: "ap-southeast-5",
      ca_central_1: "ca-central-1",
      cn_north_1: "cn-north-1",
      cn_northwest_1: "cn-northwest-1",
      eu_central_1: "eu-central-1",
      eu_central_2: "eu-central-2",
      eu_north_1: "eu-north-1",
      eu_south_1: "eu-south-1",
      eu_south_2: "eu-south-2",
      eu_west_1: "eu-west-1",
      eu_west_2: "eu-west-2",
      eu_west_3: "eu-west-3",
      il_central_1: "il-central-1",
      me_central_1: "me-central-1",
      me_south_1: "me-south-1",
      sa_east_1: "sa-east-1",
      us_east_2: "us-east-2",
      us_gov_east_1: "us-gov-east-1",
      us_gov_west_1: "us-gov-west-1",
      us_west_1: "us-west-1",
      us_west_2: "us-west-2"
    };
    var ObjectOwnership = {
      BucketOwnerEnforced: "BucketOwnerEnforced",
      BucketOwnerPreferred: "BucketOwnerPreferred",
      ObjectWriter: "ObjectWriter"
    };
    var InventoryConfigurationState = {
      DISABLED: "DISABLED",
      ENABLED: "ENABLED"
    };
    var TableSseAlgorithm = {
      AES256: "AES256",
      aws_kms: "aws:kms"
    };
    var ExpirationState = {
      DISABLED: "DISABLED",
      ENABLED: "ENABLED"
    };
    var SessionMode = {
      ReadOnly: "ReadOnly",
      ReadWrite: "ReadWrite"
    };
    var AnalyticsS3ExportFileFormat = {
      CSV: "CSV"
    };
    var StorageClassAnalysisSchemaVersion = {
      V_1: "V_1"
    };
    var EncryptionType = {
      NONE: "NONE",
      SSE_C: "SSE-C"
    };
    var IntelligentTieringStatus = {
      Disabled: "Disabled",
      Enabled: "Enabled"
    };
    var IntelligentTieringAccessTier = {
      ARCHIVE_ACCESS: "ARCHIVE_ACCESS",
      DEEP_ARCHIVE_ACCESS: "DEEP_ARCHIVE_ACCESS"
    };
    var InventoryFormat = {
      CSV: "CSV",
      ORC: "ORC",
      Parquet: "Parquet"
    };
    var InventoryIncludedObjectVersions = {
      All: "All",
      Current: "Current"
    };
    var InventoryOptionalField = {
      BucketKeyStatus: "BucketKeyStatus",
      ChecksumAlgorithm: "ChecksumAlgorithm",
      ETag: "ETag",
      EncryptionStatus: "EncryptionStatus",
      IntelligentTieringAccessTier: "IntelligentTieringAccessTier",
      IsMultipartUploaded: "IsMultipartUploaded",
      LastModifiedDate: "LastModifiedDate",
      LifecycleExpirationDate: "LifecycleExpirationDate",
      ObjectAccessControlList: "ObjectAccessControlList",
      ObjectLockLegalHoldStatus: "ObjectLockLegalHoldStatus",
      ObjectLockMode: "ObjectLockMode",
      ObjectLockRetainUntilDate: "ObjectLockRetainUntilDate",
      ObjectOwner: "ObjectOwner",
      ReplicationStatus: "ReplicationStatus",
      Size: "Size",
      StorageClass: "StorageClass"
    };
    var InventoryFrequency = {
      Daily: "Daily",
      Weekly: "Weekly"
    };
    var TransitionStorageClass = {
      DEEP_ARCHIVE: "DEEP_ARCHIVE",
      GLACIER: "GLACIER",
      GLACIER_IR: "GLACIER_IR",
      INTELLIGENT_TIERING: "INTELLIGENT_TIERING",
      ONEZONE_IA: "ONEZONE_IA",
      STANDARD_IA: "STANDARD_IA"
    };
    var ExpirationStatus = {
      Disabled: "Disabled",
      Enabled: "Enabled"
    };
    var TransitionDefaultMinimumObjectSize = {
      all_storage_classes_128K: "all_storage_classes_128K",
      varies_by_storage_class: "varies_by_storage_class"
    };
    var BucketLogsPermission = {
      FULL_CONTROL: "FULL_CONTROL",
      READ: "READ",
      WRITE: "WRITE"
    };
    var PartitionDateSource = {
      DeliveryTime: "DeliveryTime",
      EventTime: "EventTime"
    };
    var S3TablesBucketType = {
      aws: "aws",
      customer: "customer"
    };
    var Event2 = {
      s3_IntelligentTiering: "s3:IntelligentTiering",
      s3_LifecycleExpiration_: "s3:LifecycleExpiration:*",
      s3_LifecycleExpiration_Delete: "s3:LifecycleExpiration:Delete",
      s3_LifecycleExpiration_DeleteMarkerCreated: "s3:LifecycleExpiration:DeleteMarkerCreated",
      s3_LifecycleTransition: "s3:LifecycleTransition",
      s3_ObjectAcl_Put: "s3:ObjectAcl:Put",
      s3_ObjectCreated_: "s3:ObjectCreated:*",
      s3_ObjectCreated_CompleteMultipartUpload: "s3:ObjectCreated:CompleteMultipartUpload",
      s3_ObjectCreated_Copy: "s3:ObjectCreated:Copy",
      s3_ObjectCreated_Post: "s3:ObjectCreated:Post",
      s3_ObjectCreated_Put: "s3:ObjectCreated:Put",
      s3_ObjectRemoved_: "s3:ObjectRemoved:*",
      s3_ObjectRemoved_Delete: "s3:ObjectRemoved:Delete",
      s3_ObjectRemoved_DeleteMarkerCreated: "s3:ObjectRemoved:DeleteMarkerCreated",
      s3_ObjectRestore_: "s3:ObjectRestore:*",
      s3_ObjectRestore_Completed: "s3:ObjectRestore:Completed",
      s3_ObjectRestore_Delete: "s3:ObjectRestore:Delete",
      s3_ObjectRestore_Post: "s3:ObjectRestore:Post",
      s3_ObjectTagging_: "s3:ObjectTagging:*",
      s3_ObjectTagging_Delete: "s3:ObjectTagging:Delete",
      s3_ObjectTagging_Put: "s3:ObjectTagging:Put",
      s3_ReducedRedundancyLostObject: "s3:ReducedRedundancyLostObject",
      s3_Replication_: "s3:Replication:*",
      s3_Replication_OperationFailedReplication: "s3:Replication:OperationFailedReplication",
      s3_Replication_OperationMissedThreshold: "s3:Replication:OperationMissedThreshold",
      s3_Replication_OperationNotTracked: "s3:Replication:OperationNotTracked",
      s3_Replication_OperationReplicatedAfterThreshold: "s3:Replication:OperationReplicatedAfterThreshold"
    };
    var FilterRuleName = {
      prefix: "prefix",
      suffix: "suffix"
    };
    var DeleteMarkerReplicationStatus = {
      Disabled: "Disabled",
      Enabled: "Enabled"
    };
    var MetricsStatus = {
      Disabled: "Disabled",
      Enabled: "Enabled"
    };
    var ReplicationTimeStatus = {
      Disabled: "Disabled",
      Enabled: "Enabled"
    };
    var ExistingObjectReplicationStatus = {
      Disabled: "Disabled",
      Enabled: "Enabled"
    };
    var ReplicaModificationsStatus = {
      Disabled: "Disabled",
      Enabled: "Enabled"
    };
    var SseKmsEncryptedObjectsStatus = {
      Disabled: "Disabled",
      Enabled: "Enabled"
    };
    var ReplicationRuleStatus = {
      Disabled: "Disabled",
      Enabled: "Enabled"
    };
    var Payer = {
      BucketOwner: "BucketOwner",
      Requester: "Requester"
    };
    var MFADeleteStatus = {
      Disabled: "Disabled",
      Enabled: "Enabled"
    };
    var BucketVersioningStatus = {
      Enabled: "Enabled",
      Suspended: "Suspended"
    };
    var Protocol = {
      http: "http",
      https: "https"
    };
    var ReplicationStatus = {
      COMPLETE: "COMPLETE",
      COMPLETED: "COMPLETED",
      FAILED: "FAILED",
      PENDING: "PENDING",
      REPLICA: "REPLICA"
    };
    var ChecksumMode = {
      ENABLED: "ENABLED"
    };
    var ObjectAttributes = {
      CHECKSUM: "Checksum",
      ETAG: "ETag",
      OBJECT_PARTS: "ObjectParts",
      OBJECT_SIZE: "ObjectSize",
      STORAGE_CLASS: "StorageClass"
    };
    var ObjectLockEnabled = {
      Enabled: "Enabled"
    };
    var ObjectLockRetentionMode = {
      COMPLIANCE: "COMPLIANCE",
      GOVERNANCE: "GOVERNANCE"
    };
    var ArchiveStatus = {
      ARCHIVE_ACCESS: "ARCHIVE_ACCESS",
      DEEP_ARCHIVE_ACCESS: "DEEP_ARCHIVE_ACCESS"
    };
    var EncodingType = {
      url: "url"
    };
    var ObjectStorageClass = {
      DEEP_ARCHIVE: "DEEP_ARCHIVE",
      EXPRESS_ONEZONE: "EXPRESS_ONEZONE",
      FSX_ONTAP: "FSX_ONTAP",
      FSX_OPENZFS: "FSX_OPENZFS",
      GLACIER: "GLACIER",
      GLACIER_IR: "GLACIER_IR",
      INTELLIGENT_TIERING: "INTELLIGENT_TIERING",
      ONEZONE_IA: "ONEZONE_IA",
      OUTPOSTS: "OUTPOSTS",
      REDUCED_REDUNDANCY: "REDUCED_REDUNDANCY",
      SNOW: "SNOW",
      STANDARD: "STANDARD",
      STANDARD_IA: "STANDARD_IA"
    };
    var OptionalObjectAttributes = {
      RESTORE_STATUS: "RestoreStatus"
    };
    var ObjectVersionStorageClass = {
      STANDARD: "STANDARD"
    };
    var MFADelete = {
      Disabled: "Disabled",
      Enabled: "Enabled"
    };
    var Tier = {
      Bulk: "Bulk",
      Expedited: "Expedited",
      Standard: "Standard"
    };
    var ExpressionType = {
      SQL: "SQL"
    };
    var CompressionType = {
      BZIP2: "BZIP2",
      GZIP: "GZIP",
      NONE: "NONE"
    };
    var FileHeaderInfo = {
      IGNORE: "IGNORE",
      NONE: "NONE",
      USE: "USE"
    };
    var JSONType = {
      DOCUMENT: "DOCUMENT",
      LINES: "LINES"
    };
    var QuoteFields = {
      ALWAYS: "ALWAYS",
      ASNEEDED: "ASNEEDED"
    };
    var RestoreRequestType = {
      SELECT: "SELECT"
    };
    Object.defineProperty(exports2, "$Command", {
      enumerable: true,
      get: function() {
        return smithyClient.Command;
      }
    });
    Object.defineProperty(exports2, "__Client", {
      enumerable: true,
      get: function() {
        return smithyClient.Client;
      }
    });
    exports2.AbacStatus$ = AbacStatus$;
    exports2.AbortIncompleteMultipartUpload$ = AbortIncompleteMultipartUpload$;
    exports2.AbortMultipartUpload$ = AbortMultipartUpload$;
    exports2.AbortMultipartUploadCommand = AbortMultipartUploadCommand;
    exports2.AbortMultipartUploadOutput$ = AbortMultipartUploadOutput$;
    exports2.AbortMultipartUploadRequest$ = AbortMultipartUploadRequest$;
    exports2.AccelerateConfiguration$ = AccelerateConfiguration$;
    exports2.AccessControlPolicy$ = AccessControlPolicy$;
    exports2.AccessControlTranslation$ = AccessControlTranslation$;
    exports2.AnalyticsAndOperator$ = AnalyticsAndOperator$;
    exports2.AnalyticsConfiguration$ = AnalyticsConfiguration$;
    exports2.AnalyticsExportDestination$ = AnalyticsExportDestination$;
    exports2.AnalyticsFilter$ = AnalyticsFilter$;
    exports2.AnalyticsS3BucketDestination$ = AnalyticsS3BucketDestination$;
    exports2.AnalyticsS3ExportFileFormat = AnalyticsS3ExportFileFormat;
    exports2.ArchiveStatus = ArchiveStatus;
    exports2.BlockedEncryptionTypes$ = BlockedEncryptionTypes$;
    exports2.Bucket$ = Bucket$;
    exports2.BucketAbacStatus = BucketAbacStatus;
    exports2.BucketAccelerateStatus = BucketAccelerateStatus;
    exports2.BucketAlreadyExists = BucketAlreadyExists;
    exports2.BucketAlreadyExists$ = BucketAlreadyExists$;
    exports2.BucketAlreadyOwnedByYou = BucketAlreadyOwnedByYou;
    exports2.BucketAlreadyOwnedByYou$ = BucketAlreadyOwnedByYou$;
    exports2.BucketCannedACL = BucketCannedACL;
    exports2.BucketInfo$ = BucketInfo$;
    exports2.BucketLifecycleConfiguration$ = BucketLifecycleConfiguration$;
    exports2.BucketLocationConstraint = BucketLocationConstraint;
    exports2.BucketLoggingStatus$ = BucketLoggingStatus$;
    exports2.BucketLogsPermission = BucketLogsPermission;
    exports2.BucketType = BucketType;
    exports2.BucketVersioningStatus = BucketVersioningStatus;
    exports2.CORSConfiguration$ = CORSConfiguration$;
    exports2.CORSRule$ = CORSRule$;
    exports2.CSVInput$ = CSVInput$;
    exports2.CSVOutput$ = CSVOutput$;
    exports2.Checksum$ = Checksum$;
    exports2.ChecksumAlgorithm = ChecksumAlgorithm;
    exports2.ChecksumMode = ChecksumMode;
    exports2.ChecksumType = ChecksumType;
    exports2.CommonPrefix$ = CommonPrefix$;
    exports2.CompleteMultipartUpload$ = CompleteMultipartUpload$;
    exports2.CompleteMultipartUploadCommand = CompleteMultipartUploadCommand;
    exports2.CompleteMultipartUploadOutput$ = CompleteMultipartUploadOutput$;
    exports2.CompleteMultipartUploadRequest$ = CompleteMultipartUploadRequest$;
    exports2.CompletedMultipartUpload$ = CompletedMultipartUpload$;
    exports2.CompletedPart$ = CompletedPart$;
    exports2.CompressionType = CompressionType;
    exports2.Condition$ = Condition$;
    exports2.ContinuationEvent$ = ContinuationEvent$;
    exports2.CopyObject$ = CopyObject$;
    exports2.CopyObjectCommand = CopyObjectCommand2;
    exports2.CopyObjectOutput$ = CopyObjectOutput$;
    exports2.CopyObjectRequest$ = CopyObjectRequest$;
    exports2.CopyObjectResult$ = CopyObjectResult$;
    exports2.CopyPartResult$ = CopyPartResult$;
    exports2.CreateBucket$ = CreateBucket$;
    exports2.CreateBucketCommand = CreateBucketCommand;
    exports2.CreateBucketConfiguration$ = CreateBucketConfiguration$;
    exports2.CreateBucketMetadataConfiguration$ = CreateBucketMetadataConfiguration$;
    exports2.CreateBucketMetadataConfigurationCommand = CreateBucketMetadataConfigurationCommand;
    exports2.CreateBucketMetadataConfigurationRequest$ = CreateBucketMetadataConfigurationRequest$;
    exports2.CreateBucketMetadataTableConfiguration$ = CreateBucketMetadataTableConfiguration$;
    exports2.CreateBucketMetadataTableConfigurationCommand = CreateBucketMetadataTableConfigurationCommand;
    exports2.CreateBucketMetadataTableConfigurationRequest$ = CreateBucketMetadataTableConfigurationRequest$;
    exports2.CreateBucketOutput$ = CreateBucketOutput$;
    exports2.CreateBucketRequest$ = CreateBucketRequest$;
    exports2.CreateMultipartUpload$ = CreateMultipartUpload$;
    exports2.CreateMultipartUploadCommand = CreateMultipartUploadCommand;
    exports2.CreateMultipartUploadOutput$ = CreateMultipartUploadOutput$;
    exports2.CreateMultipartUploadRequest$ = CreateMultipartUploadRequest$;
    exports2.CreateSession$ = CreateSession$;
    exports2.CreateSessionCommand = CreateSessionCommand;
    exports2.CreateSessionOutput$ = CreateSessionOutput$;
    exports2.CreateSessionRequest$ = CreateSessionRequest$;
    exports2.DataRedundancy = DataRedundancy;
    exports2.DefaultRetention$ = DefaultRetention$;
    exports2.Delete$ = Delete$;
    exports2.DeleteBucket$ = DeleteBucket$;
    exports2.DeleteBucketAnalyticsConfiguration$ = DeleteBucketAnalyticsConfiguration$;
    exports2.DeleteBucketAnalyticsConfigurationCommand = DeleteBucketAnalyticsConfigurationCommand;
    exports2.DeleteBucketAnalyticsConfigurationRequest$ = DeleteBucketAnalyticsConfigurationRequest$;
    exports2.DeleteBucketCommand = DeleteBucketCommand;
    exports2.DeleteBucketCors$ = DeleteBucketCors$;
    exports2.DeleteBucketCorsCommand = DeleteBucketCorsCommand;
    exports2.DeleteBucketCorsRequest$ = DeleteBucketCorsRequest$;
    exports2.DeleteBucketEncryption$ = DeleteBucketEncryption$;
    exports2.DeleteBucketEncryptionCommand = DeleteBucketEncryptionCommand;
    exports2.DeleteBucketEncryptionRequest$ = DeleteBucketEncryptionRequest$;
    exports2.DeleteBucketIntelligentTieringConfiguration$ = DeleteBucketIntelligentTieringConfiguration$;
    exports2.DeleteBucketIntelligentTieringConfigurationCommand = DeleteBucketIntelligentTieringConfigurationCommand;
    exports2.DeleteBucketIntelligentTieringConfigurationRequest$ = DeleteBucketIntelligentTieringConfigurationRequest$;
    exports2.DeleteBucketInventoryConfiguration$ = DeleteBucketInventoryConfiguration$;
    exports2.DeleteBucketInventoryConfigurationCommand = DeleteBucketInventoryConfigurationCommand;
    exports2.DeleteBucketInventoryConfigurationRequest$ = DeleteBucketInventoryConfigurationRequest$;
    exports2.DeleteBucketLifecycle$ = DeleteBucketLifecycle$;
    exports2.DeleteBucketLifecycleCommand = DeleteBucketLifecycleCommand;
    exports2.DeleteBucketLifecycleRequest$ = DeleteBucketLifecycleRequest$;
    exports2.DeleteBucketMetadataConfiguration$ = DeleteBucketMetadataConfiguration$;
    exports2.DeleteBucketMetadataConfigurationCommand = DeleteBucketMetadataConfigurationCommand;
    exports2.DeleteBucketMetadataConfigurationRequest$ = DeleteBucketMetadataConfigurationRequest$;
    exports2.DeleteBucketMetadataTableConfiguration$ = DeleteBucketMetadataTableConfiguration$;
    exports2.DeleteBucketMetadataTableConfigurationCommand = DeleteBucketMetadataTableConfigurationCommand;
    exports2.DeleteBucketMetadataTableConfigurationRequest$ = DeleteBucketMetadataTableConfigurationRequest$;
    exports2.DeleteBucketMetricsConfiguration$ = DeleteBucketMetricsConfiguration$;
    exports2.DeleteBucketMetricsConfigurationCommand = DeleteBucketMetricsConfigurationCommand;
    exports2.DeleteBucketMetricsConfigurationRequest$ = DeleteBucketMetricsConfigurationRequest$;
    exports2.DeleteBucketOwnershipControls$ = DeleteBucketOwnershipControls$;
    exports2.DeleteBucketOwnershipControlsCommand = DeleteBucketOwnershipControlsCommand;
    exports2.DeleteBucketOwnershipControlsRequest$ = DeleteBucketOwnershipControlsRequest$;
    exports2.DeleteBucketPolicy$ = DeleteBucketPolicy$;
    exports2.DeleteBucketPolicyCommand = DeleteBucketPolicyCommand;
    exports2.DeleteBucketPolicyRequest$ = DeleteBucketPolicyRequest$;
    exports2.DeleteBucketReplication$ = DeleteBucketReplication$;
    exports2.DeleteBucketReplicationCommand = DeleteBucketReplicationCommand;
    exports2.DeleteBucketReplicationRequest$ = DeleteBucketReplicationRequest$;
    exports2.DeleteBucketRequest$ = DeleteBucketRequest$;
    exports2.DeleteBucketTagging$ = DeleteBucketTagging$;
    exports2.DeleteBucketTaggingCommand = DeleteBucketTaggingCommand;
    exports2.DeleteBucketTaggingRequest$ = DeleteBucketTaggingRequest$;
    exports2.DeleteBucketWebsite$ = DeleteBucketWebsite$;
    exports2.DeleteBucketWebsiteCommand = DeleteBucketWebsiteCommand;
    exports2.DeleteBucketWebsiteRequest$ = DeleteBucketWebsiteRequest$;
    exports2.DeleteMarkerEntry$ = DeleteMarkerEntry$;
    exports2.DeleteMarkerReplication$ = DeleteMarkerReplication$;
    exports2.DeleteMarkerReplicationStatus = DeleteMarkerReplicationStatus;
    exports2.DeleteObject$ = DeleteObject$;
    exports2.DeleteObjectCommand = DeleteObjectCommand2;
    exports2.DeleteObjectOutput$ = DeleteObjectOutput$;
    exports2.DeleteObjectRequest$ = DeleteObjectRequest$;
    exports2.DeleteObjectTagging$ = DeleteObjectTagging$;
    exports2.DeleteObjectTaggingCommand = DeleteObjectTaggingCommand;
    exports2.DeleteObjectTaggingOutput$ = DeleteObjectTaggingOutput$;
    exports2.DeleteObjectTaggingRequest$ = DeleteObjectTaggingRequest$;
    exports2.DeleteObjects$ = DeleteObjects$;
    exports2.DeleteObjectsCommand = DeleteObjectsCommand2;
    exports2.DeleteObjectsOutput$ = DeleteObjectsOutput$;
    exports2.DeleteObjectsRequest$ = DeleteObjectsRequest$;
    exports2.DeletePublicAccessBlock$ = DeletePublicAccessBlock$;
    exports2.DeletePublicAccessBlockCommand = DeletePublicAccessBlockCommand;
    exports2.DeletePublicAccessBlockRequest$ = DeletePublicAccessBlockRequest$;
    exports2.DeletedObject$ = DeletedObject$;
    exports2.Destination$ = Destination$;
    exports2.DestinationResult$ = DestinationResult$;
    exports2.EncodingType = EncodingType;
    exports2.Encryption$ = Encryption$;
    exports2.EncryptionConfiguration$ = EncryptionConfiguration$;
    exports2.EncryptionType = EncryptionType;
    exports2.EncryptionTypeMismatch = EncryptionTypeMismatch;
    exports2.EncryptionTypeMismatch$ = EncryptionTypeMismatch$;
    exports2.EndEvent$ = EndEvent$;
    exports2.ErrorDetails$ = ErrorDetails$;
    exports2.ErrorDocument$ = ErrorDocument$;
    exports2.Event = Event2;
    exports2.EventBridgeConfiguration$ = EventBridgeConfiguration$;
    exports2.ExistingObjectReplication$ = ExistingObjectReplication$;
    exports2.ExistingObjectReplicationStatus = ExistingObjectReplicationStatus;
    exports2.ExpirationState = ExpirationState;
    exports2.ExpirationStatus = ExpirationStatus;
    exports2.ExpressionType = ExpressionType;
    exports2.FileHeaderInfo = FileHeaderInfo;
    exports2.FilterRule$ = FilterRule$;
    exports2.FilterRuleName = FilterRuleName;
    exports2.GetBucketAbac$ = GetBucketAbac$;
    exports2.GetBucketAbacCommand = GetBucketAbacCommand;
    exports2.GetBucketAbacOutput$ = GetBucketAbacOutput$;
    exports2.GetBucketAbacRequest$ = GetBucketAbacRequest$;
    exports2.GetBucketAccelerateConfiguration$ = GetBucketAccelerateConfiguration$;
    exports2.GetBucketAccelerateConfigurationCommand = GetBucketAccelerateConfigurationCommand;
    exports2.GetBucketAccelerateConfigurationOutput$ = GetBucketAccelerateConfigurationOutput$;
    exports2.GetBucketAccelerateConfigurationRequest$ = GetBucketAccelerateConfigurationRequest$;
    exports2.GetBucketAcl$ = GetBucketAcl$;
    exports2.GetBucketAclCommand = GetBucketAclCommand;
    exports2.GetBucketAclOutput$ = GetBucketAclOutput$;
    exports2.GetBucketAclRequest$ = GetBucketAclRequest$;
    exports2.GetBucketAnalyticsConfiguration$ = GetBucketAnalyticsConfiguration$;
    exports2.GetBucketAnalyticsConfigurationCommand = GetBucketAnalyticsConfigurationCommand;
    exports2.GetBucketAnalyticsConfigurationOutput$ = GetBucketAnalyticsConfigurationOutput$;
    exports2.GetBucketAnalyticsConfigurationRequest$ = GetBucketAnalyticsConfigurationRequest$;
    exports2.GetBucketCors$ = GetBucketCors$;
    exports2.GetBucketCorsCommand = GetBucketCorsCommand;
    exports2.GetBucketCorsOutput$ = GetBucketCorsOutput$;
    exports2.GetBucketCorsRequest$ = GetBucketCorsRequest$;
    exports2.GetBucketEncryption$ = GetBucketEncryption$;
    exports2.GetBucketEncryptionCommand = GetBucketEncryptionCommand;
    exports2.GetBucketEncryptionOutput$ = GetBucketEncryptionOutput$;
    exports2.GetBucketEncryptionRequest$ = GetBucketEncryptionRequest$;
    exports2.GetBucketIntelligentTieringConfiguration$ = GetBucketIntelligentTieringConfiguration$;
    exports2.GetBucketIntelligentTieringConfigurationCommand = GetBucketIntelligentTieringConfigurationCommand;
    exports2.GetBucketIntelligentTieringConfigurationOutput$ = GetBucketIntelligentTieringConfigurationOutput$;
    exports2.GetBucketIntelligentTieringConfigurationRequest$ = GetBucketIntelligentTieringConfigurationRequest$;
    exports2.GetBucketInventoryConfiguration$ = GetBucketInventoryConfiguration$;
    exports2.GetBucketInventoryConfigurationCommand = GetBucketInventoryConfigurationCommand;
    exports2.GetBucketInventoryConfigurationOutput$ = GetBucketInventoryConfigurationOutput$;
    exports2.GetBucketInventoryConfigurationRequest$ = GetBucketInventoryConfigurationRequest$;
    exports2.GetBucketLifecycleConfiguration$ = GetBucketLifecycleConfiguration$;
    exports2.GetBucketLifecycleConfigurationCommand = GetBucketLifecycleConfigurationCommand;
    exports2.GetBucketLifecycleConfigurationOutput$ = GetBucketLifecycleConfigurationOutput$;
    exports2.GetBucketLifecycleConfigurationRequest$ = GetBucketLifecycleConfigurationRequest$;
    exports2.GetBucketLocation$ = GetBucketLocation$;
    exports2.GetBucketLocationCommand = GetBucketLocationCommand;
    exports2.GetBucketLocationOutput$ = GetBucketLocationOutput$;
    exports2.GetBucketLocationRequest$ = GetBucketLocationRequest$;
    exports2.GetBucketLogging$ = GetBucketLogging$;
    exports2.GetBucketLoggingCommand = GetBucketLoggingCommand;
    exports2.GetBucketLoggingOutput$ = GetBucketLoggingOutput$;
    exports2.GetBucketLoggingRequest$ = GetBucketLoggingRequest$;
    exports2.GetBucketMetadataConfiguration$ = GetBucketMetadataConfiguration$;
    exports2.GetBucketMetadataConfigurationCommand = GetBucketMetadataConfigurationCommand;
    exports2.GetBucketMetadataConfigurationOutput$ = GetBucketMetadataConfigurationOutput$;
    exports2.GetBucketMetadataConfigurationRequest$ = GetBucketMetadataConfigurationRequest$;
    exports2.GetBucketMetadataConfigurationResult$ = GetBucketMetadataConfigurationResult$;
    exports2.GetBucketMetadataTableConfiguration$ = GetBucketMetadataTableConfiguration$;
    exports2.GetBucketMetadataTableConfigurationCommand = GetBucketMetadataTableConfigurationCommand;
    exports2.GetBucketMetadataTableConfigurationOutput$ = GetBucketMetadataTableConfigurationOutput$;
    exports2.GetBucketMetadataTableConfigurationRequest$ = GetBucketMetadataTableConfigurationRequest$;
    exports2.GetBucketMetadataTableConfigurationResult$ = GetBucketMetadataTableConfigurationResult$;
    exports2.GetBucketMetricsConfiguration$ = GetBucketMetricsConfiguration$;
    exports2.GetBucketMetricsConfigurationCommand = GetBucketMetricsConfigurationCommand;
    exports2.GetBucketMetricsConfigurationOutput$ = GetBucketMetricsConfigurationOutput$;
    exports2.GetBucketMetricsConfigurationRequest$ = GetBucketMetricsConfigurationRequest$;
    exports2.GetBucketNotificationConfiguration$ = GetBucketNotificationConfiguration$;
    exports2.GetBucketNotificationConfigurationCommand = GetBucketNotificationConfigurationCommand;
    exports2.GetBucketNotificationConfigurationRequest$ = GetBucketNotificationConfigurationRequest$;
    exports2.GetBucketOwnershipControls$ = GetBucketOwnershipControls$;
    exports2.GetBucketOwnershipControlsCommand = GetBucketOwnershipControlsCommand;
    exports2.GetBucketOwnershipControlsOutput$ = GetBucketOwnershipControlsOutput$;
    exports2.GetBucketOwnershipControlsRequest$ = GetBucketOwnershipControlsRequest$;
    exports2.GetBucketPolicy$ = GetBucketPolicy$;
    exports2.GetBucketPolicyCommand = GetBucketPolicyCommand;
    exports2.GetBucketPolicyOutput$ = GetBucketPolicyOutput$;
    exports2.GetBucketPolicyRequest$ = GetBucketPolicyRequest$;
    exports2.GetBucketPolicyStatus$ = GetBucketPolicyStatus$;
    exports2.GetBucketPolicyStatusCommand = GetBucketPolicyStatusCommand;
    exports2.GetBucketPolicyStatusOutput$ = GetBucketPolicyStatusOutput$;
    exports2.GetBucketPolicyStatusRequest$ = GetBucketPolicyStatusRequest$;
    exports2.GetBucketReplication$ = GetBucketReplication$;
    exports2.GetBucketReplicationCommand = GetBucketReplicationCommand;
    exports2.GetBucketReplicationOutput$ = GetBucketReplicationOutput$;
    exports2.GetBucketReplicationRequest$ = GetBucketReplicationRequest$;
    exports2.GetBucketRequestPayment$ = GetBucketRequestPayment$;
    exports2.GetBucketRequestPaymentCommand = GetBucketRequestPaymentCommand;
    exports2.GetBucketRequestPaymentOutput$ = GetBucketRequestPaymentOutput$;
    exports2.GetBucketRequestPaymentRequest$ = GetBucketRequestPaymentRequest$;
    exports2.GetBucketTagging$ = GetBucketTagging$;
    exports2.GetBucketTaggingCommand = GetBucketTaggingCommand;
    exports2.GetBucketTaggingOutput$ = GetBucketTaggingOutput$;
    exports2.GetBucketTaggingRequest$ = GetBucketTaggingRequest$;
    exports2.GetBucketVersioning$ = GetBucketVersioning$;
    exports2.GetBucketVersioningCommand = GetBucketVersioningCommand;
    exports2.GetBucketVersioningOutput$ = GetBucketVersioningOutput$;
    exports2.GetBucketVersioningRequest$ = GetBucketVersioningRequest$;
    exports2.GetBucketWebsite$ = GetBucketWebsite$;
    exports2.GetBucketWebsiteCommand = GetBucketWebsiteCommand;
    exports2.GetBucketWebsiteOutput$ = GetBucketWebsiteOutput$;
    exports2.GetBucketWebsiteRequest$ = GetBucketWebsiteRequest$;
    exports2.GetObject$ = GetObject$;
    exports2.GetObjectAcl$ = GetObjectAcl$;
    exports2.GetObjectAclCommand = GetObjectAclCommand;
    exports2.GetObjectAclOutput$ = GetObjectAclOutput$;
    exports2.GetObjectAclRequest$ = GetObjectAclRequest$;
    exports2.GetObjectAttributes$ = GetObjectAttributes$;
    exports2.GetObjectAttributesCommand = GetObjectAttributesCommand;
    exports2.GetObjectAttributesOutput$ = GetObjectAttributesOutput$;
    exports2.GetObjectAttributesParts$ = GetObjectAttributesParts$;
    exports2.GetObjectAttributesRequest$ = GetObjectAttributesRequest$;
    exports2.GetObjectCommand = GetObjectCommand2;
    exports2.GetObjectLegalHold$ = GetObjectLegalHold$;
    exports2.GetObjectLegalHoldCommand = GetObjectLegalHoldCommand;
    exports2.GetObjectLegalHoldOutput$ = GetObjectLegalHoldOutput$;
    exports2.GetObjectLegalHoldRequest$ = GetObjectLegalHoldRequest$;
    exports2.GetObjectLockConfiguration$ = GetObjectLockConfiguration$;
    exports2.GetObjectLockConfigurationCommand = GetObjectLockConfigurationCommand;
    exports2.GetObjectLockConfigurationOutput$ = GetObjectLockConfigurationOutput$;
    exports2.GetObjectLockConfigurationRequest$ = GetObjectLockConfigurationRequest$;
    exports2.GetObjectOutput$ = GetObjectOutput$;
    exports2.GetObjectRequest$ = GetObjectRequest$;
    exports2.GetObjectRetention$ = GetObjectRetention$;
    exports2.GetObjectRetentionCommand = GetObjectRetentionCommand;
    exports2.GetObjectRetentionOutput$ = GetObjectRetentionOutput$;
    exports2.GetObjectRetentionRequest$ = GetObjectRetentionRequest$;
    exports2.GetObjectTagging$ = GetObjectTagging$;
    exports2.GetObjectTaggingCommand = GetObjectTaggingCommand;
    exports2.GetObjectTaggingOutput$ = GetObjectTaggingOutput$;
    exports2.GetObjectTaggingRequest$ = GetObjectTaggingRequest$;
    exports2.GetObjectTorrent$ = GetObjectTorrent$;
    exports2.GetObjectTorrentCommand = GetObjectTorrentCommand;
    exports2.GetObjectTorrentOutput$ = GetObjectTorrentOutput$;
    exports2.GetObjectTorrentRequest$ = GetObjectTorrentRequest$;
    exports2.GetPublicAccessBlock$ = GetPublicAccessBlock$;
    exports2.GetPublicAccessBlockCommand = GetPublicAccessBlockCommand;
    exports2.GetPublicAccessBlockOutput$ = GetPublicAccessBlockOutput$;
    exports2.GetPublicAccessBlockRequest$ = GetPublicAccessBlockRequest$;
    exports2.GlacierJobParameters$ = GlacierJobParameters$;
    exports2.Grant$ = Grant$;
    exports2.Grantee$ = Grantee$;
    exports2.HeadBucket$ = HeadBucket$;
    exports2.HeadBucketCommand = HeadBucketCommand;
    exports2.HeadBucketOutput$ = HeadBucketOutput$;
    exports2.HeadBucketRequest$ = HeadBucketRequest$;
    exports2.HeadObject$ = HeadObject$;
    exports2.HeadObjectCommand = HeadObjectCommand2;
    exports2.HeadObjectOutput$ = HeadObjectOutput$;
    exports2.HeadObjectRequest$ = HeadObjectRequest$;
    exports2.IdempotencyParameterMismatch = IdempotencyParameterMismatch;
    exports2.IdempotencyParameterMismatch$ = IdempotencyParameterMismatch$;
    exports2.IndexDocument$ = IndexDocument$;
    exports2.Initiator$ = Initiator$;
    exports2.InputSerialization$ = InputSerialization$;
    exports2.IntelligentTieringAccessTier = IntelligentTieringAccessTier;
    exports2.IntelligentTieringAndOperator$ = IntelligentTieringAndOperator$;
    exports2.IntelligentTieringConfiguration$ = IntelligentTieringConfiguration$;
    exports2.IntelligentTieringFilter$ = IntelligentTieringFilter$;
    exports2.IntelligentTieringStatus = IntelligentTieringStatus;
    exports2.InvalidObjectState = InvalidObjectState;
    exports2.InvalidObjectState$ = InvalidObjectState$;
    exports2.InvalidRequest = InvalidRequest;
    exports2.InvalidRequest$ = InvalidRequest$;
    exports2.InvalidWriteOffset = InvalidWriteOffset;
    exports2.InvalidWriteOffset$ = InvalidWriteOffset$;
    exports2.InventoryConfiguration$ = InventoryConfiguration$;
    exports2.InventoryConfigurationState = InventoryConfigurationState;
    exports2.InventoryDestination$ = InventoryDestination$;
    exports2.InventoryEncryption$ = InventoryEncryption$;
    exports2.InventoryFilter$ = InventoryFilter$;
    exports2.InventoryFormat = InventoryFormat;
    exports2.InventoryFrequency = InventoryFrequency;
    exports2.InventoryIncludedObjectVersions = InventoryIncludedObjectVersions;
    exports2.InventoryOptionalField = InventoryOptionalField;
    exports2.InventoryS3BucketDestination$ = InventoryS3BucketDestination$;
    exports2.InventorySchedule$ = InventorySchedule$;
    exports2.InventoryTableConfiguration$ = InventoryTableConfiguration$;
    exports2.InventoryTableConfigurationResult$ = InventoryTableConfigurationResult$;
    exports2.InventoryTableConfigurationUpdates$ = InventoryTableConfigurationUpdates$;
    exports2.JSONInput$ = JSONInput$;
    exports2.JSONOutput$ = JSONOutput$;
    exports2.JSONType = JSONType;
    exports2.JournalTableConfiguration$ = JournalTableConfiguration$;
    exports2.JournalTableConfigurationResult$ = JournalTableConfigurationResult$;
    exports2.JournalTableConfigurationUpdates$ = JournalTableConfigurationUpdates$;
    exports2.LambdaFunctionConfiguration$ = LambdaFunctionConfiguration$;
    exports2.LifecycleExpiration$ = LifecycleExpiration$;
    exports2.LifecycleRule$ = LifecycleRule$;
    exports2.LifecycleRuleAndOperator$ = LifecycleRuleAndOperator$;
    exports2.LifecycleRuleFilter$ = LifecycleRuleFilter$;
    exports2.ListBucketAnalyticsConfigurations$ = ListBucketAnalyticsConfigurations$;
    exports2.ListBucketAnalyticsConfigurationsCommand = ListBucketAnalyticsConfigurationsCommand;
    exports2.ListBucketAnalyticsConfigurationsOutput$ = ListBucketAnalyticsConfigurationsOutput$;
    exports2.ListBucketAnalyticsConfigurationsRequest$ = ListBucketAnalyticsConfigurationsRequest$;
    exports2.ListBucketIntelligentTieringConfigurations$ = ListBucketIntelligentTieringConfigurations$;
    exports2.ListBucketIntelligentTieringConfigurationsCommand = ListBucketIntelligentTieringConfigurationsCommand;
    exports2.ListBucketIntelligentTieringConfigurationsOutput$ = ListBucketIntelligentTieringConfigurationsOutput$;
    exports2.ListBucketIntelligentTieringConfigurationsRequest$ = ListBucketIntelligentTieringConfigurationsRequest$;
    exports2.ListBucketInventoryConfigurations$ = ListBucketInventoryConfigurations$;
    exports2.ListBucketInventoryConfigurationsCommand = ListBucketInventoryConfigurationsCommand;
    exports2.ListBucketInventoryConfigurationsOutput$ = ListBucketInventoryConfigurationsOutput$;
    exports2.ListBucketInventoryConfigurationsRequest$ = ListBucketInventoryConfigurationsRequest$;
    exports2.ListBucketMetricsConfigurations$ = ListBucketMetricsConfigurations$;
    exports2.ListBucketMetricsConfigurationsCommand = ListBucketMetricsConfigurationsCommand;
    exports2.ListBucketMetricsConfigurationsOutput$ = ListBucketMetricsConfigurationsOutput$;
    exports2.ListBucketMetricsConfigurationsRequest$ = ListBucketMetricsConfigurationsRequest$;
    exports2.ListBuckets$ = ListBuckets$;
    exports2.ListBucketsCommand = ListBucketsCommand;
    exports2.ListBucketsOutput$ = ListBucketsOutput$;
    exports2.ListBucketsRequest$ = ListBucketsRequest$;
    exports2.ListDirectoryBuckets$ = ListDirectoryBuckets$;
    exports2.ListDirectoryBucketsCommand = ListDirectoryBucketsCommand;
    exports2.ListDirectoryBucketsOutput$ = ListDirectoryBucketsOutput$;
    exports2.ListDirectoryBucketsRequest$ = ListDirectoryBucketsRequest$;
    exports2.ListMultipartUploads$ = ListMultipartUploads$;
    exports2.ListMultipartUploadsCommand = ListMultipartUploadsCommand;
    exports2.ListMultipartUploadsOutput$ = ListMultipartUploadsOutput$;
    exports2.ListMultipartUploadsRequest$ = ListMultipartUploadsRequest$;
    exports2.ListObjectVersions$ = ListObjectVersions$;
    exports2.ListObjectVersionsCommand = ListObjectVersionsCommand;
    exports2.ListObjectVersionsOutput$ = ListObjectVersionsOutput$;
    exports2.ListObjectVersionsRequest$ = ListObjectVersionsRequest$;
    exports2.ListObjects$ = ListObjects$;
    exports2.ListObjectsCommand = ListObjectsCommand;
    exports2.ListObjectsOutput$ = ListObjectsOutput$;
    exports2.ListObjectsRequest$ = ListObjectsRequest$;
    exports2.ListObjectsV2$ = ListObjectsV2$;
    exports2.ListObjectsV2Command = ListObjectsV2Command2;
    exports2.ListObjectsV2Output$ = ListObjectsV2Output$;
    exports2.ListObjectsV2Request$ = ListObjectsV2Request$;
    exports2.ListParts$ = ListParts$;
    exports2.ListPartsCommand = ListPartsCommand;
    exports2.ListPartsOutput$ = ListPartsOutput$;
    exports2.ListPartsRequest$ = ListPartsRequest$;
    exports2.LocationInfo$ = LocationInfo$;
    exports2.LocationType = LocationType;
    exports2.LoggingEnabled$ = LoggingEnabled$;
    exports2.MFADelete = MFADelete;
    exports2.MFADeleteStatus = MFADeleteStatus;
    exports2.MetadataConfiguration$ = MetadataConfiguration$;
    exports2.MetadataConfigurationResult$ = MetadataConfigurationResult$;
    exports2.MetadataDirective = MetadataDirective;
    exports2.MetadataEntry$ = MetadataEntry$;
    exports2.MetadataTableConfiguration$ = MetadataTableConfiguration$;
    exports2.MetadataTableConfigurationResult$ = MetadataTableConfigurationResult$;
    exports2.MetadataTableEncryptionConfiguration$ = MetadataTableEncryptionConfiguration$;
    exports2.Metrics$ = Metrics$;
    exports2.MetricsAndOperator$ = MetricsAndOperator$;
    exports2.MetricsConfiguration$ = MetricsConfiguration$;
    exports2.MetricsFilter$ = MetricsFilter$;
    exports2.MetricsStatus = MetricsStatus;
    exports2.MultipartUpload$ = MultipartUpload$;
    exports2.NoSuchBucket = NoSuchBucket2;
    exports2.NoSuchBucket$ = NoSuchBucket$;
    exports2.NoSuchKey = NoSuchKey2;
    exports2.NoSuchKey$ = NoSuchKey$;
    exports2.NoSuchUpload = NoSuchUpload;
    exports2.NoSuchUpload$ = NoSuchUpload$;
    exports2.NoncurrentVersionExpiration$ = NoncurrentVersionExpiration$;
    exports2.NoncurrentVersionTransition$ = NoncurrentVersionTransition$;
    exports2.NotFound = NotFound;
    exports2.NotFound$ = NotFound$;
    exports2.NotificationConfiguration$ = NotificationConfiguration$;
    exports2.NotificationConfigurationFilter$ = NotificationConfigurationFilter$;
    exports2.ObjectAlreadyInActiveTierError = ObjectAlreadyInActiveTierError;
    exports2.ObjectAlreadyInActiveTierError$ = ObjectAlreadyInActiveTierError$;
    exports2.ObjectAttributes = ObjectAttributes;
    exports2.ObjectCannedACL = ObjectCannedACL;
    exports2.ObjectIdentifier$ = ObjectIdentifier$;
    exports2.ObjectLockConfiguration$ = ObjectLockConfiguration$;
    exports2.ObjectLockEnabled = ObjectLockEnabled;
    exports2.ObjectLockLegalHold$ = ObjectLockLegalHold$;
    exports2.ObjectLockLegalHoldStatus = ObjectLockLegalHoldStatus;
    exports2.ObjectLockMode = ObjectLockMode;
    exports2.ObjectLockRetention$ = ObjectLockRetention$;
    exports2.ObjectLockRetentionMode = ObjectLockRetentionMode;
    exports2.ObjectLockRule$ = ObjectLockRule$;
    exports2.ObjectNotInActiveTierError = ObjectNotInActiveTierError;
    exports2.ObjectNotInActiveTierError$ = ObjectNotInActiveTierError$;
    exports2.ObjectOwnership = ObjectOwnership;
    exports2.ObjectPart$ = ObjectPart$;
    exports2.ObjectStorageClass = ObjectStorageClass;
    exports2.ObjectVersion$ = ObjectVersion$;
    exports2.ObjectVersionStorageClass = ObjectVersionStorageClass;
    exports2.OptionalObjectAttributes = OptionalObjectAttributes;
    exports2.OutputLocation$ = OutputLocation$;
    exports2.OutputSerialization$ = OutputSerialization$;
    exports2.Owner$ = Owner$;
    exports2.OwnerOverride = OwnerOverride;
    exports2.OwnershipControls$ = OwnershipControls$;
    exports2.OwnershipControlsRule$ = OwnershipControlsRule$;
    exports2.ParquetInput$ = ParquetInput$;
    exports2.Part$ = Part$;
    exports2.PartitionDateSource = PartitionDateSource;
    exports2.PartitionedPrefix$ = PartitionedPrefix$;
    exports2.Payer = Payer;
    exports2.Permission = Permission;
    exports2.PolicyStatus$ = PolicyStatus$;
    exports2.Progress$ = Progress$;
    exports2.ProgressEvent$ = ProgressEvent$;
    exports2.Protocol = Protocol;
    exports2.PublicAccessBlockConfiguration$ = PublicAccessBlockConfiguration$;
    exports2.PutBucketAbac$ = PutBucketAbac$;
    exports2.PutBucketAbacCommand = PutBucketAbacCommand;
    exports2.PutBucketAbacRequest$ = PutBucketAbacRequest$;
    exports2.PutBucketAccelerateConfiguration$ = PutBucketAccelerateConfiguration$;
    exports2.PutBucketAccelerateConfigurationCommand = PutBucketAccelerateConfigurationCommand;
    exports2.PutBucketAccelerateConfigurationRequest$ = PutBucketAccelerateConfigurationRequest$;
    exports2.PutBucketAcl$ = PutBucketAcl$;
    exports2.PutBucketAclCommand = PutBucketAclCommand;
    exports2.PutBucketAclRequest$ = PutBucketAclRequest$;
    exports2.PutBucketAnalyticsConfiguration$ = PutBucketAnalyticsConfiguration$;
    exports2.PutBucketAnalyticsConfigurationCommand = PutBucketAnalyticsConfigurationCommand;
    exports2.PutBucketAnalyticsConfigurationRequest$ = PutBucketAnalyticsConfigurationRequest$;
    exports2.PutBucketCors$ = PutBucketCors$;
    exports2.PutBucketCorsCommand = PutBucketCorsCommand;
    exports2.PutBucketCorsRequest$ = PutBucketCorsRequest$;
    exports2.PutBucketEncryption$ = PutBucketEncryption$;
    exports2.PutBucketEncryptionCommand = PutBucketEncryptionCommand;
    exports2.PutBucketEncryptionRequest$ = PutBucketEncryptionRequest$;
    exports2.PutBucketIntelligentTieringConfiguration$ = PutBucketIntelligentTieringConfiguration$;
    exports2.PutBucketIntelligentTieringConfigurationCommand = PutBucketIntelligentTieringConfigurationCommand;
    exports2.PutBucketIntelligentTieringConfigurationRequest$ = PutBucketIntelligentTieringConfigurationRequest$;
    exports2.PutBucketInventoryConfiguration$ = PutBucketInventoryConfiguration$;
    exports2.PutBucketInventoryConfigurationCommand = PutBucketInventoryConfigurationCommand;
    exports2.PutBucketInventoryConfigurationRequest$ = PutBucketInventoryConfigurationRequest$;
    exports2.PutBucketLifecycleConfiguration$ = PutBucketLifecycleConfiguration$;
    exports2.PutBucketLifecycleConfigurationCommand = PutBucketLifecycleConfigurationCommand;
    exports2.PutBucketLifecycleConfigurationOutput$ = PutBucketLifecycleConfigurationOutput$;
    exports2.PutBucketLifecycleConfigurationRequest$ = PutBucketLifecycleConfigurationRequest$;
    exports2.PutBucketLogging$ = PutBucketLogging$;
    exports2.PutBucketLoggingCommand = PutBucketLoggingCommand;
    exports2.PutBucketLoggingRequest$ = PutBucketLoggingRequest$;
    exports2.PutBucketMetricsConfiguration$ = PutBucketMetricsConfiguration$;
    exports2.PutBucketMetricsConfigurationCommand = PutBucketMetricsConfigurationCommand;
    exports2.PutBucketMetricsConfigurationRequest$ = PutBucketMetricsConfigurationRequest$;
    exports2.PutBucketNotificationConfiguration$ = PutBucketNotificationConfiguration$;
    exports2.PutBucketNotificationConfigurationCommand = PutBucketNotificationConfigurationCommand;
    exports2.PutBucketNotificationConfigurationRequest$ = PutBucketNotificationConfigurationRequest$;
    exports2.PutBucketOwnershipControls$ = PutBucketOwnershipControls$;
    exports2.PutBucketOwnershipControlsCommand = PutBucketOwnershipControlsCommand;
    exports2.PutBucketOwnershipControlsRequest$ = PutBucketOwnershipControlsRequest$;
    exports2.PutBucketPolicy$ = PutBucketPolicy$;
    exports2.PutBucketPolicyCommand = PutBucketPolicyCommand;
    exports2.PutBucketPolicyRequest$ = PutBucketPolicyRequest$;
    exports2.PutBucketReplication$ = PutBucketReplication$;
    exports2.PutBucketReplicationCommand = PutBucketReplicationCommand;
    exports2.PutBucketReplicationRequest$ = PutBucketReplicationRequest$;
    exports2.PutBucketRequestPayment$ = PutBucketRequestPayment$;
    exports2.PutBucketRequestPaymentCommand = PutBucketRequestPaymentCommand;
    exports2.PutBucketRequestPaymentRequest$ = PutBucketRequestPaymentRequest$;
    exports2.PutBucketTagging$ = PutBucketTagging$;
    exports2.PutBucketTaggingCommand = PutBucketTaggingCommand;
    exports2.PutBucketTaggingRequest$ = PutBucketTaggingRequest$;
    exports2.PutBucketVersioning$ = PutBucketVersioning$;
    exports2.PutBucketVersioningCommand = PutBucketVersioningCommand;
    exports2.PutBucketVersioningRequest$ = PutBucketVersioningRequest$;
    exports2.PutBucketWebsite$ = PutBucketWebsite$;
    exports2.PutBucketWebsiteCommand = PutBucketWebsiteCommand;
    exports2.PutBucketWebsiteRequest$ = PutBucketWebsiteRequest$;
    exports2.PutObject$ = PutObject$;
    exports2.PutObjectAcl$ = PutObjectAcl$;
    exports2.PutObjectAclCommand = PutObjectAclCommand;
    exports2.PutObjectAclOutput$ = PutObjectAclOutput$;
    exports2.PutObjectAclRequest$ = PutObjectAclRequest$;
    exports2.PutObjectCommand = PutObjectCommand2;
    exports2.PutObjectLegalHold$ = PutObjectLegalHold$;
    exports2.PutObjectLegalHoldCommand = PutObjectLegalHoldCommand;
    exports2.PutObjectLegalHoldOutput$ = PutObjectLegalHoldOutput$;
    exports2.PutObjectLegalHoldRequest$ = PutObjectLegalHoldRequest$;
    exports2.PutObjectLockConfiguration$ = PutObjectLockConfiguration$;
    exports2.PutObjectLockConfigurationCommand = PutObjectLockConfigurationCommand;
    exports2.PutObjectLockConfigurationOutput$ = PutObjectLockConfigurationOutput$;
    exports2.PutObjectLockConfigurationRequest$ = PutObjectLockConfigurationRequest$;
    exports2.PutObjectOutput$ = PutObjectOutput$;
    exports2.PutObjectRequest$ = PutObjectRequest$;
    exports2.PutObjectRetention$ = PutObjectRetention$;
    exports2.PutObjectRetentionCommand = PutObjectRetentionCommand;
    exports2.PutObjectRetentionOutput$ = PutObjectRetentionOutput$;
    exports2.PutObjectRetentionRequest$ = PutObjectRetentionRequest$;
    exports2.PutObjectTagging$ = PutObjectTagging$;
    exports2.PutObjectTaggingCommand = PutObjectTaggingCommand;
    exports2.PutObjectTaggingOutput$ = PutObjectTaggingOutput$;
    exports2.PutObjectTaggingRequest$ = PutObjectTaggingRequest$;
    exports2.PutPublicAccessBlock$ = PutPublicAccessBlock$;
    exports2.PutPublicAccessBlockCommand = PutPublicAccessBlockCommand;
    exports2.PutPublicAccessBlockRequest$ = PutPublicAccessBlockRequest$;
    exports2.QueueConfiguration$ = QueueConfiguration$;
    exports2.QuoteFields = QuoteFields;
    exports2.RecordExpiration$ = RecordExpiration$;
    exports2.RecordsEvent$ = RecordsEvent$;
    exports2.Redirect$ = Redirect$;
    exports2.RedirectAllRequestsTo$ = RedirectAllRequestsTo$;
    exports2.RenameObject$ = RenameObject$;
    exports2.RenameObjectCommand = RenameObjectCommand;
    exports2.RenameObjectOutput$ = RenameObjectOutput$;
    exports2.RenameObjectRequest$ = RenameObjectRequest$;
    exports2.ReplicaModifications$ = ReplicaModifications$;
    exports2.ReplicaModificationsStatus = ReplicaModificationsStatus;
    exports2.ReplicationConfiguration$ = ReplicationConfiguration$;
    exports2.ReplicationRule$ = ReplicationRule$;
    exports2.ReplicationRuleAndOperator$ = ReplicationRuleAndOperator$;
    exports2.ReplicationRuleFilter$ = ReplicationRuleFilter$;
    exports2.ReplicationRuleStatus = ReplicationRuleStatus;
    exports2.ReplicationStatus = ReplicationStatus;
    exports2.ReplicationTime$ = ReplicationTime$;
    exports2.ReplicationTimeStatus = ReplicationTimeStatus;
    exports2.ReplicationTimeValue$ = ReplicationTimeValue$;
    exports2.RequestCharged = RequestCharged;
    exports2.RequestPayer = RequestPayer;
    exports2.RequestPaymentConfiguration$ = RequestPaymentConfiguration$;
    exports2.RequestProgress$ = RequestProgress$;
    exports2.RestoreObject$ = RestoreObject$;
    exports2.RestoreObjectCommand = RestoreObjectCommand;
    exports2.RestoreObjectOutput$ = RestoreObjectOutput$;
    exports2.RestoreObjectRequest$ = RestoreObjectRequest$;
    exports2.RestoreRequest$ = RestoreRequest$;
    exports2.RestoreRequestType = RestoreRequestType;
    exports2.RestoreStatus$ = RestoreStatus$;
    exports2.RoutingRule$ = RoutingRule$;
    exports2.S3 = S3;
    exports2.S3Client = S3Client2;
    exports2.S3KeyFilter$ = S3KeyFilter$;
    exports2.S3Location$ = S3Location$;
    exports2.S3ServiceException = S3ServiceException;
    exports2.S3ServiceException$ = S3ServiceException$;
    exports2.S3TablesBucketType = S3TablesBucketType;
    exports2.S3TablesDestination$ = S3TablesDestination$;
    exports2.S3TablesDestinationResult$ = S3TablesDestinationResult$;
    exports2.SSEKMS$ = SSEKMS$;
    exports2.SSES3$ = SSES3$;
    exports2.ScanRange$ = ScanRange$;
    exports2.SelectObjectContent$ = SelectObjectContent$;
    exports2.SelectObjectContentCommand = SelectObjectContentCommand;
    exports2.SelectObjectContentEventStream$ = SelectObjectContentEventStream$;
    exports2.SelectObjectContentOutput$ = SelectObjectContentOutput$;
    exports2.SelectObjectContentRequest$ = SelectObjectContentRequest$;
    exports2.SelectParameters$ = SelectParameters$;
    exports2.ServerSideEncryption = ServerSideEncryption;
    exports2.ServerSideEncryptionByDefault$ = ServerSideEncryptionByDefault$;
    exports2.ServerSideEncryptionConfiguration$ = ServerSideEncryptionConfiguration$;
    exports2.ServerSideEncryptionRule$ = ServerSideEncryptionRule$;
    exports2.SessionCredentials$ = SessionCredentials$;
    exports2.SessionMode = SessionMode;
    exports2.SimplePrefix$ = SimplePrefix$;
    exports2.SourceSelectionCriteria$ = SourceSelectionCriteria$;
    exports2.SseKmsEncryptedObjects$ = SseKmsEncryptedObjects$;
    exports2.SseKmsEncryptedObjectsStatus = SseKmsEncryptedObjectsStatus;
    exports2.Stats$ = Stats$;
    exports2.StatsEvent$ = StatsEvent$;
    exports2.StorageClass = StorageClass;
    exports2.StorageClassAnalysis$ = StorageClassAnalysis$;
    exports2.StorageClassAnalysisDataExport$ = StorageClassAnalysisDataExport$;
    exports2.StorageClassAnalysisSchemaVersion = StorageClassAnalysisSchemaVersion;
    exports2.TableSseAlgorithm = TableSseAlgorithm;
    exports2.Tag$ = Tag$2;
    exports2.Tagging$ = Tagging$;
    exports2.TaggingDirective = TaggingDirective;
    exports2.TargetGrant$ = TargetGrant$;
    exports2.TargetObjectKeyFormat$ = TargetObjectKeyFormat$;
    exports2.Tier = Tier;
    exports2.Tiering$ = Tiering$;
    exports2.TooManyParts = TooManyParts;
    exports2.TooManyParts$ = TooManyParts$;
    exports2.TopicConfiguration$ = TopicConfiguration$;
    exports2.Transition$ = Transition$;
    exports2.TransitionDefaultMinimumObjectSize = TransitionDefaultMinimumObjectSize;
    exports2.TransitionStorageClass = TransitionStorageClass;
    exports2.Type = Type;
    exports2.UpdateBucketMetadataInventoryTableConfiguration$ = UpdateBucketMetadataInventoryTableConfiguration$;
    exports2.UpdateBucketMetadataInventoryTableConfigurationCommand = UpdateBucketMetadataInventoryTableConfigurationCommand;
    exports2.UpdateBucketMetadataInventoryTableConfigurationRequest$ = UpdateBucketMetadataInventoryTableConfigurationRequest$;
    exports2.UpdateBucketMetadataJournalTableConfiguration$ = UpdateBucketMetadataJournalTableConfiguration$;
    exports2.UpdateBucketMetadataJournalTableConfigurationCommand = UpdateBucketMetadataJournalTableConfigurationCommand;
    exports2.UpdateBucketMetadataJournalTableConfigurationRequest$ = UpdateBucketMetadataJournalTableConfigurationRequest$;
    exports2.UploadPart$ = UploadPart$;
    exports2.UploadPartCommand = UploadPartCommand;
    exports2.UploadPartCopy$ = UploadPartCopy$;
    exports2.UploadPartCopyCommand = UploadPartCopyCommand;
    exports2.UploadPartCopyOutput$ = UploadPartCopyOutput$;
    exports2.UploadPartCopyRequest$ = UploadPartCopyRequest$;
    exports2.UploadPartOutput$ = UploadPartOutput$;
    exports2.UploadPartRequest$ = UploadPartRequest$;
    exports2.VersioningConfiguration$ = VersioningConfiguration$;
    exports2.WebsiteConfiguration$ = WebsiteConfiguration$;
    exports2.WriteGetObjectResponse$ = WriteGetObjectResponse$;
    exports2.WriteGetObjectResponseCommand = WriteGetObjectResponseCommand;
    exports2.WriteGetObjectResponseRequest$ = WriteGetObjectResponseRequest$;
    exports2._Error$ = _Error$;
    exports2._Object$ = _Object$;
    exports2.paginateListBuckets = paginateListBuckets;
    exports2.paginateListDirectoryBuckets = paginateListDirectoryBuckets;
    exports2.paginateListObjectsV2 = paginateListObjectsV2;
    exports2.paginateListParts = paginateListParts;
    exports2.waitForBucketExists = waitForBucketExists;
    exports2.waitForBucketNotExists = waitForBucketNotExists;
    exports2.waitForObjectExists = waitForObjectExists;
    exports2.waitForObjectNotExists = waitForObjectNotExists;
    exports2.waitUntilBucketExists = waitUntilBucketExists;
    exports2.waitUntilBucketNotExists = waitUntilBucketNotExists;
    exports2.waitUntilObjectExists = waitUntilObjectExists;
    exports2.waitUntilObjectNotExists = waitUntilObjectNotExists;
  }
});

// node_modules/.pnpm/nanoid@5.1.6/node_modules/nanoid/url-alphabet/index.js
var urlAlphabet;
var init_url_alphabet = __esm({
  "node_modules/.pnpm/nanoid@5.1.6/node_modules/nanoid/url-alphabet/index.js"() {
    urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
  }
});

// node_modules/.pnpm/nanoid@5.1.6/node_modules/nanoid/index.js
var nanoid_exports = {};
__export(nanoid_exports, {
  customAlphabet: () => customAlphabet,
  customRandom: () => customRandom,
  nanoid: () => nanoid,
  random: () => random,
  urlAlphabet: () => urlAlphabet
});
function fillPool(bytes) {
  if (!pool || pool.length < bytes) {
    pool = Buffer.allocUnsafe(bytes * POOL_SIZE_MULTIPLIER);
    import_node_crypto.webcrypto.getRandomValues(pool);
    poolOffset = 0;
  } else if (poolOffset + bytes > pool.length) {
    import_node_crypto.webcrypto.getRandomValues(pool);
    poolOffset = 0;
  }
  poolOffset += bytes;
}
function random(bytes) {
  fillPool(bytes |= 0);
  return pool.subarray(poolOffset - bytes, poolOffset);
}
function customRandom(alphabet2, defaultSize, getRandom) {
  let mask = (2 << 31 - Math.clz32(alphabet2.length - 1 | 1)) - 1;
  let step = Math.ceil(1.6 * mask * defaultSize / alphabet2.length);
  return (size = defaultSize) => {
    if (!size) return "";
    let id2 = "";
    while (true) {
      let bytes = getRandom(step);
      let i4 = step;
      while (i4--) {
        id2 += alphabet2[bytes[i4] & mask] || "";
        if (id2.length >= size) return id2;
      }
    }
  };
}
function customAlphabet(alphabet2, size = 21) {
  return customRandom(alphabet2, size, random);
}
function nanoid(size = 21) {
  fillPool(size |= 0);
  let id2 = "";
  for (let i4 = poolOffset - size; i4 < poolOffset; i4++) {
    id2 += urlAlphabet[pool[i4] & 63];
  }
  return id2;
}
var import_node_crypto, POOL_SIZE_MULTIPLIER, pool, poolOffset;
var init_nanoid = __esm({
  "node_modules/.pnpm/nanoid@5.1.6/node_modules/nanoid/index.js"() {
    import_node_crypto = require("node:crypto");
    init_url_alphabet();
    init_url_alphabet();
    POOL_SIZE_MULTIPLIER = 128;
  }
});

// node_modules/.pnpm/jsonify@0.0.1/node_modules/jsonify/lib/parse.js
var require_parse = __commonJS({
  "node_modules/.pnpm/jsonify@0.0.1/node_modules/jsonify/lib/parse.js"(exports2, module2) {
    "use strict";
    var at;
    var ch;
    var escapee = {
      '"': '"',
      "\\": "\\",
      "/": "/",
      b: "\b",
      f: "\f",
      n: "\n",
      r: "\r",
      t: "	"
    };
    var text;
    function error2(m4) {
      throw {
        name: "SyntaxError",
        message: m4,
        at,
        text
      };
    }
    function next(c4) {
      if (c4 && c4 !== ch) {
        error2("Expected '" + c4 + "' instead of '" + ch + "'");
      }
      ch = text.charAt(at);
      at += 1;
      return ch;
    }
    function number() {
      var num;
      var str = "";
      if (ch === "-") {
        str = "-";
        next("-");
      }
      while (ch >= "0" && ch <= "9") {
        str += ch;
        next();
      }
      if (ch === ".") {
        str += ".";
        while (next() && ch >= "0" && ch <= "9") {
          str += ch;
        }
      }
      if (ch === "e" || ch === "E") {
        str += ch;
        next();
        if (ch === "-" || ch === "+") {
          str += ch;
          next();
        }
        while (ch >= "0" && ch <= "9") {
          str += ch;
          next();
        }
      }
      num = Number(str);
      if (!isFinite(num)) {
        error2("Bad number");
      }
      return num;
    }
    function string() {
      var hex;
      var i4;
      var str = "";
      var uffff;
      if (ch === '"') {
        while (next()) {
          if (ch === '"') {
            next();
            return str;
          } else if (ch === "\\") {
            next();
            if (ch === "u") {
              uffff = 0;
              for (i4 = 0; i4 < 4; i4 += 1) {
                hex = parseInt(next(), 16);
                if (!isFinite(hex)) {
                  break;
                }
                uffff = uffff * 16 + hex;
              }
              str += String.fromCharCode(uffff);
            } else if (typeof escapee[ch] === "string") {
              str += escapee[ch];
            } else {
              break;
            }
          } else {
            str += ch;
          }
        }
      }
      error2("Bad string");
    }
    function white() {
      while (ch && ch <= " ") {
        next();
      }
    }
    function word() {
      switch (ch) {
        case "t":
          next("t");
          next("r");
          next("u");
          next("e");
          return true;
        case "f":
          next("f");
          next("a");
          next("l");
          next("s");
          next("e");
          return false;
        case "n":
          next("n");
          next("u");
          next("l");
          next("l");
          return null;
        default:
          error2("Unexpected '" + ch + "'");
      }
    }
    function array() {
      var arr = [];
      if (ch === "[") {
        next("[");
        white();
        if (ch === "]") {
          next("]");
          return arr;
        }
        while (ch) {
          arr.push(value());
          white();
          if (ch === "]") {
            next("]");
            return arr;
          }
          next(",");
          white();
        }
      }
      error2("Bad array");
    }
    function object() {
      var key;
      var obj = {};
      if (ch === "{") {
        next("{");
        white();
        if (ch === "}") {
          next("}");
          return obj;
        }
        while (ch) {
          key = string();
          white();
          next(":");
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            error2('Duplicate key "' + key + '"');
          }
          obj[key] = value();
          white();
          if (ch === "}") {
            next("}");
            return obj;
          }
          next(",");
          white();
        }
      }
      error2("Bad object");
    }
    function value() {
      white();
      switch (ch) {
        case "{":
          return object();
        case "[":
          return array();
        case '"':
          return string();
        case "-":
          return number();
        default:
          return ch >= "0" && ch <= "9" ? number() : word();
      }
    }
    module2.exports = function(source, reviver) {
      var result;
      text = source;
      at = 0;
      ch = " ";
      result = value();
      white();
      if (ch) {
        error2("Syntax error");
      }
      return typeof reviver === "function" ? (function walk(holder, key) {
        var k4;
        var v4;
        var val = holder[key];
        if (val && typeof val === "object") {
          for (k4 in value) {
            if (Object.prototype.hasOwnProperty.call(val, k4)) {
              v4 = walk(val, k4);
              if (typeof v4 === "undefined") {
                delete val[k4];
              } else {
                val[k4] = v4;
              }
            }
          }
        }
        return reviver.call(holder, key, val);
      })({ "": result }, "") : result;
    };
  }
});

// node_modules/.pnpm/jsonify@0.0.1/node_modules/jsonify/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/.pnpm/jsonify@0.0.1/node_modules/jsonify/lib/stringify.js"(exports2, module2) {
    "use strict";
    var escapable = /[\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
    var gap;
    var indent;
    var meta = {
      // table of character substitutions
      "\b": "\\b",
      "	": "\\t",
      "\n": "\\n",
      "\f": "\\f",
      "\r": "\\r",
      '"': '\\"',
      "\\": "\\\\"
    };
    var rep;
    function quote(string) {
      escapable.lastIndex = 0;
      return escapable.test(string) ? '"' + string.replace(escapable, function(a4) {
        var c4 = meta[a4];
        return typeof c4 === "string" ? c4 : "\\u" + ("0000" + a4.charCodeAt(0).toString(16)).slice(-4);
      }) + '"' : '"' + string + '"';
    }
    function str(key, holder) {
      var i4;
      var k4;
      var v4;
      var length;
      var mind = gap;
      var partial;
      var value = holder[key];
      if (value && typeof value === "object" && typeof value.toJSON === "function") {
        value = value.toJSON(key);
      }
      if (typeof rep === "function") {
        value = rep.call(holder, key, value);
      }
      switch (typeof value) {
        case "string":
          return quote(value);
        case "number":
          return isFinite(value) ? String(value) : "null";
        case "boolean":
        case "null":
          return String(value);
        case "object":
          if (!value) {
            return "null";
          }
          gap += indent;
          partial = [];
          if (Object.prototype.toString.apply(value) === "[object Array]") {
            length = value.length;
            for (i4 = 0; i4 < length; i4 += 1) {
              partial[i4] = str(i4, value) || "null";
            }
            v4 = partial.length === 0 ? "[]" : gap ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" : "[" + partial.join(",") + "]";
            gap = mind;
            return v4;
          }
          if (rep && typeof rep === "object") {
            length = rep.length;
            for (i4 = 0; i4 < length; i4 += 1) {
              k4 = rep[i4];
              if (typeof k4 === "string") {
                v4 = str(k4, value);
                if (v4) {
                  partial.push(quote(k4) + (gap ? ": " : ":") + v4);
                }
              }
            }
          } else {
            for (k4 in value) {
              if (Object.prototype.hasOwnProperty.call(value, k4)) {
                v4 = str(k4, value);
                if (v4) {
                  partial.push(quote(k4) + (gap ? ": " : ":") + v4);
                }
              }
            }
          }
          v4 = partial.length === 0 ? "{}" : gap ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}" : "{" + partial.join(",") + "}";
          gap = mind;
          return v4;
        default:
      }
    }
    module2.exports = function(value, replacer, space) {
      var i4;
      gap = "";
      indent = "";
      if (typeof space === "number") {
        for (i4 = 0; i4 < space; i4 += 1) {
          indent += " ";
        }
      } else if (typeof space === "string") {
        indent = space;
      }
      rep = replacer;
      if (replacer && typeof replacer !== "function" && (typeof replacer !== "object" || typeof replacer.length !== "number")) {
        throw new Error("JSON.stringify");
      }
      return str("", { "": value });
    };
  }
});

// node_modules/.pnpm/jsonify@0.0.1/node_modules/jsonify/index.js
var require_jsonify = __commonJS({
  "node_modules/.pnpm/jsonify@0.0.1/node_modules/jsonify/index.js"(exports2) {
    "use strict";
    exports2.parse = require_parse();
    exports2.stringify = require_stringify();
  }
});

// node_modules/.pnpm/isarray@2.0.5/node_modules/isarray/index.js
var require_isarray = __commonJS({
  "node_modules/.pnpm/isarray@2.0.5/node_modules/isarray/index.js"(exports2, module2) {
    var toString2 = {}.toString;
    module2.exports = Array.isArray || function(arr) {
      return toString2.call(arr) == "[object Array]";
    };
  }
});

// node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/isArguments.js"(exports2, module2) {
    "use strict";
    var toStr = Object.prototype.toString;
    module2.exports = function isArguments2(value) {
      var str = toStr.call(value);
      var isArgs = str === "[object Arguments]";
      if (!isArgs) {
        isArgs = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
      }
      return isArgs;
    };
  }
});

// node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/implementation.js
var require_implementation = __commonJS({
  "node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/implementation.js"(exports2, module2) {
    "use strict";
    var keysShim;
    if (!Object.keys) {
      has = Object.prototype.hasOwnProperty;
      toStr = Object.prototype.toString;
      isArgs = require_isArguments();
      isEnumerable = Object.prototype.propertyIsEnumerable;
      hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
      hasProtoEnumBug = isEnumerable.call(function() {
      }, "prototype");
      dontEnums = [
        "toString",
        "toLocaleString",
        "valueOf",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "constructor"
      ];
      equalsConstructorPrototype = function(o4) {
        var ctor = o4.constructor;
        return ctor && ctor.prototype === o4;
      };
      excludedKeys = {
        $applicationCache: true,
        $console: true,
        $external: true,
        $frame: true,
        $frameElement: true,
        $frames: true,
        $innerHeight: true,
        $innerWidth: true,
        $onmozfullscreenchange: true,
        $onmozfullscreenerror: true,
        $outerHeight: true,
        $outerWidth: true,
        $pageXOffset: true,
        $pageYOffset: true,
        $parent: true,
        $scrollLeft: true,
        $scrollTop: true,
        $scrollX: true,
        $scrollY: true,
        $self: true,
        $webkitIndexedDB: true,
        $webkitStorageInfo: true,
        $window: true
      };
      hasAutomationEqualityBug = (function() {
        if (typeof window === "undefined") {
          return false;
        }
        for (var k4 in window) {
          try {
            if (!excludedKeys["$" + k4] && has.call(window, k4) && window[k4] !== null && typeof window[k4] === "object") {
              try {
                equalsConstructorPrototype(window[k4]);
              } catch (e4) {
                return true;
              }
            }
          } catch (e4) {
            return true;
          }
        }
        return false;
      })();
      equalsConstructorPrototypeIfNotBuggy = function(o4) {
        if (typeof window === "undefined" || !hasAutomationEqualityBug) {
          return equalsConstructorPrototype(o4);
        }
        try {
          return equalsConstructorPrototype(o4);
        } catch (e4) {
          return false;
        }
      };
      keysShim = function keys2(object) {
        var isObject2 = object !== null && typeof object === "object";
        var isFunction2 = toStr.call(object) === "[object Function]";
        var isArguments2 = isArgs(object);
        var isString2 = isObject2 && toStr.call(object) === "[object String]";
        var theKeys = [];
        if (!isObject2 && !isFunction2 && !isArguments2) {
          throw new TypeError("Object.keys called on a non-object");
        }
        var skipProto = hasProtoEnumBug && isFunction2;
        if (isString2 && object.length > 0 && !has.call(object, 0)) {
          for (var i4 = 0; i4 < object.length; ++i4) {
            theKeys.push(String(i4));
          }
        }
        if (isArguments2 && object.length > 0) {
          for (var j4 = 0; j4 < object.length; ++j4) {
            theKeys.push(String(j4));
          }
        } else {
          for (var name in object) {
            if (!(skipProto && name === "prototype") && has.call(object, name)) {
              theKeys.push(String(name));
            }
          }
        }
        if (hasDontEnumBug) {
          var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
          for (var k4 = 0; k4 < dontEnums.length; ++k4) {
            if (!(skipConstructor && dontEnums[k4] === "constructor") && has.call(object, dontEnums[k4])) {
              theKeys.push(dontEnums[k4]);
            }
          }
        }
        return theKeys;
      };
    }
    var has;
    var toStr;
    var isArgs;
    var isEnumerable;
    var hasDontEnumBug;
    var hasProtoEnumBug;
    var dontEnums;
    var equalsConstructorPrototype;
    var excludedKeys;
    var hasAutomationEqualityBug;
    var equalsConstructorPrototypeIfNotBuggy;
    module2.exports = keysShim;
  }
});

// node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/index.js
var require_object_keys = __commonJS({
  "node_modules/.pnpm/object-keys@1.1.1/node_modules/object-keys/index.js"(exports2, module2) {
    "use strict";
    var slice = Array.prototype.slice;
    var isArgs = require_isArguments();
    var origKeys = Object.keys;
    var keysShim = origKeys ? function keys2(o4) {
      return origKeys(o4);
    } : require_implementation();
    var originalKeys = Object.keys;
    keysShim.shim = function shimObjectKeys() {
      if (Object.keys) {
        var keysWorksWithArguments = (function() {
          var args = Object.keys(arguments);
          return args && args.length === arguments.length;
        })(1, 2);
        if (!keysWorksWithArguments) {
          Object.keys = function keys2(object) {
            if (isArgs(object)) {
              return originalKeys(slice.call(object));
            }
            return originalKeys(object);
          };
        }
      } else {
        Object.keys = keysShim;
      }
      return Object.keys || keysShim;
    };
    module2.exports = keysShim;
  }
});

// node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js
var require_es_object_atoms = __commonJS({
  "node_modules/.pnpm/es-object-atoms@1.1.1/node_modules/es-object-atoms/index.js"(exports2, module2) {
    "use strict";
    module2.exports = Object;
  }
});

// node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js
var require_es_errors = __commonJS({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/index.js"(exports2, module2) {
    "use strict";
    module2.exports = Error;
  }
});

// node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js
var require_eval = __commonJS({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/eval.js"(exports2, module2) {
    "use strict";
    module2.exports = EvalError;
  }
});

// node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js
var require_range = __commonJS({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/range.js"(exports2, module2) {
    "use strict";
    module2.exports = RangeError;
  }
});

// node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js
var require_ref = __commonJS({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/ref.js"(exports2, module2) {
    "use strict";
    module2.exports = ReferenceError;
  }
});

// node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js
var require_syntax = __commonJS({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/syntax.js"(exports2, module2) {
    "use strict";
    module2.exports = SyntaxError;
  }
});

// node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js
var require_type = __commonJS({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/type.js"(exports2, module2) {
    "use strict";
    module2.exports = TypeError;
  }
});

// node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js
var require_uri = __commonJS({
  "node_modules/.pnpm/es-errors@1.3.0/node_modules/es-errors/uri.js"(exports2, module2) {
    "use strict";
    module2.exports = URIError;
  }
});

// node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/abs.js
var require_abs = __commonJS({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/abs.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.abs;
  }
});

// node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/floor.js
var require_floor = __commonJS({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/floor.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.floor;
  }
});

// node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/max.js
var require_max = __commonJS({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/max.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.max;
  }
});

// node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/min.js
var require_min = __commonJS({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/min.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.min;
  }
});

// node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/pow.js
var require_pow = __commonJS({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/pow.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.pow;
  }
});

// node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/round.js
var require_round = __commonJS({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/round.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.round;
  }
});

// node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/isNaN.js
var require_isNaN = __commonJS({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/isNaN.js"(exports2, module2) {
    "use strict";
    module2.exports = Number.isNaN || function isNaN2(a4) {
      return a4 !== a4;
    };
  }
});

// node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/sign.js
var require_sign = __commonJS({
  "node_modules/.pnpm/math-intrinsics@1.1.0/node_modules/math-intrinsics/sign.js"(exports2, module2) {
    "use strict";
    var $isNaN = require_isNaN();
    module2.exports = function sign(number) {
      if ($isNaN(number) || number === 0) {
        return number;
      }
      return number < 0 ? -1 : 1;
    };
  }
});

// node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js
var require_gOPD = __commonJS({
  "node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/gOPD.js"(exports2, module2) {
    "use strict";
    module2.exports = Object.getOwnPropertyDescriptor;
  }
});

// node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js
var require_gopd = __commonJS({
  "node_modules/.pnpm/gopd@1.2.0/node_modules/gopd/index.js"(exports2, module2) {
    "use strict";
    var $gOPD = require_gOPD();
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e4) {
        $gOPD = null;
      }
    }
    module2.exports = $gOPD;
  }
});

// node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js
var require_es_define_property = __commonJS({
  "node_modules/.pnpm/es-define-property@1.0.1/node_modules/es-define-property/index.js"(exports2, module2) {
    "use strict";
    var $defineProperty = Object.defineProperty || false;
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e4) {
        $defineProperty = false;
      }
    }
    module2.exports = $defineProperty;
  }
});

// node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/shams.js"(exports2, module2) {
    "use strict";
    module2.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = /* @__PURE__ */ Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (var _ in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = (
          /** @type {PropertyDescriptor} */
          Object.getOwnPropertyDescriptor(obj, sym)
        );
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/.pnpm/has-symbols@1.1.0/node_modules/has-symbols/index.js"(exports2, module2) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module2.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof /* @__PURE__ */ Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js
var require_Reflect_getPrototypeOf = __commonJS({
  "node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Reflect.getPrototypeOf.js"(exports2, module2) {
    "use strict";
    module2.exports = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  }
});

// node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js
var require_Object_getPrototypeOf = __commonJS({
  "node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/Object.getPrototypeOf.js"(exports2, module2) {
    "use strict";
    var $Object = require_es_object_atoms();
    module2.exports = $Object.getPrototypeOf || null;
  }
});

// node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js
var require_implementation2 = __commonJS({
  "node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/implementation.js"(exports2, module2) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a4, b4) {
      var arr = [];
      for (var i4 = 0; i4 < a4.length; i4 += 1) {
        arr[i4] = a4[i4];
      }
      for (var j4 = 0; j4 < b4.length; j4 += 1) {
        arr[j4 + a4.length] = b4[j4];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i4 = offset || 0, j4 = 0; i4 < arrLike.length; i4 += 1, j4 += 1) {
        arr[j4] = arrLike[i4];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str = "";
      for (var i4 = 0; i4 < arr.length; i4 += 1) {
        str += arr[i4];
        if (i4 + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    module2.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i4 = 0; i4 < boundLength; i4++) {
        boundArgs[i4] = "$" + i4;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/.pnpm/function-bind@1.1.2/node_modules/function-bind/index.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation2();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js
var require_functionCall = __commonJS({
  "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionCall.js"(exports2, module2) {
    "use strict";
    module2.exports = Function.prototype.call;
  }
});

// node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js
var require_functionApply = __commonJS({
  "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/functionApply.js"(exports2, module2) {
    "use strict";
    module2.exports = Function.prototype.apply;
  }
});

// node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/reflectApply.js
var require_reflectApply = __commonJS({
  "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/reflectApply.js"(exports2, module2) {
    "use strict";
    module2.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  }
});

// node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js
var require_actualApply = __commonJS({
  "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/actualApply.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var $reflectApply = require_reflectApply();
    module2.exports = $reflectApply || bind.call($call, $apply);
  }
});

// node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js
var require_call_bind_apply_helpers = __commonJS({
  "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/index.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    var $TypeError = require_type();
    var $call = require_functionCall();
    var $actualApply = require_actualApply();
    module2.exports = function callBindBasic(args) {
      if (args.length < 1 || typeof args[0] !== "function") {
        throw new $TypeError("a function is required");
      }
      return $actualApply(bind, $call, args);
    };
  }
});

// node_modules/.pnpm/dunder-proto@1.0.1/node_modules/dunder-proto/get.js
var require_get = __commonJS({
  "node_modules/.pnpm/dunder-proto@1.0.1/node_modules/dunder-proto/get.js"(exports2, module2) {
    "use strict";
    var callBind = require_call_bind_apply_helpers();
    var gOPD = require_gopd();
    var hasProtoAccessor;
    try {
      hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
      [].__proto__ === Array.prototype;
    } catch (e4) {
      if (!e4 || typeof e4 !== "object" || !("code" in e4) || e4.code !== "ERR_PROTO_ACCESS") {
        throw e4;
      }
    }
    var desc = !!hasProtoAccessor && gOPD && gOPD(
      Object.prototype,
      /** @type {keyof typeof Object.prototype} */
      "__proto__"
    );
    var $Object = Object;
    var $getPrototypeOf = $Object.getPrototypeOf;
    module2.exports = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? (
      /** @type {import('./get')} */
      function getDunder(value) {
        return $getPrototypeOf(value == null ? value : $Object(value));
      }
    ) : false;
  }
});

// node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js
var require_get_proto = __commonJS({
  "node_modules/.pnpm/get-proto@1.0.1/node_modules/get-proto/index.js"(exports2, module2) {
    "use strict";
    var reflectGetProto = require_Reflect_getPrototypeOf();
    var originalGetProto = require_Object_getPrototypeOf();
    var getDunderProto = require_get();
    module2.exports = reflectGetProto ? function getProto(O) {
      return reflectGetProto(O);
    } : originalGetProto ? function getProto(O) {
      if (!O || typeof O !== "object" && typeof O !== "function") {
        throw new TypeError("getProto: not an object");
      }
      return originalGetProto(O);
    } : getDunderProto ? function getProto(O) {
      return getDunderProto(O);
    } : null;
  }
});

// node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js
var require_hasown = __commonJS({
  "node_modules/.pnpm/hasown@2.0.2/node_modules/hasown/index.js"(exports2, module2) {
    "use strict";
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = require_function_bind();
    module2.exports = bind.call(call, $hasOwn);
  }
});

// node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/.pnpm/get-intrinsic@1.3.0/node_modules/get-intrinsic/index.js"(exports2, module2) {
    "use strict";
    var undefined2;
    var $Object = require_es_object_atoms();
    var $Error = require_es_errors();
    var $EvalError = require_eval();
    var $RangeError = require_range();
    var $ReferenceError = require_ref();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var $URIError = require_uri();
    var abs = require_abs();
    var floor = require_floor();
    var max = require_max();
    var min = require_min();
    var pow = require_pow();
    var round = require_round();
    var sign = require_sign();
    var $Function = Function;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e4) {
      }
    };
    var $gOPD = require_gopd();
    var $defineProperty = require_es_define_property();
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? (function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    })() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = require_get_proto();
    var $ObjectGPO = require_Object_getPrototypeOf();
    var $ReflectGPO = require_Reflect_getPrototypeOf();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": $Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": $EvalError,
      "%Float16Array%": typeof Float16Array === "undefined" ? undefined2 : Float16Array,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": $Object,
      "%Object.getOwnPropertyDescriptor%": $gOPD,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": $RangeError,
      "%ReferenceError%": $ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": $URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
      "%Function.prototype.call%": $call,
      "%Function.prototype.apply%": $apply,
      "%Object.defineProperty%": $defineProperty,
      "%Object.getPrototypeOf%": $ObjectGPO,
      "%Math.abs%": abs,
      "%Math.floor%": floor,
      "%Math.max%": max,
      "%Math.min%": min,
      "%Math.pow%": pow,
      "%Math.round%": round,
      "%Math.sign%": sign,
      "%Reflect.getPrototypeOf%": $ReflectGPO
    };
    if (getProto) {
      try {
        null.error;
      } catch (e4) {
        errorProto = getProto(getProto(e4));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_hasown();
    var $concat = bind.call($call, Array.prototype.concat);
    var $spliceApply = bind.call($apply, Array.prototype.splice);
    var $replace = bind.call($call, String.prototype.replace);
    var $strSlice = bind.call($call, String.prototype.slice);
    var $exec = bind.call($call, RegExp.prototype.exec);
    var rePropName2 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar2 = /\\(\\)?/g;
    var stringToPath2 = function stringToPath3(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName2, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar2, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module2.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath2(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i4 = 1, isOwn = true; i4 < parts.length; i4 += 1) {
        var part = parts[i4];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void undefined2;
          }
          if ($gOPD && i4 + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// node_modules/.pnpm/define-data-property@1.1.4/node_modules/define-data-property/index.js
var require_define_data_property = __commonJS({
  "node_modules/.pnpm/define-data-property@1.1.4/node_modules/define-data-property/index.js"(exports2, module2) {
    "use strict";
    var $defineProperty = require_es_define_property();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var gopd = require_gopd();
    module2.exports = function defineDataProperty(obj, property, value) {
      if (!obj || typeof obj !== "object" && typeof obj !== "function") {
        throw new $TypeError("`obj` must be an object or a function`");
      }
      if (typeof property !== "string" && typeof property !== "symbol") {
        throw new $TypeError("`property` must be a string or a symbol`");
      }
      if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
        throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
        throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
        throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
        throw new $TypeError("`loose`, if provided, must be a boolean");
      }
      var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
      var nonWritable = arguments.length > 4 ? arguments[4] : null;
      var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
      var loose = arguments.length > 6 ? arguments[6] : false;
      var desc = !!gopd && gopd(obj, property);
      if ($defineProperty) {
        $defineProperty(obj, property, {
          configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
          enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
          value,
          writable: nonWritable === null && desc ? desc.writable : !nonWritable
        });
      } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
        obj[property] = value;
      } else {
        throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
      }
    };
  }
});

// node_modules/.pnpm/has-property-descriptors@1.0.2/node_modules/has-property-descriptors/index.js
var require_has_property_descriptors = __commonJS({
  "node_modules/.pnpm/has-property-descriptors@1.0.2/node_modules/has-property-descriptors/index.js"(exports2, module2) {
    "use strict";
    var $defineProperty = require_es_define_property();
    var hasPropertyDescriptors = function hasPropertyDescriptors2() {
      return !!$defineProperty;
    };
    hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
      if (!$defineProperty) {
        return null;
      }
      try {
        return $defineProperty([], "length", { value: 1 }).length !== 1;
      } catch (e4) {
        return true;
      }
    };
    module2.exports = hasPropertyDescriptors;
  }
});

// node_modules/.pnpm/set-function-length@1.2.2/node_modules/set-function-length/index.js
var require_set_function_length = __commonJS({
  "node_modules/.pnpm/set-function-length@1.2.2/node_modules/set-function-length/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var define = require_define_data_property();
    var hasDescriptors = require_has_property_descriptors()();
    var gOPD = require_gopd();
    var $TypeError = require_type();
    var $floor = GetIntrinsic("%Math.floor%");
    module2.exports = function setFunctionLength(fn, length) {
      if (typeof fn !== "function") {
        throw new $TypeError("`fn` is not a function");
      }
      if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
        throw new $TypeError("`length` must be a positive 32-bit integer");
      }
      var loose = arguments.length > 2 && !!arguments[2];
      var functionLengthIsConfigurable = true;
      var functionLengthIsWritable = true;
      if ("length" in fn && gOPD) {
        var desc = gOPD(fn, "length");
        if (desc && !desc.configurable) {
          functionLengthIsConfigurable = false;
        }
        if (desc && !desc.writable) {
          functionLengthIsWritable = false;
        }
      }
      if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
        if (hasDescriptors) {
          define(
            /** @type {Parameters<define>[0]} */
            fn,
            "length",
            length,
            true,
            true
          );
        } else {
          define(
            /** @type {Parameters<define>[0]} */
            fn,
            "length",
            length
          );
        }
      }
      return fn;
    };
  }
});

// node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/applyBind.js
var require_applyBind = __commonJS({
  "node_modules/.pnpm/call-bind-apply-helpers@1.0.2/node_modules/call-bind-apply-helpers/applyBind.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    var $apply = require_functionApply();
    var actualApply = require_actualApply();
    module2.exports = function applyBind() {
      return actualApply(bind, $apply, arguments);
    };
  }
});

// node_modules/.pnpm/call-bind@1.0.8/node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "node_modules/.pnpm/call-bind@1.0.8/node_modules/call-bind/index.js"(exports2, module2) {
    "use strict";
    var setFunctionLength = require_set_function_length();
    var $defineProperty = require_es_define_property();
    var callBindBasic = require_call_bind_apply_helpers();
    var applyBind = require_applyBind();
    module2.exports = function callBind(originalFunction) {
      var func = callBindBasic(arguments);
      var adjustedLength = originalFunction.length - (arguments.length - 1);
      return setFunctionLength(
        func,
        1 + (adjustedLength > 0 ? adjustedLength : 0),
        true
      );
    };
    if ($defineProperty) {
      $defineProperty(module2.exports, "apply", { value: applyBind });
    } else {
      module2.exports.apply = applyBind;
    }
  }
});

// node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js
var require_call_bound = __commonJS({
  "node_modules/.pnpm/call-bound@1.0.4/node_modules/call-bound/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBindBasic = require_call_bind_apply_helpers();
    var $indexOf = callBindBasic([GetIntrinsic("%String.prototype.indexOf%")]);
    module2.exports = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = (
        /** @type {(this: unknown, ...args: unknown[]) => unknown} */
        GetIntrinsic(name, !!allowMissing)
      );
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBindBasic(
          /** @type {const} */
          [intrinsic]
        );
      }
      return intrinsic;
    };
  }
});

// node_modules/.pnpm/json-stable-stringify@1.3.0/node_modules/json-stable-stringify/index.js
var require_json_stable_stringify = __commonJS({
  "node_modules/.pnpm/json-stable-stringify@1.3.0/node_modules/json-stable-stringify/index.js"(exports2, module2) {
    "use strict";
    var jsonStringify = (typeof JSON !== "undefined" ? JSON : require_jsonify()).stringify;
    var isArray2 = require_isarray();
    var objectKeys = require_object_keys();
    var callBind = require_call_bind();
    var callBound = require_call_bound();
    var $join = callBound("Array.prototype.join");
    var $indexOf = callBound("Array.prototype.indexOf");
    var $splice = callBound("Array.prototype.splice");
    var $sort = callBound("Array.prototype.sort");
    var strRepeat = function repeat(n4, char) {
      var str = "";
      for (var i4 = 0; i4 < n4; i4 += 1) {
        str += char;
      }
      return str;
    };
    var defaultReplacer = function(_parent, _key, value) {
      return value;
    };
    module2.exports = function stableStringify(obj) {
      var opts = arguments.length > 1 ? arguments[1] : void 0;
      var space = opts && opts.space || "";
      if (typeof space === "number") {
        space = strRepeat(space, " ");
      }
      var cycles = !!opts && typeof opts.cycles === "boolean" && opts.cycles;
      var replacer = opts && opts.replacer ? callBind(opts.replacer) : defaultReplacer;
      if (opts && typeof opts.collapseEmpty !== "undefined" && typeof opts.collapseEmpty !== "boolean") {
        throw new TypeError("`collapseEmpty` must be a boolean, if provided");
      }
      var collapseEmpty = !!opts && opts.collapseEmpty;
      var cmpOpt = typeof opts === "function" ? opts : opts && opts.cmp;
      var cmp = cmpOpt && function(node) {
        var get3 = (
          /** @type {NonNullable<typeof cmpOpt>} */
          cmpOpt.length > 2 && /** @type {import('.').Getter['get']} */
          function get4(k4) {
            return node[k4];
          }
        );
        return function(a4, b4) {
          return (
            /** @type {NonNullable<typeof cmpOpt>} */
            cmpOpt(
              { key: a4, value: node[a4] },
              { key: b4, value: node[b4] },
              // @ts-expect-error TS doesn't understand the optimization used here
              get3 ? (
                /** @type {import('.').Getter} */
                { __proto__: null, get: get3 }
              ) : void 0
            )
          );
        };
      };
      var seen = [];
      return (
        /** @type {(parent: import('.').Node, key: string | number, node: unknown, level: number) => string | undefined} */
        (function stringify(parent, key, node, level) {
          var indent = space ? "\n" + strRepeat(level, space) : "";
          var colonSeparator = space ? ": " : ":";
          if (node && /** @type {{ toJSON?: unknown }} */
          node.toJSON && typeof /** @type {{ toJSON?: unknown }} */
          node.toJSON === "function") {
            node = /** @type {{ toJSON: Function }} */
            node.toJSON();
          }
          node = replacer(parent, key, node);
          if (node === void 0) {
            return;
          }
          if (typeof node !== "object" || node === null) {
            return jsonStringify(node);
          }
          var groupOutput = function(out2, brackets) {
            return collapseEmpty && out2.length === 0 ? brackets : (brackets === "[]" ? "[" : "{") + $join(out2, ",") + indent + (brackets === "[]" ? "]" : "}");
          };
          if (isArray2(node)) {
            var out = [];
            for (var i4 = 0; i4 < node.length; i4++) {
              var item = stringify(node, i4, node[i4], level + 1) || jsonStringify(null);
              out[out.length] = indent + space + item;
            }
            return groupOutput(out, "[]");
          }
          if ($indexOf(seen, node) !== -1) {
            if (cycles) {
              return jsonStringify("__cycle__");
            }
            throw new TypeError("Converting circular structure to JSON");
          } else {
            seen[seen.length] = /** @type {import('.').NonArrayNode} */
            node;
          }
          var keys2 = $sort(objectKeys(node), cmp && cmp(
            /** @type {import('.').NonArrayNode} */
            node
          ));
          var out = [];
          for (var i4 = 0; i4 < keys2.length; i4++) {
            var key = keys2[i4];
            var value = stringify(
              /** @type {import('.').Node} */
              node,
              key,
              /** @type {import('.').NonArrayNode} */
              node[key],
              level + 1
            );
            if (!value) {
              continue;
            }
            var keyValue = jsonStringify(key) + colonSeparator + value;
            out[out.length] = indent + space + keyValue;
          }
          $splice(seen, $indexOf(seen, node), 1);
          return groupOutput(out, "{}");
        })({ "": obj }, "", obj, 0)
      );
    };
  }
});

// node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/helpers/deep-extend.js
var require_deep_extend = __commonJS({
  "node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/helpers/deep-extend.js"(exports2, module2) {
    "use strict";
    function isObjectHasKeys(v4) {
      if (typeof v4 !== "object" || Array.isArray(v4) || v4 == null) return false;
      return Object.keys(v4).length > 0;
    }
    function deepExtend(destination, source, options = {}) {
      for (let property in source) {
        if (isObjectHasKeys(source[property])) {
          destination[property] = destination[property] || {};
          deepExtend(destination[property], source[property], options);
        } else {
          if (options.skipIfExist === true && destination[property] !== void 0) continue;
          destination[property] = source[property];
        }
      }
      return destination;
    }
    module2.exports = deepExtend;
  }
});

// node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/helpers/replace.js
var require_replace = __commonJS({
  "node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/helpers/replace.js"(exports2, module2) {
    function convertible(value) {
      if (value === void 0) return "";
      if (value === null) return "";
      if (typeof value.toString === "function") return value;
      return typeof value;
    }
    module2.exports = (string, searchValue, newValue) => string.replace(searchValue, convertible(newValue));
  }
});

// node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/messages.js
var require_messages = __commonJS({
  "node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/messages.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      required: "The '{field}' field is required.",
      string: "The '{field}' field must be a string.",
      stringEmpty: "The '{field}' field must not be empty.",
      stringMin: "The '{field}' field length must be greater than or equal to {expected} characters long.",
      stringMax: "The '{field}' field length must be less than or equal to {expected} characters long.",
      stringLength: "The '{field}' field length must be {expected} characters long.",
      stringPattern: "The '{field}' field fails to match the required pattern.",
      stringContains: "The '{field}' field must contain the '{expected}' text.",
      stringEnum: "The '{field}' field does not match any of the allowed values.",
      stringNumeric: "The '{field}' field must be a numeric string.",
      stringAlpha: "The '{field}' field must be an alphabetic string.",
      stringAlphanum: "The '{field}' field must be an alphanumeric string.",
      stringAlphadash: "The '{field}' field must be an alphadash string.",
      stringHex: "The '{field}' field must be a hex string.",
      stringSingleLine: "The '{field}' field must be a single line string.",
      stringBase64: "The '{field}' field must be a base64 string.",
      number: "The '{field}' field must be a number.",
      numberMin: "The '{field}' field must be greater than or equal to {expected}.",
      numberMax: "The '{field}' field must be less than or equal to {expected}.",
      numberEqual: "The '{field}' field must be equal to {expected}.",
      numberNotEqual: "The '{field}' field can't be equal to {expected}.",
      numberInteger: "The '{field}' field must be an integer.",
      numberPositive: "The '{field}' field must be a positive number.",
      numberNegative: "The '{field}' field must be a negative number.",
      array: "The '{field}' field must be an array.",
      arrayEmpty: "The '{field}' field must not be an empty array.",
      arrayMin: "The '{field}' field must contain at least {expected} items.",
      arrayMax: "The '{field}' field must contain less than or equal to {expected} items.",
      arrayLength: "The '{field}' field must contain {expected} items.",
      arrayContains: "The '{field}' field must contain the '{expected}' item.",
      arrayUnique: "The '{actual}' value in '{field}' field does not unique the '{expected}' values.",
      arrayEnum: "The '{actual}' value in '{field}' field does not match any of the '{expected}' values.",
      tuple: "The '{field}' field must be an array.",
      tupleEmpty: "The '{field}' field must not be an empty array.",
      tupleLength: "The '{field}' field must contain {expected} items.",
      boolean: "The '{field}' field must be a boolean.",
      currency: "The '{field}' must be a valid currency format",
      date: "The '{field}' field must be a Date.",
      dateMin: "The '{field}' field must be greater than or equal to {expected}.",
      dateMax: "The '{field}' field must be less than or equal to {expected}.",
      enumValue: "The '{field}' field value '{expected}' does not match any of the allowed values.",
      equalValue: "The '{field}' field value must be equal to '{expected}'.",
      equalField: "The '{field}' field value must be equal to '{expected}' field value.",
      forbidden: "The '{field}' field is forbidden.",
      function: "The '{field}' field must be a function.",
      email: "The '{field}' field must be a valid e-mail.",
      emailEmpty: "The '{field}' field must not be empty.",
      emailMin: "The '{field}' field length must be greater than or equal to {expected} characters long.",
      emailMax: "The '{field}' field length must be less than or equal to {expected} characters long.",
      luhn: "The '{field}' field must be a valid checksum luhn.",
      mac: "The '{field}' field must be a valid MAC address.",
      object: "The '{field}' must be an Object.",
      objectStrict: "The object '{field}' contains forbidden keys: '{actual}'.",
      objectMinProps: "The object '{field}' must contain at least {expected} properties.",
      objectMaxProps: "The object '{field}' must contain {expected} properties at most.",
      url: "The '{field}' field must be a valid URL.",
      urlEmpty: "The '{field}' field must not be empty.",
      uuid: "The '{field}' field must be a valid UUID.",
      uuidVersion: "The '{field}' field must be a valid UUID version provided.",
      classInstanceOf: "The '{field}' field must be an instance of the '{expected}' class.",
      objectID: "The '{field}' field must be an valid ObjectID",
      record: "The '{field}' must be an Object."
    };
  }
});

// node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/rules/any.js
var require_any = __commonJS({
  "node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/rules/any.js"(exports2, module2) {
    "use strict";
    module2.exports = function() {
      const src = [];
      src.push(`
		return value;
	`);
      return {
        source: src.join("\n")
      };
    };
  }
});

// node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/rules/array.js
var require_array = __commonJS({
  "node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/rules/array.js"(exports2, module2) {
    "use strict";
    module2.exports = function({ schema, messages }, path3, context) {
      const src = [];
      let sanitized = false;
      if (schema.convert === true) {
        sanitized = true;
        src.push(`
			if (!Array.isArray(value) && value != null) {
				value = [value];
			}
		`);
      }
      src.push(`
		if (!Array.isArray(value)) {
			${this.makeError({ type: "array", actual: "value", messages })}
			return value;
		}

		var len = value.length;
	`);
      if (schema.empty === false) {
        src.push(`
			if (len === 0) {
				${this.makeError({ type: "arrayEmpty", actual: "value", messages })}
			}
		`);
      }
      if (schema.min != null) {
        src.push(`
			if (len < ${schema.min}) {
				${this.makeError({ type: "arrayMin", expected: schema.min, actual: "len", messages })}
			}
		`);
      }
      if (schema.max != null) {
        src.push(`
			if (len > ${schema.max}) {
				${this.makeError({ type: "arrayMax", expected: schema.max, actual: "len", messages })}
			}
		`);
      }
      if (schema.length != null) {
        src.push(`
			if (len !== ${schema.length}) {
				${this.makeError({ type: "arrayLength", expected: schema.length, actual: "len", messages })}
			}
		`);
      }
      if (schema.contains != null) {
        src.push(`
			if (value.indexOf(${JSON.stringify(schema.contains)}) === -1) {
				${this.makeError({ type: "arrayContains", expected: JSON.stringify(schema.contains), actual: "value", messages })}
			}
		`);
      }
      if (schema.unique === true) {
        src.push(`
			if(len > (new Set(value)).size) {
				${this.makeError({ type: "arrayUnique", expected: "Array.from(new Set(value.filter((item, index) => value.indexOf(item) !== index)))", actual: "value", messages })}
			}
		`);
      }
      if (schema.enum != null) {
        const enumStr = JSON.stringify(schema.enum);
        src.push(`
			for (var i = 0; i < value.length; i++) {
				if (${enumStr}.indexOf(value[i]) === -1) {
					${this.makeError({ type: "arrayEnum", expected: '"' + schema.enum.join(", ") + '"', actual: "value[i]", messages })}
				}
			}
		`);
      }
      if (schema.items != null) {
        src.push(`
			var arr = value;
			var parentField = field;
			for (var i = 0; i < arr.length; i++) {
				value = arr[i];
		`);
        const itemPath = path3 + "[]";
        const rule = this.getRuleFromSchema(schema.items);
        const innerSource = `arr[i] = ${context.async ? "await " : ""}context.fn[%%INDEX%%](arr[i], (parentField ? parentField : "") + "[" + i + "]", parent, errors, context)`;
        src.push(this.compileRule(rule, context, itemPath, innerSource, "arr[i]"));
        src.push(`
			}
		`);
        src.push(`
		return arr;
	`);
      } else {
        src.push(`
		return value;
	`);
      }
      return {
        sanitized,
        source: src.join("\n")
      };
    };
  }
});

// node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/rules/boolean.js
var require_boolean = __commonJS({
  "node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/rules/boolean.js"(exports2, module2) {
    "use strict";
    module2.exports = function({ schema, messages }, path3, context) {
      const src = [];
      let sanitized = false;
      src.push(`
		var origValue = value;
	`);
      if (schema.convert === true) {
        sanitized = true;
        src.push(`
			if (typeof value !== "boolean") {
				if (
				value === 1
				|| value === "true"
				|| value === "1"
				|| value === "on"
				) {
					value = true;
				} else if (
				value === 0
				|| value === "false"
				|| value === "0"
				|| value === "off"
				) {
					value = false;
				}
			}
		`);
      }
      src.push(`
		if (typeof value !== "boolean") {
			${this.makeError({ type: "boolean", actual: "origValue", messages })}
		}
		
		return value;
	`);
      return {
        sanitized,
        source: src.join("\n")
      };
    };
  }
});

// node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/rules/class.js
var require_class = __commonJS({
  "node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/rules/class.js"(exports2, module2) {
    "use strict";
    module2.exports = function({ schema, messages, index }, path3, context) {
      const src = [];
      const className = schema.instanceOf.name ? schema.instanceOf.name : "<UnknowClass>";
      if (!context.customs[index]) context.customs[index] = { schema };
      else context.customs[index].schema = schema;
      src.push(`
		if (!(value instanceof context.customs[${index}].schema.instanceOf))
			${this.makeError({ type: "classInstanceOf", actual: "value", expected: "'" + className + "'", messages })}
	`);
      src.push(`
		return value;
	`);
      return {
        source: src.join("\n")
      };
    };
  }
});

// node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/rules/custom.js
var require_custom = __commonJS({
  "node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/rules/custom.js"(exports2, module2) {
    "use strict";
    module2.exports = function({ schema, messages, index }, path3, context) {
      const src = [];
      src.push(`
		${this.makeCustomValidator({ fnName: "check", path: path3, schema, messages, context, ruleIndex: index })}
		return value;
	`);
      return {
        source: src.join("\n")
      };
    };
  }
});

// node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/rules/currency.js
var require_currency = __commonJS({
  "node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/rules/currency.js"(exports2, module2) {
    "use strict";
    var CURRENCY_REGEX = "(?=.*\\d)^(-?~1|~1-?)(([0-9]\\d{0,2}(~2\\d{3})*)|0)?(\\~3\\d{1,2})?$";
    module2.exports = function({ schema, messages }, path3, context) {
      const currencySymbol = schema.currencySymbol || null;
      const thousandSeparator = schema.thousandSeparator || ",";
      const decimalSeparator = schema.decimalSeparator || ".";
      const customRegex = schema.customRegex;
      let isCurrencySymbolMandatory = !schema.symbolOptional;
      let finalRegex = CURRENCY_REGEX.replace(/~1/g, currencySymbol ? `\\${currencySymbol}${isCurrencySymbolMandatory ? "" : "?"}` : "").replace("~2", thousandSeparator).replace("~3", decimalSeparator);
      const src = [];
      src.push(`
		if (!value.match(${customRegex || new RegExp(finalRegex)})) {
			${this.makeError({ type: "currency", actual: "value", messages })}
			return value;
		}

		return value;
	`);
      return {
        source: src.join("\n")
      };
    };
  }
});

// node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/rules/date.js
var require_date = __commonJS({
  "node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/rules/date.js"(exports2, module2) {
    "use strict";
    module2.exports = function({ schema, messages }, path3, context) {
      const src = [];
      let sanitized = false;
      src.push(`
		var origValue = value;
	`);
      if (schema.convert === true) {
        sanitized = true;
        src.push(`
			if (!(value instanceof Date)) {
				value = new Date(value.length && !isNaN(+value) ? +value : value);
			}
		`);
      }
      src.push(`
		if (!(value instanceof Date) || isNaN(value.getTime()))
			${this.makeError({ type: "date", actual: "origValue", messages })}

		return value;
	`);
      return {
        sanitized,
        source: src.join("\n")
      };
    };
  }
});

// node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/rules/email.js
var require_email = __commonJS({
  "node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/rules/email.js"(exports2, module2) {
    "use strict";
    var PRECISE_PATTERN = /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
    var BASIC_PATTERN = /^\S+@\S+\.\S+$/;
    module2.exports = function({ schema, messages }, path3, context) {
      const src = [];
      const pattern = schema.mode == "precise" ? PRECISE_PATTERN : BASIC_PATTERN;
      let sanitized = false;
      src.push(`
		if (typeof value !== "string") {
			${this.makeError({ type: "string", actual: "value", messages })}
			return value;
		}
	`);
      if (!schema.empty) {
        src.push(`
			if (value.length === 0) {
				${this.makeError({ type: "emailEmpty", actual: "value", messages })}
				return value;
			}
		`);
      } else {
        src.push(`
			if (value.length === 0) return value;
		`);
      }
      if (schema.normalize) {
        sanitized = true;
        src.push(`
			value = value.trim().toLowerCase();
		`);
      }
      if (schema.min != null) {
        src.push(`
			if (value.length < ${schema.min}) {
				${this.makeError({ type: "emailMin", expected: schema.min, actual: "value.length", messages })}
			}
		`);
      }
      if (schema.max != null) {
        src.push(`
			if (value.length > ${schema.max}) {
				${this.makeError({ type: "emailMax", expected: schema.max, actual: "value.length", messages })}
			}
		`);
      }
      src.push(`
		if (!${pattern.toString()}.test(value)) {
			${this.makeError({ type: "email", actual: "value", messages })}
		}

		return value;
	`);
      return {
        sanitized,
        source: src.join("\n")
      };
    };
  }
});

// node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/rules/enum.js
var require_enum = __commonJS({
  "node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/rules/enum.js"(exports2, module2) {
    "use strict";
    module2.exports = function({ schema, messages }, path3, context) {
      const enumStr = JSON.stringify(schema.values || []);
      return {
        source: `
			if (${enumStr}.indexOf(value) === -1)
				${this.makeError({ type: "enumValue", expected: '"' + schema.values.join(", ") + '"', actual: "value", messages })}
			
			return value;
		`
      };
    };
  }
});

// node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/rules/equal.js
var require_equal = __commonJS({
  "node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/rules/equal.js"(exports2, module2) {
    "use strict";
    module2.exports = function({ schema, messages }, path3, context) {
      const src = [];
      if (schema.field) {
        if (schema.strict) {
          src.push(`
				if (value !== parent["${schema.field}"])
			`);
        } else {
          src.push(`
				if (value != parent["${schema.field}"])
			`);
        }
        src.push(`
				${this.makeError({ type: "equalField", actual: "value", expected: JSON.stringify(schema.field), messages })}
		`);
      } else {
        if (schema.strict) {
          src.push(`
				if (value !== ${JSON.stringify(schema.value)})
			`);
        } else {
          src.push(`
				if (value != ${JSON.stringify(schema.value)})
			`);
        }
        src.push(`
				${this.makeError({ type: "equalValue", actual: "value", expected: JSON.stringify(schema.value), messages })}
		`);
      }
      src.push(`
		return value;
	`);
      return {
        source: src.join("\n")
      };
    };
  }
});

// node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/rules/forbidden.js
var require_forbidden = __commonJS({
  "node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/rules/forbidden.js"(exports2, module2) {
    "use strict";
    module2.exports = function checkForbidden({ schema, messages }, path3, context) {
      const src = [];
      src.push(`
		if (value !== null && value !== undefined) {
	`);
      if (schema.remove) {
        src.push(`
			return undefined;
		`);
      } else {
        src.push(`
			${this.makeError({ type: "forbidden", actual: "value", messages })}
		`);
      }
      src.push(`
		}

		return value;
	`);
      return {
        source: src.join("\n")
      };
    };
  }
});

// node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/rules/function.js
var require_function = __commonJS({
  "node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/rules/function.js"(exports2, module2) {
    "use strict";
    module2.exports = function({ schema, messages }, path3, context) {
      return {
        source: `
			if (typeof value !== "function")
				${this.makeError({ type: "function", actual: "value", messages })}

			return value;
		`
      };
    };
  }
});

// node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/rules/multi.js
var require_multi = __commonJS({
  "node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/rules/multi.js"(exports2, module2) {
    "use strict";
    module2.exports = function({ schema, messages }, path3, context) {
      const src = [];
      src.push(`
		var hasValid = false;
		var newVal = value;
		var checkErrors = [];
		var errorsSize = errors.length;
	`);
      for (let i4 = 0; i4 < schema.rules.length; i4++) {
        src.push(`
			if (!hasValid) {
				var _errors = [];
		`);
        const rule = this.getRuleFromSchema(schema.rules[i4]);
        src.push(this.compileRule(rule, context, path3, `var tmpVal = ${context.async ? "await " : ""}context.fn[%%INDEX%%](value, field, parent, _errors, context);`, "tmpVal"));
        src.push(`
				if (errors.length == errorsSize && _errors.length == 0) {
					hasValid = true;
					newVal = tmpVal;
				} else {
					Array.prototype.push.apply(checkErrors, [].concat(_errors, errors.splice(errorsSize)));
				}
			}
		`);
      }
      src.push(`
		if (!hasValid) {
			Array.prototype.push.apply(errors, checkErrors);
		}

		return newVal;
	`);
      return {
        source: src.join("\n")
      };
    };
  }
});

// node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/rules/number.js
var require_number = __commonJS({
  "node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/rules/number.js"(exports2, module2) {
    "use strict";
    module2.exports = function({ schema, messages }, path3, context) {
      const src = [];
      src.push(`
		var origValue = value;
	`);
      let sanitized = false;
      if (schema.convert === true) {
        sanitized = true;
        src.push(`
			if (typeof value !== "number") {
				value = Number(value);
			}
		`);
      }
      src.push(`
		if (typeof value !== "number" || isNaN(value) || !isFinite(value)) {
			${this.makeError({ type: "number", actual: "origValue", messages })}
			return value;
		}
	`);
      if (schema.min != null) {
        src.push(`
			if (value < ${schema.min}) {
				${this.makeError({ type: "numberMin", expected: schema.min, actual: "origValue", messages })}
			}
		`);
      }
      if (schema.max != null) {
        src.push(`
			if (value > ${schema.max}) {
				${this.makeError({ type: "numberMax", expected: schema.max, actual: "origValue", messages })}
			}
		`);
      }
      if (schema.equal != null) {
        src.push(`
			if (value !== ${schema.equal}) {
				${this.makeError({ type: "numberEqual", expected: schema.equal, actual: "origValue", messages })}
			}
		`);
      }
      if (schema.notEqual != null) {
        src.push(`
			if (value === ${schema.notEqual}) {
				${this.makeError({ type: "numberNotEqual", expected: schema.notEqual, actual: "origValue", messages })}
			}
		`);
      }
      if (schema.integer === true) {
        src.push(`
			if (value % 1 !== 0) {
				${this.makeError({ type: "numberInteger", actual: "origValue", messages })}
			}
		`);
      }
      if (schema.positive === true) {
        src.push(`
			if (value <= 0) {
				${this.makeError({ type: "numberPositive", actual: "origValue", messages })}
			}
		`);
      }
      if (schema.negative === true) {
        src.push(`
			if (value >= 0) {
				${this.makeError({ type: "numberNegative", actual: "origValue", messages })}
			}
		`);
      }
      src.push(`
		return value;
	`);
      return {
        sanitized,
        source: src.join("\n")
      };
    };
  }
});

// node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/rules/object.js
var require_object = __commonJS({
  "node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/rules/object.js"(exports2, module2) {
    "use strict";
    var identifierRegex = /^[_$a-zA-Z][_$a-zA-Z0-9]*$/;
    var escapeEvalRegex = /["'\\\n\r\u2028\u2029]/g;
    function escapeEvalString(str) {
      return str.replace(escapeEvalRegex, function(character) {
        switch (character) {
          case '"':
          case "'":
          case "\\":
            return "\\" + character;
          // Four possible LineTerminator characters need to be escaped:
          case "\n":
            return "\\n";
          case "\r":
            return "\\r";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
        }
      });
    }
    module2.exports = function({ schema, messages }, path3, context) {
      const sourceCode = [];
      sourceCode.push(`
		if (typeof value !== "object" || value === null || Array.isArray(value)) {
			${this.makeError({ type: "object", actual: "value", messages })}
			return value;
		}
	`);
      const subSchema = schema.properties || schema.props;
      if (subSchema) {
        sourceCode.push("var parentObj = value;");
        sourceCode.push("var parentField = field;");
        const keys2 = Object.keys(subSchema).filter((key) => !this.isMetaKey(key));
        for (let i4 = 0; i4 < keys2.length; i4++) {
          const property = keys2[i4];
          const rule = this.getRuleFromSchema(subSchema[property]);
          const name = escapeEvalString(property);
          const safeSubName = identifierRegex.test(name) ? `.${name}` : `['${name}']`;
          const safePropName = `parentObj${safeSubName}`;
          const newPath = (path3 ? path3 + "." : "") + property;
          const labelName = rule.schema.label;
          const label = labelName ? `'${escapeEvalString(labelName)}'` : void 0;
          sourceCode.push(`
// Field: ${escapeEvalString(newPath)}`);
          sourceCode.push(`field = parentField ? parentField + "${safeSubName}" : "${name}";`);
          sourceCode.push(`value = ${safePropName};`);
          sourceCode.push(`label = ${label}`);
          const innerSource = `
				${safePropName} = ${context.async ? "await " : ""}context.fn[%%INDEX%%](value, field, parentObj, errors, context, label);
			`;
          sourceCode.push(this.compileRule(rule, context, newPath, innerSource, safePropName));
          if (this.opts.haltOnFirstError === true) {
            sourceCode.push("if (errors.length) return parentObj;");
          }
        }
        if (schema.strict) {
          const allowedProps = Object.keys(subSchema);
          sourceCode.push(`
				field = parentField;
				var invalidProps = [];
				var props = Object.keys(parentObj);

				for (let i = 0; i < props.length; i++) {
					if (${JSON.stringify(allowedProps)}.indexOf(props[i]) === -1) {
						invalidProps.push(props[i]);
					}
				}
				if (invalidProps.length) {
			`);
          if (schema.strict === "remove") {
            sourceCode.push(`
					if (errors.length === 0) {
				`);
            sourceCode.push(`
						invalidProps.forEach(function(field) {
							delete parentObj[field];
						});
				`);
            sourceCode.push(`
					}
				`);
          } else {
            sourceCode.push(`
					${this.makeError({ type: "objectStrict", expected: '"' + allowedProps.join(", ") + '"', actual: "invalidProps.join(', ')", messages })}
				`);
          }
          sourceCode.push(`
				}
			`);
        }
      }
      if (schema.minProps != null || schema.maxProps != null) {
        if (schema.strict) {
          sourceCode.push(`
				props = Object.keys(${subSchema ? "parentObj" : "value"});
			`);
        } else {
          sourceCode.push(`
				var props = Object.keys(${subSchema ? "parentObj" : "value"});
				${subSchema ? "field = parentField;" : ""}
			`);
        }
      }
      if (schema.minProps != null) {
        sourceCode.push(`
			if (props.length < ${schema.minProps}) {
				${this.makeError({ type: "objectMinProps", expected: schema.minProps, actual: "props.length", messages })}
			}
		`);
      }
      if (schema.maxProps != null) {
        sourceCode.push(`
			if (props.length > ${schema.maxProps}) {
				${this.makeError({ type: "objectMaxProps", expected: schema.maxProps, actual: "props.length", messages })}
			}
		`);
      }
      if (subSchema) {
        sourceCode.push(`
			return parentObj;
		`);
      } else {
        sourceCode.push(`
			return value;
		`);
      }
      return {
        source: sourceCode.join("\n")
      };
    };
  }
});

// node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/rules/objectID.js
var require_objectID = __commonJS({
  "node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/rules/objectID.js"(exports2, module2) {
    "use strict";
    module2.exports = function({ schema, messages, index }, path3, context) {
      const src = [];
      if (!context.customs[index]) context.customs[index] = { schema };
      else context.customs[index].schema = schema;
      src.push(`
		const ObjectID = context.customs[${index}].schema.ObjectID;
		if (!ObjectID.isValid(value)) {
			${this.makeError({ type: "objectID", actual: "value", messages })}
			return;
		}
	`);
      if (schema.convert === true) src.push("return new ObjectID(value)");
      else if (schema.convert === "hexString") src.push("return value.toString()");
      else src.push("return value");
      return {
        source: src.join("\n")
      };
    };
  }
});

// node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/rules/record.js
var require_record = __commonJS({
  "node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/rules/record.js"(exports2, module2) {
    function patchKeyRuleMessages(rule) {
      for (const type in rule.messages) {
        if (type.startsWith("string")) {
          rule.messages[type] = rule.messages[type].replace(" field ", " key ");
        }
      }
    }
    module2.exports = function compileRecordRule({ schema, messages }, path3, context) {
      const sourceCode = [];
      sourceCode.push(`
		if (typeof value !== "object" || value === null || Array.isArray(value)) {
			${this.makeError({ type: "record", actual: "value", messages })}
			return value;
		}
	`);
      const keyRuleName = schema.key || "string";
      const valueRuleName = schema.value || "any";
      sourceCode.push(`
		const record = value;
		let sanitizedKey, sanitizedValue;
		const result = {};
		for (let key in value) {
	`);
      sourceCode.push("sanitizedKey = value = key;");
      const keyRule = this.getRuleFromSchema(keyRuleName);
      patchKeyRuleMessages(keyRule);
      const keyInnerSource = `
		sanitizedKey = ${context.async ? "await " : ""}context.fn[%%INDEX%%](key, field ? field + "." + key : key, record, errors, context);
	`;
      sourceCode.push(this.compileRule(keyRule, context, null, keyInnerSource, "sanitizedKey"));
      sourceCode.push("sanitizedValue = value = record[key];");
      const valueRule = this.getRuleFromSchema(valueRuleName);
      const valueInnerSource = `
		sanitizedValue = ${context.async ? "await " : ""}context.fn[%%INDEX%%](value, field ? field + "." + key : key, record, errors, context);
	`;
      sourceCode.push(this.compileRule(valueRule, context, `${path3}[key]`, valueInnerSource, "sanitizedValue"));
      sourceCode.push("result[sanitizedKey] = sanitizedValue;");
      sourceCode.push(`
		}
	`);
      sourceCode.push("return result;");
      return {
        source: sourceCode.join("\n")
      };
    };
  }
});

// node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/rules/string.js
var require_string = __commonJS({
  "node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/rules/string.js"(exports2, module2) {
    "use strict";
    var NUMERIC_PATTERN = /^-?[0-9]\d*(\.\d+)?$/;
    var ALPHA_PATTERN = /^[a-zA-Z]+$/;
    var ALPHANUM_PATTERN = /^[a-zA-Z0-9]+$/;
    var ALPHADASH_PATTERN = /^[a-zA-Z0-9_-]+$/;
    var HEX_PATTERN = /^[0-9a-fA-F]+$/;
    var BASE64_PATTERN = /^(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+/]{3}=)?$/;
    module2.exports = function checkString({ schema, messages }, path3, context) {
      const src = [];
      let sanitized = false;
      if (schema.convert === true) {
        sanitized = true;
        src.push(`
			if (typeof value !== "string") {
				value = String(value);
			}
		`);
      }
      src.push(`
		if (typeof value !== "string") {
			${this.makeError({ type: "string", actual: "value", messages })}
			return value;
		}

		var origValue = value;
	`);
      if (schema.trim) {
        sanitized = true;
        src.push(`
			value = value.trim();
		`);
      }
      if (schema.trimLeft) {
        sanitized = true;
        src.push(`
			value = value.trimLeft();
		`);
      }
      if (schema.trimRight) {
        sanitized = true;
        src.push(`
			value = value.trimRight();
		`);
      }
      if (schema.padStart) {
        sanitized = true;
        const padChar = schema.padChar != null ? schema.padChar : " ";
        src.push(`
			value = value.padStart(${schema.padStart}, ${JSON.stringify(padChar)});
		`);
      }
      if (schema.padEnd) {
        sanitized = true;
        const padChar = schema.padChar != null ? schema.padChar : " ";
        src.push(`
			value = value.padEnd(${schema.padEnd}, ${JSON.stringify(padChar)});
		`);
      }
      if (schema.lowercase) {
        sanitized = true;
        src.push(`
			value = value.toLowerCase();
		`);
      }
      if (schema.uppercase) {
        sanitized = true;
        src.push(`
			value = value.toUpperCase();
		`);
      }
      if (schema.localeLowercase) {
        sanitized = true;
        src.push(`
			value = value.toLocaleLowerCase();
		`);
      }
      if (schema.localeUppercase) {
        sanitized = true;
        src.push(`
			value = value.toLocaleUpperCase();
		`);
      }
      src.push(`
			var len = value.length;
	`);
      if (schema.empty === false) {
        src.push(`
			if (len === 0) {
				${this.makeError({ type: "stringEmpty", actual: "value", messages })}
			}
		`);
      } else if (schema.empty === true) {
        src.push(`
			if (len === 0) {
				return value;
			}
		`);
      }
      if (schema.min != null) {
        src.push(`
			if (len < ${schema.min}) {
				${this.makeError({ type: "stringMin", expected: schema.min, actual: "len", messages })}
			}
		`);
      }
      if (schema.max != null) {
        src.push(`
			if (len > ${schema.max}) {
				${this.makeError({ type: "stringMax", expected: schema.max, actual: "len", messages })}
			}
		`);
      }
      if (schema.length != null) {
        src.push(`
			if (len !== ${schema.length}) {
				${this.makeError({ type: "stringLength", expected: schema.length, actual: "len", messages })}
			}
		`);
      }
      if (schema.pattern != null) {
        let pattern = schema.pattern;
        if (typeof schema.pattern == "string")
          pattern = new RegExp(schema.pattern, schema.patternFlags);
        src.push(`
			if (!${pattern.toString()}.test(value)) {
				${this.makeError({ type: "stringPattern", expected: `"${pattern.toString().replace(/"/g, "\\$&")}"`, actual: "origValue", messages })}
			}
		`);
      }
      if (schema.contains != null) {
        src.push(`
			if (value.indexOf("${schema.contains}") === -1) {
				${this.makeError({ type: "stringContains", expected: '"' + schema.contains + '"', actual: "origValue", messages })}
			}
		`);
      }
      if (schema.enum != null) {
        const enumStr = JSON.stringify(schema.enum);
        src.push(`
			if (${enumStr}.indexOf(value) === -1) {
				${this.makeError({ type: "stringEnum", expected: '"' + schema.enum.join(", ") + '"', actual: "origValue", messages })}
			}
		`);
      }
      if (schema.numeric === true) {
        src.push(`
			if (!${NUMERIC_PATTERN.toString()}.test(value) ) {
				${this.makeError({ type: "stringNumeric", actual: "origValue", messages })}
			}
		`);
      }
      if (schema.alpha === true) {
        src.push(`
			if(!${ALPHA_PATTERN.toString()}.test(value)) {
				${this.makeError({ type: "stringAlpha", actual: "origValue", messages })}
			}
		`);
      }
      if (schema.alphanum === true) {
        src.push(`
			if(!${ALPHANUM_PATTERN.toString()}.test(value)) {
				${this.makeError({ type: "stringAlphanum", actual: "origValue", messages })}
			}
		`);
      }
      if (schema.alphadash === true) {
        src.push(`
			if(!${ALPHADASH_PATTERN.toString()}.test(value)) {
				${this.makeError({ type: "stringAlphadash", actual: "origValue", messages })}
			}
		`);
      }
      if (schema.hex === true) {
        src.push(`
			if(value.length % 2 !== 0 || !${HEX_PATTERN.toString()}.test(value)) {
				${this.makeError({ type: "stringHex", actual: "origValue", messages })}
			}
		`);
      }
      if (schema.singleLine === true) {
        src.push(`
			if(value.includes("\\n")) {
				${this.makeError({ type: "stringSingleLine", messages })}
			}
		`);
      }
      if (schema.base64 === true) {
        src.push(`
			if(!${BASE64_PATTERN.toString()}.test(value)) {
				${this.makeError({ type: "stringBase64", actual: "origValue", messages })}
			}
		`);
      }
      src.push(`
		return value;
	`);
      return {
        sanitized,
        source: src.join("\n")
      };
    };
  }
});

// node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/rules/tuple.js
var require_tuple = __commonJS({
  "node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/rules/tuple.js"(exports2, module2) {
    "use strict";
    module2.exports = function({ schema, messages }, path3, context) {
      const src = [];
      if (schema.items != null) {
        if (!Array.isArray(schema.items)) {
          throw new Error(`Invalid '${schema.type}' schema. The 'items' field must be an array.`);
        }
        if (schema.items.length === 0) {
          throw new Error(`Invalid '${schema.type}' schema. The 'items' field must not be an empty array.`);
        }
      }
      src.push(`
		if (!Array.isArray(value)) {
			${this.makeError({ type: "tuple", actual: "value", messages })}
			return value;
		}

		var len = value.length;
	`);
      if (schema.empty === false) {
        src.push(`
			if (len === 0) {
				${this.makeError({ type: "tupleEmpty", actual: "value", messages })}
				return value;
			}
		`);
      }
      if (schema.items != null) {
        src.push(`
			if (${schema.empty} !== false && len === 0) {
				return value;
			}

			if (len !== ${schema.items.length}) {
				${this.makeError({ type: "tupleLength", expected: schema.items.length, actual: "len", messages })}
				return value;
			}
		`);
        src.push(`
			var arr = value;
			var parentField = field;
		`);
        for (let i4 = 0; i4 < schema.items.length; i4++) {
          src.push(`
			value = arr[${i4}];
		`);
          const itemPath = `${path3}[${i4}]`;
          const rule = this.getRuleFromSchema(schema.items[i4]);
          const innerSource = `
			arr[${i4}] = ${context.async ? "await " : ""}context.fn[%%INDEX%%](arr[${i4}], (parentField ? parentField : "") + "[" + ${i4} + "]", parent, errors, context);
		`;
          src.push(this.compileRule(rule, context, itemPath, innerSource, `arr[${i4}]`));
        }
        src.push(`
		return arr;
	`);
      } else {
        src.push(`
		return value;
	`);
      }
      return {
        source: src.join("\n")
      };
    };
  }
});

// node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/rules/url.js
var require_url = __commonJS({
  "node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/rules/url.js"(exports2, module2) {
    "use strict";
    var PATTERN = /^https?:\/\/\S+/;
    module2.exports = function({ schema, messages }, path3, context) {
      const src = [];
      src.push(`
		if (typeof value !== "string") {
			${this.makeError({ type: "string", actual: "value", messages })}
			return value;
		}
	`);
      if (!schema.empty) {
        src.push(`
			if (value.length === 0) {
				${this.makeError({ type: "urlEmpty", actual: "value", messages })}
				return value;
			}
		`);
      } else {
        src.push(`
			if (value.length === 0) return value;
		`);
      }
      src.push(`
		if (!${PATTERN.toString()}.test(value)) {
			${this.makeError({ type: "url", actual: "value", messages })}
		}

		return value;
	`);
      return {
        source: src.join("\n")
      };
    };
  }
});

// node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/rules/uuid.js
var require_uuid = __commonJS({
  "node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/rules/uuid.js"(exports2, module2) {
    "use strict";
    var PATTERN = /^([0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[0-9a-f]{4}-[0-9a-f]{12}|[0]{8}-[0]{4}-[0]{4}-[0]{4}-[0]{12})$/i;
    module2.exports = function({ schema, messages }, path3) {
      const src = [];
      src.push(`
		if (typeof value !== "string") {
			${this.makeError({ type: "string", actual: "value", messages })}
			return value;
		}

		var val = value.toLowerCase();
		if (!${PATTERN.toString()}.test(val)) {
			${this.makeError({ type: "uuid", actual: "value", messages })}
			return value;
		}

		const version = val.charAt(14) | 0;
	`);
      if (parseInt(schema.version) < 9) {
        src.push(`
			if (${schema.version} !== version) {
				${this.makeError({ type: "uuidVersion", expected: schema.version, actual: "version", messages })}
				return value;
			}
		`);
      }
      src.push(`
		switch (version) {
		case 0:
		case 1:
		case 2:
		case 6:
			break;
		case 3:
		case 4:
		case 5:
  		case 7:
		case 8:
			if (["8", "9", "a", "b"].indexOf(val.charAt(19)) === -1) {
				${this.makeError({ type: "uuid", actual: "value", messages })}
			}
		}

		return value;
	`);
      return {
        source: src.join("\n")
      };
    };
  }
});

// node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/rules/mac.js
var require_mac = __commonJS({
  "node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/rules/mac.js"(exports2, module2) {
    "use strict";
    var PATTERN = /^((([a-f0-9][a-f0-9]+[-]){5}|([a-f0-9][a-f0-9]+[:]){5})([a-f0-9][a-f0-9])$)|(^([a-f0-9][a-f0-9][a-f0-9][a-f0-9]+[.]){2}([a-f0-9][a-f0-9][a-f0-9][a-f0-9]))$/i;
    module2.exports = function({ schema, messages }, path3, context) {
      return {
        source: `
			if (typeof value !== "string") {
				${this.makeError({ type: "string", actual: "value", messages })}
				return value;
			}

			var v = value.toLowerCase();
			if (!${PATTERN.toString()}.test(v)) {
				${this.makeError({ type: "mac", actual: "value", messages })}
			}
			
			return value;
		`
      };
    };
  }
});

// node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/rules/luhn.js
var require_luhn = __commonJS({
  "node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/rules/luhn.js"(exports2, module2) {
    "use strict";
    module2.exports = function({ schema, messages }, path3, context) {
      return {
        source: `
			if (typeof value !== "string") {
				${this.makeError({ type: "string", actual: "value", messages })}
				return value;
			}

			if (typeof value !== "string")
				value = String(value);

			val = value.replace(/\\D+/g, "");

			var array = [0, 2, 4, 6, 8, 1, 3, 5, 7, 9];
			var len = val ? val.length : 0,
				bit = 1,
				sum = 0;
			while (len--) {
				sum += !(bit ^= 1) ? parseInt(val[len], 10) : array[val[len]];
			}

			if (!(sum % 10 === 0 && sum > 0)) {
				${this.makeError({ type: "luhn", actual: "value", messages })}
			}

			return value;
		`
      };
    };
  }
});

// node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/helpers/prettier.js
var require_prettier = __commonJS({
  "node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/helpers/prettier.js"(exports2, module2) {
    var prettier;
    var prettierOpts;
    var hljs;
    var hljsOpts;
    var mod1 = "prettier";
    var mod2 = "cli-highlight";
    module2.exports = function(source) {
      if (!prettier) {
        prettier = require(mod1);
        prettierOpts = {
          parser: "babel",
          useTabs: false,
          printWidth: 120,
          trailingComma: "none",
          tabWidth: 4,
          singleQuote: false,
          semi: true,
          bracketSpacing: true
        };
        hljs = require(mod2);
        hljsOpts = {
          language: "js",
          theme: hljs.fromJson({
            keyword: ["white", "bold"],
            built_in: "magenta",
            literal: "cyan",
            number: "magenta",
            regexp: "red",
            string: ["yellow", "bold"],
            symbol: "plain",
            class: "blue",
            attr: "plain",
            function: ["white", "bold"],
            title: "plain",
            params: "green",
            comment: "grey"
          })
        };
      }
      const res = prettier.format(source, prettierOpts);
      return hljs.highlight(res, hljsOpts);
    };
  }
});

// node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/validator.js
var require_validator = __commonJS({
  "node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/lib/validator.js"(exports2, module2) {
    "use strict";
    var AsyncFunction;
    try {
      AsyncFunction = new Function("return Object.getPrototypeOf(async function(){}).constructor")();
    } catch (err) {
    }
    var deepExtend = require_deep_extend();
    var replace = require_replace();
    function loadMessages() {
      return Object.assign({}, require_messages());
    }
    function loadRules() {
      return {
        any: require_any(),
        array: require_array(),
        boolean: require_boolean(),
        class: require_class(),
        custom: require_custom(),
        currency: require_currency(),
        date: require_date(),
        email: require_email(),
        enum: require_enum(),
        equal: require_equal(),
        forbidden: require_forbidden(),
        function: require_function(),
        multi: require_multi(),
        number: require_number(),
        object: require_object(),
        objectID: require_objectID(),
        record: require_record(),
        string: require_string(),
        tuple: require_tuple(),
        url: require_url(),
        uuid: require_uuid(),
        mac: require_mac(),
        luhn: require_luhn()
      };
    }
    var Validator2 = class {
      /**
       * Validator class constructor
       *
       * @param {Object} opts
       */
      constructor(opts) {
        this.opts = {};
        this.defaults = {};
        this.messages = loadMessages();
        this.rules = loadRules();
        this.aliases = {};
        this.cache = /* @__PURE__ */ new Map();
        this.customFunctions = {};
        if (opts) {
          deepExtend(this.opts, opts);
          if (opts.defaults) deepExtend(this.defaults, opts.defaults);
          if (opts.messages) {
            for (const messageName in opts.messages) this.addMessage(messageName, opts.messages[messageName]);
          }
          if (opts.aliases) {
            for (const aliasName in opts.aliases) this.alias(aliasName, opts.aliases[aliasName]);
          }
          if (opts.customRules) {
            for (const ruleName in opts.customRules) this.add(ruleName, opts.customRules[ruleName]);
          }
          if (opts.customFunctions) {
            for (const customName in opts.customFunctions) this.addCustomFunction(customName, opts.customFunctions[customName]);
          }
          if (opts.plugins) {
            const plugins = opts.plugins;
            if (!Array.isArray(plugins)) throw new Error("Plugins type must be array");
            plugins.forEach(this.plugin.bind(this));
          }
          if (this.opts.debug) {
            let formatter = function(code) {
              return code;
            };
            if (typeof window === "undefined") {
              formatter = require_prettier();
            }
            this._formatter = formatter;
          }
        }
      }
      /**
       * Validate an object by schema
       *
       * @param {Object} obj
       * @param {Object} schema
       * @returns {Array<Object>|boolean}
       */
      validate(obj, schema) {
        const check = this.compile(schema);
        return check(obj);
      }
      /**
       * Wrap a source code with `required` & `optional` checker codes.
       * @param {Object} rule
       * @param {String} innerSrc
       * @param {String?} resVar
       * @returns {String}
       */
      wrapRequiredCheckSourceCode(rule, innerSrc, context, resVar) {
        const src = [];
        const { considerNullAsAValue = false } = this.opts;
        let handleNoValue;
        let skipUndefinedValue = rule.schema.optional === true || rule.schema.type === "forbidden";
        let skipNullValue = considerNullAsAValue ? rule.schema.nullable !== false || rule.schema.type === "forbidden" : rule.schema.optional === true || rule.schema.nullable === true || rule.schema.type === "forbidden";
        const ruleHasDefault = considerNullAsAValue ? rule.schema.default != void 0 && rule.schema.default != null : rule.schema.default != void 0;
        if (ruleHasDefault) {
          skipUndefinedValue = false;
          if (considerNullAsAValue) {
            if (rule.schema.nullable === false) skipNullValue = false;
          } else {
            if (rule.schema.nullable !== true) skipNullValue = false;
          }
          let defaultValue;
          if (typeof rule.schema.default === "function") {
            if (!context.customs[rule.index]) context.customs[rule.index] = {};
            context.customs[rule.index].defaultFn = rule.schema.default;
            defaultValue = `context.customs[${rule.index}].defaultFn.call(this, context.rules[${rule.index}].schema, field, parent, context)`;
          } else {
            defaultValue = JSON.stringify(rule.schema.default);
          }
          handleNoValue = `
				value = ${defaultValue};
				${resVar} = value;
			`;
        } else {
          handleNoValue = this.makeError({ type: "required", actual: "value", messages: rule.messages });
        }
        src.push(`
			${`if (value === undefined) { ${skipUndefinedValue ? "\n// allow undefined\n" : handleNoValue} }`}
			${`else if (value === null) { ${skipNullValue ? "\n// allow null\n" : handleNoValue} }`}
			${innerSrc ? `else { ${innerSrc} }` : ""}
		`);
        return src.join("\n");
      }
      /**
       * check if the key is a meta key
       *
       * @param key
       * @return {boolean}
       */
      isMetaKey(key) {
        return key.startsWith("$$");
      }
      /**
       * will remove all "metas" keys (keys starting with $$)
       *
       * @param obj
       */
      removeMetasKeys(obj) {
        Object.keys(obj).forEach((key) => {
          if (!this.isMetaKey(key)) {
            return;
          }
          delete obj[key];
        });
      }
      /**
       * Compile a schema
       *
       * @param {Object} schema
       * @throws {Error} Invalid schema
       * @returns {Function}
       */
      compile(schema) {
        if (schema === null || typeof schema !== "object") {
          throw new Error("Invalid schema.");
        }
        const self2 = this;
        const context = {
          index: 0,
          async: schema.$$async === true,
          rules: [],
          fn: [],
          customs: {},
          customFunctions: this.customFunctions,
          utils: {
            replace
          }
        };
        this.cache.clear();
        delete schema.$$async;
        if (context.async && !AsyncFunction) {
          throw new Error("Asynchronous mode is not supported.");
        }
        if (schema.$$root !== true) {
          if (Array.isArray(schema)) {
            const rule2 = this.getRuleFromSchema(schema);
            schema = rule2.schema;
          } else {
            const prevSchema = Object.assign({}, schema);
            schema = {
              type: "object",
              strict: prevSchema.$$strict,
              properties: prevSchema
            };
            this.removeMetasKeys(prevSchema);
          }
        }
        const sourceCode = [
          "var errors = [];",
          "var field;",
          "var parent = null;",
          `var label = ${schema.label ? '"' + schema.label + '"' : "null"};`
        ];
        const rule = this.getRuleFromSchema(schema);
        sourceCode.push(this.compileRule(rule, context, null, `${context.async ? "await " : ""}context.fn[%%INDEX%%](value, field, null, errors, context, label);`, "value"));
        sourceCode.push("if (errors.length) {");
        sourceCode.push(`
			return errors.map(err => {
				if (err.message) {
					err.message = context.utils.replace(err.message, /\\{field\\}/g, err.label || err.field);
					err.message = context.utils.replace(err.message, /\\{expected\\}/g, err.expected);
					err.message = context.utils.replace(err.message, /\\{actual\\}/g, err.actual);
				}
				if(!err.label) delete err.label
				return err;
			});
		`);
        sourceCode.push("}");
        sourceCode.push("return true;");
        const src = sourceCode.join("\n");
        const FnClass = context.async ? AsyncFunction : Function;
        const checkFn = new FnClass("value", "context", src);
        if (this.opts.debug) {
          console.log(this._formatter("// Main check function\n" + checkFn.toString()));
        }
        this.cache.clear();
        const resFn = function(data2, opts) {
          context.data = data2;
          if (opts && opts.meta)
            context.meta = opts.meta;
          return checkFn.call(self2, data2, context);
        };
        resFn.async = context.async;
        return resFn;
      }
      /**
       * Compile a rule to source code.
       * @param {Object} rule
       * @param {Object} context
       * @param {String} path
       * @param {String} innerSrc
       * @param {String} resVar
       * @returns {String}
       */
      compileRule(rule, context, path3, innerSrc, resVar) {
        const sourceCode = [];
        const item = this.cache.get(rule.schema);
        if (item) {
          rule = item;
          rule.cycle = true;
          rule.cycleStack = [];
          sourceCode.push(this.wrapRequiredCheckSourceCode(rule, `
				var rule = context.rules[${rule.index}];
				if (rule.cycleStack.indexOf(value) === -1) {
					rule.cycleStack.push(value);
					${innerSrc.replace(/%%INDEX%%/g, rule.index)}
					rule.cycleStack.pop(value);
				}
			`, context, resVar));
        } else {
          this.cache.set(rule.schema, rule);
          rule.index = context.index;
          context.rules[context.index] = rule;
          const customPath = path3 != null ? path3 : "$$root";
          context.index++;
          const res = rule.ruleFunction.call(this, rule, path3, context);
          res.source = res.source.replace(/%%INDEX%%/g, rule.index);
          const FnClass = context.async ? AsyncFunction : Function;
          const fn = new FnClass("value", "field", "parent", "errors", "context", "label", res.source);
          context.fn[rule.index] = fn.bind(this);
          sourceCode.push(this.wrapRequiredCheckSourceCode(rule, innerSrc.replace(/%%INDEX%%/g, rule.index), context, resVar));
          sourceCode.push(this.makeCustomValidator({ vName: resVar, path: customPath, schema: rule.schema, context, messages: rule.messages, ruleIndex: rule.index }));
          if (this.opts.debug) {
            console.log(this._formatter(`// Context.fn[${rule.index}]
` + fn.toString()));
          }
        }
        return sourceCode.join("\n");
      }
      /**
       * Create a rule instance from schema definition.
       * @param {Object} schema
       * @returns {Object} rule
       */
      getRuleFromSchema(schema) {
        schema = this.resolveType(schema);
        const alias = this.aliases[schema.type];
        if (alias) {
          delete schema.type;
          schema = deepExtend(schema, alias, { skipIfExist: true });
        }
        const ruleFunction = this.rules[schema.type];
        if (!ruleFunction)
          throw new Error("Invalid '" + schema.type + "' type in validator schema.");
        const rule = {
          messages: Object.assign({}, this.messages, schema.messages),
          schema: deepExtend(schema, this.defaults[schema.type], { skipIfExist: true }),
          ruleFunction
        };
        return rule;
      }
      /**
       * Parse rule from shorthand string
       * @param {String} str shorthand string
       * @param {Object} schema schema reference
       */
      parseShortHand(str) {
        const p4 = str.split("|").map((s4) => s4.trim());
        let type = p4[0];
        let schema;
        if (type.endsWith("[]")) {
          schema = this.getRuleFromSchema({ type: "array", items: type.slice(0, -2) }).schema;
        } else {
          schema = {
            type: p4[0]
          };
        }
        p4.slice(1).forEach((s4) => {
          const idx = s4.indexOf(":");
          if (idx !== -1) {
            const key = s4.substring(0, idx).trim();
            let value = s4.substring(idx + 1).trim();
            if (value === "true" || value === "false")
              value = value === "true";
            else if (!Number.isNaN(Number(value))) {
              value = Number(value);
            }
            schema[key] = value;
          } else {
            if (s4.startsWith("no-")) schema[s4.slice(3)] = false;
            else schema[s4] = true;
          }
        });
        return schema;
      }
      /**
       * Generate error source code.
       * @param {Object} opts
       * @param {String} opts.type
       * @param {String} opts.field
       * @param {any} opts.expected
       * @param {any} opts.actual
       * @param {Object} opts.messages
       */
      makeError({ type, field, expected, actual, messages }) {
        const o4 = {
          type: `"${type}"`,
          message: `"${messages[type]}"`
        };
        if (field) o4.field = `"${field}"`;
        else o4.field = "field";
        if (expected != null) o4.expected = expected;
        if (actual != null) o4.actual = actual;
        o4.label = "label";
        const s4 = Object.keys(o4).map((key) => `${key}: ${o4[key]}`).join(", ");
        return `errors.push({ ${s4} });`;
      }
      /**
       * Generate custom validator function source code.
       * @param {Object} opts
       * @param {String} opts.vName
       * @param {String} opts.fnName
       * @param {String} opts.ruleIndex
       * @param {String} opts.path
       * @param {Object} opts.schema
       * @param {Object} opts.context
      	 * @param {Object} opts.messages
       */
      makeCustomValidator({ vName = "value", fnName = "custom", ruleIndex, path: path3, schema, context, messages }) {
        const ruleVName = "rule" + ruleIndex;
        const fnCustomErrorsVName = "fnCustomErrors" + ruleIndex;
        if (typeof schema[fnName] == "function" || Array.isArray(schema[fnName])) {
          if (context.customs[ruleIndex]) {
            context.customs[ruleIndex].messages = messages;
            context.customs[ruleIndex].schema = schema;
          } else {
            context.customs[ruleIndex] = { messages, schema };
          }
          const ret = [];
          if (this.opts.useNewCustomCheckerFunction) {
            ret.push(`
               		const ${ruleVName} = context.customs[${ruleIndex}];
					const ${fnCustomErrorsVName} = [];
				`);
            if (Array.isArray(schema[fnName])) {
              for (let i4 = 0; i4 < schema[fnName].length; i4++) {
                let custom = schema[fnName][i4];
                if (typeof custom === "string") {
                  custom = this.parseShortHand(custom);
                  schema[fnName][i4] = custom;
                }
                const customIndex = ruleIndex * 1e3 + i4;
                context.customs[customIndex] = { messages, schema: Object.assign({}, schema, { custom, index: i4 }) };
                ret.push(`
							const ${ruleVName}_${i4} = context.customs[${customIndex}];

					 	`);
                if (custom.type) {
                  ret.push(`
							 ${vName} = ${context.async ? "await " : ""}context.customFunctions[${ruleVName}.schema.${fnName}[${i4}].type].call(this, ${vName}, ${fnCustomErrorsVName} , ${ruleVName}_${i4}.schema, "${path3}", parent, context);
							`);
                }
                if (typeof custom === "function") {
                  ret.push(`
							${vName} = ${context.async ? "await " : ""}${ruleVName}.schema.${fnName}[${i4}].call(this, ${vName}, ${fnCustomErrorsVName} , ${ruleVName}.schema, "${path3}", parent, context);
							`);
                }
              }
            } else {
              ret.push(`
					${vName} = ${context.async ? "await " : ""}${ruleVName}.schema.${fnName}.call(this, ${vName}, ${fnCustomErrorsVName} , ${ruleVName}.schema, "${path3}", parent, context);
					`);
            }
            ret.push(`
					if (Array.isArray(${fnCustomErrorsVName} )) {
                  		${fnCustomErrorsVName} .forEach(err => errors.push(Object.assign({ message: ${ruleVName}.messages[err.type], field }, err)));
					}
				`);
          } else {
            const result = "res_" + ruleVName;
            ret.push(`
					const ${ruleVName} = context.customs[${ruleIndex}];
					const ${result} = ${context.async ? "await " : ""}${ruleVName}.schema.${fnName}.call(this, ${vName}, ${ruleVName}.schema, "${path3}", parent, context);
					if (Array.isArray(${result})) {
						${result}.forEach(err => errors.push(Object.assign({ message: ${ruleVName}.messages[err.type], field }, err)));
					}
			`);
          }
          return ret.join("\n");
        }
        return "";
      }
      /**
       * Add a custom rule
       *
       * @param {String} type
       * @param {Function} fn
       */
      add(type, fn) {
        this.rules[type] = fn;
      }
      /**
       * Add a custom function
       *
       * @param {String} type
       * @param {Function} fn
       */
      addCustomFunction(name, fn) {
        this.customFunctions[name] = fn;
      }
      /**
       * Add a message
       *
       * @param {String} name
       * @param {String} message
       */
      addMessage(name, message) {
        this.messages[name] = message;
      }
      /**
       * create alias name for a rule
       *
       * @param {String} name
       * @param validationRule
       */
      alias(name, validationRule) {
        if (this.rules[name]) throw new Error("Alias name must not be a rule name");
        this.aliases[name] = validationRule;
      }
      /**
       * Add a plugin
       *
       * @param {Function} fn
       */
      plugin(fn) {
        if (typeof fn !== "function") throw new Error("Plugin fn type must be function");
        return fn(this);
      }
      /**
       * Resolve the schema 'type' by:
       * - parsing short hands into full type definitions
       * - expanding arrays into 'multi' types with a rules property
       * - objects which have a root $$type property into a schema which
       *   explicitly has a 'type' property and a 'props' property.
       *
       * @param schema The schema to resolve the type of
       */
      resolveType(schema) {
        if (typeof schema === "string") {
          schema = this.parseShortHand(schema);
        } else if (Array.isArray(schema)) {
          if (schema.length === 0)
            throw new Error("Invalid schema.");
          schema = {
            type: "multi",
            rules: schema
          };
          const isOptional = schema.rules.map((s4) => this.getRuleFromSchema(s4)).every((rule) => rule.schema.optional === true);
          if (isOptional)
            schema.optional = true;
          const nullCheck = this.opts.considerNullAsAValue ? false : true;
          const setNullable = schema.rules.map((s4) => this.getRuleFromSchema(s4)).every((rule) => rule.schema.nullable === nullCheck);
          if (setNullable)
            schema.nullable = nullCheck;
        }
        if (schema.$$type) {
          const type = schema.$$type;
          const otherShorthandProps = this.getRuleFromSchema(type).schema;
          delete schema.$$type;
          const props = Object.assign({}, schema);
          for (const key in schema) {
            delete schema[key];
          }
          deepExtend(schema, otherShorthandProps, { skipIfExist: true });
          schema.props = props;
        }
        return schema;
      }
      /**
       * Normalize a schema, type or short hand definition by expanding it to a full form. The 'normalized'
       * form is the equivalent schema with any short hands undone. This ensure that each rule; always includes
       * a 'type' key, arrays always have an 'items' key, 'multi' always have a 'rules' key and objects always
       * have their properties defined in a 'props' key
       *
       * @param {Object|String} value The value to normalize
       * @returns {Object} The normalized form of the given rule or schema
       */
      normalize(value) {
        let result = this.resolveType(value);
        if (this.aliases[result.type])
          result = deepExtend(result, this.normalize(this.aliases[result.type]), { skipIfExists: true });
        result = deepExtend(result, this.defaults[result.type], { skipIfExist: true });
        if (result.type === "multi") {
          result.rules = result.rules.map((r4) => this.normalize(r4));
          result.optional = result.rules.every((r4) => r4.optional === true);
          return result;
        }
        if (result.type === "array") {
          result.items = this.normalize(result.items);
          return result;
        }
        if (result.type === "object") {
          if (result.props) {
            Object.entries(result.props).forEach(([k4, v4]) => result.props[k4] = this.normalize(v4));
          }
        }
        if (typeof value === "object") {
          if (value.type) {
            const config = this.normalize(value.type);
            deepExtend(result, config, { skipIfExists: true });
          } else {
            Object.entries(value).forEach(([k4, v4]) => result[k4] = this.normalize(v4));
          }
        }
        return result;
      }
    };
    module2.exports = Validator2;
  }
});

// node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/index.js
var require_fastest_validator = __commonJS({
  "node_modules/.pnpm/fastest-validator@1.19.1/node_modules/fastest-validator/index.js"(exports2, module2) {
    module2.exports = require_validator();
  }
});

// node_modules/.pnpm/pino-std-serializers@7.1.0/node_modules/pino-std-serializers/lib/err-helpers.js
var require_err_helpers = __commonJS({
  "node_modules/.pnpm/pino-std-serializers@7.1.0/node_modules/pino-std-serializers/lib/err-helpers.js"(exports2, module2) {
    "use strict";
    var isErrorLike = (err) => {
      return err && typeof err.message === "string";
    };
    var getErrorCause = (err) => {
      if (!err) return;
      const cause = err.cause;
      if (typeof cause === "function") {
        const causeResult = err.cause();
        return isErrorLike(causeResult) ? causeResult : void 0;
      } else {
        return isErrorLike(cause) ? cause : void 0;
      }
    };
    var _stackWithCauses = (err, seen) => {
      if (!isErrorLike(err)) return "";
      const stack = err.stack || "";
      if (seen.has(err)) {
        return stack + "\ncauses have become circular...";
      }
      const cause = getErrorCause(err);
      if (cause) {
        seen.add(err);
        return stack + "\ncaused by: " + _stackWithCauses(cause, seen);
      } else {
        return stack;
      }
    };
    var stackWithCauses = (err) => _stackWithCauses(err, /* @__PURE__ */ new Set());
    var _messageWithCauses = (err, seen, skip) => {
      if (!isErrorLike(err)) return "";
      const message = skip ? "" : err.message || "";
      if (seen.has(err)) {
        return message + ": ...";
      }
      const cause = getErrorCause(err);
      if (cause) {
        seen.add(err);
        const skipIfVErrorStyleCause = typeof err.cause === "function";
        return message + (skipIfVErrorStyleCause ? "" : ": ") + _messageWithCauses(cause, seen, skipIfVErrorStyleCause);
      } else {
        return message;
      }
    };
    var messageWithCauses = (err) => _messageWithCauses(err, /* @__PURE__ */ new Set());
    module2.exports = {
      isErrorLike,
      getErrorCause,
      stackWithCauses,
      messageWithCauses
    };
  }
});

// node_modules/.pnpm/pino-std-serializers@7.1.0/node_modules/pino-std-serializers/lib/err-proto.js
var require_err_proto = __commonJS({
  "node_modules/.pnpm/pino-std-serializers@7.1.0/node_modules/pino-std-serializers/lib/err-proto.js"(exports2, module2) {
    "use strict";
    var seen = /* @__PURE__ */ Symbol("circular-ref-tag");
    var rawSymbol = /* @__PURE__ */ Symbol("pino-raw-err-ref");
    var pinoErrProto = Object.create({}, {
      type: {
        enumerable: true,
        writable: true,
        value: void 0
      },
      message: {
        enumerable: true,
        writable: true,
        value: void 0
      },
      stack: {
        enumerable: true,
        writable: true,
        value: void 0
      },
      aggregateErrors: {
        enumerable: true,
        writable: true,
        value: void 0
      },
      raw: {
        enumerable: false,
        get: function() {
          return this[rawSymbol];
        },
        set: function(val) {
          this[rawSymbol] = val;
        }
      }
    });
    Object.defineProperty(pinoErrProto, rawSymbol, {
      writable: true,
      value: {}
    });
    module2.exports = {
      pinoErrProto,
      pinoErrorSymbols: {
        seen,
        rawSymbol
      }
    };
  }
});

// node_modules/.pnpm/pino-std-serializers@7.1.0/node_modules/pino-std-serializers/lib/err.js
var require_err = __commonJS({
  "node_modules/.pnpm/pino-std-serializers@7.1.0/node_modules/pino-std-serializers/lib/err.js"(exports2, module2) {
    "use strict";
    module2.exports = errSerializer;
    var { messageWithCauses, stackWithCauses, isErrorLike } = require_err_helpers();
    var { pinoErrProto, pinoErrorSymbols } = require_err_proto();
    var { seen } = pinoErrorSymbols;
    var { toString: toString2 } = Object.prototype;
    function errSerializer(err) {
      if (!isErrorLike(err)) {
        return err;
      }
      err[seen] = void 0;
      const _err = Object.create(pinoErrProto);
      _err.type = toString2.call(err.constructor) === "[object Function]" ? err.constructor.name : err.name;
      _err.message = messageWithCauses(err);
      _err.stack = stackWithCauses(err);
      if (Array.isArray(err.errors)) {
        _err.aggregateErrors = err.errors.map((err2) => errSerializer(err2));
      }
      for (const key in err) {
        if (_err[key] === void 0) {
          const val = err[key];
          if (isErrorLike(val)) {
            if (key !== "cause" && !Object.prototype.hasOwnProperty.call(val, seen)) {
              _err[key] = errSerializer(val);
            }
          } else {
            _err[key] = val;
          }
        }
      }
      delete err[seen];
      _err.raw = err;
      return _err;
    }
  }
});

// node_modules/.pnpm/pino-std-serializers@7.1.0/node_modules/pino-std-serializers/lib/err-with-cause.js
var require_err_with_cause = __commonJS({
  "node_modules/.pnpm/pino-std-serializers@7.1.0/node_modules/pino-std-serializers/lib/err-with-cause.js"(exports2, module2) {
    "use strict";
    module2.exports = errWithCauseSerializer;
    var { isErrorLike } = require_err_helpers();
    var { pinoErrProto, pinoErrorSymbols } = require_err_proto();
    var { seen } = pinoErrorSymbols;
    var { toString: toString2 } = Object.prototype;
    function errWithCauseSerializer(err) {
      if (!isErrorLike(err)) {
        return err;
      }
      err[seen] = void 0;
      const _err = Object.create(pinoErrProto);
      _err.type = toString2.call(err.constructor) === "[object Function]" ? err.constructor.name : err.name;
      _err.message = err.message;
      _err.stack = err.stack;
      if (Array.isArray(err.errors)) {
        _err.aggregateErrors = err.errors.map((err2) => errWithCauseSerializer(err2));
      }
      if (isErrorLike(err.cause) && !Object.prototype.hasOwnProperty.call(err.cause, seen)) {
        _err.cause = errWithCauseSerializer(err.cause);
      }
      for (const key in err) {
        if (_err[key] === void 0) {
          const val = err[key];
          if (isErrorLike(val)) {
            if (!Object.prototype.hasOwnProperty.call(val, seen)) {
              _err[key] = errWithCauseSerializer(val);
            }
          } else {
            _err[key] = val;
          }
        }
      }
      delete err[seen];
      _err.raw = err;
      return _err;
    }
  }
});

// node_modules/.pnpm/pino-std-serializers@7.1.0/node_modules/pino-std-serializers/lib/req.js
var require_req = __commonJS({
  "node_modules/.pnpm/pino-std-serializers@7.1.0/node_modules/pino-std-serializers/lib/req.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      mapHttpRequest,
      reqSerializer
    };
    var rawSymbol = /* @__PURE__ */ Symbol("pino-raw-req-ref");
    var pinoReqProto = Object.create({}, {
      id: {
        enumerable: true,
        writable: true,
        value: ""
      },
      method: {
        enumerable: true,
        writable: true,
        value: ""
      },
      url: {
        enumerable: true,
        writable: true,
        value: ""
      },
      query: {
        enumerable: true,
        writable: true,
        value: ""
      },
      params: {
        enumerable: true,
        writable: true,
        value: ""
      },
      headers: {
        enumerable: true,
        writable: true,
        value: {}
      },
      remoteAddress: {
        enumerable: true,
        writable: true,
        value: ""
      },
      remotePort: {
        enumerable: true,
        writable: true,
        value: ""
      },
      raw: {
        enumerable: false,
        get: function() {
          return this[rawSymbol];
        },
        set: function(val) {
          this[rawSymbol] = val;
        }
      }
    });
    Object.defineProperty(pinoReqProto, rawSymbol, {
      writable: true,
      value: {}
    });
    function reqSerializer(req) {
      const connection2 = req.info || req.socket;
      const _req = Object.create(pinoReqProto);
      _req.id = typeof req.id === "function" ? req.id() : req.id || (req.info ? req.info.id : void 0);
      _req.method = req.method;
      if (req.originalUrl) {
        _req.url = req.originalUrl;
      } else {
        const path3 = req.path;
        _req.url = typeof path3 === "string" ? path3 : req.url ? req.url.path || req.url : void 0;
      }
      if (req.query) {
        _req.query = req.query;
      }
      if (req.params) {
        _req.params = req.params;
      }
      _req.headers = req.headers;
      _req.remoteAddress = connection2 && connection2.remoteAddress;
      _req.remotePort = connection2 && connection2.remotePort;
      _req.raw = req.raw || req;
      return _req;
    }
    function mapHttpRequest(req) {
      return {
        req: reqSerializer(req)
      };
    }
  }
});

// node_modules/.pnpm/pino-std-serializers@7.1.0/node_modules/pino-std-serializers/lib/res.js
var require_res = __commonJS({
  "node_modules/.pnpm/pino-std-serializers@7.1.0/node_modules/pino-std-serializers/lib/res.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      mapHttpResponse,
      resSerializer
    };
    var rawSymbol = /* @__PURE__ */ Symbol("pino-raw-res-ref");
    var pinoResProto = Object.create({}, {
      statusCode: {
        enumerable: true,
        writable: true,
        value: 0
      },
      headers: {
        enumerable: true,
        writable: true,
        value: ""
      },
      raw: {
        enumerable: false,
        get: function() {
          return this[rawSymbol];
        },
        set: function(val) {
          this[rawSymbol] = val;
        }
      }
    });
    Object.defineProperty(pinoResProto, rawSymbol, {
      writable: true,
      value: {}
    });
    function resSerializer(res) {
      const _res = Object.create(pinoResProto);
      _res.statusCode = res.headersSent ? res.statusCode : null;
      _res.headers = res.getHeaders ? res.getHeaders() : res._headers;
      _res.raw = res;
      return _res;
    }
    function mapHttpResponse(res) {
      return {
        res: resSerializer(res)
      };
    }
  }
});

// node_modules/.pnpm/pino-std-serializers@7.1.0/node_modules/pino-std-serializers/index.js
var require_pino_std_serializers = __commonJS({
  "node_modules/.pnpm/pino-std-serializers@7.1.0/node_modules/pino-std-serializers/index.js"(exports2, module2) {
    "use strict";
    var errSerializer = require_err();
    var errWithCauseSerializer = require_err_with_cause();
    var reqSerializers = require_req();
    var resSerializers = require_res();
    module2.exports = {
      err: errSerializer,
      errWithCause: errWithCauseSerializer,
      mapHttpRequest: reqSerializers.mapHttpRequest,
      mapHttpResponse: resSerializers.mapHttpResponse,
      req: reqSerializers.reqSerializer,
      res: resSerializers.resSerializer,
      wrapErrorSerializer: function wrapErrorSerializer(customSerializer) {
        if (customSerializer === errSerializer) return customSerializer;
        return function wrapErrSerializer(err) {
          return customSerializer(errSerializer(err));
        };
      },
      wrapRequestSerializer: function wrapRequestSerializer(customSerializer) {
        if (customSerializer === reqSerializers.reqSerializer) return customSerializer;
        return function wrappedReqSerializer(req) {
          return customSerializer(reqSerializers.reqSerializer(req));
        };
      },
      wrapResponseSerializer: function wrapResponseSerializer(customSerializer) {
        if (customSerializer === resSerializers.resSerializer) return customSerializer;
        return function wrappedResSerializer(res) {
          return customSerializer(resSerializers.resSerializer(res));
        };
      }
    };
  }
});

// node_modules/.pnpm/pino@10.2.0/node_modules/pino/lib/caller.js
var require_caller = __commonJS({
  "node_modules/.pnpm/pino@10.2.0/node_modules/pino/lib/caller.js"(exports2, module2) {
    "use strict";
    function noOpPrepareStackTrace(_, stack) {
      return stack;
    }
    module2.exports = function getCallers() {
      const originalPrepare = Error.prepareStackTrace;
      Error.prepareStackTrace = noOpPrepareStackTrace;
      const stack = new Error().stack;
      Error.prepareStackTrace = originalPrepare;
      if (!Array.isArray(stack)) {
        return void 0;
      }
      const entries = stack.slice(2);
      const fileNames = [];
      for (const entry of entries) {
        if (!entry) {
          continue;
        }
        fileNames.push(entry.getFileName());
      }
      return fileNames;
    };
  }
});

// node_modules/.pnpm/@pinojs+redact@0.4.0/node_modules/@pinojs/redact/index.js
var require_redact = __commonJS({
  "node_modules/.pnpm/@pinojs+redact@0.4.0/node_modules/@pinojs/redact/index.js"(exports2, module2) {
    "use strict";
    function deepClone(obj) {
      if (obj === null || typeof obj !== "object") {
        return obj;
      }
      if (obj instanceof Date) {
        return new Date(obj.getTime());
      }
      if (obj instanceof Array) {
        const cloned = [];
        for (let i4 = 0; i4 < obj.length; i4++) {
          cloned[i4] = deepClone(obj[i4]);
        }
        return cloned;
      }
      if (typeof obj === "object") {
        const cloned = Object.create(Object.getPrototypeOf(obj));
        for (const key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            cloned[key] = deepClone(obj[key]);
          }
        }
        return cloned;
      }
      return obj;
    }
    function parsePath(path3) {
      const parts = [];
      let current = "";
      let inBrackets = false;
      let inQuotes = false;
      let quoteChar = "";
      for (let i4 = 0; i4 < path3.length; i4++) {
        const char = path3[i4];
        if (!inBrackets && char === ".") {
          if (current) {
            parts.push(current);
            current = "";
          }
        } else if (char === "[") {
          if (current) {
            parts.push(current);
            current = "";
          }
          inBrackets = true;
        } else if (char === "]" && inBrackets) {
          parts.push(current);
          current = "";
          inBrackets = false;
          inQuotes = false;
        } else if ((char === '"' || char === "'") && inBrackets) {
          if (!inQuotes) {
            inQuotes = true;
            quoteChar = char;
          } else if (char === quoteChar) {
            inQuotes = false;
            quoteChar = "";
          } else {
            current += char;
          }
        } else {
          current += char;
        }
      }
      if (current) {
        parts.push(current);
      }
      return parts;
    }
    function setValue(obj, parts, value) {
      let current = obj;
      for (let i4 = 0; i4 < parts.length - 1; i4++) {
        const key = parts[i4];
        if (typeof current !== "object" || current === null || !(key in current)) {
          return false;
        }
        if (typeof current[key] !== "object" || current[key] === null) {
          return false;
        }
        current = current[key];
      }
      const lastKey = parts[parts.length - 1];
      if (lastKey === "*") {
        if (Array.isArray(current)) {
          for (let i4 = 0; i4 < current.length; i4++) {
            current[i4] = value;
          }
        } else if (typeof current === "object" && current !== null) {
          for (const key in current) {
            if (Object.prototype.hasOwnProperty.call(current, key)) {
              current[key] = value;
            }
          }
        }
      } else {
        if (typeof current === "object" && current !== null && lastKey in current && Object.prototype.hasOwnProperty.call(current, lastKey)) {
          current[lastKey] = value;
        }
      }
      return true;
    }
    function removeKey(obj, parts) {
      let current = obj;
      for (let i4 = 0; i4 < parts.length - 1; i4++) {
        const key = parts[i4];
        if (typeof current !== "object" || current === null || !(key in current)) {
          return false;
        }
        if (typeof current[key] !== "object" || current[key] === null) {
          return false;
        }
        current = current[key];
      }
      const lastKey = parts[parts.length - 1];
      if (lastKey === "*") {
        if (Array.isArray(current)) {
          for (let i4 = 0; i4 < current.length; i4++) {
            current[i4] = void 0;
          }
        } else if (typeof current === "object" && current !== null) {
          for (const key in current) {
            if (Object.prototype.hasOwnProperty.call(current, key)) {
              delete current[key];
            }
          }
        }
      } else {
        if (typeof current === "object" && current !== null && lastKey in current && Object.prototype.hasOwnProperty.call(current, lastKey)) {
          delete current[lastKey];
        }
      }
      return true;
    }
    var PATH_NOT_FOUND = /* @__PURE__ */ Symbol("PATH_NOT_FOUND");
    function getValueIfExists(obj, parts) {
      let current = obj;
      for (const part of parts) {
        if (current === null || current === void 0) {
          return PATH_NOT_FOUND;
        }
        if (typeof current !== "object" || current === null) {
          return PATH_NOT_FOUND;
        }
        if (!(part in current)) {
          return PATH_NOT_FOUND;
        }
        current = current[part];
      }
      return current;
    }
    function getValue2(obj, parts) {
      let current = obj;
      for (const part of parts) {
        if (current === null || current === void 0) {
          return void 0;
        }
        if (typeof current !== "object" || current === null) {
          return void 0;
        }
        current = current[part];
      }
      return current;
    }
    function redactPaths(obj, paths, censor, remove = false) {
      for (const path3 of paths) {
        const parts = parsePath(path3);
        if (parts.includes("*")) {
          redactWildcardPath(obj, parts, censor, path3, remove);
        } else {
          if (remove) {
            removeKey(obj, parts);
          } else {
            const value = getValueIfExists(obj, parts);
            if (value === PATH_NOT_FOUND) {
              continue;
            }
            const actualCensor = typeof censor === "function" ? censor(value, parts) : censor;
            setValue(obj, parts, actualCensor);
          }
        }
      }
    }
    function redactWildcardPath(obj, parts, censor, originalPath, remove = false) {
      const wildcardIndex = parts.indexOf("*");
      if (wildcardIndex === parts.length - 1) {
        const parentParts = parts.slice(0, -1);
        let current = obj;
        for (const part of parentParts) {
          if (current === null || current === void 0) return;
          if (typeof current !== "object" || current === null) return;
          current = current[part];
        }
        if (Array.isArray(current)) {
          if (remove) {
            for (let i4 = 0; i4 < current.length; i4++) {
              current[i4] = void 0;
            }
          } else {
            for (let i4 = 0; i4 < current.length; i4++) {
              const indexPath = [...parentParts, i4.toString()];
              const actualCensor = typeof censor === "function" ? censor(current[i4], indexPath) : censor;
              current[i4] = actualCensor;
            }
          }
        } else if (typeof current === "object" && current !== null) {
          if (remove) {
            const keysToDelete = [];
            for (const key in current) {
              if (Object.prototype.hasOwnProperty.call(current, key)) {
                keysToDelete.push(key);
              }
            }
            for (const key of keysToDelete) {
              delete current[key];
            }
          } else {
            for (const key in current) {
              const keyPath = [...parentParts, key];
              const actualCensor = typeof censor === "function" ? censor(current[key], keyPath) : censor;
              current[key] = actualCensor;
            }
          }
        }
      } else {
        redactIntermediateWildcard(obj, parts, censor, wildcardIndex, originalPath, remove);
      }
    }
    function redactIntermediateWildcard(obj, parts, censor, wildcardIndex, originalPath, remove = false) {
      const beforeWildcard = parts.slice(0, wildcardIndex);
      const afterWildcard = parts.slice(wildcardIndex + 1);
      const pathArray = [];
      function traverse(current, pathLength) {
        if (pathLength === beforeWildcard.length) {
          if (Array.isArray(current)) {
            for (let i4 = 0; i4 < current.length; i4++) {
              pathArray[pathLength] = i4.toString();
              traverse(current[i4], pathLength + 1);
            }
          } else if (typeof current === "object" && current !== null) {
            for (const key in current) {
              pathArray[pathLength] = key;
              traverse(current[key], pathLength + 1);
            }
          }
        } else if (pathLength < beforeWildcard.length) {
          const nextKey = beforeWildcard[pathLength];
          if (current && typeof current === "object" && current !== null && nextKey in current) {
            pathArray[pathLength] = nextKey;
            traverse(current[nextKey], pathLength + 1);
          }
        } else {
          if (afterWildcard.includes("*")) {
            const wrappedCensor = typeof censor === "function" ? (value, path3) => {
              const fullPath = [...pathArray.slice(0, pathLength), ...path3];
              return censor(value, fullPath);
            } : censor;
            redactWildcardPath(current, afterWildcard, wrappedCensor, originalPath, remove);
          } else {
            if (remove) {
              removeKey(current, afterWildcard);
            } else {
              const actualCensor = typeof censor === "function" ? censor(getValue2(current, afterWildcard), [...pathArray.slice(0, pathLength), ...afterWildcard]) : censor;
              setValue(current, afterWildcard, actualCensor);
            }
          }
        }
      }
      if (beforeWildcard.length === 0) {
        traverse(obj, 0);
      } else {
        let current = obj;
        for (let i4 = 0; i4 < beforeWildcard.length; i4++) {
          const part = beforeWildcard[i4];
          if (current === null || current === void 0) return;
          if (typeof current !== "object" || current === null) return;
          current = current[part];
          pathArray[i4] = part;
        }
        if (current !== null && current !== void 0) {
          traverse(current, beforeWildcard.length);
        }
      }
    }
    function buildPathStructure(pathsToClone) {
      if (pathsToClone.length === 0) {
        return null;
      }
      const pathStructure = /* @__PURE__ */ new Map();
      for (const path3 of pathsToClone) {
        const parts = parsePath(path3);
        let current = pathStructure;
        for (let i4 = 0; i4 < parts.length; i4++) {
          const part = parts[i4];
          if (!current.has(part)) {
            current.set(part, /* @__PURE__ */ new Map());
          }
          current = current.get(part);
        }
      }
      return pathStructure;
    }
    function selectiveClone(obj, pathStructure) {
      if (!pathStructure) {
        return obj;
      }
      function cloneSelectively(source, pathMap, depth = 0) {
        if (!pathMap || pathMap.size === 0) {
          return source;
        }
        if (source === null || typeof source !== "object") {
          return source;
        }
        if (source instanceof Date) {
          return new Date(source.getTime());
        }
        if (Array.isArray(source)) {
          const cloned2 = [];
          for (let i4 = 0; i4 < source.length; i4++) {
            const indexStr = i4.toString();
            if (pathMap.has(indexStr) || pathMap.has("*")) {
              cloned2[i4] = cloneSelectively(source[i4], pathMap.get(indexStr) || pathMap.get("*"));
            } else {
              cloned2[i4] = source[i4];
            }
          }
          return cloned2;
        }
        const cloned = Object.create(Object.getPrototypeOf(source));
        for (const key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            if (pathMap.has(key) || pathMap.has("*")) {
              cloned[key] = cloneSelectively(source[key], pathMap.get(key) || pathMap.get("*"));
            } else {
              cloned[key] = source[key];
            }
          }
        }
        return cloned;
      }
      return cloneSelectively(obj, pathStructure);
    }
    function validatePath(path3) {
      if (typeof path3 !== "string") {
        throw new Error("Paths must be (non-empty) strings");
      }
      if (path3 === "") {
        throw new Error("Invalid redaction path ()");
      }
      if (path3.includes("..")) {
        throw new Error(`Invalid redaction path (${path3})`);
      }
      if (path3.includes(",")) {
        throw new Error(`Invalid redaction path (${path3})`);
      }
      let bracketCount = 0;
      let inQuotes = false;
      let quoteChar = "";
      for (let i4 = 0; i4 < path3.length; i4++) {
        const char = path3[i4];
        if ((char === '"' || char === "'") && bracketCount > 0) {
          if (!inQuotes) {
            inQuotes = true;
            quoteChar = char;
          } else if (char === quoteChar) {
            inQuotes = false;
            quoteChar = "";
          }
        } else if (char === "[" && !inQuotes) {
          bracketCount++;
        } else if (char === "]" && !inQuotes) {
          bracketCount--;
          if (bracketCount < 0) {
            throw new Error(`Invalid redaction path (${path3})`);
          }
        }
      }
      if (bracketCount !== 0) {
        throw new Error(`Invalid redaction path (${path3})`);
      }
    }
    function validatePaths(paths) {
      if (!Array.isArray(paths)) {
        throw new TypeError("paths must be an array");
      }
      for (const path3 of paths) {
        validatePath(path3);
      }
    }
    function slowRedact(options = {}) {
      const {
        paths = [],
        censor = "[REDACTED]",
        serialize = JSON.stringify,
        strict = true,
        remove = false
      } = options;
      validatePaths(paths);
      const pathStructure = buildPathStructure(paths);
      return function redact(obj) {
        if (strict && (obj === null || typeof obj !== "object")) {
          if (obj === null || obj === void 0) {
            return serialize ? serialize(obj) : obj;
          }
          if (typeof obj !== "object") {
            return serialize ? serialize(obj) : obj;
          }
        }
        const cloned = selectiveClone(obj, pathStructure);
        const original = obj;
        let actualCensor = censor;
        if (typeof censor === "function") {
          actualCensor = censor;
        }
        redactPaths(cloned, paths, actualCensor, remove);
        if (serialize === false) {
          cloned.restore = function() {
            return deepClone(original);
          };
          return cloned;
        }
        if (typeof serialize === "function") {
          return serialize(cloned);
        }
        return JSON.stringify(cloned);
      };
    }
    module2.exports = slowRedact;
  }
});

// node_modules/.pnpm/pino@10.2.0/node_modules/pino/lib/symbols.js
var require_symbols = __commonJS({
  "node_modules/.pnpm/pino@10.2.0/node_modules/pino/lib/symbols.js"(exports2, module2) {
    "use strict";
    var setLevelSym = /* @__PURE__ */ Symbol("pino.setLevel");
    var getLevelSym = /* @__PURE__ */ Symbol("pino.getLevel");
    var levelValSym = /* @__PURE__ */ Symbol("pino.levelVal");
    var levelCompSym = /* @__PURE__ */ Symbol("pino.levelComp");
    var useLevelLabelsSym = /* @__PURE__ */ Symbol("pino.useLevelLabels");
    var useOnlyCustomLevelsSym = /* @__PURE__ */ Symbol("pino.useOnlyCustomLevels");
    var mixinSym = /* @__PURE__ */ Symbol("pino.mixin");
    var lsCacheSym = /* @__PURE__ */ Symbol("pino.lsCache");
    var chindingsSym = /* @__PURE__ */ Symbol("pino.chindings");
    var asJsonSym = /* @__PURE__ */ Symbol("pino.asJson");
    var writeSym = /* @__PURE__ */ Symbol("pino.write");
    var redactFmtSym = /* @__PURE__ */ Symbol("pino.redactFmt");
    var timeSym = /* @__PURE__ */ Symbol("pino.time");
    var timeSliceIndexSym = /* @__PURE__ */ Symbol("pino.timeSliceIndex");
    var streamSym = /* @__PURE__ */ Symbol("pino.stream");
    var stringifySym = /* @__PURE__ */ Symbol("pino.stringify");
    var stringifySafeSym = /* @__PURE__ */ Symbol("pino.stringifySafe");
    var stringifiersSym = /* @__PURE__ */ Symbol("pino.stringifiers");
    var endSym = /* @__PURE__ */ Symbol("pino.end");
    var formatOptsSym = /* @__PURE__ */ Symbol("pino.formatOpts");
    var messageKeySym = /* @__PURE__ */ Symbol("pino.messageKey");
    var errorKeySym = /* @__PURE__ */ Symbol("pino.errorKey");
    var nestedKeySym = /* @__PURE__ */ Symbol("pino.nestedKey");
    var nestedKeyStrSym = /* @__PURE__ */ Symbol("pino.nestedKeyStr");
    var mixinMergeStrategySym = /* @__PURE__ */ Symbol("pino.mixinMergeStrategy");
    var msgPrefixSym = /* @__PURE__ */ Symbol("pino.msgPrefix");
    var wildcardFirstSym = /* @__PURE__ */ Symbol("pino.wildcardFirst");
    var serializersSym = /* @__PURE__ */ Symbol.for("pino.serializers");
    var formattersSym = /* @__PURE__ */ Symbol.for("pino.formatters");
    var hooksSym = /* @__PURE__ */ Symbol.for("pino.hooks");
    var needsMetadataGsym = /* @__PURE__ */ Symbol.for("pino.metadata");
    module2.exports = {
      setLevelSym,
      getLevelSym,
      levelValSym,
      levelCompSym,
      useLevelLabelsSym,
      mixinSym,
      lsCacheSym,
      chindingsSym,
      asJsonSym,
      writeSym,
      serializersSym,
      redactFmtSym,
      timeSym,
      timeSliceIndexSym,
      streamSym,
      stringifySym,
      stringifySafeSym,
      stringifiersSym,
      endSym,
      formatOptsSym,
      messageKeySym,
      errorKeySym,
      nestedKeySym,
      wildcardFirstSym,
      needsMetadataGsym,
      useOnlyCustomLevelsSym,
      formattersSym,
      hooksSym,
      nestedKeyStrSym,
      mixinMergeStrategySym,
      msgPrefixSym
    };
  }
});

// node_modules/.pnpm/pino@10.2.0/node_modules/pino/lib/redaction.js
var require_redaction = __commonJS({
  "node_modules/.pnpm/pino@10.2.0/node_modules/pino/lib/redaction.js"(exports2, module2) {
    "use strict";
    var Redact = require_redact();
    var { redactFmtSym, wildcardFirstSym } = require_symbols();
    var rx = /[^.[\]]+|\[([^[\]]*?)\]/g;
    var CENSOR = "[Redacted]";
    var strict = false;
    function redaction(opts, serialize) {
      const { paths, censor, remove } = handle(opts);
      const shape = paths.reduce((o4, str) => {
        rx.lastIndex = 0;
        const first = rx.exec(str);
        const next = rx.exec(str);
        let ns = first[1] !== void 0 ? first[1].replace(/^(?:"|'|`)(.*)(?:"|'|`)$/, "$1") : first[0];
        if (ns === "*") {
          ns = wildcardFirstSym;
        }
        if (next === null) {
          o4[ns] = null;
          return o4;
        }
        if (o4[ns] === null) {
          return o4;
        }
        const { index } = next;
        const nextPath = `${str.substr(index, str.length - 1)}`;
        o4[ns] = o4[ns] || [];
        if (ns !== wildcardFirstSym && o4[ns].length === 0) {
          o4[ns].push(...o4[wildcardFirstSym] || []);
        }
        if (ns === wildcardFirstSym) {
          Object.keys(o4).forEach(function(k4) {
            if (o4[k4]) {
              o4[k4].push(nextPath);
            }
          });
        }
        o4[ns].push(nextPath);
        return o4;
      }, {});
      const result = {
        [redactFmtSym]: Redact({ paths, censor, serialize, strict, remove })
      };
      const topCensor = (...args) => {
        return typeof censor === "function" ? serialize(censor(...args)) : serialize(censor);
      };
      return [...Object.keys(shape), ...Object.getOwnPropertySymbols(shape)].reduce((o4, k4) => {
        if (shape[k4] === null) {
          o4[k4] = (value) => topCensor(value, [k4]);
        } else {
          const wrappedCensor = typeof censor === "function" ? (value, path3) => {
            return censor(value, [k4, ...path3]);
          } : censor;
          o4[k4] = Redact({
            paths: shape[k4],
            censor: wrappedCensor,
            serialize,
            strict,
            remove
          });
        }
        return o4;
      }, result);
    }
    function handle(opts) {
      if (Array.isArray(opts)) {
        opts = { paths: opts, censor: CENSOR };
        return opts;
      }
      let { paths, censor = CENSOR, remove } = opts;
      if (Array.isArray(paths) === false) {
        throw Error("pino \u2013 redact must contain an array of strings");
      }
      if (remove === true) censor = void 0;
      return { paths, censor, remove };
    }
    module2.exports = redaction;
  }
});

// node_modules/.pnpm/pino@10.2.0/node_modules/pino/lib/time.js
var require_time = __commonJS({
  "node_modules/.pnpm/pino@10.2.0/node_modules/pino/lib/time.js"(exports2, module2) {
    "use strict";
    var nullTime = () => "";
    var epochTime = () => `,"time":${Date.now()}`;
    var unixTime = () => `,"time":${Math.round(Date.now() / 1e3)}`;
    var isoTime = () => `,"time":"${new Date(Date.now()).toISOString()}"`;
    var NS_PER_MS = 1000000n;
    var NS_PER_SEC = 1000000000n;
    var startWallTimeNs = BigInt(Date.now()) * NS_PER_MS;
    var startHrTime = process.hrtime.bigint();
    var isoTimeNano = () => {
      const elapsedNs = process.hrtime.bigint() - startHrTime;
      const currentTimeNs = startWallTimeNs + elapsedNs;
      const secondsSinceEpoch = currentTimeNs / NS_PER_SEC;
      const nanosWithinSecond = currentTimeNs % NS_PER_SEC;
      const msSinceEpoch = Number(secondsSinceEpoch * 1000n + nanosWithinSecond / 1000000n);
      const date3 = new Date(msSinceEpoch);
      const year2 = date3.getUTCFullYear();
      const month = (date3.getUTCMonth() + 1).toString().padStart(2, "0");
      const day = date3.getUTCDate().toString().padStart(2, "0");
      const hours = date3.getUTCHours().toString().padStart(2, "0");
      const minutes = date3.getUTCMinutes().toString().padStart(2, "0");
      const seconds = date3.getUTCSeconds().toString().padStart(2, "0");
      return `,"time":"${year2}-${month}-${day}T${hours}:${minutes}:${seconds}.${nanosWithinSecond.toString().padStart(9, "0")}Z"`;
    };
    module2.exports = { nullTime, epochTime, unixTime, isoTime, isoTimeNano };
  }
});

// node_modules/.pnpm/quick-format-unescaped@4.0.4/node_modules/quick-format-unescaped/index.js
var require_quick_format_unescaped = __commonJS({
  "node_modules/.pnpm/quick-format-unescaped@4.0.4/node_modules/quick-format-unescaped/index.js"(exports2, module2) {
    "use strict";
    function tryStringify(o4) {
      try {
        return JSON.stringify(o4);
      } catch (e4) {
        return '"[Circular]"';
      }
    }
    module2.exports = format2;
    function format2(f4, args, opts) {
      var ss = opts && opts.stringify || tryStringify;
      var offset = 1;
      if (typeof f4 === "object" && f4 !== null) {
        var len = args.length + offset;
        if (len === 1) return f4;
        var objects = new Array(len);
        objects[0] = ss(f4);
        for (var index = 1; index < len; index++) {
          objects[index] = ss(args[index]);
        }
        return objects.join(" ");
      }
      if (typeof f4 !== "string") {
        return f4;
      }
      var argLen = args.length;
      if (argLen === 0) return f4;
      var str = "";
      var a4 = 1 - offset;
      var lastPos = -1;
      var flen = f4 && f4.length || 0;
      for (var i4 = 0; i4 < flen; ) {
        if (f4.charCodeAt(i4) === 37 && i4 + 1 < flen) {
          lastPos = lastPos > -1 ? lastPos : 0;
          switch (f4.charCodeAt(i4 + 1)) {
            case 100:
            // 'd'
            case 102:
              if (a4 >= argLen)
                break;
              if (args[a4] == null) break;
              if (lastPos < i4)
                str += f4.slice(lastPos, i4);
              str += Number(args[a4]);
              lastPos = i4 + 2;
              i4++;
              break;
            case 105:
              if (a4 >= argLen)
                break;
              if (args[a4] == null) break;
              if (lastPos < i4)
                str += f4.slice(lastPos, i4);
              str += Math.floor(Number(args[a4]));
              lastPos = i4 + 2;
              i4++;
              break;
            case 79:
            // 'O'
            case 111:
            // 'o'
            case 106:
              if (a4 >= argLen)
                break;
              if (args[a4] === void 0) break;
              if (lastPos < i4)
                str += f4.slice(lastPos, i4);
              var type = typeof args[a4];
              if (type === "string") {
                str += "'" + args[a4] + "'";
                lastPos = i4 + 2;
                i4++;
                break;
              }
              if (type === "function") {
                str += args[a4].name || "<anonymous>";
                lastPos = i4 + 2;
                i4++;
                break;
              }
              str += ss(args[a4]);
              lastPos = i4 + 2;
              i4++;
              break;
            case 115:
              if (a4 >= argLen)
                break;
              if (lastPos < i4)
                str += f4.slice(lastPos, i4);
              str += String(args[a4]);
              lastPos = i4 + 2;
              i4++;
              break;
            case 37:
              if (lastPos < i4)
                str += f4.slice(lastPos, i4);
              str += "%";
              lastPos = i4 + 2;
              i4++;
              a4--;
              break;
          }
          ++a4;
        }
        ++i4;
      }
      if (lastPos === -1)
        return f4;
      else if (lastPos < flen) {
        str += f4.slice(lastPos);
      }
      return str;
    }
  }
});

// node_modules/.pnpm/atomic-sleep@1.0.0/node_modules/atomic-sleep/index.js
var require_atomic_sleep = __commonJS({
  "node_modules/.pnpm/atomic-sleep@1.0.0/node_modules/atomic-sleep/index.js"(exports2, module2) {
    "use strict";
    if (typeof SharedArrayBuffer !== "undefined" && typeof Atomics !== "undefined") {
      let sleep2 = function(ms) {
        const valid2 = ms > 0 && ms < Infinity;
        if (valid2 === false) {
          if (typeof ms !== "number" && typeof ms !== "bigint") {
            throw TypeError("sleep: ms must be a number");
          }
          throw RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
        }
        Atomics.wait(nil, 0, 0, Number(ms));
      };
      const nil = new Int32Array(new SharedArrayBuffer(4));
      module2.exports = sleep2;
    } else {
      let sleep2 = function(ms) {
        const valid2 = ms > 0 && ms < Infinity;
        if (valid2 === false) {
          if (typeof ms !== "number" && typeof ms !== "bigint") {
            throw TypeError("sleep: ms must be a number");
          }
          throw RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
        }
        const target = Date.now() + Number(ms);
        while (target > Date.now()) {
        }
      };
      module2.exports = sleep2;
    }
  }
});

// node_modules/.pnpm/sonic-boom@4.2.0/node_modules/sonic-boom/index.js
var require_sonic_boom = __commonJS({
  "node_modules/.pnpm/sonic-boom@4.2.0/node_modules/sonic-boom/index.js"(exports2, module2) {
    "use strict";
    var fs3 = require("fs");
    var EventEmitter2 = require("events");
    var inherits = require("util").inherits;
    var path3 = require("path");
    var sleep2 = require_atomic_sleep();
    var assert = require("assert");
    var BUSY_WRITE_TIMEOUT = 100;
    var kEmptyBuffer = Buffer.allocUnsafe(0);
    var MAX_WRITE = 16 * 1024;
    var kContentModeBuffer = "buffer";
    var kContentModeUtf8 = "utf8";
    var [major, minor] = (process.versions.node || "0.0").split(".").map(Number);
    var kCopyBuffer = major >= 22 && minor >= 7;
    function openFile(file, sonic) {
      sonic._opening = true;
      sonic._writing = true;
      sonic._asyncDrainScheduled = false;
      function fileOpened(err, fd) {
        if (err) {
          sonic._reopening = false;
          sonic._writing = false;
          sonic._opening = false;
          if (sonic.sync) {
            process.nextTick(() => {
              if (sonic.listenerCount("error") > 0) {
                sonic.emit("error", err);
              }
            });
          } else {
            sonic.emit("error", err);
          }
          return;
        }
        const reopening = sonic._reopening;
        sonic.fd = fd;
        sonic.file = file;
        sonic._reopening = false;
        sonic._opening = false;
        sonic._writing = false;
        if (sonic.sync) {
          process.nextTick(() => sonic.emit("ready"));
        } else {
          sonic.emit("ready");
        }
        if (sonic.destroyed) {
          return;
        }
        if (!sonic._writing && sonic._len > sonic.minLength || sonic._flushPending) {
          sonic._actualWrite();
        } else if (reopening) {
          process.nextTick(() => sonic.emit("drain"));
        }
      }
      const flags = sonic.append ? "a" : "w";
      const mode = sonic.mode;
      if (sonic.sync) {
        try {
          if (sonic.mkdir) fs3.mkdirSync(path3.dirname(file), { recursive: true });
          const fd = fs3.openSync(file, flags, mode);
          fileOpened(null, fd);
        } catch (err) {
          fileOpened(err);
          throw err;
        }
      } else if (sonic.mkdir) {
        fs3.mkdir(path3.dirname(file), { recursive: true }, (err) => {
          if (err) return fileOpened(err);
          fs3.open(file, flags, mode, fileOpened);
        });
      } else {
        fs3.open(file, flags, mode, fileOpened);
      }
    }
    function SonicBoom(opts) {
      if (!(this instanceof SonicBoom)) {
        return new SonicBoom(opts);
      }
      let { fd, dest, minLength, maxLength, maxWrite, periodicFlush, sync, append: append2 = true, mkdir: mkdir2, retryEAGAIN, fsync, contentMode, mode } = opts || {};
      fd = fd || dest;
      this._len = 0;
      this.fd = -1;
      this._bufs = [];
      this._lens = [];
      this._writing = false;
      this._ending = false;
      this._reopening = false;
      this._asyncDrainScheduled = false;
      this._flushPending = false;
      this._hwm = Math.max(minLength || 0, 16387);
      this.file = null;
      this.destroyed = false;
      this.minLength = minLength || 0;
      this.maxLength = maxLength || 0;
      this.maxWrite = maxWrite || MAX_WRITE;
      this._periodicFlush = periodicFlush || 0;
      this._periodicFlushTimer = void 0;
      this.sync = sync || false;
      this.writable = true;
      this._fsync = fsync || false;
      this.append = append2 || false;
      this.mode = mode;
      this.retryEAGAIN = retryEAGAIN || (() => true);
      this.mkdir = mkdir2 || false;
      let fsWriteSync;
      let fsWrite;
      if (contentMode === kContentModeBuffer) {
        this._writingBuf = kEmptyBuffer;
        this.write = writeBuffer;
        this.flush = flushBuffer;
        this.flushSync = flushBufferSync;
        this._actualWrite = actualWriteBuffer;
        fsWriteSync = () => fs3.writeSync(this.fd, this._writingBuf);
        fsWrite = () => fs3.write(this.fd, this._writingBuf, this.release);
      } else if (contentMode === void 0 || contentMode === kContentModeUtf8) {
        this._writingBuf = "";
        this.write = write;
        this.flush = flush;
        this.flushSync = flushSync;
        this._actualWrite = actualWrite;
        fsWriteSync = () => fs3.writeSync(this.fd, this._writingBuf, "utf8");
        fsWrite = () => fs3.write(this.fd, this._writingBuf, "utf8", this.release);
      } else {
        throw new Error(`SonicBoom supports "${kContentModeUtf8}" and "${kContentModeBuffer}", but passed ${contentMode}`);
      }
      if (typeof fd === "number") {
        this.fd = fd;
        process.nextTick(() => this.emit("ready"));
      } else if (typeof fd === "string") {
        openFile(fd, this);
      } else {
        throw new Error("SonicBoom supports only file descriptors and files");
      }
      if (this.minLength >= this.maxWrite) {
        throw new Error(`minLength should be smaller than maxWrite (${this.maxWrite})`);
      }
      this.release = (err, n4) => {
        if (err) {
          if ((err.code === "EAGAIN" || err.code === "EBUSY") && this.retryEAGAIN(err, this._writingBuf.length, this._len - this._writingBuf.length)) {
            if (this.sync) {
              try {
                sleep2(BUSY_WRITE_TIMEOUT);
                this.release(void 0, 0);
              } catch (err2) {
                this.release(err2);
              }
            } else {
              setTimeout(fsWrite, BUSY_WRITE_TIMEOUT);
            }
          } else {
            this._writing = false;
            this.emit("error", err);
          }
          return;
        }
        this.emit("write", n4);
        const releasedBufObj = releaseWritingBuf(this._writingBuf, this._len, n4);
        this._len = releasedBufObj.len;
        this._writingBuf = releasedBufObj.writingBuf;
        if (this._writingBuf.length) {
          if (!this.sync) {
            fsWrite();
            return;
          }
          try {
            do {
              const n5 = fsWriteSync();
              const releasedBufObj2 = releaseWritingBuf(this._writingBuf, this._len, n5);
              this._len = releasedBufObj2.len;
              this._writingBuf = releasedBufObj2.writingBuf;
            } while (this._writingBuf.length);
          } catch (err2) {
            this.release(err2);
            return;
          }
        }
        if (this._fsync) {
          fs3.fsyncSync(this.fd);
        }
        const len = this._len;
        if (this._reopening) {
          this._writing = false;
          this._reopening = false;
          this.reopen();
        } else if (len > this.minLength) {
          this._actualWrite();
        } else if (this._ending) {
          if (len > 0) {
            this._actualWrite();
          } else {
            this._writing = false;
            actualClose(this);
          }
        } else {
          this._writing = false;
          if (this.sync) {
            if (!this._asyncDrainScheduled) {
              this._asyncDrainScheduled = true;
              process.nextTick(emitDrain, this);
            }
          } else {
            this.emit("drain");
          }
        }
      };
      this.on("newListener", function(name) {
        if (name === "drain") {
          this._asyncDrainScheduled = false;
        }
      });
      if (this._periodicFlush !== 0) {
        this._periodicFlushTimer = setInterval(() => this.flush(null), this._periodicFlush);
        this._periodicFlushTimer.unref();
      }
    }
    function releaseWritingBuf(writingBuf, len, n4) {
      if (typeof writingBuf === "string" && Buffer.byteLength(writingBuf) !== n4) {
        n4 = Buffer.from(writingBuf).subarray(0, n4).toString().length;
      }
      len = Math.max(len - n4, 0);
      writingBuf = writingBuf.slice(n4);
      return { writingBuf, len };
    }
    function emitDrain(sonic) {
      const hasListeners = sonic.listenerCount("drain") > 0;
      if (!hasListeners) return;
      sonic._asyncDrainScheduled = false;
      sonic.emit("drain");
    }
    inherits(SonicBoom, EventEmitter2);
    function mergeBuf(bufs, len) {
      if (bufs.length === 0) {
        return kEmptyBuffer;
      }
      if (bufs.length === 1) {
        return bufs[0];
      }
      return Buffer.concat(bufs, len);
    }
    function write(data2) {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      const len = this._len + data2.length;
      const bufs = this._bufs;
      if (this.maxLength && len > this.maxLength) {
        this.emit("drop", data2);
        return this._len < this._hwm;
      }
      if (bufs.length === 0 || bufs[bufs.length - 1].length + data2.length > this.maxWrite) {
        bufs.push("" + data2);
      } else {
        bufs[bufs.length - 1] += data2;
      }
      this._len = len;
      if (!this._writing && this._len >= this.minLength) {
        this._actualWrite();
      }
      return this._len < this._hwm;
    }
    function writeBuffer(data2) {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      const len = this._len + data2.length;
      const bufs = this._bufs;
      const lens = this._lens;
      if (this.maxLength && len > this.maxLength) {
        this.emit("drop", data2);
        return this._len < this._hwm;
      }
      if (bufs.length === 0 || lens[lens.length - 1] + data2.length > this.maxWrite) {
        bufs.push([data2]);
        lens.push(data2.length);
      } else {
        bufs[bufs.length - 1].push(data2);
        lens[lens.length - 1] += data2.length;
      }
      this._len = len;
      if (!this._writing && this._len >= this.minLength) {
        this._actualWrite();
      }
      return this._len < this._hwm;
    }
    function callFlushCallbackOnDrain(cb) {
      this._flushPending = true;
      const onDrain = () => {
        if (!this._fsync) {
          try {
            fs3.fsync(this.fd, (err) => {
              this._flushPending = false;
              cb(err);
            });
          } catch (err) {
            cb(err);
          }
        } else {
          this._flushPending = false;
          cb();
        }
        this.off("error", onError);
      };
      const onError = (err) => {
        this._flushPending = false;
        cb(err);
        this.off("drain", onDrain);
      };
      this.once("drain", onDrain);
      this.once("error", onError);
    }
    function flush(cb) {
      if (cb != null && typeof cb !== "function") {
        throw new Error("flush cb must be a function");
      }
      if (this.destroyed) {
        const error2 = new Error("SonicBoom destroyed");
        if (cb) {
          cb(error2);
          return;
        }
        throw error2;
      }
      if (this.minLength <= 0) {
        cb?.();
        return;
      }
      if (cb) {
        callFlushCallbackOnDrain.call(this, cb);
      }
      if (this._writing) {
        return;
      }
      if (this._bufs.length === 0) {
        this._bufs.push("");
      }
      this._actualWrite();
    }
    function flushBuffer(cb) {
      if (cb != null && typeof cb !== "function") {
        throw new Error("flush cb must be a function");
      }
      if (this.destroyed) {
        const error2 = new Error("SonicBoom destroyed");
        if (cb) {
          cb(error2);
          return;
        }
        throw error2;
      }
      if (this.minLength <= 0) {
        cb?.();
        return;
      }
      if (cb) {
        callFlushCallbackOnDrain.call(this, cb);
      }
      if (this._writing) {
        return;
      }
      if (this._bufs.length === 0) {
        this._bufs.push([]);
        this._lens.push(0);
      }
      this._actualWrite();
    }
    SonicBoom.prototype.reopen = function(file) {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      if (this._opening) {
        this.once("ready", () => {
          this.reopen(file);
        });
        return;
      }
      if (this._ending) {
        return;
      }
      if (!this.file) {
        throw new Error("Unable to reopen a file descriptor, you must pass a file to SonicBoom");
      }
      if (file) {
        this.file = file;
      }
      this._reopening = true;
      if (this._writing) {
        return;
      }
      const fd = this.fd;
      this.once("ready", () => {
        if (fd !== this.fd) {
          fs3.close(fd, (err) => {
            if (err) {
              return this.emit("error", err);
            }
          });
        }
      });
      openFile(this.file, this);
    };
    SonicBoom.prototype.end = function() {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      if (this._opening) {
        this.once("ready", () => {
          this.end();
        });
        return;
      }
      if (this._ending) {
        return;
      }
      this._ending = true;
      if (this._writing) {
        return;
      }
      if (this._len > 0 && this.fd >= 0) {
        this._actualWrite();
      } else {
        actualClose(this);
      }
    };
    function flushSync() {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      if (this.fd < 0) {
        throw new Error("sonic boom is not ready yet");
      }
      if (!this._writing && this._writingBuf.length > 0) {
        this._bufs.unshift(this._writingBuf);
        this._writingBuf = "";
      }
      let buf = "";
      while (this._bufs.length || buf) {
        if (buf.length <= 0) {
          buf = this._bufs[0];
        }
        try {
          const n4 = fs3.writeSync(this.fd, buf, "utf8");
          const releasedBufObj = releaseWritingBuf(buf, this._len, n4);
          buf = releasedBufObj.writingBuf;
          this._len = releasedBufObj.len;
          if (buf.length <= 0) {
            this._bufs.shift();
          }
        } catch (err) {
          const shouldRetry = err.code === "EAGAIN" || err.code === "EBUSY";
          if (shouldRetry && !this.retryEAGAIN(err, buf.length, this._len - buf.length)) {
            throw err;
          }
          sleep2(BUSY_WRITE_TIMEOUT);
        }
      }
      try {
        fs3.fsyncSync(this.fd);
      } catch {
      }
    }
    function flushBufferSync() {
      if (this.destroyed) {
        throw new Error("SonicBoom destroyed");
      }
      if (this.fd < 0) {
        throw new Error("sonic boom is not ready yet");
      }
      if (!this._writing && this._writingBuf.length > 0) {
        this._bufs.unshift([this._writingBuf]);
        this._writingBuf = kEmptyBuffer;
      }
      let buf = kEmptyBuffer;
      while (this._bufs.length || buf.length) {
        if (buf.length <= 0) {
          buf = mergeBuf(this._bufs[0], this._lens[0]);
        }
        try {
          const n4 = fs3.writeSync(this.fd, buf);
          buf = buf.subarray(n4);
          this._len = Math.max(this._len - n4, 0);
          if (buf.length <= 0) {
            this._bufs.shift();
            this._lens.shift();
          }
        } catch (err) {
          const shouldRetry = err.code === "EAGAIN" || err.code === "EBUSY";
          if (shouldRetry && !this.retryEAGAIN(err, buf.length, this._len - buf.length)) {
            throw err;
          }
          sleep2(BUSY_WRITE_TIMEOUT);
        }
      }
    }
    SonicBoom.prototype.destroy = function() {
      if (this.destroyed) {
        return;
      }
      actualClose(this);
    };
    function actualWrite() {
      const release = this.release;
      this._writing = true;
      this._writingBuf = this._writingBuf || this._bufs.shift() || "";
      if (this.sync) {
        try {
          const written = fs3.writeSync(this.fd, this._writingBuf, "utf8");
          release(null, written);
        } catch (err) {
          release(err);
        }
      } else {
        fs3.write(this.fd, this._writingBuf, "utf8", release);
      }
    }
    function actualWriteBuffer() {
      const release = this.release;
      this._writing = true;
      this._writingBuf = this._writingBuf.length ? this._writingBuf : mergeBuf(this._bufs.shift(), this._lens.shift());
      if (this.sync) {
        try {
          const written = fs3.writeSync(this.fd, this._writingBuf);
          release(null, written);
        } catch (err) {
          release(err);
        }
      } else {
        if (kCopyBuffer) {
          this._writingBuf = Buffer.from(this._writingBuf);
        }
        fs3.write(this.fd, this._writingBuf, release);
      }
    }
    function actualClose(sonic) {
      if (sonic.fd === -1) {
        sonic.once("ready", actualClose.bind(null, sonic));
        return;
      }
      if (sonic._periodicFlushTimer !== void 0) {
        clearInterval(sonic._periodicFlushTimer);
      }
      sonic.destroyed = true;
      sonic._bufs = [];
      sonic._lens = [];
      assert(typeof sonic.fd === "number", `sonic.fd must be a number, got ${typeof sonic.fd}`);
      try {
        fs3.fsync(sonic.fd, closeWrapped);
      } catch {
      }
      function closeWrapped() {
        if (sonic.fd !== 1 && sonic.fd !== 2) {
          fs3.close(sonic.fd, done);
        } else {
          done();
        }
      }
      function done(err) {
        if (err) {
          sonic.emit("error", err);
          return;
        }
        if (sonic._ending && !sonic._writing) {
          sonic.emit("finish");
        }
        sonic.emit("close");
      }
    }
    SonicBoom.SonicBoom = SonicBoom;
    SonicBoom.default = SonicBoom;
    module2.exports = SonicBoom;
  }
});

// node_modules/.pnpm/on-exit-leak-free@2.1.2/node_modules/on-exit-leak-free/index.js
var require_on_exit_leak_free = __commonJS({
  "node_modules/.pnpm/on-exit-leak-free@2.1.2/node_modules/on-exit-leak-free/index.js"(exports2, module2) {
    "use strict";
    var refs = {
      exit: [],
      beforeExit: []
    };
    var functions = {
      exit: onExit,
      beforeExit: onBeforeExit
    };
    var registry;
    function ensureRegistry() {
      if (registry === void 0) {
        registry = new FinalizationRegistry(clear);
      }
    }
    function install(event) {
      if (refs[event].length > 0) {
        return;
      }
      process.on(event, functions[event]);
    }
    function uninstall(event) {
      if (refs[event].length > 0) {
        return;
      }
      process.removeListener(event, functions[event]);
      if (refs.exit.length === 0 && refs.beforeExit.length === 0) {
        registry = void 0;
      }
    }
    function onExit() {
      callRefs("exit");
    }
    function onBeforeExit() {
      callRefs("beforeExit");
    }
    function callRefs(event) {
      for (const ref of refs[event]) {
        const obj = ref.deref();
        const fn = ref.fn;
        if (obj !== void 0) {
          fn(obj, event);
        }
      }
      refs[event] = [];
    }
    function clear(ref) {
      for (const event of ["exit", "beforeExit"]) {
        const index = refs[event].indexOf(ref);
        refs[event].splice(index, index + 1);
        uninstall(event);
      }
    }
    function _register(event, obj, fn) {
      if (obj === void 0) {
        throw new Error("the object can't be undefined");
      }
      install(event);
      const ref = new WeakRef(obj);
      ref.fn = fn;
      ensureRegistry();
      registry.register(obj, ref);
      refs[event].push(ref);
    }
    function register(obj, fn) {
      _register("exit", obj, fn);
    }
    function registerBeforeExit(obj, fn) {
      _register("beforeExit", obj, fn);
    }
    function unregister(obj) {
      if (registry === void 0) {
        return;
      }
      registry.unregister(obj);
      for (const event of ["exit", "beforeExit"]) {
        refs[event] = refs[event].filter((ref) => {
          const _obj = ref.deref();
          return _obj && _obj !== obj;
        });
        uninstall(event);
      }
    }
    module2.exports = {
      register,
      registerBeforeExit,
      unregister
    };
  }
});

// node_modules/.pnpm/thread-stream@4.0.0/node_modules/thread-stream/package.json
var require_package3 = __commonJS({
  "node_modules/.pnpm/thread-stream@4.0.0/node_modules/thread-stream/package.json"(exports2, module2) {
    module2.exports = {
      name: "thread-stream",
      version: "4.0.0",
      description: "A streaming way to send data to a Node.js Worker Thread",
      main: "index.js",
      types: "index.d.ts",
      engines: {
        node: ">=20"
      },
      dependencies: {
        "real-require": "^0.2.0"
      },
      devDependencies: {
        "@types/node": "^22.0.0",
        "@yao-pkg/pkg": "^6.0.0",
        borp: "^0.21.0",
        desm: "^1.3.0",
        eslint: "^9.39.1",
        fastbench: "^1.0.1",
        husky: "^9.0.6",
        neostandard: "^0.12.2",
        "pino-elasticsearch": "^8.0.0",
        "sonic-boom": "^4.0.1",
        "ts-node": "^10.8.0",
        typescript: "~5.7.3"
      },
      scripts: {
        build: "tsc --noEmit",
        lint: "eslint",
        test: "npm run lint && npm run build && npm run transpile && borp --pattern 'test/*.test.{js,mjs}'",
        "test:ci": "npm run lint && npm run transpile && borp --pattern 'test/*.test.{js,mjs}'",
        "test:yarn": "npm run transpile && borp --pattern 'test/*.test.js'",
        transpile: "sh ./test/ts/transpile.sh",
        prepare: "husky install"
      },
      repository: {
        type: "git",
        url: "git+https://github.com/mcollina/thread-stream.git"
      },
      keywords: [
        "worker",
        "thread",
        "threads",
        "stream"
      ],
      author: "Matteo Collina <hello@matteocollina.com>",
      license: "MIT",
      bugs: {
        url: "https://github.com/mcollina/thread-stream/issues"
      },
      homepage: "https://github.com/mcollina/thread-stream#readme"
    };
  }
});

// node_modules/.pnpm/thread-stream@4.0.0/node_modules/thread-stream/lib/wait.js
var require_wait = __commonJS({
  "node_modules/.pnpm/thread-stream@4.0.0/node_modules/thread-stream/lib/wait.js"(exports2, module2) {
    "use strict";
    var WAIT_MS = 1e4;
    function wait(state2, index, expected, timeout, done) {
      const max = timeout === Infinity ? Infinity : Date.now() + timeout;
      const check = () => {
        const current = Atomics.load(state2, index);
        if (current === expected) {
          done(null, "ok");
          return;
        }
        if (max !== Infinity && Date.now() > max) {
          done(null, "timed-out");
          return;
        }
        const remaining = max === Infinity ? WAIT_MS : Math.min(WAIT_MS, Math.max(1, max - Date.now()));
        const result = Atomics.waitAsync(state2, index, current, remaining);
        if (result.async) {
          result.value.then(check);
        } else {
          setImmediate(check);
        }
      };
      check();
    }
    function waitDiff(state2, index, expected, timeout, done) {
      const max = timeout === Infinity ? Infinity : Date.now() + timeout;
      const check = () => {
        const current = Atomics.load(state2, index);
        if (current !== expected) {
          done(null, "ok");
          return;
        }
        if (max !== Infinity && Date.now() > max) {
          done(null, "timed-out");
          return;
        }
        const remaining = max === Infinity ? WAIT_MS : Math.min(WAIT_MS, Math.max(1, max - Date.now()));
        const result = Atomics.waitAsync(state2, index, expected, remaining);
        if (result.async) {
          result.value.then(check);
        } else {
          setImmediate(check);
        }
      };
      check();
    }
    module2.exports = { wait, waitDiff };
  }
});

// node_modules/.pnpm/thread-stream@4.0.0/node_modules/thread-stream/lib/indexes.js
var require_indexes = __commonJS({
  "node_modules/.pnpm/thread-stream@4.0.0/node_modules/thread-stream/lib/indexes.js"(exports2, module2) {
    "use strict";
    var WRITE_INDEX = 4;
    var READ_INDEX = 8;
    module2.exports = {
      WRITE_INDEX,
      READ_INDEX
    };
  }
});

// node_modules/.pnpm/thread-stream@4.0.0/node_modules/thread-stream/index.js
var require_thread_stream = __commonJS({
  "node_modules/.pnpm/thread-stream@4.0.0/node_modules/thread-stream/index.js"(exports2, module2) {
    "use strict";
    var { version } = require_package3();
    var { EventEmitter: EventEmitter2 } = require("events");
    var { Worker } = require("worker_threads");
    var { join: join2 } = require("path");
    var { pathToFileURL } = require("url");
    var { wait } = require_wait();
    var {
      WRITE_INDEX,
      READ_INDEX
    } = require_indexes();
    var buffer = require("buffer");
    var assert = require("assert");
    var kImpl = /* @__PURE__ */ Symbol("kImpl");
    var MAX_STRING = buffer.constants.MAX_STRING_LENGTH;
    var FakeWeakRef = class {
      constructor(value) {
        this._value = value;
      }
      deref() {
        return this._value;
      }
    };
    var FakeFinalizationRegistry = class {
      register() {
      }
      unregister() {
      }
    };
    var FinalizationRegistry2 = process.env.NODE_V8_COVERAGE ? FakeFinalizationRegistry : global.FinalizationRegistry || FakeFinalizationRegistry;
    var WeakRef2 = process.env.NODE_V8_COVERAGE ? FakeWeakRef : global.WeakRef || FakeWeakRef;
    var registry = new FinalizationRegistry2((worker) => {
      if (worker.exited) {
        return;
      }
      worker.terminate();
    });
    function createWorker(stream, opts) {
      const { filename, workerData } = opts;
      const bundlerOverrides = "__bundlerPathsOverrides" in globalThis ? globalThis.__bundlerPathsOverrides : {};
      const toExecute = bundlerOverrides["thread-stream-worker"] || join2(__dirname, "lib", "worker.js");
      const worker = new Worker(toExecute, {
        ...opts.workerOpts,
        trackUnmanagedFds: false,
        workerData: {
          filename: filename.indexOf("file://") === 0 ? filename : pathToFileURL(filename).href,
          dataBuf: stream[kImpl].dataBuf,
          stateBuf: stream[kImpl].stateBuf,
          workerData: {
            $context: {
              threadStreamVersion: version
            },
            ...workerData
          }
        }
      });
      worker.stream = new FakeWeakRef(stream);
      worker.on("message", onWorkerMessage);
      worker.on("exit", onWorkerExit);
      registry.register(stream, worker);
      return worker;
    }
    function drain(stream) {
      assert(!stream[kImpl].sync);
      if (stream[kImpl].needDrain) {
        stream[kImpl].needDrain = false;
        stream.emit("drain");
      }
    }
    function nextFlush(stream) {
      const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
      let leftover = stream[kImpl].data.length - writeIndex;
      if (leftover > 0) {
        if (stream[kImpl].buf.length === 0) {
          stream[kImpl].flushing = false;
          if (stream[kImpl].ending) {
            end(stream);
          } else if (stream[kImpl].needDrain) {
            process.nextTick(drain, stream);
          }
          return;
        }
        let toWrite = stream[kImpl].buf.slice(0, leftover);
        let toWriteBytes = Buffer.byteLength(toWrite);
        if (toWriteBytes <= leftover) {
          stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
          write(stream, toWrite, nextFlush.bind(null, stream));
        } else {
          stream.flush(() => {
            if (stream.destroyed) {
              return;
            }
            Atomics.store(stream[kImpl].state, READ_INDEX, 0);
            Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
            Atomics.notify(stream[kImpl].state, READ_INDEX);
            while (toWriteBytes > stream[kImpl].data.length) {
              leftover = leftover / 2;
              toWrite = stream[kImpl].buf.slice(0, leftover);
              toWriteBytes = Buffer.byteLength(toWrite);
            }
            stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
            write(stream, toWrite, nextFlush.bind(null, stream));
          });
        }
      } else if (leftover === 0) {
        if (writeIndex === 0 && stream[kImpl].buf.length === 0) {
          return;
        }
        stream.flush(() => {
          Atomics.store(stream[kImpl].state, READ_INDEX, 0);
          Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
          Atomics.notify(stream[kImpl].state, READ_INDEX);
          nextFlush(stream);
        });
      } else {
        destroy(stream, new Error("overwritten"));
      }
    }
    function onWorkerMessage(msg) {
      const stream = this.stream.deref();
      if (stream === void 0) {
        this.exited = true;
        this.terminate();
        return;
      }
      switch (msg.code) {
        case "READY":
          this.stream = new WeakRef2(stream);
          stream.flush(() => {
            stream[kImpl].ready = true;
            stream.emit("ready");
          });
          break;
        case "ERROR":
          destroy(stream, msg.err);
          break;
        case "EVENT":
          if (Array.isArray(msg.args)) {
            stream.emit(msg.name, ...msg.args);
          } else {
            stream.emit(msg.name, msg.args);
          }
          break;
        case "WARNING":
          process.emitWarning(msg.err);
          break;
        default:
          destroy(stream, new Error("this should not happen: " + msg.code));
      }
    }
    function onWorkerExit(code) {
      const stream = this.stream.deref();
      if (stream === void 0) {
        return;
      }
      registry.unregister(stream);
      stream.worker.exited = true;
      stream.worker.off("exit", onWorkerExit);
      destroy(stream, code !== 0 ? new Error("the worker thread exited") : null);
    }
    var ThreadStream = class extends EventEmitter2 {
      constructor(opts = {}) {
        super();
        if (opts.bufferSize < 4) {
          throw new Error("bufferSize must at least fit a 4-byte utf-8 char");
        }
        this[kImpl] = {};
        this[kImpl].stateBuf = new SharedArrayBuffer(128);
        this[kImpl].state = new Int32Array(this[kImpl].stateBuf);
        this[kImpl].dataBuf = new SharedArrayBuffer(opts.bufferSize || 4 * 1024 * 1024);
        this[kImpl].data = Buffer.from(this[kImpl].dataBuf);
        this[kImpl].sync = opts.sync || false;
        this[kImpl].ending = false;
        this[kImpl].ended = false;
        this[kImpl].needDrain = false;
        this[kImpl].destroyed = false;
        this[kImpl].flushing = false;
        this[kImpl].ready = false;
        this[kImpl].finished = false;
        this[kImpl].errored = null;
        this[kImpl].closed = false;
        this[kImpl].buf = "";
        this.worker = createWorker(this, opts);
        this.on("message", (message, transferList) => {
          this.worker.postMessage(message, transferList);
        });
      }
      write(data2) {
        if (this[kImpl].destroyed) {
          error2(this, new Error("the worker has exited"));
          return false;
        }
        if (this[kImpl].ending) {
          error2(this, new Error("the worker is ending"));
          return false;
        }
        if (this[kImpl].flushing && this[kImpl].buf.length + data2.length >= MAX_STRING) {
          try {
            writeSync(this);
            this[kImpl].flushing = true;
          } catch (err) {
            destroy(this, err);
            return false;
          }
        }
        this[kImpl].buf += data2;
        if (this[kImpl].sync) {
          try {
            writeSync(this);
            return true;
          } catch (err) {
            destroy(this, err);
            return false;
          }
        }
        if (!this[kImpl].flushing) {
          this[kImpl].flushing = true;
          setImmediate(nextFlush, this);
        }
        this[kImpl].needDrain = this[kImpl].data.length - this[kImpl].buf.length - Atomics.load(this[kImpl].state, WRITE_INDEX) <= 0;
        return !this[kImpl].needDrain;
      }
      end() {
        if (this[kImpl].destroyed) {
          return;
        }
        this[kImpl].ending = true;
        end(this);
      }
      flush(cb) {
        if (this[kImpl].destroyed) {
          if (typeof cb === "function") {
            process.nextTick(cb, new Error("the worker has exited"));
          }
          return;
        }
        const writeIndex = Atomics.load(this[kImpl].state, WRITE_INDEX);
        wait(this[kImpl].state, READ_INDEX, writeIndex, Infinity, (err, res) => {
          if (err) {
            destroy(this, err);
            process.nextTick(cb, err);
            return;
          }
          if (res === "not-equal") {
            this.flush(cb);
            return;
          }
          process.nextTick(cb);
        });
      }
      flushSync() {
        if (this[kImpl].destroyed) {
          return;
        }
        writeSync(this);
        flushSync(this);
      }
      unref() {
        this.worker.unref();
      }
      ref() {
        this.worker.ref();
      }
      get ready() {
        return this[kImpl].ready;
      }
      get destroyed() {
        return this[kImpl].destroyed;
      }
      get closed() {
        return this[kImpl].closed;
      }
      get writable() {
        return !this[kImpl].destroyed && !this[kImpl].ending;
      }
      get writableEnded() {
        return this[kImpl].ending;
      }
      get writableFinished() {
        return this[kImpl].finished;
      }
      get writableNeedDrain() {
        return this[kImpl].needDrain;
      }
      get writableObjectMode() {
        return false;
      }
      get writableErrored() {
        return this[kImpl].errored;
      }
    };
    function error2(stream, err) {
      setImmediate(() => {
        stream.emit("error", err);
      });
    }
    function destroy(stream, err) {
      if (stream[kImpl].destroyed) {
        return;
      }
      stream[kImpl].destroyed = true;
      if (err) {
        stream[kImpl].errored = err;
        error2(stream, err);
      }
      if (!stream.worker.exited) {
        stream.worker.terminate().catch(() => {
        }).then(() => {
          stream[kImpl].closed = true;
          stream.emit("close");
        });
      } else {
        setImmediate(() => {
          stream[kImpl].closed = true;
          stream.emit("close");
        });
      }
    }
    function write(stream, data2, cb) {
      const current = Atomics.load(stream[kImpl].state, WRITE_INDEX);
      const length = Buffer.byteLength(data2);
      stream[kImpl].data.write(data2, current);
      Atomics.store(stream[kImpl].state, WRITE_INDEX, current + length);
      Atomics.notify(stream[kImpl].state, WRITE_INDEX);
      cb();
      return true;
    }
    function end(stream) {
      if (stream[kImpl].ended || !stream[kImpl].ending || stream[kImpl].flushing) {
        return;
      }
      stream[kImpl].ended = true;
      try {
        stream.flushSync();
        let readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
        Atomics.store(stream[kImpl].state, WRITE_INDEX, -1);
        Atomics.notify(stream[kImpl].state, WRITE_INDEX);
        let spins = 0;
        while (readIndex !== -1) {
          Atomics.wait(stream[kImpl].state, READ_INDEX, readIndex, 1e3);
          readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
          if (readIndex === -2) {
            destroy(stream, new Error("end() failed"));
            return;
          }
          if (++spins === 10) {
            destroy(stream, new Error("end() took too long (10s)"));
            return;
          }
        }
        process.nextTick(() => {
          stream[kImpl].finished = true;
          stream.emit("finish");
        });
      } catch (err) {
        destroy(stream, err);
      }
    }
    function writeSync(stream) {
      const cb = () => {
        if (stream[kImpl].ending) {
          end(stream);
        } else if (stream[kImpl].needDrain) {
          process.nextTick(drain, stream);
        }
      };
      stream[kImpl].flushing = false;
      while (stream[kImpl].buf.length !== 0) {
        const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
        let leftover = stream[kImpl].data.length - writeIndex;
        if (leftover === 0) {
          flushSync(stream);
          Atomics.store(stream[kImpl].state, READ_INDEX, 0);
          Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
          Atomics.notify(stream[kImpl].state, READ_INDEX);
          continue;
        } else if (leftover < 0) {
          throw new Error("overwritten");
        }
        let toWrite = stream[kImpl].buf.slice(0, leftover);
        let toWriteBytes = Buffer.byteLength(toWrite);
        if (toWriteBytes <= leftover) {
          stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
          write(stream, toWrite, cb);
        } else {
          flushSync(stream);
          Atomics.store(stream[kImpl].state, READ_INDEX, 0);
          Atomics.store(stream[kImpl].state, WRITE_INDEX, 0);
          Atomics.notify(stream[kImpl].state, READ_INDEX);
          while (toWriteBytes > stream[kImpl].buf.length) {
            leftover = leftover / 2;
            toWrite = stream[kImpl].buf.slice(0, leftover);
            toWriteBytes = Buffer.byteLength(toWrite);
          }
          stream[kImpl].buf = stream[kImpl].buf.slice(leftover);
          write(stream, toWrite, cb);
        }
      }
    }
    function flushSync(stream) {
      if (stream[kImpl].flushing) {
        throw new Error("unable to flush while flushing");
      }
      const writeIndex = Atomics.load(stream[kImpl].state, WRITE_INDEX);
      let spins = 0;
      while (true) {
        const readIndex = Atomics.load(stream[kImpl].state, READ_INDEX);
        if (readIndex === -2) {
          throw Error("_flushSync failed");
        }
        if (readIndex !== writeIndex) {
          Atomics.wait(stream[kImpl].state, READ_INDEX, readIndex, 1e3);
        } else {
          break;
        }
        if (++spins === 10) {
          throw new Error("_flushSync took too long (10s)");
        }
      }
    }
    module2.exports = ThreadStream;
  }
});

// node_modules/.pnpm/pino@10.2.0/node_modules/pino/lib/transport.js
var require_transport = __commonJS({
  "node_modules/.pnpm/pino@10.2.0/node_modules/pino/lib/transport.js"(exports2, module2) {
    "use strict";
    var { createRequire } = require("module");
    var getCallers = require_caller();
    var { join: join2, isAbsolute, sep } = require("node:path");
    var sleep2 = require_atomic_sleep();
    var onExit = require_on_exit_leak_free();
    var ThreadStream = require_thread_stream();
    function setupOnExit(stream) {
      onExit.register(stream, autoEnd);
      onExit.registerBeforeExit(stream, flush);
      stream.on("close", function() {
        onExit.unregister(stream);
      });
    }
    function processPreloadFlags() {
      const execArgv = process.execArgv;
      let hasPreload = false;
      const filtered = [];
      for (let i4 = 0; i4 < execArgv.length; i4++) {
        const arg = execArgv[i4];
        if (arg === "--import" || arg === "--require" || arg === "-r") {
          hasPreload = true;
          i4++;
          continue;
        }
        if (arg.startsWith("--import=") || arg.startsWith("--require=") || arg.startsWith("-r=")) {
          hasPreload = true;
          continue;
        }
        filtered.push(arg);
      }
      return { hasPreload, filtered };
    }
    function buildStream(filename, workerData, workerOpts, sync) {
      if (!workerOpts.execArgv) {
        const { hasPreload, filtered } = processPreloadFlags();
        if (hasPreload && require.main === void 0) {
          workerOpts = {
            ...workerOpts,
            execArgv: filtered
          };
        }
      }
      const stream = new ThreadStream({
        filename,
        workerData,
        workerOpts,
        sync
      });
      stream.on("ready", onReady);
      stream.on("close", function() {
        process.removeListener("exit", onExit2);
      });
      process.on("exit", onExit2);
      function onReady() {
        process.removeListener("exit", onExit2);
        stream.unref();
        if (workerOpts.autoEnd !== false) {
          setupOnExit(stream);
        }
      }
      function onExit2() {
        if (stream.closed) {
          return;
        }
        stream.flushSync();
        sleep2(100);
        stream.end();
      }
      return stream;
    }
    function autoEnd(stream) {
      stream.ref();
      stream.flushSync();
      stream.end();
      stream.once("close", function() {
        stream.unref();
      });
    }
    function flush(stream) {
      stream.flushSync();
    }
    function transport(fullOptions) {
      const { pipeline, targets, levels, dedupe, worker = {}, caller = getCallers(), sync = false } = fullOptions;
      const options = {
        ...fullOptions.options
      };
      const callers = typeof caller === "string" ? [caller] : caller;
      const bundlerOverrides = typeof globalThis === "object" && Object.prototype.hasOwnProperty.call(globalThis, "__bundlerPathsOverrides") && globalThis.__bundlerPathsOverrides && typeof globalThis.__bundlerPathsOverrides === "object" ? globalThis.__bundlerPathsOverrides : /* @__PURE__ */ Object.create(null);
      let target = fullOptions.target;
      if (target && targets) {
        throw new Error("only one of target or targets can be specified");
      }
      if (targets) {
        target = bundlerOverrides["pino-worker"] || join2(__dirname, "worker.js");
        options.targets = targets.filter((dest) => dest.target).map((dest) => {
          return {
            ...dest,
            target: fixTarget(dest.target)
          };
        });
        options.pipelines = targets.filter((dest) => dest.pipeline).map((dest) => {
          return dest.pipeline.map((t4) => {
            return {
              ...t4,
              level: dest.level,
              // duplicate the pipeline `level` property defined in the upper level
              target: fixTarget(t4.target)
            };
          });
        });
      } else if (pipeline) {
        target = bundlerOverrides["pino-worker"] || join2(__dirname, "worker.js");
        options.pipelines = [pipeline.map((dest) => {
          return {
            ...dest,
            target: fixTarget(dest.target)
          };
        })];
      }
      if (levels) {
        options.levels = levels;
      }
      if (dedupe) {
        options.dedupe = dedupe;
      }
      options.pinoWillSendConfig = true;
      return buildStream(fixTarget(target), options, worker, sync);
      function fixTarget(origin) {
        origin = bundlerOverrides[origin] || origin;
        if (isAbsolute(origin) || origin.indexOf("file://") === 0) {
          return origin;
        }
        if (origin === "pino/file") {
          return join2(__dirname, "..", "file.js");
        }
        let fixTarget2;
        for (const filePath of callers) {
          try {
            const context = filePath === "node:repl" ? process.cwd() + sep : filePath;
            fixTarget2 = createRequire(context).resolve(origin);
            break;
          } catch (err) {
            continue;
          }
        }
        if (!fixTarget2) {
          throw new Error(`unable to determine transport target for "${origin}"`);
        }
        return fixTarget2;
      }
    }
    module2.exports = transport;
  }
});

// node_modules/.pnpm/pino@10.2.0/node_modules/pino/lib/tools.js
var require_tools = __commonJS({
  "node_modules/.pnpm/pino@10.2.0/node_modules/pino/lib/tools.js"(exports2, module2) {
    "use strict";
    var diagChan = require("node:diagnostics_channel");
    var format2 = require_quick_format_unescaped();
    var { mapHttpRequest, mapHttpResponse } = require_pino_std_serializers();
    var SonicBoom = require_sonic_boom();
    var onExit = require_on_exit_leak_free();
    var {
      lsCacheSym,
      chindingsSym,
      writeSym,
      serializersSym,
      formatOptsSym,
      endSym,
      stringifiersSym,
      stringifySym,
      stringifySafeSym,
      wildcardFirstSym,
      nestedKeySym,
      formattersSym,
      messageKeySym,
      errorKeySym,
      nestedKeyStrSym,
      msgPrefixSym
    } = require_symbols();
    var { isMainThread } = require("worker_threads");
    var transport = require_transport();
    var [nodeMajor] = process.versions.node.split(".").map((v4) => Number(v4));
    var asJsonChan = diagChan.tracingChannel("pino_asJson");
    var asString = nodeMajor >= 25 ? (str) => JSON.stringify(str) : _asString;
    function noop2() {
    }
    function genLog(level, hook) {
      if (!hook) return LOG;
      return function hookWrappedLog(...args) {
        hook.call(this, args, LOG, level);
      };
      function LOG(o4, ...n4) {
        if (typeof o4 === "object") {
          let msg = o4;
          if (o4 !== null) {
            if (o4.method && o4.headers && o4.socket) {
              o4 = mapHttpRequest(o4);
            } else if (typeof o4.setHeader === "function") {
              o4 = mapHttpResponse(o4);
            }
          }
          let formatParams;
          if (msg === null && n4.length === 0) {
            formatParams = [null];
          } else {
            msg = n4.shift();
            formatParams = n4;
          }
          if (typeof this[msgPrefixSym] === "string" && msg !== void 0 && msg !== null) {
            msg = this[msgPrefixSym] + msg;
          }
          this[writeSym](o4, format2(msg, formatParams, this[formatOptsSym]), level);
        } else {
          let msg = o4 === void 0 ? n4.shift() : o4;
          if (typeof this[msgPrefixSym] === "string" && msg !== void 0 && msg !== null) {
            msg = this[msgPrefixSym] + msg;
          }
          this[writeSym](null, format2(msg, n4, this[formatOptsSym]), level);
        }
      }
    }
    function _asString(str) {
      let result = "";
      let last = 0;
      let found = false;
      let point = 255;
      const l4 = str.length;
      if (l4 > 100) {
        return JSON.stringify(str);
      }
      for (var i4 = 0; i4 < l4 && point >= 32; i4++) {
        point = str.charCodeAt(i4);
        if (point === 34 || point === 92) {
          result += str.slice(last, i4) + "\\";
          last = i4;
          found = true;
        }
      }
      if (!found) {
        result = str;
      } else {
        result += str.slice(last);
      }
      return point < 32 ? JSON.stringify(str) : '"' + result + '"';
    }
    function asJson(obj, msg, num, time2) {
      if (asJsonChan.hasSubscribers === false) {
        return _asJson.call(this, obj, msg, num, time2);
      }
      const store = { instance: this, arguments };
      return asJsonChan.traceSync(_asJson, store, this, obj, msg, num, time2);
    }
    function _asJson(obj, msg, num, time2) {
      const stringify2 = this[stringifySym];
      const stringifySafe = this[stringifySafeSym];
      const stringifiers = this[stringifiersSym];
      const end = this[endSym];
      const chindings = this[chindingsSym];
      const serializers = this[serializersSym];
      const formatters = this[formattersSym];
      const messageKey = this[messageKeySym];
      const errorKey = this[errorKeySym];
      let data2 = this[lsCacheSym][num] + time2;
      data2 = data2 + chindings;
      let value;
      if (formatters.log) {
        obj = formatters.log(obj);
      }
      const wildcardStringifier = stringifiers[wildcardFirstSym];
      let propStr = "";
      for (const key in obj) {
        value = obj[key];
        if (Object.prototype.hasOwnProperty.call(obj, key) && value !== void 0) {
          if (serializers[key]) {
            value = serializers[key](value);
          } else if (key === errorKey && serializers.err) {
            value = serializers.err(value);
          }
          const stringifier = stringifiers[key] || wildcardStringifier;
          switch (typeof value) {
            case "undefined":
            case "function":
              continue;
            case "number":
              if (Number.isFinite(value) === false) {
                value = null;
              }
            // this case explicitly falls through to the next one
            case "boolean":
              if (stringifier) value = stringifier(value);
              break;
            case "string":
              value = (stringifier || asString)(value);
              break;
            default:
              value = (stringifier || stringify2)(value, stringifySafe);
          }
          if (value === void 0) continue;
          const strKey = asString(key);
          propStr += "," + strKey + ":" + value;
        }
      }
      let msgStr = "";
      if (msg !== void 0) {
        value = serializers[messageKey] ? serializers[messageKey](msg) : msg;
        const stringifier = stringifiers[messageKey] || wildcardStringifier;
        switch (typeof value) {
          case "function":
            break;
          case "number":
            if (Number.isFinite(value) === false) {
              value = null;
            }
          // this case explicitly falls through to the next one
          case "boolean":
            if (stringifier) value = stringifier(value);
            msgStr = ',"' + messageKey + '":' + value;
            break;
          case "string":
            value = (stringifier || asString)(value);
            msgStr = ',"' + messageKey + '":' + value;
            break;
          default:
            value = (stringifier || stringify2)(value, stringifySafe);
            msgStr = ',"' + messageKey + '":' + value;
        }
      }
      if (this[nestedKeySym] && propStr) {
        return data2 + this[nestedKeyStrSym] + propStr.slice(1) + "}" + msgStr + end;
      } else {
        return data2 + propStr + msgStr + end;
      }
    }
    function asChindings(instance, bindings) {
      let value;
      let data2 = instance[chindingsSym];
      const stringify2 = instance[stringifySym];
      const stringifySafe = instance[stringifySafeSym];
      const stringifiers = instance[stringifiersSym];
      const wildcardStringifier = stringifiers[wildcardFirstSym];
      const serializers = instance[serializersSym];
      const formatter = instance[formattersSym].bindings;
      bindings = formatter(bindings);
      for (const key in bindings) {
        value = bindings[key];
        const valid2 = (key.length < 5 || key !== "level" && key !== "serializers" && key !== "formatters" && key !== "customLevels") && bindings.hasOwnProperty(key) && value !== void 0;
        if (valid2 === true) {
          value = serializers[key] ? serializers[key](value) : value;
          value = (stringifiers[key] || wildcardStringifier || stringify2)(value, stringifySafe);
          if (value === void 0) continue;
          data2 += ',"' + key + '":' + value;
        }
      }
      return data2;
    }
    function hasBeenTampered(stream) {
      return stream.write !== stream.constructor.prototype.write;
    }
    function buildSafeSonicBoom(opts) {
      const stream = new SonicBoom(opts);
      stream.on("error", filterBrokenPipe);
      if (!opts.sync && isMainThread) {
        onExit.register(stream, autoEnd);
        stream.on("close", function() {
          onExit.unregister(stream);
        });
      }
      return stream;
      function filterBrokenPipe(err) {
        if (err.code === "EPIPE") {
          stream.write = noop2;
          stream.end = noop2;
          stream.flushSync = noop2;
          stream.destroy = noop2;
          return;
        }
        stream.removeListener("error", filterBrokenPipe);
        stream.emit("error", err);
      }
    }
    function autoEnd(stream, eventName) {
      if (stream.destroyed) {
        return;
      }
      if (eventName === "beforeExit") {
        stream.flush();
        stream.on("drain", function() {
          stream.end();
        });
      } else {
        stream.flushSync();
      }
    }
    function createArgsNormalizer(defaultOptions2) {
      return function normalizeArgs(instance, caller, opts = {}, stream) {
        if (typeof opts === "string") {
          stream = buildSafeSonicBoom({ dest: opts });
          opts = {};
        } else if (typeof stream === "string") {
          if (opts && opts.transport) {
            throw Error("only one of option.transport or stream can be specified");
          }
          stream = buildSafeSonicBoom({ dest: stream });
        } else if (opts instanceof SonicBoom || opts.writable || opts._writableState) {
          stream = opts;
          opts = {};
        } else if (opts.transport) {
          if (opts.transport instanceof SonicBoom || opts.transport.writable || opts.transport._writableState) {
            throw Error("option.transport do not allow stream, please pass to option directly. e.g. pino(transport)");
          }
          if (opts.transport.targets && opts.transport.targets.length && opts.formatters && typeof opts.formatters.level === "function") {
            throw Error("option.transport.targets do not allow custom level formatters");
          }
          let customLevels;
          if (opts.customLevels) {
            customLevels = opts.useOnlyCustomLevels ? opts.customLevels : Object.assign({}, opts.levels, opts.customLevels);
          }
          stream = transport({ caller, ...opts.transport, levels: customLevels });
        }
        opts = Object.assign({}, defaultOptions2, opts);
        opts.serializers = Object.assign({}, defaultOptions2.serializers, opts.serializers);
        opts.formatters = Object.assign({}, defaultOptions2.formatters, opts.formatters);
        if (opts.prettyPrint) {
          throw new Error("prettyPrint option is no longer supported, see the pino-pretty package (https://github.com/pinojs/pino-pretty)");
        }
        const { enabled, onChild } = opts;
        if (enabled === false) opts.level = "silent";
        if (!onChild) opts.onChild = noop2;
        if (!stream) {
          if (!hasBeenTampered(process.stdout)) {
            stream = buildSafeSonicBoom({ fd: process.stdout.fd || 1 });
          } else {
            stream = process.stdout;
          }
        }
        return { opts, stream };
      };
    }
    function stringify(obj, stringifySafeFn) {
      try {
        return JSON.stringify(obj);
      } catch (_) {
        try {
          const stringify2 = stringifySafeFn || this[stringifySafeSym];
          return stringify2(obj);
        } catch (_2) {
          return '"[unable to serialize, circular reference is too complex to analyze]"';
        }
      }
    }
    function buildFormatters(level, bindings, log) {
      return {
        level,
        bindings,
        log
      };
    }
    function normalizeDestFileDescriptor(destination) {
      const fd = Number(destination);
      if (typeof destination === "string" && Number.isFinite(fd)) {
        return fd;
      }
      if (destination === void 0) {
        return 1;
      }
      return destination;
    }
    module2.exports = {
      noop: noop2,
      buildSafeSonicBoom,
      asChindings,
      asJson,
      genLog,
      createArgsNormalizer,
      stringify,
      buildFormatters,
      normalizeDestFileDescriptor
    };
  }
});

// node_modules/.pnpm/pino@10.2.0/node_modules/pino/lib/constants.js
var require_constants = __commonJS({
  "node_modules/.pnpm/pino@10.2.0/node_modules/pino/lib/constants.js"(exports2, module2) {
    var DEFAULT_LEVELS = {
      trace: 10,
      debug: 20,
      info: 30,
      warn: 40,
      error: 50,
      fatal: 60
    };
    var SORTING_ORDER = {
      ASC: "ASC",
      DESC: "DESC"
    };
    module2.exports = {
      DEFAULT_LEVELS,
      SORTING_ORDER
    };
  }
});

// node_modules/.pnpm/pino@10.2.0/node_modules/pino/lib/levels.js
var require_levels = __commonJS({
  "node_modules/.pnpm/pino@10.2.0/node_modules/pino/lib/levels.js"(exports2, module2) {
    "use strict";
    var {
      lsCacheSym,
      levelValSym,
      useOnlyCustomLevelsSym,
      streamSym,
      formattersSym,
      hooksSym,
      levelCompSym
    } = require_symbols();
    var { noop: noop2, genLog } = require_tools();
    var { DEFAULT_LEVELS, SORTING_ORDER } = require_constants();
    var levelMethods = {
      fatal: (hook) => {
        const logFatal = genLog(DEFAULT_LEVELS.fatal, hook);
        return function(...args) {
          const stream = this[streamSym];
          logFatal.call(this, ...args);
          if (typeof stream.flushSync === "function") {
            try {
              stream.flushSync();
            } catch (e4) {
            }
          }
        };
      },
      error: (hook) => genLog(DEFAULT_LEVELS.error, hook),
      warn: (hook) => genLog(DEFAULT_LEVELS.warn, hook),
      info: (hook) => genLog(DEFAULT_LEVELS.info, hook),
      debug: (hook) => genLog(DEFAULT_LEVELS.debug, hook),
      trace: (hook) => genLog(DEFAULT_LEVELS.trace, hook)
    };
    var nums = Object.keys(DEFAULT_LEVELS).reduce((o4, k4) => {
      o4[DEFAULT_LEVELS[k4]] = k4;
      return o4;
    }, {});
    var initialLsCache = Object.keys(nums).reduce((o4, k4) => {
      o4[k4] = '{"level":' + Number(k4);
      return o4;
    }, {});
    function genLsCache(instance) {
      const formatter = instance[formattersSym].level;
      const { labels } = instance.levels;
      const cache5 = {};
      for (const label in labels) {
        const level = formatter(labels[label], Number(label));
        cache5[label] = JSON.stringify(level).slice(0, -1);
      }
      instance[lsCacheSym] = cache5;
      return instance;
    }
    function isStandardLevel(level, useOnlyCustomLevels) {
      if (useOnlyCustomLevels) {
        return false;
      }
      switch (level) {
        case "fatal":
        case "error":
        case "warn":
        case "info":
        case "debug":
        case "trace":
          return true;
        default:
          return false;
      }
    }
    function setLevel(level) {
      const { labels, values } = this.levels;
      if (typeof level === "number") {
        if (labels[level] === void 0) throw Error("unknown level value" + level);
        level = labels[level];
      }
      if (values[level] === void 0) throw Error("unknown level " + level);
      const preLevelVal = this[levelValSym];
      const levelVal = this[levelValSym] = values[level];
      const useOnlyCustomLevelsVal = this[useOnlyCustomLevelsSym];
      const levelComparison = this[levelCompSym];
      const hook = this[hooksSym].logMethod;
      for (const key in values) {
        if (levelComparison(values[key], levelVal) === false) {
          this[key] = noop2;
          continue;
        }
        this[key] = isStandardLevel(key, useOnlyCustomLevelsVal) ? levelMethods[key](hook) : genLog(values[key], hook);
      }
      this.emit(
        "level-change",
        level,
        levelVal,
        labels[preLevelVal],
        preLevelVal,
        this
      );
    }
    function getLevel(level) {
      const { levels, levelVal } = this;
      return levels && levels.labels ? levels.labels[levelVal] : "";
    }
    function isLevelEnabled(logLevel) {
      const { values } = this.levels;
      const logLevelVal = values[logLevel];
      return logLevelVal !== void 0 && this[levelCompSym](logLevelVal, this[levelValSym]);
    }
    function compareLevel(direction, current, expected) {
      if (direction === SORTING_ORDER.DESC) {
        return current <= expected;
      }
      return current >= expected;
    }
    function genLevelComparison(levelComparison) {
      if (typeof levelComparison === "string") {
        return compareLevel.bind(null, levelComparison);
      }
      return levelComparison;
    }
    function mappings(customLevels = null, useOnlyCustomLevels = false) {
      const customNums = customLevels ? Object.keys(customLevels).reduce((o4, k4) => {
        o4[customLevels[k4]] = k4;
        return o4;
      }, {}) : null;
      const labels = Object.assign(
        Object.create(Object.prototype, { Infinity: { value: "silent" } }),
        useOnlyCustomLevels ? null : nums,
        customNums
      );
      const values = Object.assign(
        Object.create(Object.prototype, { silent: { value: Infinity } }),
        useOnlyCustomLevels ? null : DEFAULT_LEVELS,
        customLevels
      );
      return { labels, values };
    }
    function assertDefaultLevelFound(defaultLevel, customLevels, useOnlyCustomLevels) {
      if (typeof defaultLevel === "number") {
        const values = [].concat(
          Object.keys(customLevels || {}).map((key) => customLevels[key]),
          useOnlyCustomLevels ? [] : Object.keys(nums).map((level) => +level),
          Infinity
        );
        if (!values.includes(defaultLevel)) {
          throw Error(`default level:${defaultLevel} must be included in custom levels`);
        }
        return;
      }
      const labels = Object.assign(
        Object.create(Object.prototype, { silent: { value: Infinity } }),
        useOnlyCustomLevels ? null : DEFAULT_LEVELS,
        customLevels
      );
      if (!(defaultLevel in labels)) {
        throw Error(`default level:${defaultLevel} must be included in custom levels`);
      }
    }
    function assertNoLevelCollisions(levels, customLevels) {
      const { labels, values } = levels;
      for (const k4 in customLevels) {
        if (k4 in values) {
          throw Error("levels cannot be overridden");
        }
        if (customLevels[k4] in labels) {
          throw Error("pre-existing level values cannot be used for new levels");
        }
      }
    }
    function assertLevelComparison(levelComparison) {
      if (typeof levelComparison === "function") {
        return;
      }
      if (typeof levelComparison === "string" && Object.values(SORTING_ORDER).includes(levelComparison)) {
        return;
      }
      throw new Error('Levels comparison should be one of "ASC", "DESC" or "function" type');
    }
    module2.exports = {
      initialLsCache,
      genLsCache,
      levelMethods,
      getLevel,
      setLevel,
      isLevelEnabled,
      mappings,
      assertNoLevelCollisions,
      assertDefaultLevelFound,
      genLevelComparison,
      assertLevelComparison
    };
  }
});

// node_modules/.pnpm/pino@10.2.0/node_modules/pino/lib/meta.js
var require_meta = __commonJS({
  "node_modules/.pnpm/pino@10.2.0/node_modules/pino/lib/meta.js"(exports2, module2) {
    "use strict";
    module2.exports = { version: "10.2.0" };
  }
});

// node_modules/.pnpm/pino@10.2.0/node_modules/pino/lib/proto.js
var require_proto = __commonJS({
  "node_modules/.pnpm/pino@10.2.0/node_modules/pino/lib/proto.js"(exports2, module2) {
    "use strict";
    var { EventEmitter: EventEmitter2 } = require("node:events");
    var {
      lsCacheSym,
      levelValSym,
      setLevelSym,
      getLevelSym,
      chindingsSym,
      mixinSym,
      asJsonSym,
      writeSym,
      mixinMergeStrategySym,
      timeSym,
      timeSliceIndexSym,
      streamSym,
      serializersSym,
      formattersSym,
      errorKeySym,
      messageKeySym,
      useOnlyCustomLevelsSym,
      needsMetadataGsym,
      redactFmtSym,
      stringifySym,
      formatOptsSym,
      stringifiersSym,
      msgPrefixSym,
      hooksSym
    } = require_symbols();
    var {
      getLevel,
      setLevel,
      isLevelEnabled,
      mappings,
      initialLsCache,
      genLsCache,
      assertNoLevelCollisions
    } = require_levels();
    var {
      asChindings,
      asJson,
      buildFormatters,
      stringify,
      noop: noop2
    } = require_tools();
    var {
      version
    } = require_meta();
    var redaction = require_redaction();
    var constructor = class Pino {
    };
    var prototype = {
      constructor,
      child,
      bindings,
      setBindings,
      flush,
      isLevelEnabled,
      version,
      get level() {
        return this[getLevelSym]();
      },
      set level(lvl) {
        this[setLevelSym](lvl);
      },
      get levelVal() {
        return this[levelValSym];
      },
      set levelVal(n4) {
        throw Error("levelVal is read-only");
      },
      get msgPrefix() {
        return this[msgPrefixSym];
      },
      get [Symbol.toStringTag]() {
        return "Pino";
      },
      [lsCacheSym]: initialLsCache,
      [writeSym]: write,
      [asJsonSym]: asJson,
      [getLevelSym]: getLevel,
      [setLevelSym]: setLevel
    };
    Object.setPrototypeOf(prototype, EventEmitter2.prototype);
    module2.exports = function() {
      return Object.create(prototype);
    };
    var resetChildingsFormatter = (bindings2) => bindings2;
    function child(bindings2, options) {
      if (!bindings2) {
        throw Error("missing bindings for child Pino");
      }
      const serializers = this[serializersSym];
      const formatters = this[formattersSym];
      const instance = Object.create(this);
      if (options == null) {
        if (instance[formattersSym].bindings !== resetChildingsFormatter) {
          instance[formattersSym] = buildFormatters(
            formatters.level,
            resetChildingsFormatter,
            formatters.log
          );
        }
        instance[chindingsSym] = asChindings(instance, bindings2);
        if (this.onChild !== noop2) {
          this.onChild(instance);
        }
        return instance;
      }
      if (options.hasOwnProperty("serializers") === true) {
        instance[serializersSym] = /* @__PURE__ */ Object.create(null);
        for (const k4 in serializers) {
          instance[serializersSym][k4] = serializers[k4];
        }
        const parentSymbols = Object.getOwnPropertySymbols(serializers);
        for (var i4 = 0; i4 < parentSymbols.length; i4++) {
          const ks = parentSymbols[i4];
          instance[serializersSym][ks] = serializers[ks];
        }
        for (const bk in options.serializers) {
          instance[serializersSym][bk] = options.serializers[bk];
        }
        const bindingsSymbols = Object.getOwnPropertySymbols(options.serializers);
        for (var bi = 0; bi < bindingsSymbols.length; bi++) {
          const bks = bindingsSymbols[bi];
          instance[serializersSym][bks] = options.serializers[bks];
        }
      } else instance[serializersSym] = serializers;
      if (options.hasOwnProperty("formatters")) {
        const { level, bindings: chindings, log } = options.formatters;
        instance[formattersSym] = buildFormatters(
          level || formatters.level,
          chindings || resetChildingsFormatter,
          log || formatters.log
        );
      } else {
        instance[formattersSym] = buildFormatters(
          formatters.level,
          resetChildingsFormatter,
          formatters.log
        );
      }
      if (options.hasOwnProperty("customLevels") === true) {
        assertNoLevelCollisions(this.levels, options.customLevels);
        instance.levels = mappings(options.customLevels, instance[useOnlyCustomLevelsSym]);
        genLsCache(instance);
      }
      if (typeof options.redact === "object" && options.redact !== null || Array.isArray(options.redact)) {
        instance.redact = options.redact;
        const stringifiers = redaction(instance.redact, stringify);
        const formatOpts = { stringify: stringifiers[redactFmtSym] };
        instance[stringifySym] = stringify;
        instance[stringifiersSym] = stringifiers;
        instance[formatOptsSym] = formatOpts;
      }
      if (typeof options.msgPrefix === "string") {
        instance[msgPrefixSym] = (this[msgPrefixSym] || "") + options.msgPrefix;
      }
      instance[chindingsSym] = asChindings(instance, bindings2);
      if (options.level !== void 0 && options.level !== this.level || options.hasOwnProperty("customLevels")) {
        const childLevel = options.level || this.level;
        instance[setLevelSym](childLevel);
      }
      this.onChild(instance);
      return instance;
    }
    function bindings() {
      const chindings = this[chindingsSym];
      const chindingsJson = `{${chindings.substr(1)}}`;
      const bindingsFromJson = JSON.parse(chindingsJson);
      delete bindingsFromJson.pid;
      delete bindingsFromJson.hostname;
      return bindingsFromJson;
    }
    function setBindings(newBindings) {
      const chindings = asChindings(this, newBindings);
      this[chindingsSym] = chindings;
    }
    function defaultMixinMergeStrategy(mergeObject, mixinObject) {
      return Object.assign(mixinObject, mergeObject);
    }
    function write(_obj, msg, num) {
      const t4 = this[timeSym]();
      const mixin = this[mixinSym];
      const errorKey = this[errorKeySym];
      const messageKey = this[messageKeySym];
      const mixinMergeStrategy = this[mixinMergeStrategySym] || defaultMixinMergeStrategy;
      let obj;
      const streamWriteHook = this[hooksSym].streamWrite;
      if (_obj === void 0 || _obj === null) {
        obj = {};
      } else if (_obj instanceof Error) {
        obj = { [errorKey]: _obj };
        if (msg === void 0) {
          msg = _obj.message;
        }
      } else {
        obj = _obj;
        if (msg === void 0 && _obj[messageKey] === void 0 && _obj[errorKey]) {
          msg = _obj[errorKey].message;
        }
      }
      if (mixin) {
        obj = mixinMergeStrategy(obj, mixin(obj, num, this));
      }
      const s4 = this[asJsonSym](obj, msg, num, t4);
      const stream = this[streamSym];
      if (stream[needsMetadataGsym] === true) {
        stream.lastLevel = num;
        stream.lastObj = obj;
        stream.lastMsg = msg;
        stream.lastTime = t4.slice(this[timeSliceIndexSym]);
        stream.lastLogger = this;
      }
      stream.write(streamWriteHook ? streamWriteHook(s4) : s4);
    }
    function flush(cb) {
      if (cb != null && typeof cb !== "function") {
        throw Error("callback must be a function");
      }
      const stream = this[streamSym];
      if (typeof stream.flush === "function") {
        stream.flush(cb || noop2);
      } else if (cb) cb();
    }
  }
});

// node_modules/.pnpm/safe-stable-stringify@2.5.0/node_modules/safe-stable-stringify/index.js
var require_safe_stable_stringify = __commonJS({
  "node_modules/.pnpm/safe-stable-stringify@2.5.0/node_modules/safe-stable-stringify/index.js"(exports2, module2) {
    "use strict";
    var { hasOwnProperty: hasOwnProperty13 } = Object.prototype;
    var stringify = configure();
    stringify.configure = configure;
    stringify.stringify = stringify;
    stringify.default = stringify;
    exports2.stringify = stringify;
    exports2.configure = configure;
    module2.exports = stringify;
    var strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;
    function strEscape(str) {
      if (str.length < 5e3 && !strEscapeSequencesRegExp.test(str)) {
        return `"${str}"`;
      }
      return JSON.stringify(str);
    }
    function sort(array, comparator) {
      if (array.length > 200 || comparator) {
        return array.sort(comparator);
      }
      for (let i4 = 1; i4 < array.length; i4++) {
        const currentValue = array[i4];
        let position = i4;
        while (position !== 0 && array[position - 1] > currentValue) {
          array[position] = array[position - 1];
          position--;
        }
        array[position] = currentValue;
      }
      return array;
    }
    var typedArrayPrototypeGetSymbolToStringTag = Object.getOwnPropertyDescriptor(
      Object.getPrototypeOf(
        Object.getPrototypeOf(
          new Int8Array()
        )
      ),
      Symbol.toStringTag
    ).get;
    function isTypedArrayWithEntries(value) {
      return typedArrayPrototypeGetSymbolToStringTag.call(value) !== void 0 && value.length !== 0;
    }
    function stringifyTypedArray(array, separator, maximumBreadth) {
      if (array.length < maximumBreadth) {
        maximumBreadth = array.length;
      }
      const whitespace2 = separator === "," ? "" : " ";
      let res = `"0":${whitespace2}${array[0]}`;
      for (let i4 = 1; i4 < maximumBreadth; i4++) {
        res += `${separator}"${i4}":${whitespace2}${array[i4]}`;
      }
      return res;
    }
    function getCircularValueOption(options) {
      if (hasOwnProperty13.call(options, "circularValue")) {
        const circularValue = options.circularValue;
        if (typeof circularValue === "string") {
          return `"${circularValue}"`;
        }
        if (circularValue == null) {
          return circularValue;
        }
        if (circularValue === Error || circularValue === TypeError) {
          return {
            toString() {
              throw new TypeError("Converting circular structure to JSON");
            }
          };
        }
        throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
      }
      return '"[Circular]"';
    }
    function getDeterministicOption(options) {
      let value;
      if (hasOwnProperty13.call(options, "deterministic")) {
        value = options.deterministic;
        if (typeof value !== "boolean" && typeof value !== "function") {
          throw new TypeError('The "deterministic" argument must be of type boolean or comparator function');
        }
      }
      return value === void 0 ? true : value;
    }
    function getBooleanOption(options, key) {
      let value;
      if (hasOwnProperty13.call(options, key)) {
        value = options[key];
        if (typeof value !== "boolean") {
          throw new TypeError(`The "${key}" argument must be of type boolean`);
        }
      }
      return value === void 0 ? true : value;
    }
    function getPositiveIntegerOption(options, key) {
      let value;
      if (hasOwnProperty13.call(options, key)) {
        value = options[key];
        if (typeof value !== "number") {
          throw new TypeError(`The "${key}" argument must be of type number`);
        }
        if (!Number.isInteger(value)) {
          throw new TypeError(`The "${key}" argument must be an integer`);
        }
        if (value < 1) {
          throw new RangeError(`The "${key}" argument must be >= 1`);
        }
      }
      return value === void 0 ? Infinity : value;
    }
    function getItemCount(number) {
      if (number === 1) {
        return "1 item";
      }
      return `${number} items`;
    }
    function getUniqueReplacerSet(replacerArray) {
      const replacerSet = /* @__PURE__ */ new Set();
      for (const value of replacerArray) {
        if (typeof value === "string" || typeof value === "number") {
          replacerSet.add(String(value));
        }
      }
      return replacerSet;
    }
    function getStrictOption(options) {
      if (hasOwnProperty13.call(options, "strict")) {
        const value = options.strict;
        if (typeof value !== "boolean") {
          throw new TypeError('The "strict" argument must be of type boolean');
        }
        if (value) {
          return (value2) => {
            let message = `Object can not safely be stringified. Received type ${typeof value2}`;
            if (typeof value2 !== "function") message += ` (${value2.toString()})`;
            throw new Error(message);
          };
        }
      }
    }
    function configure(options) {
      options = { ...options };
      const fail = getStrictOption(options);
      if (fail) {
        if (options.bigint === void 0) {
          options.bigint = false;
        }
        if (!("circularValue" in options)) {
          options.circularValue = Error;
        }
      }
      const circularValue = getCircularValueOption(options);
      const bigint = getBooleanOption(options, "bigint");
      const deterministic = getDeterministicOption(options);
      const comparator = typeof deterministic === "function" ? deterministic : void 0;
      const maximumDepth = getPositiveIntegerOption(options, "maximumDepth");
      const maximumBreadth = getPositiveIntegerOption(options, "maximumBreadth");
      function stringifyFnReplacer(key, parent, stack, replacer, spacer, indentation) {
        let value = parent[key];
        if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        value = replacer.call(parent, key, value);
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            let res = "";
            let join2 = ",";
            const originalIndentation = indentation;
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              if (spacer !== "") {
                indentation += spacer;
                res += `
${indentation}`;
                join2 = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i4 = 0;
              for (; i4 < maximumValuesToStringify - 1; i4++) {
                const tmp2 = stringifyFnReplacer(String(i4), value, stack, replacer, spacer, indentation);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += join2;
              }
              const tmp = stringifyFnReplacer(String(i4), value, stack, replacer, spacer, indentation);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `${join2}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== "") {
                res += `
${originalIndentation}`;
              }
              stack.pop();
              return `[${res}]`;
            }
            let keys2 = Object.keys(value);
            const keyLength = keys2.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            let whitespace2 = "";
            let separator = "";
            if (spacer !== "") {
              indentation += spacer;
              join2 = `,
${indentation}`;
              whitespace2 = " ";
            }
            const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (deterministic && !isTypedArrayWithEntries(value)) {
              keys2 = sort(keys2, comparator);
            }
            stack.push(value);
            for (let i4 = 0; i4 < maximumPropertiesToStringify; i4++) {
              const key2 = keys2[i4];
              const tmp = stringifyFnReplacer(key2, value, stack, replacer, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${whitespace2}${tmp}`;
                separator = join2;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...":${whitespace2}"${getItemCount(removedKeys)} not stringified"`;
              separator = join2;
            }
            if (spacer !== "" && separator.length > 1) {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifyArrayReplacer(key, value, stack, replacer, spacer, indentation) {
        if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            let res = "";
            let join2 = ",";
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              if (spacer !== "") {
                indentation += spacer;
                res += `
${indentation}`;
                join2 = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i4 = 0;
              for (; i4 < maximumValuesToStringify - 1; i4++) {
                const tmp2 = stringifyArrayReplacer(String(i4), value[i4], stack, replacer, spacer, indentation);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += join2;
              }
              const tmp = stringifyArrayReplacer(String(i4), value[i4], stack, replacer, spacer, indentation);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `${join2}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== "") {
                res += `
${originalIndentation}`;
              }
              stack.pop();
              return `[${res}]`;
            }
            stack.push(value);
            let whitespace2 = "";
            if (spacer !== "") {
              indentation += spacer;
              join2 = `,
${indentation}`;
              whitespace2 = " ";
            }
            let separator = "";
            for (const key2 of replacer) {
              const tmp = stringifyArrayReplacer(key2, value[key2], stack, replacer, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${whitespace2}${tmp}`;
                separator = join2;
              }
            }
            if (spacer !== "" && separator.length > 1) {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifyIndent(key, value, stack, spacer, indentation) {
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (typeof value.toJSON === "function") {
              value = value.toJSON(key);
              if (typeof value !== "object") {
                return stringifyIndent(key, value, stack, spacer, indentation);
              }
              if (value === null) {
                return "null";
              }
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              indentation += spacer;
              let res2 = `
${indentation}`;
              const join3 = `,
${indentation}`;
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i4 = 0;
              for (; i4 < maximumValuesToStringify - 1; i4++) {
                const tmp2 = stringifyIndent(String(i4), value[i4], stack, spacer, indentation);
                res2 += tmp2 !== void 0 ? tmp2 : "null";
                res2 += join3;
              }
              const tmp = stringifyIndent(String(i4), value[i4], stack, spacer, indentation);
              res2 += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res2 += `${join3}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              res2 += `
${originalIndentation}`;
              stack.pop();
              return `[${res2}]`;
            }
            let keys2 = Object.keys(value);
            const keyLength = keys2.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            indentation += spacer;
            const join2 = `,
${indentation}`;
            let res = "";
            let separator = "";
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (isTypedArrayWithEntries(value)) {
              res += stringifyTypedArray(value, join2, maximumBreadth);
              keys2 = keys2.slice(value.length);
              maximumPropertiesToStringify -= value.length;
              separator = join2;
            }
            if (deterministic) {
              keys2 = sort(keys2, comparator);
            }
            stack.push(value);
            for (let i4 = 0; i4 < maximumPropertiesToStringify; i4++) {
              const key2 = keys2[i4];
              const tmp = stringifyIndent(key2, value[key2], stack, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}: ${tmp}`;
                separator = join2;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...": "${getItemCount(removedKeys)} not stringified"`;
              separator = join2;
            }
            if (separator !== "") {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifySimple(key, value, stack) {
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (typeof value.toJSON === "function") {
              value = value.toJSON(key);
              if (typeof value !== "object") {
                return stringifySimple(key, value, stack);
              }
              if (value === null) {
                return "null";
              }
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            let res = "";
            const hasLength = value.length !== void 0;
            if (hasLength && Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i4 = 0;
              for (; i4 < maximumValuesToStringify - 1; i4++) {
                const tmp2 = stringifySimple(String(i4), value[i4], stack);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += ",";
              }
              const tmp = stringifySimple(String(i4), value[i4], stack);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `,"... ${getItemCount(removedKeys)} not stringified"`;
              }
              stack.pop();
              return `[${res}]`;
            }
            let keys2 = Object.keys(value);
            const keyLength = keys2.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            let separator = "";
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (hasLength && isTypedArrayWithEntries(value)) {
              res += stringifyTypedArray(value, ",", maximumBreadth);
              keys2 = keys2.slice(value.length);
              maximumPropertiesToStringify -= value.length;
              separator = ",";
            }
            if (deterministic) {
              keys2 = sort(keys2, comparator);
            }
            stack.push(value);
            for (let i4 = 0; i4 < maximumPropertiesToStringify; i4++) {
              const key2 = keys2[i4];
              const tmp = stringifySimple(key2, value[key2], stack);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${tmp}`;
                separator = ",";
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...":"${getItemCount(removedKeys)} not stringified"`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          // fallthrough
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringify2(value, replacer, space) {
        if (arguments.length > 1) {
          let spacer = "";
          if (typeof space === "number") {
            spacer = " ".repeat(Math.min(space, 10));
          } else if (typeof space === "string") {
            spacer = space.slice(0, 10);
          }
          if (replacer != null) {
            if (typeof replacer === "function") {
              return stringifyFnReplacer("", { "": value }, [], replacer, spacer, "");
            }
            if (Array.isArray(replacer)) {
              return stringifyArrayReplacer("", value, [], getUniqueReplacerSet(replacer), spacer, "");
            }
          }
          if (spacer.length !== 0) {
            return stringifyIndent("", value, [], spacer, "");
          }
        }
        return stringifySimple("", value, []);
      }
      return stringify2;
    }
  }
});

// node_modules/.pnpm/pino@10.2.0/node_modules/pino/lib/multistream.js
var require_multistream = __commonJS({
  "node_modules/.pnpm/pino@10.2.0/node_modules/pino/lib/multistream.js"(exports2, module2) {
    "use strict";
    var metadata = /* @__PURE__ */ Symbol.for("pino.metadata");
    var { DEFAULT_LEVELS } = require_constants();
    var DEFAULT_INFO_LEVEL = DEFAULT_LEVELS.info;
    function multistream(streamsArray, opts) {
      streamsArray = streamsArray || [];
      opts = opts || { dedupe: false };
      const streamLevels = Object.create(DEFAULT_LEVELS);
      streamLevels.silent = Infinity;
      if (opts.levels && typeof opts.levels === "object") {
        Object.keys(opts.levels).forEach((i4) => {
          streamLevels[i4] = opts.levels[i4];
        });
      }
      const res = {
        write,
        add,
        remove,
        emit,
        flushSync,
        end,
        minLevel: 0,
        lastId: 0,
        streams: [],
        clone,
        [metadata]: true,
        streamLevels
      };
      if (Array.isArray(streamsArray)) {
        streamsArray.forEach(add, res);
      } else {
        add.call(res, streamsArray);
      }
      streamsArray = null;
      return res;
      function write(data2) {
        let dest;
        const level = this.lastLevel;
        const { streams } = this;
        let recordedLevel = 0;
        let stream;
        for (let i4 = initLoopVar(streams.length, opts.dedupe); checkLoopVar(i4, streams.length, opts.dedupe); i4 = adjustLoopVar(i4, opts.dedupe)) {
          dest = streams[i4];
          if (dest.level <= level) {
            if (recordedLevel !== 0 && recordedLevel !== dest.level) {
              break;
            }
            stream = dest.stream;
            if (stream[metadata]) {
              const { lastTime, lastMsg, lastObj, lastLogger } = this;
              stream.lastLevel = level;
              stream.lastTime = lastTime;
              stream.lastMsg = lastMsg;
              stream.lastObj = lastObj;
              stream.lastLogger = lastLogger;
            }
            stream.write(data2);
            if (opts.dedupe) {
              recordedLevel = dest.level;
            }
          } else if (!opts.dedupe) {
            break;
          }
        }
      }
      function emit(...args) {
        for (const { stream } of this.streams) {
          if (typeof stream.emit === "function") {
            stream.emit(...args);
          }
        }
      }
      function flushSync() {
        for (const { stream } of this.streams) {
          if (typeof stream.flushSync === "function") {
            stream.flushSync();
          }
        }
      }
      function add(dest) {
        if (!dest) {
          return res;
        }
        const isStream = typeof dest.write === "function" || dest.stream;
        const stream_ = dest.write ? dest : dest.stream;
        if (!isStream) {
          throw Error("stream object needs to implement either StreamEntry or DestinationStream interface");
        }
        const { streams, streamLevels: streamLevels2 } = this;
        let level;
        if (typeof dest.levelVal === "number") {
          level = dest.levelVal;
        } else if (typeof dest.level === "string") {
          level = streamLevels2[dest.level];
        } else if (typeof dest.level === "number") {
          level = dest.level;
        } else {
          level = DEFAULT_INFO_LEVEL;
        }
        const dest_ = {
          stream: stream_,
          level,
          levelVal: void 0,
          id: ++res.lastId
        };
        streams.unshift(dest_);
        streams.sort(compareByLevel);
        this.minLevel = streams[0].level;
        return res;
      }
      function remove(id2) {
        const { streams } = this;
        const index = streams.findIndex((s4) => s4.id === id2);
        if (index >= 0) {
          streams.splice(index, 1);
          streams.sort(compareByLevel);
          this.minLevel = streams.length > 0 ? streams[0].level : -1;
        }
        return res;
      }
      function end() {
        for (const { stream } of this.streams) {
          if (typeof stream.flushSync === "function") {
            stream.flushSync();
          }
          stream.end();
        }
      }
      function clone(level) {
        const streams = new Array(this.streams.length);
        for (let i4 = 0; i4 < streams.length; i4++) {
          streams[i4] = {
            level,
            stream: this.streams[i4].stream
          };
        }
        return {
          write,
          add,
          remove,
          minLevel: level,
          streams,
          clone,
          emit,
          flushSync,
          [metadata]: true
        };
      }
    }
    function compareByLevel(a4, b4) {
      return a4.level - b4.level;
    }
    function initLoopVar(length, dedupe) {
      return dedupe ? length - 1 : 0;
    }
    function adjustLoopVar(i4, dedupe) {
      return dedupe ? i4 - 1 : i4 + 1;
    }
    function checkLoopVar(i4, length, dedupe) {
      return dedupe ? i4 >= 0 : i4 < length;
    }
    module2.exports = multistream;
  }
});

// node_modules/.pnpm/pino@10.2.0/node_modules/pino/pino.js
var require_pino = __commonJS({
  "node_modules/.pnpm/pino@10.2.0/node_modules/pino/pino.js"(exports2, module2) {
    "use strict";
    var os3 = require("node:os");
    var stdSerializers = require_pino_std_serializers();
    var caller = require_caller();
    var redaction = require_redaction();
    var time2 = require_time();
    var proto = require_proto();
    var symbols2 = require_symbols();
    var { configure } = require_safe_stable_stringify();
    var { assertDefaultLevelFound, mappings, genLsCache, genLevelComparison, assertLevelComparison } = require_levels();
    var { DEFAULT_LEVELS, SORTING_ORDER } = require_constants();
    var {
      createArgsNormalizer,
      asChindings,
      buildSafeSonicBoom,
      buildFormatters,
      stringify,
      normalizeDestFileDescriptor,
      noop: noop2
    } = require_tools();
    var { version } = require_meta();
    var {
      chindingsSym,
      redactFmtSym,
      serializersSym,
      timeSym,
      timeSliceIndexSym,
      streamSym,
      stringifySym,
      stringifySafeSym,
      stringifiersSym,
      setLevelSym,
      endSym,
      formatOptsSym,
      messageKeySym,
      errorKeySym,
      nestedKeySym,
      mixinSym,
      levelCompSym,
      useOnlyCustomLevelsSym,
      formattersSym,
      hooksSym,
      nestedKeyStrSym,
      mixinMergeStrategySym,
      msgPrefixSym
    } = symbols2;
    var { epochTime, nullTime } = time2;
    var { pid } = process;
    var hostname = os3.hostname();
    var defaultErrorSerializer = stdSerializers.err;
    var defaultOptions2 = {
      level: "info",
      levelComparison: SORTING_ORDER.ASC,
      levels: DEFAULT_LEVELS,
      messageKey: "msg",
      errorKey: "err",
      nestedKey: null,
      enabled: true,
      base: { pid, hostname },
      serializers: Object.assign(/* @__PURE__ */ Object.create(null), {
        err: defaultErrorSerializer
      }),
      formatters: Object.assign(/* @__PURE__ */ Object.create(null), {
        bindings(bindings) {
          return bindings;
        },
        level(label, number) {
          return { level: number };
        }
      }),
      hooks: {
        logMethod: void 0,
        streamWrite: void 0
      },
      timestamp: epochTime,
      name: void 0,
      redact: null,
      customLevels: null,
      useOnlyCustomLevels: false,
      depthLimit: 5,
      edgeLimit: 100
    };
    var normalize = createArgsNormalizer(defaultOptions2);
    var serializers = Object.assign(/* @__PURE__ */ Object.create(null), stdSerializers);
    function pino2(...args) {
      const instance = {};
      const { opts, stream } = normalize(instance, caller(), ...args);
      if (opts.level && typeof opts.level === "string" && DEFAULT_LEVELS[opts.level.toLowerCase()] !== void 0) opts.level = opts.level.toLowerCase();
      const {
        redact,
        crlf,
        serializers: serializers2,
        timestamp,
        messageKey,
        errorKey,
        nestedKey,
        base: base2,
        name,
        level,
        customLevels,
        levelComparison,
        mixin,
        mixinMergeStrategy,
        useOnlyCustomLevels,
        formatters,
        hooks,
        depthLimit,
        edgeLimit,
        onChild,
        msgPrefix
      } = opts;
      const stringifySafe = configure({
        maximumDepth: depthLimit,
        maximumBreadth: edgeLimit
      });
      const allFormatters = buildFormatters(
        formatters.level,
        formatters.bindings,
        formatters.log
      );
      const stringifyFn = stringify.bind({
        [stringifySafeSym]: stringifySafe
      });
      const stringifiers = redact ? redaction(redact, stringifyFn) : {};
      const formatOpts = redact ? { stringify: stringifiers[redactFmtSym] } : { stringify: stringifyFn };
      const end = "}" + (crlf ? "\r\n" : "\n");
      const coreChindings = asChindings.bind(null, {
        [chindingsSym]: "",
        [serializersSym]: serializers2,
        [stringifiersSym]: stringifiers,
        [stringifySym]: stringify,
        [stringifySafeSym]: stringifySafe,
        [formattersSym]: allFormatters
      });
      let chindings = "";
      if (base2 !== null) {
        if (name === void 0) {
          chindings = coreChindings(base2);
        } else {
          chindings = coreChindings(Object.assign({}, base2, { name }));
        }
      }
      const time3 = timestamp instanceof Function ? timestamp : timestamp ? epochTime : nullTime;
      const timeSliceIndex = time3().indexOf(":") + 1;
      if (useOnlyCustomLevels && !customLevels) throw Error("customLevels is required if useOnlyCustomLevels is set true");
      if (mixin && typeof mixin !== "function") throw Error(`Unknown mixin type "${typeof mixin}" - expected "function"`);
      if (msgPrefix && typeof msgPrefix !== "string") throw Error(`Unknown msgPrefix type "${typeof msgPrefix}" - expected "string"`);
      assertDefaultLevelFound(level, customLevels, useOnlyCustomLevels);
      const levels = mappings(customLevels, useOnlyCustomLevels);
      if (typeof stream.emit === "function") {
        stream.emit("message", { code: "PINO_CONFIG", config: { levels, messageKey, errorKey } });
      }
      assertLevelComparison(levelComparison);
      const levelCompFunc = genLevelComparison(levelComparison);
      Object.assign(instance, {
        levels,
        [levelCompSym]: levelCompFunc,
        [useOnlyCustomLevelsSym]: useOnlyCustomLevels,
        [streamSym]: stream,
        [timeSym]: time3,
        [timeSliceIndexSym]: timeSliceIndex,
        [stringifySym]: stringify,
        [stringifySafeSym]: stringifySafe,
        [stringifiersSym]: stringifiers,
        [endSym]: end,
        [formatOptsSym]: formatOpts,
        [messageKeySym]: messageKey,
        [errorKeySym]: errorKey,
        [nestedKeySym]: nestedKey,
        // protect against injection
        [nestedKeyStrSym]: nestedKey ? `,${JSON.stringify(nestedKey)}:{` : "",
        [serializersSym]: serializers2,
        [mixinSym]: mixin,
        [mixinMergeStrategySym]: mixinMergeStrategy,
        [chindingsSym]: chindings,
        [formattersSym]: allFormatters,
        [hooksSym]: hooks,
        silent: noop2,
        onChild,
        [msgPrefixSym]: msgPrefix
      });
      Object.setPrototypeOf(instance, proto());
      genLsCache(instance);
      instance[setLevelSym](level);
      return instance;
    }
    module2.exports = pino2;
    module2.exports.destination = (dest = process.stdout.fd) => {
      if (typeof dest === "object") {
        dest.dest = normalizeDestFileDescriptor(dest.dest || process.stdout.fd);
        return buildSafeSonicBoom(dest);
      } else {
        return buildSafeSonicBoom({ dest: normalizeDestFileDescriptor(dest), minLength: 0 });
      }
    };
    module2.exports.transport = require_transport();
    module2.exports.multistream = require_multistream();
    module2.exports.levels = mappings();
    module2.exports.stdSerializers = serializers;
    module2.exports.stdTimeFunctions = Object.assign({}, time2);
    module2.exports.symbols = symbols2;
    module2.exports.version = version;
    module2.exports.default = pino2;
    module2.exports.pino = pino2;
  }
});

// stub-native:bcrypt
var require_bcrypt = __commonJS({
  "stub-native:bcrypt"(exports2, module2) {
    module2.exports = {};
  }
});

// src/action/index.ts
var import_node_fs2 = __toESM(require("node:fs"), 1);
var import_node_path2 = __toESM(require("node:path"), 1);

// src/action/inputs.ts
function getInput(name, required = false) {
  const envName = `INPUT_${name.replace(/-/g, "_").toUpperCase()}`;
  const value = process.env[envName] || "";
  if (required && !value) {
    throw new Error(`Input required and not supplied: ${name}`);
  }
  return value.trim();
}
function getBooleanInput(name, defaultValue = false) {
  const value = getInput(name).toLowerCase();
  if (!value) return defaultValue;
  return value === "true" || value === "yes" || value === "1";
}
function getInputs() {
  const backend = getInput("backend") || process.env.VAULTER_BACKEND || process.env.VAULTER_CONNECTION_STRING || "";
  if (!backend) {
    throw new Error('Backend is required. Set "backend" input or VAULTER_BACKEND environment variable.');
  }
  const passphrase = getInput("passphrase") || process.env.VAULTER_PASSPHRASE || "";
  const project = getInput("project", true);
  const environment = getInput("environment", true);
  const service = getInput("service") || void 0;
  const outputsRaw = getInput("outputs") || "env";
  const validOutputs = ["env", "json", "k8s-secret", "k8s-configmap", "helm-values", "tfvars", "shell"];
  const outputs = outputsRaw.split(",").map((o4) => o4.trim().toLowerCase()).filter((o4) => validOutputs.includes(o4));
  if (outputs.length === 0) {
    outputs.push("env");
  }
  const envPath = getInput("env-path") || ".env";
  const jsonPath = getInput("json-path") || "vaulter-vars.json";
  const k8sSecretPath = getInput("k8s-secret-path") || "k8s-secret.yaml";
  const k8sConfigMapPath = getInput("k8s-configmap-path") || "k8s-configmap.yaml";
  const helmValuesPath = getInput("helm-values-path") || "helm-values.yaml";
  const tfvarsPath = getInput("tfvars-path") || "terraform.auto.tfvars";
  const shellPath = getInput("shell-path") || "vaulter-env.sh";
  const k8sSecretName = getInput("k8s-secret-name") || void 0;
  const k8sConfigMapName = getInput("k8s-configmap-name") || void 0;
  const k8sNamespace = getInput("k8s-namespace") || "default";
  const encryptionMode = getInput("encryption-mode") || "symmetric";
  const publicKey = getInput("public-key") || void 0;
  const privateKey = getInput("private-key") || void 0;
  const asymmetricAlgorithm = getInput("asymmetric-algorithm") || "rsa-4096";
  if (encryptionMode === "asymmetric" && !publicKey && !privateKey) {
    throw new Error("Asymmetric mode requires at least public-key or private-key");
  }
  const includeShared = getBooleanInput("include-shared", true);
  const exportToEnv = getBooleanInput("export-to-env", false);
  const maskValues = getBooleanInput("mask-values", true);
  return {
    backend,
    passphrase,
    project,
    environment,
    service,
    outputs,
    envPath,
    jsonPath,
    k8sSecretPath,
    k8sConfigMapPath,
    helmValuesPath,
    tfvarsPath,
    shellPath,
    k8sSecretName,
    k8sConfigMapName,
    k8sNamespace,
    encryptionMode,
    publicKey,
    privateKey,
    asymmetricAlgorithm,
    includeShared,
    exportToEnv,
    maskValues
  };
}

// src/action/formats.ts
function base64Encode(str) {
  return Buffer.from(str, "utf-8").toString("base64");
}
function sanitizeK8sName(name) {
  return name.toLowerCase().replace(/[^a-z0-9-]/g, "-").replace(/--+/g, "-").replace(/^-|-$/g, "").slice(0, 63);
}
function escapeEnvValue(value) {
  if (value.includes(" ") || value.includes('"') || value.includes("'") || value.includes("#") || value.includes("\n") || value.includes("$") || value.startsWith(" ") || value.endsWith(" ")) {
    return `"${value.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\n/g, "\\n")}"`;
  }
  return value;
}
function formatYamlValue(value) {
  const needsQuote = value === "" || value === "true" || value === "false" || value === "null" || value === "yes" || value === "no" || value === "on" || value === "off" || !isNaN(Number(value)) || value.includes(":") || value.includes("#") || value.includes("\n") || value.includes('"') || value.includes("'") || value.startsWith(" ") || value.endsWith(" ") || value.startsWith("{") || value.startsWith("[") || value.startsWith("*") || value.startsWith("&");
  if (needsQuote) {
    return `"${value.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\n/g, "\\n")}"`;
  }
  return value;
}
function formatTfValue(value) {
  const escaped = value.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\t/g, "\\t");
  return `"${escaped}"`;
}
function escapeShellValue(value) {
  return `'${value.replace(/'/g, "'\\''")}'`;
}
function generateEnvFile(vars) {
  const lines = [
    "# Generated by Vaulter GitHub Action",
    `# Generated at: ${(/* @__PURE__ */ new Date()).toISOString()}`,
    ""
  ];
  for (const [key, value] of Object.entries(vars)) {
    lines.push(`${key}=${escapeEnvValue(value)}`);
  }
  return lines.join("\n") + "\n";
}
function generateJsonFile(vars) {
  return JSON.stringify(vars, null, 2) + "\n";
}
function generateK8sSecret(vars, options) {
  const lines = [
    "# Generated by Vaulter GitHub Action",
    `# Generated at: ${(/* @__PURE__ */ new Date()).toISOString()}`,
    "# Apply: kubectl apply -f <file>",
    "apiVersion: v1",
    "kind: Secret",
    "metadata:",
    `  name: ${sanitizeK8sName(options.name)}`,
    `  namespace: ${sanitizeK8sName(options.namespace)}`,
    "  labels:",
    "    app.kubernetes.io/managed-by: vaulter",
    `    app.kubernetes.io/environment: ${options.environment}`,
    "type: Opaque",
    "data:"
  ];
  for (const [key, value] of Object.entries(vars)) {
    lines.push(`  ${key}: ${base64Encode(value)}`);
  }
  return lines.join("\n") + "\n";
}
function generateK8sConfigMap(vars, options) {
  const lines = [
    "# Generated by Vaulter GitHub Action",
    `# Generated at: ${(/* @__PURE__ */ new Date()).toISOString()}`,
    "# Apply: kubectl apply -f <file>",
    "apiVersion: v1",
    "kind: ConfigMap",
    "metadata:",
    `  name: ${sanitizeK8sName(options.name)}`,
    `  namespace: ${sanitizeK8sName(options.namespace)}`,
    "  labels:",
    "    app.kubernetes.io/managed-by: vaulter",
    `    app.kubernetes.io/environment: ${options.environment}`,
    "data:"
  ];
  for (const [key, value] of Object.entries(vars)) {
    lines.push(`  ${key}: ${formatYamlValue(value)}`);
  }
  return lines.join("\n") + "\n";
}
function generateHelmValues(vars, options) {
  const lines = [
    "# Generated by Vaulter GitHub Action",
    `# Project: ${options.project}`,
    `# Environment: ${options.environment}`,
    options.service ? `# Service: ${options.service}` : null,
    `# Generated at: ${(/* @__PURE__ */ new Date()).toISOString()}`,
    "# DO NOT EDIT - changes will be overwritten",
    "",
    "# All environment variables",
    "env:"
  ].filter(Boolean);
  for (const [key, value] of Object.entries(vars)) {
    lines.push(`  ${key}: ${formatYamlValue(value)}`);
  }
  lines.push("");
  lines.push("# As key-value pairs for envFrom");
  lines.push("envVars:");
  for (const [key, value] of Object.entries(vars)) {
    lines.push(`  - name: ${key}`);
    lines.push(`    value: ${formatYamlValue(value)}`);
  }
  return lines.join("\n") + "\n";
}
function generateTfVars(vars, options) {
  const lines = [
    "# Generated by Vaulter GitHub Action",
    `# Project: ${options.project}`,
    `# Environment: ${options.environment}`,
    options.service ? `# Service: ${options.service}` : null,
    `# Generated at: ${(/* @__PURE__ */ new Date()).toISOString()}`,
    "# DO NOT EDIT - changes will be overwritten",
    ""
  ].filter(Boolean);
  for (const [key, value] of Object.entries(vars)) {
    const tfKey = key.toLowerCase();
    lines.push(`${tfKey} = ${formatTfValue(value)}`);
  }
  lines.push("");
  lines.push("# All environment variables as a map");
  lines.push("env_vars = {");
  for (const [key, value] of Object.entries(vars)) {
    lines.push(`  "${key}" = ${formatTfValue(value)}`);
  }
  lines.push("}");
  return lines.join("\n") + "\n";
}
function generateShellExport(vars) {
  const lines = [
    "#!/bin/bash",
    "# Generated by Vaulter GitHub Action",
    `# Generated at: ${(/* @__PURE__ */ new Date()).toISOString()}`,
    "# Usage: source <file> or . <file>",
    ""
  ];
  for (const [key, value] of Object.entries(vars)) {
    lines.push(`export ${key}=${escapeShellValue(value)}`);
  }
  return lines.join("\n") + "\n";
}

// node_modules/.pnpm/s3db.js@19.3.17_@hono+node-server@1.19.9_hono@4.11.4__express@5.2.1_hono@4.11.4_jose@6.1.3_zod@4.3.5/node_modules/s3db.js/dist/s3db-lite.es.js
var import_node_assert = __toESM(require("node:assert"), 1);
var import_node_net = __toESM(require("node:net"), 1);
var import_node_http = __toESM(require("node:http"), 1);
var import_node_stream = __toESM(require("node:stream"), 1);
var import_node_querystring = __toESM(require("node:querystring"), 1);
var import_node_events = __toESM(require("node:events"), 1);
var import_node_diagnostics_channel = __toESM(require("node:diagnostics_channel"), 1);
var import_node_util = __toESM(require("node:util"), 1);
var import_node_tls = __toESM(require("node:tls"), 1);
var import_node_buffer = __toESM(require("node:buffer"), 1);
var import_node_zlib = __toESM(require("node:zlib"), 1);
var import_node_perf_hooks = __toESM(require("node:perf_hooks"), 1);
var import_types3 = __toESM(require("node:util/types"), 1);
var import_node_crypto2 = __toESM(require("node:crypto"), 1);
var import_node_sqlite = __toESM(require_node_sqlite(), 1);
var import_node_worker_threads = __toESM(require("node:worker_threads"), 1);
var import_node_async_hooks = __toESM(require("node:async_hooks"), 1);
var import_node_console = __toESM(require("node:console"), 1);
var import_promises = __toESM(require("node:fs/promises"), 1);
var import_node_path = __toESM(require("node:path"), 1);
var import_node_timers = __toESM(require("node:timers"), 1);
var import_node_dns = __toESM(require("node:dns"), 1);
var import_perf_hooks = require("perf_hooks");
var import_async_hooks = require("async_hooks");
var import_promises2 = __toESM(require("node:dns/promises"), 1);
var import_node_os = __toESM(require("node:os"), 1);
var import_node_fs = __toESM(require("node:fs"), 1);
var import_node_v8 = __toESM(require("node:v8"), 1);
var import_node_child_process = require("node:child_process");
var import_path = __toESM(require("path"), 1);
var import_events = __toESM(require("events"), 1);

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_freeGlobal.js
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal_default = freeGlobal;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_root.js
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal_default || freeSelf || Function("return this")();
var root_default = root;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_Symbol.js
var Symbol2 = root_default.Symbol;
var Symbol_default = Symbol2;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_getRawTag.js
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var nativeObjectToString = objectProto.toString;
var symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag), tag2 = value[symToStringTag];
  try {
    value[symToStringTag] = void 0;
    var unmasked = true;
  } catch (e4) {
  }
  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag2;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}
var getRawTag_default = getRawTag;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_objectToString.js
var objectProto2 = Object.prototype;
var nativeObjectToString2 = objectProto2.toString;
function objectToString(value) {
  return nativeObjectToString2.call(value);
}
var objectToString_default = objectToString;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_baseGetTag.js
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag2 && symToStringTag2 in Object(value) ? getRawTag_default(value) : objectToString_default(value);
}
var baseGetTag_default = baseGetTag;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/isObjectLike.js
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_default = isObjectLike;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/isSymbol.js
var symbolTag = "[object Symbol]";
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike_default(value) && baseGetTag_default(value) == symbolTag;
}
var isSymbol_default = isSymbol;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_arrayMap.js
function arrayMap(array, iteratee) {
  var index = -1, length = array == null ? 0 : array.length, result = Array(length);
  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}
var arrayMap_default = arrayMap;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/isArray.js
var isArray = Array.isArray;
var isArray_default = isArray;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_baseToString.js
var INFINITY = 1 / 0;
var symbolProto = Symbol_default ? Symbol_default.prototype : void 0;
var symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray_default(value)) {
    return arrayMap_default(value, baseToString) + "";
  }
  if (isSymbol_default(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
var baseToString_default = baseToString;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_trimmedEndIndex.js
var reWhitespace = /\s/;
function trimmedEndIndex(string) {
  var index = string.length;
  while (index-- && reWhitespace.test(string.charAt(index))) {
  }
  return index;
}
var trimmedEndIndex_default = trimmedEndIndex;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_baseTrim.js
var reTrimStart = /^\s+/;
function baseTrim(string) {
  return string ? string.slice(0, trimmedEndIndex_default(string) + 1).replace(reTrimStart, "") : string;
}
var baseTrim_default = baseTrim;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/isObject.js
function isObject(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_default = isObject;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/toNumber.js
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol_default(value)) {
    return NAN;
  }
  if (isObject_default(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject_default(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim_default(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var toNumber_default = toNumber;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/toFinite.js
var INFINITY2 = 1 / 0;
var MAX_INTEGER = 17976931348623157e292;
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber_default(value);
  if (value === INFINITY2 || value === -INFINITY2) {
    var sign = value < 0 ? -1 : 1;
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}
var toFinite_default = toFinite;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/toInteger.js
function toInteger(value) {
  var result = toFinite_default(value), remainder = result % 1;
  return result === result ? remainder ? result - remainder : result : 0;
}
var toInteger_default = toInteger;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/identity.js
function identity(value) {
  return value;
}
var identity_default = identity;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/isFunction.js
var asyncTag = "[object AsyncFunction]";
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction(value) {
  if (!isObject_default(value)) {
    return false;
  }
  var tag2 = baseGetTag_default(value);
  return tag2 == funcTag || tag2 == genTag || tag2 == asyncTag || tag2 == proxyTag;
}
var isFunction_default = isFunction;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_coreJsData.js
var coreJsData = root_default["__core-js_shared__"];
var coreJsData_default = coreJsData;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_isMasked.js
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData_default && coreJsData_default.keys && coreJsData_default.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
})();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var isMasked_default = isMasked;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_toSource.js
var funcProto = Function.prototype;
var funcToString = funcProto.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e4) {
    }
    try {
      return func + "";
    } catch (e4) {
    }
  }
  return "";
}
var toSource_default = toSource;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_baseIsNative.js
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto2 = Function.prototype;
var objectProto3 = Object.prototype;
var funcToString2 = funcProto2.toString;
var hasOwnProperty2 = objectProto3.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(value) {
  if (!isObject_default(value) || isMasked_default(value)) {
    return false;
  }
  var pattern = isFunction_default(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource_default(value));
}
var baseIsNative_default = baseIsNative;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_getValue.js
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
var getValue_default = getValue;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_getNative.js
function getNative(object, key) {
  var value = getValue_default(object, key);
  return baseIsNative_default(value) ? value : void 0;
}
var getNative_default = getNative;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_WeakMap.js
var WeakMap2 = getNative_default(root_default, "WeakMap");
var WeakMap_default = WeakMap2;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_baseCreate.js
var objectCreate = Object.create;
var baseCreate = /* @__PURE__ */ (function() {
  function object() {
  }
  return function(proto) {
    if (!isObject_default(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
})();
var baseCreate_default = baseCreate;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_apply.js
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var apply_default = apply;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/noop.js
function noop() {
}
var noop_default = noop;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_copyArray.js
function copyArray(source, array) {
  var index = -1, length = source.length;
  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}
var copyArray_default = copyArray;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_shortOut.js
var HOT_COUNT = 800;
var HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut(func) {
  var count = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var shortOut_default = shortOut;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/constant.js
function constant(value) {
  return function() {
    return value;
  };
}
var constant_default = constant;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_defineProperty.js
var defineProperty = (function() {
  try {
    var func = getNative_default(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e4) {
  }
})();
var defineProperty_default = defineProperty;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_baseSetToString.js
var baseSetToString = !defineProperty_default ? identity_default : function(func, string) {
  return defineProperty_default(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant_default(string),
    "writable": true
  });
};
var baseSetToString_default = baseSetToString;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_setToString.js
var setToString = shortOut_default(baseSetToString_default);
var setToString_default = setToString;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_arrayEach.js
function arrayEach(array, iteratee) {
  var index = -1, length = array == null ? 0 : array.length;
  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}
var arrayEach_default = arrayEach;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_baseFindIndex.js
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
  while (fromRight ? index-- : ++index < length) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}
var baseFindIndex_default = baseFindIndex;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_baseIsNaN.js
function baseIsNaN(value) {
  return value !== value;
}
var baseIsNaN_default = baseIsNaN;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_strictIndexOf.js
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1, length = array.length;
  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}
var strictIndexOf_default = strictIndexOf;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_baseIndexOf.js
function baseIndexOf(array, value, fromIndex) {
  return value === value ? strictIndexOf_default(array, value, fromIndex) : baseFindIndex_default(array, baseIsNaN_default, fromIndex);
}
var baseIndexOf_default = baseIndexOf;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_arrayIncludes.js
function arrayIncludes(array, value) {
  var length = array == null ? 0 : array.length;
  return !!length && baseIndexOf_default(array, value, 0) > -1;
}
var arrayIncludes_default = arrayIncludes;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_isIndex.js
var MAX_SAFE_INTEGER = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var isIndex_default = isIndex;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_baseAssignValue.js
function baseAssignValue(object, key, value) {
  if (key == "__proto__" && defineProperty_default) {
    defineProperty_default(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
var baseAssignValue_default = baseAssignValue;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/eq.js
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_default = eq;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_assignValue.js
var objectProto4 = Object.prototype;
var hasOwnProperty3 = objectProto4.hasOwnProperty;
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty3.call(object, key) && eq_default(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue_default(object, key, value);
  }
}
var assignValue_default = assignValue;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_copyObject.js
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1, length = props.length;
  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue_default(object, key, newValue);
    } else {
      assignValue_default(object, key, newValue);
    }
  }
  return object;
}
var copyObject_default = copyObject;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_overRest.js
var nativeMax = Math.max;
function overRest(func, start, transform) {
  start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
  return function() {
    var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply_default(func, this, otherArgs);
  };
}
var overRest_default = overRest;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_baseRest.js
function baseRest(func, start) {
  return setToString_default(overRest_default(func, start, identity_default), func + "");
}
var baseRest_default = baseRest;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/isLength.js
var MAX_SAFE_INTEGER2 = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
}
var isLength_default = isLength;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/isArrayLike.js
function isArrayLike(value) {
  return value != null && isLength_default(value.length) && !isFunction_default(value);
}
var isArrayLike_default = isArrayLike;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_isIterateeCall.js
function isIterateeCall(value, index, object) {
  if (!isObject_default(object)) {
    return false;
  }
  var type = typeof index;
  if (type == "number" ? isArrayLike_default(object) && isIndex_default(index, object.length) : type == "string" && index in object) {
    return eq_default(object[index], value);
  }
  return false;
}
var isIterateeCall_default = isIterateeCall;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_createAssigner.js
function createAssigner(assigner) {
  return baseRest_default(function(object, sources) {
    var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
    if (guard && isIterateeCall_default(sources[0], sources[1], guard)) {
      customizer = length < 3 ? void 0 : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}
var createAssigner_default = createAssigner;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_isPrototype.js
var objectProto5 = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto5;
  return value === proto;
}
var isPrototype_default = isPrototype;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_baseTimes.js
function baseTimes(n4, iteratee) {
  var index = -1, result = Array(n4);
  while (++index < n4) {
    result[index] = iteratee(index);
  }
  return result;
}
var baseTimes_default = baseTimes;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_baseIsArguments.js
var argsTag = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == argsTag;
}
var baseIsArguments_default = baseIsArguments;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/isArguments.js
var objectProto6 = Object.prototype;
var hasOwnProperty4 = objectProto6.hasOwnProperty;
var propertyIsEnumerable = objectProto6.propertyIsEnumerable;
var isArguments = baseIsArguments_default(/* @__PURE__ */ (function() {
  return arguments;
})()) ? baseIsArguments_default : function(value) {
  return isObjectLike_default(value) && hasOwnProperty4.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
};
var isArguments_default = isArguments;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/stubFalse.js
function stubFalse() {
  return false;
}
var stubFalse_default = stubFalse;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/isBuffer.js
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer2 = moduleExports ? root_default.Buffer : void 0;
var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse_default;
var isBuffer_default = isBuffer;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_baseIsTypedArray.js
var argsTag2 = "[object Arguments]";
var arrayTag = "[object Array]";
var boolTag = "[object Boolean]";
var dateTag = "[object Date]";
var errorTag = "[object Error]";
var funcTag2 = "[object Function]";
var mapTag = "[object Map]";
var numberTag = "[object Number]";
var objectTag = "[object Object]";
var regexpTag = "[object RegExp]";
var setTag = "[object Set]";
var stringTag = "[object String]";
var weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]";
var dataViewTag = "[object DataView]";
var float32Tag = "[object Float32Array]";
var float64Tag = "[object Float64Array]";
var int8Tag = "[object Int8Array]";
var int16Tag = "[object Int16Array]";
var int32Tag = "[object Int32Array]";
var uint8Tag = "[object Uint8Array]";
var uint8ClampedTag = "[object Uint8ClampedArray]";
var uint16Tag = "[object Uint16Array]";
var uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag2] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag2] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
function baseIsTypedArray(value) {
  return isObjectLike_default(value) && isLength_default(value.length) && !!typedArrayTags[baseGetTag_default(value)];
}
var baseIsTypedArray_default = baseIsTypedArray;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_baseUnary.js
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
var baseUnary_default = baseUnary;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_nodeUtil.js
var freeExports2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule2 = freeExports2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
var freeProcess = moduleExports2 && freeGlobal_default.process;
var nodeUtil = (function() {
  try {
    var types = freeModule2 && freeModule2.require && freeModule2.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e4) {
  }
})();
var nodeUtil_default = nodeUtil;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/isTypedArray.js
var nodeIsTypedArray = nodeUtil_default && nodeUtil_default.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary_default(nodeIsTypedArray) : baseIsTypedArray_default;
var isTypedArray_default = isTypedArray;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_arrayLikeKeys.js
var objectProto7 = Object.prototype;
var hasOwnProperty5 = objectProto7.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray_default(value), isArg = !isArr && isArguments_default(value), isBuff = !isArr && !isArg && isBuffer_default(value), isType = !isArr && !isArg && !isBuff && isTypedArray_default(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes_default(value.length, String) : [], length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty5.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex_default(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
var arrayLikeKeys_default = arrayLikeKeys;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_overArg.js
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var overArg_default = overArg;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_nativeKeys.js
var nativeKeys = overArg_default(Object.keys, Object);
var nativeKeys_default = nativeKeys;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_baseKeys.js
var objectProto8 = Object.prototype;
var hasOwnProperty6 = objectProto8.hasOwnProperty;
function baseKeys(object) {
  if (!isPrototype_default(object)) {
    return nativeKeys_default(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty6.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
var baseKeys_default = baseKeys;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/keys.js
function keys(object) {
  return isArrayLike_default(object) ? arrayLikeKeys_default(object) : baseKeys_default(object);
}
var keys_default = keys;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_nativeKeysIn.js
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}
var nativeKeysIn_default = nativeKeysIn;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_baseKeysIn.js
var objectProto9 = Object.prototype;
var hasOwnProperty7 = objectProto9.hasOwnProperty;
function baseKeysIn(object) {
  if (!isObject_default(object)) {
    return nativeKeysIn_default(object);
  }
  var isProto = isPrototype_default(object), result = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty7.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}
var baseKeysIn_default = baseKeysIn;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/keysIn.js
function keysIn(object) {
  return isArrayLike_default(object) ? arrayLikeKeys_default(object, true) : baseKeysIn_default(object);
}
var keysIn_default = keysIn;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_isKey.js
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
function isKey(value, object) {
  if (isArray_default(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol_default(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var isKey_default = isKey;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_nativeCreate.js
var nativeCreate = getNative_default(Object, "create");
var nativeCreate_default = nativeCreate;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_hashClear.js
function hashClear() {
  this.__data__ = nativeCreate_default ? nativeCreate_default(null) : {};
  this.size = 0;
}
var hashClear_default = hashClear;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_hashDelete.js
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var hashDelete_default = hashDelete;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_hashGet.js
var HASH_UNDEFINED = "__lodash_hash_undefined__";
var objectProto10 = Object.prototype;
var hasOwnProperty8 = objectProto10.hasOwnProperty;
function hashGet(key) {
  var data2 = this.__data__;
  if (nativeCreate_default) {
    var result = data2[key];
    return result === HASH_UNDEFINED ? void 0 : result;
  }
  return hasOwnProperty8.call(data2, key) ? data2[key] : void 0;
}
var hashGet_default = hashGet;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_hashHas.js
var objectProto11 = Object.prototype;
var hasOwnProperty9 = objectProto11.hasOwnProperty;
function hashHas(key) {
  var data2 = this.__data__;
  return nativeCreate_default ? data2[key] !== void 0 : hasOwnProperty9.call(data2, key);
}
var hashHas_default = hashHas;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_hashSet.js
var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data2 = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data2[key] = nativeCreate_default && value === void 0 ? HASH_UNDEFINED2 : value;
  return this;
}
var hashSet_default = hashSet;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_Hash.js
function Hash(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear_default;
Hash.prototype["delete"] = hashDelete_default;
Hash.prototype.get = hashGet_default;
Hash.prototype.has = hashHas_default;
Hash.prototype.set = hashSet_default;
var Hash_default = Hash;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_listCacheClear.js
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
var listCacheClear_default = listCacheClear;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_assocIndexOf.js
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq_default(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var assocIndexOf_default = assocIndexOf;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_listCacheDelete.js
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data2 = this.__data__, index = assocIndexOf_default(data2, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data2.length - 1;
  if (index == lastIndex) {
    data2.pop();
  } else {
    splice.call(data2, index, 1);
  }
  --this.size;
  return true;
}
var listCacheDelete_default = listCacheDelete;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_listCacheGet.js
function listCacheGet(key) {
  var data2 = this.__data__, index = assocIndexOf_default(data2, key);
  return index < 0 ? void 0 : data2[index][1];
}
var listCacheGet_default = listCacheGet;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_listCacheHas.js
function listCacheHas(key) {
  return assocIndexOf_default(this.__data__, key) > -1;
}
var listCacheHas_default = listCacheHas;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_listCacheSet.js
function listCacheSet(key, value) {
  var data2 = this.__data__, index = assocIndexOf_default(data2, key);
  if (index < 0) {
    ++this.size;
    data2.push([key, value]);
  } else {
    data2[index][1] = value;
  }
  return this;
}
var listCacheSet_default = listCacheSet;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_ListCache.js
function ListCache(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear_default;
ListCache.prototype["delete"] = listCacheDelete_default;
ListCache.prototype.get = listCacheGet_default;
ListCache.prototype.has = listCacheHas_default;
ListCache.prototype.set = listCacheSet_default;
var ListCache_default = ListCache;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_Map.js
var Map2 = getNative_default(root_default, "Map");
var Map_default = Map2;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_mapCacheClear.js
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash_default(),
    "map": new (Map_default || ListCache_default)(),
    "string": new Hash_default()
  };
}
var mapCacheClear_default = mapCacheClear;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_isKeyable.js
function isKeyable(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
var isKeyable_default = isKeyable;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_getMapData.js
function getMapData(map2, key) {
  var data2 = map2.__data__;
  return isKeyable_default(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
}
var getMapData_default = getMapData;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_mapCacheDelete.js
function mapCacheDelete(key) {
  var result = getMapData_default(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var mapCacheDelete_default = mapCacheDelete;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_mapCacheGet.js
function mapCacheGet(key) {
  return getMapData_default(this, key).get(key);
}
var mapCacheGet_default = mapCacheGet;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_mapCacheHas.js
function mapCacheHas(key) {
  return getMapData_default(this, key).has(key);
}
var mapCacheHas_default = mapCacheHas;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_mapCacheSet.js
function mapCacheSet(key, value) {
  var data2 = getMapData_default(this, key), size = data2.size;
  data2.set(key, value);
  this.size += data2.size == size ? 0 : 1;
  return this;
}
var mapCacheSet_default = mapCacheSet;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_MapCache.js
function MapCache(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear_default;
MapCache.prototype["delete"] = mapCacheDelete_default;
MapCache.prototype.get = mapCacheGet_default;
MapCache.prototype.has = mapCacheHas_default;
MapCache.prototype.set = mapCacheSet_default;
var MapCache_default = MapCache;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/memoize.js
var FUNC_ERROR_TEXT = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache5 = memoized.cache;
    if (cache5.has(key)) {
      return cache5.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache5.set(key, result) || cache5;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache_default)();
  return memoized;
}
memoize.Cache = MapCache_default;
var memoize_default = memoize;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_memoizeCapped.js
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result = memoize_default(func, function(key) {
    if (cache5.size === MAX_MEMOIZE_SIZE) {
      cache5.clear();
    }
    return key;
  });
  var cache5 = result.cache;
  return result;
}
var memoizeCapped_default = memoizeCapped;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_stringToPath.js
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped_default(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
  });
  return result;
});
var stringToPath_default = stringToPath;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/toString.js
function toString(value) {
  return value == null ? "" : baseToString_default(value);
}
var toString_default = toString;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_castPath.js
function castPath(value, object) {
  if (isArray_default(value)) {
    return value;
  }
  return isKey_default(value, object) ? [value] : stringToPath_default(toString_default(value));
}
var castPath_default = castPath;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_toKey.js
var INFINITY3 = 1 / 0;
function toKey(value) {
  if (typeof value == "string" || isSymbol_default(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY3 ? "-0" : result;
}
var toKey_default = toKey;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_baseGet.js
function baseGet(object, path3) {
  path3 = castPath_default(path3, object);
  var index = 0, length = path3.length;
  while (object != null && index < length) {
    object = object[toKey_default(path3[index++])];
  }
  return index && index == length ? object : void 0;
}
var baseGet_default = baseGet;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/get.js
function get(object, path3, defaultValue) {
  var result = object == null ? void 0 : baseGet_default(object, path3);
  return result === void 0 ? defaultValue : result;
}
var get_default = get;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_arrayPush.js
function arrayPush(array, values) {
  var index = -1, length = values.length, offset = array.length;
  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}
var arrayPush_default = arrayPush;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_getPrototype.js
var getPrototype = overArg_default(Object.getPrototypeOf, Object);
var getPrototype_default = getPrototype;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/isPlainObject.js
var objectTag2 = "[object Object]";
var funcProto3 = Function.prototype;
var objectProto12 = Object.prototype;
var funcToString3 = funcProto3.toString;
var hasOwnProperty10 = objectProto12.hasOwnProperty;
var objectCtorString = funcToString3.call(Object);
function isPlainObject(value) {
  if (!isObjectLike_default(value) || baseGetTag_default(value) != objectTag2) {
    return false;
  }
  var proto = getPrototype_default(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty10.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString3.call(Ctor) == objectCtorString;
}
var isPlainObject_default = isPlainObject;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_baseSlice.js
function baseSlice(array, start, end) {
  var index = -1, length = array.length;
  if (start < 0) {
    start = -start > length ? 0 : length + start;
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : end - start >>> 0;
  start >>>= 0;
  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}
var baseSlice_default = baseSlice;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/chunk.js
var nativeCeil = Math.ceil;
var nativeMax2 = Math.max;
function chunk(array, size, guard) {
  if (guard ? isIterateeCall_default(array, size, guard) : size === void 0) {
    size = 1;
  } else {
    size = nativeMax2(toInteger_default(size), 0);
  }
  var length = array == null ? 0 : array.length;
  if (!length || size < 1) {
    return [];
  }
  var index = 0, resIndex = 0, result = Array(nativeCeil(length / size));
  while (index < length) {
    result[resIndex++] = baseSlice_default(array, index, index += size);
  }
  return result;
}
var chunk_default = chunk;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_stackClear.js
function stackClear() {
  this.__data__ = new ListCache_default();
  this.size = 0;
}
var stackClear_default = stackClear;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_stackDelete.js
function stackDelete(key) {
  var data2 = this.__data__, result = data2["delete"](key);
  this.size = data2.size;
  return result;
}
var stackDelete_default = stackDelete;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_stackGet.js
function stackGet(key) {
  return this.__data__.get(key);
}
var stackGet_default = stackGet;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_stackHas.js
function stackHas(key) {
  return this.__data__.has(key);
}
var stackHas_default = stackHas;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_stackSet.js
var LARGE_ARRAY_SIZE = 200;
function stackSet(key, value) {
  var data2 = this.__data__;
  if (data2 instanceof ListCache_default) {
    var pairs = data2.__data__;
    if (!Map_default || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data2.size;
      return this;
    }
    data2 = this.__data__ = new MapCache_default(pairs);
  }
  data2.set(key, value);
  this.size = data2.size;
  return this;
}
var stackSet_default = stackSet;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_Stack.js
function Stack(entries) {
  var data2 = this.__data__ = new ListCache_default(entries);
  this.size = data2.size;
}
Stack.prototype.clear = stackClear_default;
Stack.prototype["delete"] = stackDelete_default;
Stack.prototype.get = stackGet_default;
Stack.prototype.has = stackHas_default;
Stack.prototype.set = stackSet_default;
var Stack_default = Stack;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_baseAssign.js
function baseAssign(object, source) {
  return object && copyObject_default(source, keys_default(source), object);
}
var baseAssign_default = baseAssign;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_baseAssignIn.js
function baseAssignIn(object, source) {
  return object && copyObject_default(source, keysIn_default(source), object);
}
var baseAssignIn_default = baseAssignIn;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_cloneBuffer.js
var freeExports3 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule3 = freeExports3 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports3 = freeModule3 && freeModule3.exports === freeExports3;
var Buffer3 = moduleExports3 ? root_default.Buffer : void 0;
var allocUnsafe = Buffer3 ? Buffer3.allocUnsafe : void 0;
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result);
  return result;
}
var cloneBuffer_default = cloneBuffer;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_arrayFilter.js
function arrayFilter(array, predicate) {
  var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
var arrayFilter_default = arrayFilter;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/stubArray.js
function stubArray() {
  return [];
}
var stubArray_default = stubArray;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_getSymbols.js
var objectProto13 = Object.prototype;
var propertyIsEnumerable2 = objectProto13.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols ? stubArray_default : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter_default(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable2.call(object, symbol);
  });
};
var getSymbols_default = getSymbols;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_copySymbols.js
function copySymbols(source, object) {
  return copyObject_default(source, getSymbols_default(source), object);
}
var copySymbols_default = copySymbols;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_getSymbolsIn.js
var nativeGetSymbols2 = Object.getOwnPropertySymbols;
var getSymbolsIn = !nativeGetSymbols2 ? stubArray_default : function(object) {
  var result = [];
  while (object) {
    arrayPush_default(result, getSymbols_default(object));
    object = getPrototype_default(object);
  }
  return result;
};
var getSymbolsIn_default = getSymbolsIn;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_copySymbolsIn.js
function copySymbolsIn(source, object) {
  return copyObject_default(source, getSymbolsIn_default(source), object);
}
var copySymbolsIn_default = copySymbolsIn;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_baseGetAllKeys.js
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray_default(object) ? result : arrayPush_default(result, symbolsFunc(object));
}
var baseGetAllKeys_default = baseGetAllKeys;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_getAllKeys.js
function getAllKeys(object) {
  return baseGetAllKeys_default(object, keys_default, getSymbols_default);
}
var getAllKeys_default = getAllKeys;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_getAllKeysIn.js
function getAllKeysIn(object) {
  return baseGetAllKeys_default(object, keysIn_default, getSymbolsIn_default);
}
var getAllKeysIn_default = getAllKeysIn;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_DataView.js
var DataView2 = getNative_default(root_default, "DataView");
var DataView_default = DataView2;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_Promise.js
var Promise2 = getNative_default(root_default, "Promise");
var Promise_default = Promise2;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_Set.js
var Set2 = getNative_default(root_default, "Set");
var Set_default = Set2;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_getTag.js
var mapTag2 = "[object Map]";
var objectTag3 = "[object Object]";
var promiseTag = "[object Promise]";
var setTag2 = "[object Set]";
var weakMapTag2 = "[object WeakMap]";
var dataViewTag2 = "[object DataView]";
var dataViewCtorString = toSource_default(DataView_default);
var mapCtorString = toSource_default(Map_default);
var promiseCtorString = toSource_default(Promise_default);
var setCtorString = toSource_default(Set_default);
var weakMapCtorString = toSource_default(WeakMap_default);
var getTag = baseGetTag_default;
if (DataView_default && getTag(new DataView_default(new ArrayBuffer(1))) != dataViewTag2 || Map_default && getTag(new Map_default()) != mapTag2 || Promise_default && getTag(Promise_default.resolve()) != promiseTag || Set_default && getTag(new Set_default()) != setTag2 || WeakMap_default && getTag(new WeakMap_default()) != weakMapTag2) {
  getTag = function(value) {
    var result = baseGetTag_default(value), Ctor = result == objectTag3 ? value.constructor : void 0, ctorString = Ctor ? toSource_default(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag2;
        case mapCtorString:
          return mapTag2;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag2;
        case weakMapCtorString:
          return weakMapTag2;
      }
    }
    return result;
  };
}
var getTag_default = getTag;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_initCloneArray.js
var objectProto14 = Object.prototype;
var hasOwnProperty11 = objectProto14.hasOwnProperty;
function initCloneArray(array) {
  var length = array.length, result = new array.constructor(length);
  if (length && typeof array[0] == "string" && hasOwnProperty11.call(array, "index")) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}
var initCloneArray_default = initCloneArray;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_Uint8Array.js
var Uint8Array2 = root_default.Uint8Array;
var Uint8Array_default = Uint8Array2;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_cloneArrayBuffer.js
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array_default(result).set(new Uint8Array_default(arrayBuffer));
  return result;
}
var cloneArrayBuffer_default = cloneArrayBuffer;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_cloneDataView.js
function cloneDataView(dataView3, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer_default(dataView3.buffer) : dataView3.buffer;
  return new dataView3.constructor(buffer, dataView3.byteOffset, dataView3.byteLength);
}
var cloneDataView_default = cloneDataView;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_cloneRegExp.js
var reFlags = /\w*$/;
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}
var cloneRegExp_default = cloneRegExp;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_cloneSymbol.js
var symbolProto2 = Symbol_default ? Symbol_default.prototype : void 0;
var symbolValueOf = symbolProto2 ? symbolProto2.valueOf : void 0;
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}
var cloneSymbol_default = cloneSymbol;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_cloneTypedArray.js
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer_default(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var cloneTypedArray_default = cloneTypedArray;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_initCloneByTag.js
var boolTag2 = "[object Boolean]";
var dateTag2 = "[object Date]";
var mapTag3 = "[object Map]";
var numberTag2 = "[object Number]";
var regexpTag2 = "[object RegExp]";
var setTag3 = "[object Set]";
var stringTag2 = "[object String]";
var symbolTag2 = "[object Symbol]";
var arrayBufferTag2 = "[object ArrayBuffer]";
var dataViewTag3 = "[object DataView]";
var float32Tag2 = "[object Float32Array]";
var float64Tag2 = "[object Float64Array]";
var int8Tag2 = "[object Int8Array]";
var int16Tag2 = "[object Int16Array]";
var int32Tag2 = "[object Int32Array]";
var uint8Tag2 = "[object Uint8Array]";
var uint8ClampedTag2 = "[object Uint8ClampedArray]";
var uint16Tag2 = "[object Uint16Array]";
var uint32Tag2 = "[object Uint32Array]";
function initCloneByTag(object, tag2, isDeep) {
  var Ctor = object.constructor;
  switch (tag2) {
    case arrayBufferTag2:
      return cloneArrayBuffer_default(object);
    case boolTag2:
    case dateTag2:
      return new Ctor(+object);
    case dataViewTag3:
      return cloneDataView_default(object, isDeep);
    case float32Tag2:
    case float64Tag2:
    case int8Tag2:
    case int16Tag2:
    case int32Tag2:
    case uint8Tag2:
    case uint8ClampedTag2:
    case uint16Tag2:
    case uint32Tag2:
      return cloneTypedArray_default(object, isDeep);
    case mapTag3:
      return new Ctor();
    case numberTag2:
    case stringTag2:
      return new Ctor(object);
    case regexpTag2:
      return cloneRegExp_default(object);
    case setTag3:
      return new Ctor();
    case symbolTag2:
      return cloneSymbol_default(object);
  }
}
var initCloneByTag_default = initCloneByTag;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_initCloneObject.js
function initCloneObject(object) {
  return typeof object.constructor == "function" && !isPrototype_default(object) ? baseCreate_default(getPrototype_default(object)) : {};
}
var initCloneObject_default = initCloneObject;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_baseIsMap.js
var mapTag4 = "[object Map]";
function baseIsMap(value) {
  return isObjectLike_default(value) && getTag_default(value) == mapTag4;
}
var baseIsMap_default = baseIsMap;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/isMap.js
var nodeIsMap = nodeUtil_default && nodeUtil_default.isMap;
var isMap = nodeIsMap ? baseUnary_default(nodeIsMap) : baseIsMap_default;
var isMap_default = isMap;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_baseIsSet.js
var setTag4 = "[object Set]";
function baseIsSet(value) {
  return isObjectLike_default(value) && getTag_default(value) == setTag4;
}
var baseIsSet_default = baseIsSet;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/isSet.js
var nodeIsSet = nodeUtil_default && nodeUtil_default.isSet;
var isSet = nodeIsSet ? baseUnary_default(nodeIsSet) : baseIsSet_default;
var isSet_default = isSet;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_baseClone.js
var CLONE_DEEP_FLAG = 1;
var CLONE_FLAT_FLAG = 2;
var CLONE_SYMBOLS_FLAG = 4;
var argsTag3 = "[object Arguments]";
var arrayTag2 = "[object Array]";
var boolTag3 = "[object Boolean]";
var dateTag3 = "[object Date]";
var errorTag2 = "[object Error]";
var funcTag3 = "[object Function]";
var genTag2 = "[object GeneratorFunction]";
var mapTag5 = "[object Map]";
var numberTag3 = "[object Number]";
var objectTag4 = "[object Object]";
var regexpTag3 = "[object RegExp]";
var setTag5 = "[object Set]";
var stringTag3 = "[object String]";
var symbolTag3 = "[object Symbol]";
var weakMapTag3 = "[object WeakMap]";
var arrayBufferTag3 = "[object ArrayBuffer]";
var dataViewTag4 = "[object DataView]";
var float32Tag3 = "[object Float32Array]";
var float64Tag3 = "[object Float64Array]";
var int8Tag3 = "[object Int8Array]";
var int16Tag3 = "[object Int16Array]";
var int32Tag3 = "[object Int32Array]";
var uint8Tag3 = "[object Uint8Array]";
var uint8ClampedTag3 = "[object Uint8ClampedArray]";
var uint16Tag3 = "[object Uint16Array]";
var uint32Tag3 = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag3] = cloneableTags[arrayTag2] = cloneableTags[arrayBufferTag3] = cloneableTags[dataViewTag4] = cloneableTags[boolTag3] = cloneableTags[dateTag3] = cloneableTags[float32Tag3] = cloneableTags[float64Tag3] = cloneableTags[int8Tag3] = cloneableTags[int16Tag3] = cloneableTags[int32Tag3] = cloneableTags[mapTag5] = cloneableTags[numberTag3] = cloneableTags[objectTag4] = cloneableTags[regexpTag3] = cloneableTags[setTag5] = cloneableTags[stringTag3] = cloneableTags[symbolTag3] = cloneableTags[uint8Tag3] = cloneableTags[uint8ClampedTag3] = cloneableTags[uint16Tag3] = cloneableTags[uint32Tag3] = true;
cloneableTags[errorTag2] = cloneableTags[funcTag3] = cloneableTags[weakMapTag3] = false;
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== void 0) {
    return result;
  }
  if (!isObject_default(value)) {
    return value;
  }
  var isArr = isArray_default(value);
  if (isArr) {
    result = initCloneArray_default(value);
    if (!isDeep) {
      return copyArray_default(value, result);
    }
  } else {
    var tag2 = getTag_default(value), isFunc = tag2 == funcTag3 || tag2 == genTag2;
    if (isBuffer_default(value)) {
      return cloneBuffer_default(value, isDeep);
    }
    if (tag2 == objectTag4 || tag2 == argsTag3 || isFunc && !object) {
      result = isFlat || isFunc ? {} : initCloneObject_default(value);
      if (!isDeep) {
        return isFlat ? copySymbolsIn_default(value, baseAssignIn_default(result, value)) : copySymbols_default(value, baseAssign_default(result, value));
      }
    } else {
      if (!cloneableTags[tag2]) {
        return object ? value : {};
      }
      result = initCloneByTag_default(value, tag2, isDeep);
    }
  }
  stack || (stack = new Stack_default());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);
  if (isSet_default(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap_default(value)) {
    value.forEach(function(subValue, key2) {
      result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn_default : getAllKeys_default : isFlat ? keysIn_default : keys_default;
  var props = isArr ? void 0 : keysFunc(value);
  arrayEach_default(props || value, function(subValue, key2) {
    if (props) {
      key2 = subValue;
      subValue = value[key2];
    }
    assignValue_default(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
  });
  return result;
}
var baseClone_default = baseClone;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/cloneDeep.js
var CLONE_DEEP_FLAG2 = 1;
var CLONE_SYMBOLS_FLAG2 = 4;
function cloneDeep(value) {
  return baseClone_default(value, CLONE_DEEP_FLAG2 | CLONE_SYMBOLS_FLAG2);
}
var cloneDeep_default = cloneDeep;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_setCacheAdd.js
var HASH_UNDEFINED3 = "__lodash_hash_undefined__";
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED3);
  return this;
}
var setCacheAdd_default = setCacheAdd;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_setCacheHas.js
function setCacheHas(value) {
  return this.__data__.has(value);
}
var setCacheHas_default = setCacheHas;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_SetCache.js
function SetCache(values) {
  var index = -1, length = values == null ? 0 : values.length;
  this.__data__ = new MapCache_default();
  while (++index < length) {
    this.add(values[index]);
  }
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd_default;
SetCache.prototype.has = setCacheHas_default;
var SetCache_default = SetCache;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_cacheHas.js
function cacheHas(cache5, key) {
  return cache5.has(key);
}
var cacheHas_default = cacheHas;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_setToArray.js
function setToArray(set2) {
  var index = -1, result = Array(set2.size);
  set2.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}
var setToArray_default = setToArray;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_createBaseFor.js
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var createBaseFor_default = createBaseFor;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_baseFor.js
var baseFor = createBaseFor_default();
var baseFor_default = baseFor;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_baseForOwn.js
function baseForOwn(object, iteratee) {
  return object && baseFor_default(object, iteratee, keys_default);
}
var baseForOwn_default = baseForOwn;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_assignMergeValue.js
function assignMergeValue(object, key, value) {
  if (value !== void 0 && !eq_default(object[key], value) || value === void 0 && !(key in object)) {
    baseAssignValue_default(object, key, value);
  }
}
var assignMergeValue_default = assignMergeValue;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/isArrayLikeObject.js
function isArrayLikeObject(value) {
  return isObjectLike_default(value) && isArrayLike_default(value);
}
var isArrayLikeObject_default = isArrayLikeObject;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_safeGet.js
function safeGet(object, key) {
  if (key === "constructor" && typeof object[key] === "function") {
    return;
  }
  if (key == "__proto__") {
    return;
  }
  return object[key];
}
var safeGet_default = safeGet;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/toPlainObject.js
function toPlainObject(value) {
  return copyObject_default(value, keysIn_default(value));
}
var toPlainObject_default = toPlainObject;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_baseMergeDeep.js
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet_default(object, key), srcValue = safeGet_default(source, key), stacked = stack.get(srcValue);
  if (stacked) {
    assignMergeValue_default(object, key, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
  var isCommon = newValue === void 0;
  if (isCommon) {
    var isArr = isArray_default(srcValue), isBuff = !isArr && isBuffer_default(srcValue), isTyped = !isArr && !isBuff && isTypedArray_default(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray_default(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject_default(objValue)) {
        newValue = copyArray_default(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer_default(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray_default(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject_default(srcValue) || isArguments_default(srcValue)) {
      newValue = objValue;
      if (isArguments_default(objValue)) {
        newValue = toPlainObject_default(objValue);
      } else if (!isObject_default(objValue) || isFunction_default(objValue)) {
        newValue = initCloneObject_default(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack["delete"](srcValue);
  }
  assignMergeValue_default(object, key, newValue);
}
var baseMergeDeep_default = baseMergeDeep;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_baseMerge.js
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor_default(source, function(srcValue, key) {
    stack || (stack = new Stack_default());
    if (isObject_default(srcValue)) {
      baseMergeDeep_default(object, source, key, srcIndex, baseMerge, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet_default(object, key), srcValue, key + "", object, source, stack) : void 0;
      if (newValue === void 0) {
        newValue = srcValue;
      }
      assignMergeValue_default(object, key, newValue);
    }
  }, keysIn_default);
}
var baseMerge_default = baseMerge;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_arrayIncludesWith.js
function arrayIncludesWith(array, value, comparator) {
  var index = -1, length = array == null ? 0 : array.length;
  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}
var arrayIncludesWith_default = arrayIncludesWith;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/isString.js
var stringTag4 = "[object String]";
function isString(value) {
  return typeof value == "string" || !isArray_default(value) && isObjectLike_default(value) && baseGetTag_default(value) == stringTag4;
}
var isString_default = isString;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_baseInverter.js
function baseInverter(object, setter, iteratee, accumulator) {
  baseForOwn_default(object, function(value, key, object2) {
    setter(accumulator, iteratee(value), key, object2);
  });
  return accumulator;
}
var baseInverter_default = baseInverter;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_createInverter.js
function createInverter(setter, toIteratee) {
  return function(object, iteratee) {
    return baseInverter_default(object, setter, toIteratee(iteratee), {});
  };
}
var createInverter_default = createInverter;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/invert.js
var objectProto15 = Object.prototype;
var nativeObjectToString3 = objectProto15.toString;
var invert = createInverter_default(function(result, value, key) {
  if (value != null && typeof value.toString != "function") {
    value = nativeObjectToString3.call(value);
  }
  result[value] = key;
}, constant_default(identity_default));
var invert_default = invert;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/isEmpty.js
var mapTag6 = "[object Map]";
var setTag6 = "[object Set]";
var objectProto16 = Object.prototype;
var hasOwnProperty12 = objectProto16.hasOwnProperty;
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if (isArrayLike_default(value) && (isArray_default(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer_default(value) || isTypedArray_default(value) || isArguments_default(value))) {
    return !value.length;
  }
  var tag2 = getTag_default(value);
  if (tag2 == mapTag6 || tag2 == setTag6) {
    return !value.size;
  }
  if (isPrototype_default(value)) {
    return !baseKeys_default(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty12.call(value, key)) {
      return false;
    }
  }
  return true;
}
var isEmpty_default = isEmpty;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/merge.js
var merge = createAssigner_default(function(object, source, srcIndex) {
  baseMerge_default(object, source, srcIndex);
});
var merge_default = merge;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_baseSet.js
function baseSet(object, path3, value, customizer) {
  if (!isObject_default(object)) {
    return object;
  }
  path3 = castPath_default(path3, object);
  var index = -1, length = path3.length, lastIndex = length - 1, nested = object;
  while (nested != null && ++index < length) {
    var key = toKey_default(path3[index]), newValue = value;
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      return object;
    }
    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : void 0;
      if (newValue === void 0) {
        newValue = isObject_default(objValue) ? objValue : isIndex_default(path3[index + 1]) ? [] : {};
      }
    }
    assignValue_default(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}
var baseSet_default = baseSet;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/set.js
function set(object, path3, value) {
  return object == null ? object : baseSet_default(object, path3, value);
}
var set_default = set;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_createSet.js
var INFINITY4 = 1 / 0;
var createSet = !(Set_default && 1 / setToArray_default(new Set_default([, -0]))[1] == INFINITY4) ? noop_default : function(values) {
  return new Set_default(values);
};
var createSet_default = createSet;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/_baseUniq.js
var LARGE_ARRAY_SIZE2 = 200;
function baseUniq(array, iteratee, comparator) {
  var index = -1, includes = arrayIncludes_default, length = array.length, isCommon = true, result = [], seen = result;
  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith_default;
  } else if (length >= LARGE_ARRAY_SIZE2) {
    var set2 = iteratee ? null : createSet_default(array);
    if (set2) {
      return setToArray_default(set2);
    }
    isCommon = false;
    includes = cacheHas_default;
    seen = new SetCache_default();
  } else {
    seen = iteratee ? [] : result;
  }
  outer:
    while (++index < length) {
      var value = array[index], computed = iteratee ? iteratee(value) : value;
      value = comparator || value !== 0 ? value : 0;
      if (isCommon && computed === computed) {
        var seenIndex = seen.length;
        while (seenIndex--) {
          if (seen[seenIndex] === computed) {
            continue outer;
          }
        }
        if (iteratee) {
          seen.push(computed);
        }
        result.push(value);
      } else if (!includes(seen, computed, comparator)) {
        if (seen !== result) {
          seen.push(computed);
        }
        result.push(value);
      }
    }
  return result;
}
var baseUniq_default = baseUniq;

// node_modules/.pnpm/lodash-es@4.17.22/node_modules/lodash-es/uniq.js
function uniq(array) {
  return array && array.length ? baseUniq_default(array) : [];
}
var uniq_default = uniq;

// node_modules/.pnpm/s3db.js@19.3.17_@hono+node-server@1.19.9_hono@4.11.4__express@5.2.1_hono@4.11.4_jose@6.1.3_zod@4.3.5/node_modules/s3db.js/dist/s3db-lite.es.js
var import_client_s3 = __toESM(require_dist_cjs72(), 1);
var import_crypto = __toESM(require("crypto"), 1);
var import_os = __toESM(require("os"), 1);
var import_promises3 = require("timers/promises");
init_nanoid();
var import_promises4 = require("fs/promises");
var import_stream = require("stream");
var import_fs = require("fs");
var import_zlib = __toESM(require("zlib"), 1);
var import_json_stable_stringify = __toESM(require_json_stable_stringify(), 1);
var FastestValidatorModule = __toESM(require_fastest_validator(), 1);
var import_web = require("node:stream/web");
var import_pino = __toESM(require_pino(), 1);
function tryFn$1(fnOrPromise) {
  if (fnOrPromise == null) {
    const err = new Error("fnOrPromise cannot be null or undefined");
    err.stack = new Error().stack;
    return [false, err, void 0];
  }
  if (typeof fnOrPromise === "function") {
    try {
      const result = fnOrPromise();
      if (result == null) {
        return [true, null, result];
      }
      if (typeof result.then === "function") {
        return result.then((data2) => [true, null, data2]).catch((error2) => {
          if (error2 instanceof Error && Object.isExtensible(error2)) {
            const desc = Object.getOwnPropertyDescriptor(error2, "stack");
            if (desc?.writable && desc.configurable && Object.prototype.hasOwnProperty.call(error2, "stack")) {
              try {
                error2.stack = new Error().stack;
              } catch {
              }
            }
          }
          return [false, error2 instanceof Error ? error2 : new Error(String(error2)), void 0];
        });
      }
      return [true, null, result];
    } catch (error2) {
      if (error2 instanceof Error && Object.isExtensible(error2)) {
        const desc = Object.getOwnPropertyDescriptor(error2, "stack");
        if (desc?.writable && desc.configurable && Object.prototype.hasOwnProperty.call(error2, "stack")) {
          try {
            error2.stack = new Error().stack;
          } catch {
          }
        }
      }
      return [false, error2 instanceof Error ? error2 : new Error(String(error2)), void 0];
    }
  }
  if (typeof fnOrPromise.then === "function") {
    return Promise.resolve(fnOrPromise).then((data2) => [true, null, data2]).catch((error2) => {
      if (error2 instanceof Error && Object.isExtensible(error2)) {
        const desc = Object.getOwnPropertyDescriptor(error2, "stack");
        if (desc?.writable && desc.configurable && Object.prototype.hasOwnProperty.call(error2, "stack")) {
          try {
            error2.stack = new Error().stack;
          } catch {
          }
        }
      }
      return [false, error2 instanceof Error ? error2 : new Error(String(error2)), void 0];
    });
  }
  return [true, null, fnOrPromise];
}
function tryFnSync(fn) {
  try {
    const result = fn();
    return [true, null, result];
  } catch (err) {
    return [false, err instanceof Error ? err : new Error(String(err)), void 0];
  }
}
var ReckerError = class extends Error {
  request;
  response;
  suggestions;
  retriable;
  constructor(message, request2, response2, suggestions = [], retriable = false) {
    super(message);
    this.name = "ReckerError";
    this.request = request2;
    this.response = response2;
    this.suggestions = suggestions;
    this.retriable = retriable;
  }
};
var HttpError = class extends ReckerError {
  status;
  statusText;
  constructor(response2, request2) {
    super(`Request failed with status code ${response2.status} ${response2.statusText}`, request2, response2, ["Check the upstream service response body for error details.", "Inspect request headers/body to ensure they match the API contract.", "Retry if this is a transient 5xx/429 error."], isRetryableStatus(response2.status));
    this.name = "HttpError";
    this.status = response2.status;
    this.statusText = response2.statusText;
  }
};
var TimeoutError = class extends ReckerError {
  phase;
  timeout;
  elapsed;
  event;
  constructor(request2, options) {
    const phase = options?.phase || "request";
    const timeout = options?.timeout;
    const elapsed = options?.elapsed;
    const phaseMessages = {
      lookup: "DNS lookup timed out",
      connect: "TCP connection timed out",
      secureConnect: "TLS handshake timed out",
      socket: "Socket assignment timed out (connection pool exhausted)",
      send: "Request body upload timed out",
      response: "Waiting for response timed out (TTFB)",
      request: "Request timed out (total time exceeded)",
      "webrtc-connect": "WebRTC peer connection timed out"
    };
    let message = phaseMessages[phase];
    if (timeout !== void 0) {
      message += ` after ${timeout}ms`;
    }
    if (elapsed !== void 0 && elapsed !== timeout) {
      message += ` (elapsed: ${Math.round(elapsed)}ms)`;
    }
    const suggestions = [
      "Verify network connectivity and DNS resolution for the target host.",
      "Increase the specific timeout phase or optimize the upstream response time.",
      "Reduce concurrent requests if the connection pool is exhausted."
    ];
    super(message, request2, void 0, suggestions, true);
    this.name = "TimeoutError";
    this.phase = phase;
    this.timeout = timeout ?? 0;
    this.elapsed = elapsed;
    this.event = `timeout:${phase}`;
  }
};
var NetworkError = class extends ReckerError {
  code;
  constructor(message, code, request2) {
    const suggestions = [
      "Confirm the host and port are reachable from this environment.",
      "Check proxy/VPN/firewall settings that might block the request.",
      "Retry the request or switch transport if this is transient."
    ];
    super(message, request2, void 0, suggestions, true);
    this.name = "NetworkError";
    this.code = code;
  }
};
var Http2Error = class extends ReckerError {
  errorCode;
  level;
  streamId;
  suggestFallback;
  constructor(message, errorCode, options = {}) {
    const retriable = isRetriableHttp2Error(errorCode);
    const suggestFallback = shouldFallbackToHttp1(errorCode);
    const suggestions = getHttp2ErrorSuggestions(errorCode, suggestFallback);
    super(message, options.request, void 0, suggestions, retriable);
    this.name = "Http2Error";
    this.errorCode = errorCode;
    this.level = options.level ?? "stream";
    this.streamId = options.streamId;
    this.suggestFallback = suggestFallback;
  }
};
function isRetriableHttp2Error(errorCode) {
  const retriableCodes = [
    "NO_ERROR",
    "INTERNAL_ERROR",
    "REFUSED_STREAM",
    "ENHANCE_YOUR_CALM",
    "CANCEL"
  ];
  return retriableCodes.includes(errorCode);
}
function shouldFallbackToHttp1(errorCode) {
  const fallbackCodes = [
    "HTTP_1_1_REQUIRED",
    "INADEQUATE_SECURITY",
    "PROTOCOL_ERROR",
    "COMPRESSION_ERROR"
  ];
  return fallbackCodes.includes(errorCode);
}
function getHttp2ErrorSuggestions(errorCode, suggestFallback) {
  const suggestions = [];
  switch (errorCode) {
    case "ENHANCE_YOUR_CALM":
      suggestions.push("Server is rate limiting. Implement exponential backoff.");
      suggestions.push("Reduce concurrent requests to this origin.");
      break;
    case "REFUSED_STREAM":
      suggestions.push("Server is overloaded. Retry with backoff.");
      suggestions.push("Consider reducing max concurrent streams.");
      break;
    case "FLOW_CONTROL_ERROR":
      suggestions.push("Reduce initial window size in HTTP/2 settings.");
      suggestions.push("Server may not handle large uploads well over HTTP/2.");
      break;
    case "HTTP_1_1_REQUIRED":
      suggestions.push("Server requires HTTP/1.1 for this request.");
      suggestions.push("Disable HTTP/2 for this origin.");
      break;
    case "INADEQUATE_SECURITY":
      suggestions.push("Upgrade TLS configuration or use HTTP/1.1.");
      break;
    case "GOAWAY":
      suggestions.push("Server is shutting down connection. Retry is safe.");
      break;
    default:
      suggestions.push("Check server logs for details.");
  }
  if (suggestFallback) {
    suggestions.push("Consider disabling HTTP/2 for this origin with { http2: false }.");
  }
  return suggestions;
}
function parseHttp2Error(error2) {
  const message = error2.message || "";
  const code = error2.code || "";
  if (message.includes("GOAWAY") || code.includes("GOAWAY")) {
    return new Http2Error("Server sent GOAWAY frame, closing connection", "NO_ERROR", { level: "session" });
  }
  if (message.includes("RST_STREAM") || code.includes("RST_STREAM")) {
    const match = message.match(/RST_STREAM.*code[:\s]+(\w+)/i);
    const errorCode = match?.[1] || "CANCEL";
    return new Http2Error(`Stream was reset: ${errorCode}`, errorCode, { level: "stream" });
  }
  const h2ErrorCodes = [
    "PROTOCOL_ERROR",
    "INTERNAL_ERROR",
    "FLOW_CONTROL_ERROR",
    "SETTINGS_TIMEOUT",
    "STREAM_CLOSED",
    "FRAME_SIZE_ERROR",
    "REFUSED_STREAM",
    "CANCEL",
    "COMPRESSION_ERROR",
    "CONNECT_ERROR",
    "ENHANCE_YOUR_CALM",
    "INADEQUATE_SECURITY",
    "HTTP_1_1_REQUIRED"
  ];
  for (const errorCode of h2ErrorCodes) {
    if (message.includes(errorCode) || code.includes(errorCode)) {
      return new Http2Error(`HTTP/2 error: ${errorCode}`, errorCode, { level: message.includes("session") ? "session" : "stream" });
    }
  }
  if (code.startsWith("ERR_HTTP2_")) {
    const errorCode = code.replace("ERR_HTTP2_", "");
    return new Http2Error(message || `HTTP/2 error: ${errorCode}`, errorCode, { level: "session" });
  }
  return null;
}
var MaxSizeExceededError = class extends ReckerError {
  maxSize;
  actualSize;
  constructor(maxSize, actualSize, request2) {
    const sizeInfo = actualSize ? `${actualSize} bytes (max: ${maxSize} bytes)` : `${maxSize} bytes`;
    super(`Response size exceeded maximum allowed: ${sizeInfo}`, request2, void 0, [
      "Increase maxResponseSize if the larger payload is expected.",
      "Add pagination/streaming to reduce payload size.",
      "Ensure the upstream is not returning unexpected large responses."
    ], false);
    this.name = "MaxSizeExceededError";
    this.maxSize = maxSize;
    this.actualSize = actualSize;
  }
};
function isRetryableStatus(status) {
  return [408, 425, 429, 500, 502, 503, 504].includes(status);
}
var ConnectionError = class extends ReckerError {
  host;
  port;
  code;
  constructor(message, options) {
    super(message, options?.request, void 0, [
      "Verify the host and port are correct and the service is running.",
      "Check network connectivity and firewall rules.",
      "Ensure the service is accepting connections on the specified port."
    ], options?.retriable ?? true);
    this.name = "ConnectionError";
    this.host = options?.host;
    this.port = options?.port;
    this.code = options?.code;
  }
};
var StateError = class extends ReckerError {
  expectedState;
  actualState;
  constructor(message, options) {
    super(message, options?.request, void 0, [
      "Ensure the required setup/initialization step was performed.",
      "Check that operations are called in the correct order.",
      "Verify the connection or resource is still valid."
    ], false);
    this.name = "StateError";
    this.expectedState = options?.expectedState;
    this.actualState = options?.actualState;
  }
};
var ValidationError$1 = class ValidationError extends ReckerError {
  field;
  value;
  constructor(message, options) {
    super(message, options?.request, void 0, [
      "Check the input format and constraints.",
      "Refer to the API documentation for valid values.",
      "Ensure required fields are provided."
    ], false);
    this.name = "ValidationError";
    this.field = options?.field;
    this.value = options?.value;
  }
};
var ConfigurationError = class extends ReckerError {
  configKey;
  constructor(message, options) {
    super(message, options?.request, void 0, [
      "Check the configuration file or environment variables.",
      "Ensure all required configuration keys are set.",
      "Verify the configuration values are in the correct format."
    ], false);
    this.name = "ConfigurationError";
    this.configKey = options?.configKey;
  }
};
var UnsupportedError = class extends ReckerError {
  feature;
  constructor(message, options) {
    super(message, options?.request, void 0, [
      "Check if this feature is supported in the current context.",
      "Refer to the documentation for supported operations.",
      "Consider using an alternative approach."
    ], false);
    this.name = "UnsupportedError";
    this.feature = options?.feature;
  }
};
var StreamError$1 = class StreamError extends ReckerError {
  streamType;
  constructor(message, options) {
    super(message, options?.request, void 0, [
      "Check if the stream was prematurely closed.",
      "Verify the data source is still available.",
      "Ensure proper error handling for stream events."
    ], options?.retriable ?? false);
    this.name = "StreamError";
    this.streamType = options?.streamType;
  }
};
function tryFn(fnOrPromise) {
  if (fnOrPromise == null) {
    const err = new ReckerError("fnOrPromise cannot be null or undefined", void 0, void 0, ["Pass a valid function or promise to tryFn.", "Check the caller to ensure an undefined value is not passed."]);
    err.stack = new Error().stack;
    return [false, err, void 0];
  }
  if (typeof fnOrPromise === "function") {
    try {
      const result = fnOrPromise();
      if (result == null) {
        return [true, null, result];
      }
      if (typeof result.then === "function") {
        return result.then((data2) => [true, null, data2]).catch((error2) => {
          if (error2 instanceof Error && Object.isExtensible(error2)) {
            const desc = Object.getOwnPropertyDescriptor(error2, "stack");
            if (!desc || desc.writable && desc.configurable) {
              try {
              } catch (_) {
              }
            }
          }
          return [false, wrapUnknownError(error2, "Function threw an error"), void 0];
        });
      }
      return [true, null, result];
    } catch (error2) {
      return [false, wrapUnknownError(error2, "Function threw an error"), void 0];
    }
  }
  if (typeof fnOrPromise.then === "function") {
    return Promise.resolve(fnOrPromise).then((data2) => [true, null, data2]).catch((error2) => {
      return [false, wrapUnknownError(error2, "Promise rejected"), void 0];
    });
  }
  return [true, null, fnOrPromise];
}
function wrapUnknownError(err, context) {
  if (err instanceof Error)
    return err;
  return new ReckerError(`${context}: ${String(err)}`, void 0, void 0, ["Inspect the original value being thrown.", "Ensure errors are instances of Error or ReckerError.", "Add contextual information when throwing custom errors."]);
}
function parseYaml(yaml, options = {}) {
  const opts = {
    allowDuplicateKeys: options.allowDuplicateKeys ?? false,
    parseDates: options.parseDates ?? true,
    customTags: options.customTags ?? {},
    maxDepth: options.maxDepth ?? 100,
    maxKeys: options.maxKeys ?? 1e4
  };
  if (!yaml || !yaml.trim()) {
    return null;
  }
  let content = yaml.replace(/^\uFEFF/, "");
  content = content.replace(/^---\s*$/gm, "").replace(/^\.\.\.\s*$/gm, "");
  const lines = content.split("\n");
  const state2 = {
    lines,
    index: 0,
    depth: 0,
    keyCount: 0,
    options: opts
  };
  const anchors = /* @__PURE__ */ new Map();
  return parseValue(state2, 0, anchors);
}
function parseValue(state2, baseIndent, anchors) {
  skipEmptyAndComments(state2);
  if (state2.index >= state2.lines.length) {
    return null;
  }
  const line = state2.lines[state2.index];
  const trimmed = line.trim();
  if (trimmed === "~" || trimmed === "null" || trimmed === "Null" || trimmed === "NULL") {
    state2.index++;
    return null;
  }
  if (trimmed.startsWith("- ") || trimmed === "-") {
    return parseSequence(state2, baseIndent, anchors);
  }
  if (trimmed.includes(":") && !trimmed.startsWith('"') && !trimmed.startsWith("'")) {
    return parseMapping(state2, baseIndent, anchors);
  }
  state2.index++;
  return parseScalar(trimmed, state2.options, anchors);
}
function parseMapping(state2, baseIndent, anchors) {
  const result = {};
  state2.depth++;
  if (state2.depth > state2.options.maxDepth) {
    throw new YamlError("Maximum nesting depth exceeded", state2.index);
  }
  while (state2.index < state2.lines.length) {
    skipEmptyAndComments(state2);
    if (state2.index >= state2.lines.length)
      break;
    const line = state2.lines[state2.index];
    const currentIndent = getIndent(line);
    if (currentIndent < baseIndent && line.trim()) {
      break;
    }
    if (currentIndent < baseIndent) {
      state2.index++;
      continue;
    }
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith("#")) {
      state2.index++;
      continue;
    }
    if (trimmed.startsWith("- ") && currentIndent <= baseIndent) {
      break;
    }
    const colonIndex = findKeyColon(trimmed);
    if (colonIndex === -1) {
      state2.index++;
      continue;
    }
    let key = trimmed.substring(0, colonIndex).trim();
    let valueStr = trimmed.substring(colonIndex + 1).trim();
    let anchor = null;
    const anchorMatch = key.match(/^&(\w+)\s+/);
    if (anchorMatch) {
      anchor = anchorMatch[1];
      key = key.substring(anchorMatch[0].length);
    }
    if (valueStr.startsWith("*")) {
      const aliasName = valueStr.substring(1).split(/\s/)[0];
      if (!anchors.has(aliasName)) {
        throw new YamlError(`Unknown alias: ${aliasName}`, state2.index);
      }
      result[key] = anchors.get(aliasName);
      state2.index++;
      continue;
    }
    const valueAnchorMatch = valueStr.match(/^&(\w+)\s*/);
    if (valueAnchorMatch) {
      anchor = valueAnchorMatch[1];
      valueStr = valueStr.substring(valueAnchorMatch[0].length);
    }
    key = unquote(key);
    state2.keyCount++;
    if (state2.keyCount > state2.options.maxKeys) {
      throw new YamlError("Maximum number of keys exceeded", state2.index);
    }
    if (!state2.options.allowDuplicateKeys && key in result) {
      throw new YamlError(`Duplicate key: ${key}`, state2.index);
    }
    state2.index++;
    let value;
    if (valueStr === "" || valueStr === "|" || valueStr === ">" || valueStr === "|-" || valueStr === ">-") {
      if (valueStr === "|" || valueStr === "|-") {
        value = parseLiteralBlock(state2, currentIndent, valueStr === "|-");
      } else if (valueStr === ">" || valueStr === ">-") {
        value = parseFoldedBlock(state2, currentIndent, valueStr === ">-");
      } else {
        skipEmptyAndComments(state2);
        if (state2.index < state2.lines.length) {
          const nextIndent = getIndent(state2.lines[state2.index]);
          if (nextIndent > currentIndent) {
            value = parseValue(state2, nextIndent, anchors);
          } else {
            value = null;
          }
        } else {
          value = null;
        }
      }
    } else {
      value = parseScalar(valueStr, state2.options, anchors);
    }
    if (anchor) {
      anchors.set(anchor, value);
    }
    result[key] = value;
  }
  state2.depth--;
  return result;
}
function parseSequence(state2, baseIndent, anchors) {
  const result = [];
  state2.depth++;
  if (state2.depth > state2.options.maxDepth) {
    throw new YamlError("Maximum nesting depth exceeded", state2.index);
  }
  while (state2.index < state2.lines.length) {
    skipEmptyAndComments(state2);
    if (state2.index >= state2.lines.length)
      break;
    const line = state2.lines[state2.index];
    const currentIndent = getIndent(line);
    const trimmed = line.trim();
    if (currentIndent < baseIndent && trimmed) {
      break;
    }
    if (!trimmed.startsWith("-")) {
      if (currentIndent <= baseIndent)
        break;
      state2.index++;
      continue;
    }
    let anchor = null;
    let valueStr = trimmed.substring(1).trim();
    const anchorMatch = valueStr.match(/^&(\w+)\s*/);
    if (anchorMatch) {
      anchor = anchorMatch[1];
      valueStr = valueStr.substring(anchorMatch[0].length);
    }
    if (valueStr.startsWith("*")) {
      const aliasName = valueStr.substring(1).split(/\s/)[0];
      if (!anchors.has(aliasName)) {
        throw new YamlError(`Unknown alias: ${aliasName}`, state2.index);
      }
      result.push(anchors.get(aliasName));
      state2.index++;
      continue;
    }
    state2.index++;
    let value;
    if (valueStr === "") {
      skipEmptyAndComments(state2);
      if (state2.index < state2.lines.length) {
        const nextIndent = getIndent(state2.lines[state2.index]);
        if (nextIndent > currentIndent) {
          value = parseValue(state2, nextIndent, anchors);
        } else {
          value = null;
        }
      } else {
        value = null;
      }
    } else if (valueStr.includes(":") && !valueStr.startsWith('"') && !valueStr.startsWith("'")) {
      state2.index--;
      const fakeLine = " ".repeat(currentIndent + 2) + valueStr;
      const originalLine = state2.lines[state2.index];
      state2.lines[state2.index] = fakeLine;
      value = parseMapping(state2, currentIndent + 2, anchors);
      if (state2.index < state2.lines.length) {
        state2.lines[state2.index - 1] = originalLine;
      }
    } else {
      value = parseScalar(valueStr, state2.options, anchors);
    }
    if (anchor) {
      anchors.set(anchor, value);
    }
    result.push(value);
  }
  state2.depth--;
  return result;
}
function parseLiteralBlock(state2, baseIndent, chomp) {
  const lines = [];
  let contentIndent = -1;
  while (state2.index < state2.lines.length) {
    const line = state2.lines[state2.index];
    const indent = getIndent(line);
    const trimmed = line.trim();
    if (contentIndent === -1 && trimmed) {
      contentIndent = indent;
    }
    if (contentIndent !== -1 && indent < contentIndent && trimmed) {
      break;
    }
    if (trimmed && indent <= baseIndent) {
      break;
    }
    if (contentIndent !== -1) {
      const relativeIndent = Math.max(0, indent - contentIndent);
      lines.push(" ".repeat(relativeIndent) + trimmed);
    } else {
      lines.push("");
    }
    state2.index++;
  }
  if (chomp) {
    while (lines.length > 0 && lines[lines.length - 1] === "") {
      lines.pop();
    }
  }
  return lines.join("\n");
}
function parseFoldedBlock(state2, baseIndent, chomp) {
  const paragraphs = [];
  let currentParagraph = [];
  let contentIndent = -1;
  while (state2.index < state2.lines.length) {
    const line = state2.lines[state2.index];
    const indent = getIndent(line);
    const trimmed = line.trim();
    if (contentIndent === -1 && trimmed) {
      contentIndent = indent;
    }
    if (contentIndent !== -1 && indent < contentIndent && trimmed) {
      break;
    }
    if (trimmed && indent <= baseIndent) {
      break;
    }
    if (contentIndent !== -1) {
      if (trimmed === "") {
        if (currentParagraph.length > 0) {
          paragraphs.push(currentParagraph.join(" "));
          currentParagraph = [];
        }
        paragraphs.push("");
      } else {
        currentParagraph.push(trimmed);
      }
    }
    state2.index++;
  }
  if (currentParagraph.length > 0) {
    paragraphs.push(currentParagraph.join(" "));
  }
  if (chomp) {
    while (paragraphs.length > 0 && paragraphs[paragraphs.length - 1] === "") {
      paragraphs.pop();
    }
  }
  return paragraphs.join("\n");
}
function parseScalar(value, options, anchors) {
  if (value.startsWith("*")) {
    const aliasName = value.substring(1).split(/\s|#/)[0];
    if (!anchors.has(aliasName)) {
      throw new YamlError(`Unknown alias: ${aliasName}`);
    }
    return anchors.get(aliasName);
  }
  const commentIndex = findInlineComment(value);
  if (commentIndex !== -1) {
    value = value.substring(0, commentIndex).trim();
  }
  const tagMatch = value.match(/^!(\S+)\s*/);
  if (tagMatch) {
    const tag2 = tagMatch[1];
    const tagValue = value.substring(tagMatch[0].length);
    if (options.customTags[tag2]) {
      return options.customTags[tag2](tagValue);
    }
    return tagValue;
  }
  if (value === "" || value === "~" || value === "null" || value === "Null" || value === "NULL") {
    return null;
  }
  if (value === "true" || value === "True" || value === "TRUE" || value === "yes" || value === "Yes" || value === "YES" || value === "on" || value === "On" || value === "ON") {
    return true;
  }
  if (value === "false" || value === "False" || value === "FALSE" || value === "no" || value === "No" || value === "NO" || value === "off" || value === "Off" || value === "OFF") {
    return false;
  }
  if (value === ".inf" || value === ".Inf" || value === ".INF" || value === "+.inf" || value === "+.Inf" || value === "+.INF") {
    return Infinity;
  }
  if (value === "-.inf" || value === "-.Inf" || value === "-.INF") {
    return -Infinity;
  }
  if (value === ".nan" || value === ".NaN" || value === ".NAN") {
    return NaN;
  }
  if (/^0o[0-7]+$/.test(value)) {
    return parseInt(value.substring(2), 8);
  }
  if (/^0x[0-9a-fA-F]+$/.test(value)) {
    return parseInt(value, 16);
  }
  if (/^[-+]?\d+$/.test(value)) {
    const num = parseInt(value, 10);
    if (Number.isSafeInteger(num)) {
      return num;
    }
    return num;
  }
  if (/^[-+]?(\d+\.?\d*|\.\d+)([eE][-+]?\d+)?$/.test(value)) {
    return parseFloat(value);
  }
  if (/^\d+:\d{2}(:\d{2})?(\.\d+)?$/.test(value)) {
    const parts = value.split(":").map(parseFloat);
    let result = parts[0];
    for (let i4 = 1; i4 < parts.length; i4++) {
      result = result * 60 + parts[i4];
    }
    return result;
  }
  if (options.parseDates) {
    if (/^\d{4}-\d{2}-\d{2}([T ]\d{2}:\d{2}:\d{2}(\.\d+)?(Z|[+-]\d{2}:\d{2})?)?$/.test(value)) {
      const date3 = new Date(value.replace(" ", "T"));
      if (!isNaN(date3.getTime())) {
        return date3;
      }
    }
  }
  if (value.startsWith('"') && value.endsWith('"') || value.startsWith("'") && value.endsWith("'")) {
    return unquote(value);
  }
  if (value.startsWith("[") && value.endsWith("]")) {
    return parseFlowSequence(value, options, anchors);
  }
  if (value.startsWith("{") && value.endsWith("}")) {
    return parseFlowMapping(value, options, anchors);
  }
  return value;
}
function parseFlowSequence(value, options, anchors) {
  const inner = value.slice(1, -1).trim();
  if (!inner)
    return [];
  const items = [];
  let current = "";
  let depth = 0;
  let inQuote = false;
  let quoteChar = "";
  for (let i4 = 0; i4 < inner.length; i4++) {
    const char = inner[i4];
    if (inQuote) {
      current += char;
      if (char === quoteChar && inner[i4 - 1] !== "\\") {
        inQuote = false;
      }
      continue;
    }
    if (char === '"' || char === "'") {
      inQuote = true;
      quoteChar = char;
      current += char;
      continue;
    }
    if (char === "[" || char === "{") {
      depth++;
      current += char;
      continue;
    }
    if (char === "]" || char === "}") {
      depth--;
      current += char;
      continue;
    }
    if (char === "," && depth === 0) {
      items.push(parseScalar(current.trim(), options, anchors));
      current = "";
      continue;
    }
    current += char;
  }
  if (current.trim()) {
    items.push(parseScalar(current.trim(), options, anchors));
  }
  return items;
}
function parseFlowMapping(value, options, anchors) {
  const inner = value.slice(1, -1).trim();
  if (!inner)
    return {};
  const result = {};
  let current = "";
  let depth = 0;
  let inQuote = false;
  let quoteChar = "";
  for (let i4 = 0; i4 < inner.length; i4++) {
    const char = inner[i4];
    if (inQuote) {
      current += char;
      if (char === quoteChar && inner[i4 - 1] !== "\\") {
        inQuote = false;
      }
      continue;
    }
    if (char === '"' || char === "'") {
      inQuote = true;
      quoteChar = char;
      current += char;
      continue;
    }
    if (char === "[" || char === "{") {
      depth++;
      current += char;
      continue;
    }
    if (char === "]" || char === "}") {
      depth--;
      current += char;
      continue;
    }
    if (char === "," && depth === 0) {
      const colonIdx = findKeyColon(current);
      if (colonIdx !== -1) {
        const key = unquote(current.substring(0, colonIdx).trim());
        const val = current.substring(colonIdx + 1).trim();
        result[key] = parseScalar(val, options, anchors);
      }
      current = "";
      continue;
    }
    current += char;
  }
  if (current.trim()) {
    const colonIdx = findKeyColon(current);
    if (colonIdx !== -1) {
      const key = unquote(current.substring(0, colonIdx).trim());
      const val = current.substring(colonIdx + 1).trim();
      result[key] = parseScalar(val, options, anchors);
    }
  }
  return result;
}
function getIndent(line) {
  const match = line.match(/^(\s*)/);
  return match ? match[1].length : 0;
}
function skipEmptyAndComments(state2) {
  while (state2.index < state2.lines.length) {
    const trimmed = state2.lines[state2.index].trim();
    if (trimmed && !trimmed.startsWith("#")) {
      break;
    }
    state2.index++;
  }
}
function findKeyColon(str) {
  let inQuote = false;
  let quoteChar = "";
  for (let i4 = 0; i4 < str.length; i4++) {
    const char = str[i4];
    if (inQuote) {
      if (char === quoteChar && str[i4 - 1] !== "\\") {
        inQuote = false;
      }
      continue;
    }
    if (char === '"' || char === "'") {
      inQuote = true;
      quoteChar = char;
      continue;
    }
    if (char === ":") {
      if (i4 === str.length - 1 || str[i4 + 1] === " " || str[i4 + 1] === "\n" || str[i4 + 1] === "	") {
        return i4;
      }
    }
  }
  return -1;
}
function findInlineComment(str) {
  let inQuote = false;
  let quoteChar = "";
  for (let i4 = 0; i4 < str.length; i4++) {
    const char = str[i4];
    if (inQuote) {
      if (char === quoteChar && str[i4 - 1] !== "\\") {
        inQuote = false;
      }
      continue;
    }
    if (char === '"' || char === "'") {
      inQuote = true;
      quoteChar = char;
      continue;
    }
    if (char === "#" && (i4 === 0 || str[i4 - 1] === " " || str[i4 - 1] === "	")) {
      return i4;
    }
  }
  return -1;
}
function unquote(str) {
  if (str.startsWith('"') && str.endsWith('"')) {
    return str.slice(1, -1).replace(/\\"/g, '"').replace(/\\\\/g, "\\").replace(/\\n/g, "\n").replace(/\\t/g, "	").replace(/\\r/g, "\r").replace(/\\0/g, "\0").replace(/\\x([0-9a-fA-F]{2})/g, (_, hex) => String.fromCharCode(parseInt(hex, 16))).replace(/\\u([0-9a-fA-F]{4})/g, (_, hex) => String.fromCharCode(parseInt(hex, 16)));
  }
  if (str.startsWith("'") && str.endsWith("'")) {
    return str.slice(1, -1).replace(/''/g, "'");
  }
  return str;
}
var YamlError = class extends Error {
  line;
  constructor(message, line) {
    super(line !== void 0 ? `${message} at line ${line + 1}` : message);
    this.name = "YamlError";
    this.line = line;
  }
};
function serializeYaml(data2, options = {}) {
  const opts = {
    indent: options.indent ?? 2,
    lineWidth: options.lineWidth ?? 80,
    forceQuotes: options.forceQuotes ?? false,
    flowStyle: options.flowStyle ?? false,
    sortKeys: options.sortKeys ?? false,
    skipUndefined: options.skipUndefined ?? true,
    documentMarkers: options.documentMarkers ?? false
  };
  let result = "";
  if (opts.documentMarkers) {
    result += "---\n";
  }
  result += serializeValue(data2, 0, opts);
  if (opts.documentMarkers) {
    result += "\n...";
  }
  return result;
}
function serializeValue(value, depth, opts) {
  if (value === null || value === void 0) {
    return "null";
  }
  if (typeof value === "boolean") {
    return value ? "true" : "false";
  }
  if (typeof value === "number") {
    if (Number.isNaN(value))
      return ".nan";
    if (value === Infinity)
      return ".inf";
    if (value === -Infinity)
      return "-.inf";
    return String(value);
  }
  if (typeof value === "string") {
    return serializeString(value, depth, opts);
  }
  if (value instanceof Date) {
    return value.toISOString();
  }
  if (Array.isArray(value)) {
    return serializeArray(value, depth, opts);
  }
  if (typeof value === "object") {
    return serializeObject(value, depth, opts);
  }
  return String(value);
}
function serializeString(str, depth, opts) {
  const needsQuotes = opts.forceQuotes || str === "" || str === "null" || str === "true" || str === "false" || str === "~" || /^[\d\-.]+$/.test(str) || /^[&*!|>'"%@`]/.test(str) || /[:#\[\]{}]/.test(str) || str.includes("\n");
  if (str.includes("\n")) {
    const indent = " ".repeat(opts.indent * (depth + 1));
    const lines = str.split("\n");
    return "|\n" + lines.map((line) => indent + line).join("\n");
  }
  if (needsQuotes) {
    const escaped = str.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\n/g, "\\n").replace(/\t/g, "\\t").replace(/\r/g, "\\r");
    return `"${escaped}"`;
  }
  return str;
}
function serializeArray(arr, depth, opts) {
  if (arr.length === 0) {
    return "[]";
  }
  if (opts.flowStyle && arr.length <= 5 && arr.every((v4) => typeof v4 !== "object" || v4 === null)) {
    const items = arr.map((v4) => serializeValue(v4, depth, opts));
    const flow = `[${items.join(", ")}]`;
    if (flow.length <= opts.lineWidth) {
      return flow;
    }
  }
  const indent = " ".repeat(opts.indent * depth);
  const lines = [];
  for (const item of arr) {
    if (opts.skipUndefined && item === void 0) {
      continue;
    }
    if (typeof item === "object" && item !== null && !Array.isArray(item) && !(item instanceof Date)) {
      const objStr = serializeObject(item, depth + 1, opts);
      const firstLine = objStr.split("\n")[0];
      const restLines = objStr.split("\n").slice(1);
      lines.push(`${indent}- ${firstLine}`);
      lines.push(...restLines.map((l4) => `${indent}  ${l4.trimStart()}`));
    } else if (Array.isArray(item) && item.length > 0 && !opts.flowStyle) {
      lines.push(`${indent}-`);
      const nested = serializeArray(item, depth + 1, opts);
      lines.push(...nested.split("\n").map((l4) => `${indent}  ${l4.trimStart()}`));
    } else {
      lines.push(`${indent}- ${serializeValue(item, depth + 1, opts)}`);
    }
  }
  return lines.join("\n");
}
function serializeObject(obj, depth, opts) {
  const keys2 = Object.keys(obj);
  if (keys2.length === 0) {
    return "{}";
  }
  if (opts.sortKeys) {
    keys2.sort();
  }
  if (opts.flowStyle && keys2.length <= 3 && keys2.every((k4) => typeof obj[k4] !== "object" || obj[k4] === null)) {
    const items = keys2.map((k4) => `${k4}: ${serializeValue(obj[k4], depth, opts)}`);
    const flow = `{${items.join(", ")}}`;
    if (flow.length <= opts.lineWidth) {
      return flow;
    }
  }
  const indent = " ".repeat(opts.indent * depth);
  const lines = [];
  for (const key of keys2) {
    const value = obj[key];
    if (opts.skipUndefined && value === void 0) {
      continue;
    }
    const quotedKey = /^[\w-]+$/.test(key) && key !== "true" && key !== "false" && key !== "null" ? key : `"${key}"`;
    if (typeof value === "object" && value !== null && !Array.isArray(value) && !(value instanceof Date)) {
      lines.push(`${indent}${quotedKey}:`);
      const nested = serializeObject(value, depth + 1, opts);
      lines.push(...nested.split("\n"));
    } else if (Array.isArray(value) && value.length > 0 && !opts.flowStyle) {
      lines.push(`${indent}${quotedKey}:`);
      const nested = serializeArray(value, depth + 1, opts);
      lines.push(...nested.split("\n"));
    } else {
      lines.push(`${indent}${quotedKey}: ${serializeValue(value, depth + 1, opts)}`);
    }
  }
  return lines.join("\n");
}
function parseCsv(csv, options = {}) {
  const opts = {
    headers: options.headers ?? true,
    columns: options.columns,
    delimiter: options.delimiter ?? ",",
    quote: options.quote ?? '"',
    skipEmptyLines: options.skipEmptyLines ?? true,
    trim: options.trim ?? false,
    parseNumbers: options.parseNumbers ?? false,
    parseBooleans: options.parseBooleans ?? false,
    comment: options.comment,
    maxRows: options.maxRows ?? 1e5,
    maxColumns: options.maxColumns ?? 1e3
  };
  if (!csv || !csv.trim()) {
    return [];
  }
  const normalized = csv.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
  const rows = [];
  let currentRow = [];
  let currentField = "";
  let inQuotes = false;
  let rowCount = 0;
  for (let i4 = 0; i4 < normalized.length; i4++) {
    const char = normalized[i4];
    const nextChar = normalized[i4 + 1];
    if (inQuotes) {
      if (char === opts.quote) {
        if (nextChar === opts.quote) {
          currentField += opts.quote;
          i4++;
        } else {
          inQuotes = false;
        }
      } else {
        currentField += char;
      }
    } else {
      if (char === opts.quote && currentField === "") {
        inQuotes = true;
      } else if (char === opts.delimiter) {
        currentRow.push(processField(currentField, opts));
        currentField = "";
        if (currentRow.length > opts.maxColumns) {
          throw new CsvError(`Maximum columns (${opts.maxColumns}) exceeded`, rowCount);
        }
      } else if (char === "\n") {
        currentRow.push(processField(currentField, opts));
        currentField = "";
        if (opts.comment && currentRow.length === 1 && currentRow[0].startsWith(opts.comment)) {
          currentRow = [];
          continue;
        }
        if (opts.skipEmptyLines && currentRow.length === 1 && currentRow[0] === "") {
          currentRow = [];
          continue;
        }
        rows.push(currentRow);
        currentRow = [];
        rowCount++;
        if (rowCount > opts.maxRows) {
          throw new CsvError(`Maximum rows (${opts.maxRows}) exceeded`, rowCount);
        }
      } else {
        currentField += char;
      }
    }
  }
  if (currentField || currentRow.length > 0) {
    currentRow.push(processField(currentField, opts));
    if (!(opts.comment && currentRow.length === 1 && currentRow[0].startsWith(opts.comment))) {
      if (!(opts.skipEmptyLines && currentRow.length === 1 && currentRow[0] === "")) {
        rows.push(currentRow);
      }
    }
  }
  if (!opts.headers && !opts.columns) {
    return rows;
  }
  let headers2;
  let dataRows;
  if (opts.columns) {
    headers2 = opts.columns;
    dataRows = opts.headers ? rows.slice(1) : rows;
  } else {
    if (rows.length === 0) {
      return [];
    }
    headers2 = rows[0];
    dataRows = rows.slice(1);
  }
  return dataRows.map((row) => {
    const obj = {};
    for (let i4 = 0; i4 < headers2.length; i4++) {
      obj[headers2[i4]] = row[i4] ?? "";
    }
    return obj;
  });
}
function processField(field, opts) {
  let value = opts.trim ? field.trim() : field;
  if (opts.parseNumbers) {
    const num = Number(value);
    if (!isNaN(num) && value !== "") {
      return num;
    }
  }
  if (opts.parseBooleans) {
    const lower = value.toLowerCase();
    if (lower === "true")
      return true;
    if (lower === "false")
      return false;
  }
  return value;
}
var CsvError = class extends Error {
  row;
  constructor(message, row) {
    super(row !== void 0 ? `${message} at row ${row + 1}` : message);
    this.name = "CsvError";
    this.row = row;
  }
};
function serializeCsv(data2, options = {}) {
  const opts = {
    headers: options.headers ?? true,
    columns: options.columns,
    delimiter: options.delimiter ?? ",",
    quote: options.quote ?? '"',
    alwaysQuote: options.alwaysQuote ?? false,
    lineEnding: options.lineEnding ?? "\r\n",
    nullValue: options.nullValue ?? ""
  };
  if (!data2 || data2.length === 0) {
    return "";
  }
  const lines = [];
  const isArrayOfArrays = Array.isArray(data2[0]);
  if (isArrayOfArrays) {
    for (const row of data2) {
      lines.push(row.map((field) => quoteField(field, opts)).join(opts.delimiter));
    }
  } else {
    const objects = data2;
    let columns;
    if (opts.columns) {
      columns = opts.columns;
    } else {
      const keySet = /* @__PURE__ */ new Set();
      for (const obj of objects) {
        for (const key of Object.keys(obj)) {
          keySet.add(key);
        }
      }
      columns = Array.from(keySet);
    }
    if (opts.headers) {
      lines.push(columns.map((col) => quoteField(col, opts)).join(opts.delimiter));
    }
    for (const obj of objects) {
      const row = columns.map((col) => {
        const value = obj[col];
        return quoteField(value, opts);
      });
      lines.push(row.join(opts.delimiter));
    }
  }
  return lines.join(opts.lineEnding);
}
function quoteField(value, opts) {
  if (value === null || value === void 0) {
    return opts.nullValue;
  }
  const str = String(value);
  const needsQuoting = opts.alwaysQuote || str.includes(opts.quote) || str.includes(opts.delimiter) || str.includes("\n") || str.includes("\r");
  if (needsQuoting) {
    const escaped = str.replace(new RegExp(opts.quote, "g"), opts.quote + opts.quote);
    return opts.quote + escaped + opts.quote;
  }
  return str;
}
function isNodeRuntime$5() {
  return typeof globalThis !== "undefined" && Boolean(globalThis.process?.versions?.node);
}
var RequestPromise = class {
  promise;
  abortController;
  constructor(promise2, abortController) {
    this.promise = promise2;
    this.abortController = abortController;
  }
  get [Symbol.toStringTag]() {
    return "RequestPromise";
  }
  then(onfulfilled, onrejected) {
    return this.promise.then(onfulfilled, onrejected);
  }
  catch(onrejected) {
    return this.promise.catch(onrejected);
  }
  finally(onfinally) {
    return this.promise.finally(onfinally);
  }
  cancel() {
    if (this.abortController) {
      this.abortController.abort();
    }
  }
  async json() {
    const response2 = await this.promise;
    return response2.json();
  }
  async yaml(options) {
    const response2 = await this.promise;
    const text = await response2.text();
    return parseYaml(text, options);
  }
  async csv(options) {
    const response2 = await this.promise;
    const text = await response2.text();
    return parseCsv(text, options);
  }
  async text() {
    const response2 = await this.promise;
    return response2.text();
  }
  async cleanText() {
    const response2 = await this.promise;
    return response2.cleanText();
  }
  async blob() {
    const response2 = await this.promise;
    return response2.blob();
  }
  async read() {
    const response2 = await this.promise;
    return response2.read();
  }
  async write(path3) {
    if (!isNodeRuntime$5()) {
      throw new StreamError$1("write() is only supported in Node.js environments.", { streamType: "response", retriable: false });
    }
    const response2 = await this.promise;
    const body2 = response2.read();
    if (!body2) {
      throw new StreamError$1("Response has no body to write", {
        streamType: "response",
        retriable: true
      });
    }
    const [{ createWriteStream: createWriteStream2 }, { pipeline }, { Readable: Readable2 }] = await Promise.all([
      import("node:fs"),
      import("node:stream/promises"),
      import("node:stream")
    ]);
    const nodeStream = Readable2.fromWeb(body2);
    const fileStream = createWriteStream2(path3);
    await pipeline(nodeStream, fileStream);
  }
  async parse(schema) {
    const data2 = await this.json();
    return schema.parse(data2);
  }
  async safe() {
    return tryFn(() => this.json());
  }
  async *sse() {
    const response2 = await this.promise;
    yield* response2.sse();
  }
  async *download() {
    const response2 = await this.promise;
    yield* response2.download();
  }
  async *[Symbol.asyncIterator]() {
    const response2 = await this.promise;
    yield* response2;
  }
};
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x4) {
  return x4 && x4.__esModule && Object.prototype.hasOwnProperty.call(x4, "default") ? x4["default"] : x4;
}
var undici$1 = { exports: {} };
var symbols;
var hasRequiredSymbols;
function requireSymbols() {
  if (hasRequiredSymbols) return symbols;
  hasRequiredSymbols = 1;
  symbols = {
    kClose: /* @__PURE__ */ Symbol("close"),
    kDestroy: /* @__PURE__ */ Symbol("destroy"),
    kDispatch: /* @__PURE__ */ Symbol("dispatch"),
    kUrl: /* @__PURE__ */ Symbol("url"),
    kWriting: /* @__PURE__ */ Symbol("writing"),
    kResuming: /* @__PURE__ */ Symbol("resuming"),
    kQueue: /* @__PURE__ */ Symbol("queue"),
    kConnect: /* @__PURE__ */ Symbol("connect"),
    kConnecting: /* @__PURE__ */ Symbol("connecting"),
    kKeepAliveDefaultTimeout: /* @__PURE__ */ Symbol("default keep alive timeout"),
    kKeepAliveMaxTimeout: /* @__PURE__ */ Symbol("max keep alive timeout"),
    kKeepAliveTimeoutThreshold: /* @__PURE__ */ Symbol("keep alive timeout threshold"),
    kKeepAliveTimeoutValue: /* @__PURE__ */ Symbol("keep alive timeout"),
    kKeepAlive: /* @__PURE__ */ Symbol("keep alive"),
    kHeadersTimeout: /* @__PURE__ */ Symbol("headers timeout"),
    kBodyTimeout: /* @__PURE__ */ Symbol("body timeout"),
    kServerName: /* @__PURE__ */ Symbol("server name"),
    kLocalAddress: /* @__PURE__ */ Symbol("local address"),
    kHost: /* @__PURE__ */ Symbol("host"),
    kNoRef: /* @__PURE__ */ Symbol("no ref"),
    kBodyUsed: /* @__PURE__ */ Symbol("used"),
    kBody: /* @__PURE__ */ Symbol("abstracted request body"),
    kRunning: /* @__PURE__ */ Symbol("running"),
    kBlocking: /* @__PURE__ */ Symbol("blocking"),
    kPending: /* @__PURE__ */ Symbol("pending"),
    kSize: /* @__PURE__ */ Symbol("size"),
    kBusy: /* @__PURE__ */ Symbol("busy"),
    kQueued: /* @__PURE__ */ Symbol("queued"),
    kFree: /* @__PURE__ */ Symbol("free"),
    kConnected: /* @__PURE__ */ Symbol("connected"),
    kClosed: /* @__PURE__ */ Symbol("closed"),
    kNeedDrain: /* @__PURE__ */ Symbol("need drain"),
    kReset: /* @__PURE__ */ Symbol("reset"),
    kDestroyed: /* @__PURE__ */ Symbol.for("nodejs.stream.destroyed"),
    kResume: /* @__PURE__ */ Symbol("resume"),
    kOnError: /* @__PURE__ */ Symbol("on error"),
    kMaxHeadersSize: /* @__PURE__ */ Symbol("max headers size"),
    kRunningIdx: /* @__PURE__ */ Symbol("running index"),
    kPendingIdx: /* @__PURE__ */ Symbol("pending index"),
    kError: /* @__PURE__ */ Symbol("error"),
    kClients: /* @__PURE__ */ Symbol("clients"),
    kClient: /* @__PURE__ */ Symbol("client"),
    kParser: /* @__PURE__ */ Symbol("parser"),
    kOnDestroyed: /* @__PURE__ */ Symbol("destroy callbacks"),
    kPipelining: /* @__PURE__ */ Symbol("pipelining"),
    kSocket: /* @__PURE__ */ Symbol("socket"),
    kHostHeader: /* @__PURE__ */ Symbol("host header"),
    kConnector: /* @__PURE__ */ Symbol("connector"),
    kStrictContentLength: /* @__PURE__ */ Symbol("strict content length"),
    kMaxRedirections: /* @__PURE__ */ Symbol("maxRedirections"),
    kMaxRequests: /* @__PURE__ */ Symbol("maxRequestsPerClient"),
    kProxy: /* @__PURE__ */ Symbol("proxy agent options"),
    kCounter: /* @__PURE__ */ Symbol("socket request counter"),
    kMaxResponseSize: /* @__PURE__ */ Symbol("max response size"),
    kHTTP2Session: /* @__PURE__ */ Symbol("http2Session"),
    kHTTP2SessionState: /* @__PURE__ */ Symbol("http2Session state"),
    kRetryHandlerDefaultRetry: /* @__PURE__ */ Symbol("retry agent default retry"),
    kConstruct: /* @__PURE__ */ Symbol("constructable"),
    kListeners: /* @__PURE__ */ Symbol("listeners"),
    kHTTPContext: /* @__PURE__ */ Symbol("http context"),
    kMaxConcurrentStreams: /* @__PURE__ */ Symbol("max concurrent streams"),
    kEnableConnectProtocol: /* @__PURE__ */ Symbol("http2session connect protocol"),
    kRemoteSettings: /* @__PURE__ */ Symbol("http2session remote settings"),
    kHTTP2Stream: /* @__PURE__ */ Symbol("http2session client stream"),
    kNoProxyAgent: /* @__PURE__ */ Symbol("no proxy agent"),
    kHttpProxyAgent: /* @__PURE__ */ Symbol("http proxy agent"),
    kHttpsProxyAgent: /* @__PURE__ */ Symbol("https proxy agent")
  };
  return symbols;
}
var timers;
var hasRequiredTimers;
function requireTimers() {
  if (hasRequiredTimers) return timers;
  hasRequiredTimers = 1;
  let fastNow = 0;
  const RESOLUTION_MS = 1e3;
  const TICK_MS = (RESOLUTION_MS >> 1) - 1;
  let fastNowTimeout;
  const kFastTimer = /* @__PURE__ */ Symbol("kFastTimer");
  const fastTimers = [];
  const NOT_IN_LIST = -2;
  const TO_BE_CLEARED = -1;
  const PENDING = 0;
  const ACTIVE = 1;
  function onTick() {
    fastNow += TICK_MS;
    let idx = 0;
    let len = fastTimers.length;
    while (idx < len) {
      const timer = fastTimers[idx];
      if (timer._state === PENDING) {
        timer._idleStart = fastNow - TICK_MS;
        timer._state = ACTIVE;
      } else if (timer._state === ACTIVE && fastNow >= timer._idleStart + timer._idleTimeout) {
        timer._state = TO_BE_CLEARED;
        timer._idleStart = -1;
        timer._onTimeout(timer._timerArg);
      }
      if (timer._state === TO_BE_CLEARED) {
        timer._state = NOT_IN_LIST;
        if (--len !== 0) {
          fastTimers[idx] = fastTimers[len];
        }
      } else {
        ++idx;
      }
    }
    fastTimers.length = len;
    if (fastTimers.length !== 0) {
      refreshTimeout();
    }
  }
  function refreshTimeout() {
    if (fastNowTimeout?.refresh) {
      fastNowTimeout.refresh();
    } else {
      clearTimeout(fastNowTimeout);
      fastNowTimeout = setTimeout(onTick, TICK_MS);
      fastNowTimeout?.unref();
    }
  }
  class FastTimer {
    [kFastTimer] = true;
    /**
     * The state of the timer, which can be one of the following:
     * - NOT_IN_LIST (-2)
     * - TO_BE_CLEARED (-1)
     * - PENDING (0)
     * - ACTIVE (1)
     *
     * @type {-2|-1|0|1}
     * @private
     */
    _state = NOT_IN_LIST;
    /**
     * The number of milliseconds to wait before calling the callback.
     *
     * @type {number}
     * @private
     */
    _idleTimeout = -1;
    /**
     * The time in milliseconds when the timer was started. This value is used to
     * calculate when the timer should expire.
     *
     * @type {number}
     * @default -1
     * @private
     */
    _idleStart = -1;
    /**
     * The function to be executed when the timer expires.
     * @type {Function}
     * @private
     */
    _onTimeout;
    /**
     * The argument to be passed to the callback when the timer expires.
     *
     * @type {*}
     * @private
     */
    _timerArg;
    /**
     * @constructor
     * @param {Function} callback A function to be executed after the timer
     * expires.
     * @param {number} delay The time, in milliseconds that the timer should wait
     * before the specified function or code is executed.
     * @param {*} arg
     */
    constructor(callback, delay, arg) {
      this._onTimeout = callback;
      this._idleTimeout = delay;
      this._timerArg = arg;
      this.refresh();
    }
    /**
     * Sets the timer's start time to the current time, and reschedules the timer
     * to call its callback at the previously specified duration adjusted to the
     * current time.
     * Using this on a timer that has already called its callback will reactivate
     * the timer.
     *
     * @returns {void}
     */
    refresh() {
      if (this._state === NOT_IN_LIST) {
        fastTimers.push(this);
      }
      if (!fastNowTimeout || fastTimers.length === 1) {
        refreshTimeout();
      }
      this._state = PENDING;
    }
    /**
     * The `clear` method cancels the timer, preventing it from executing.
     *
     * @returns {void}
     * @private
     */
    clear() {
      this._state = TO_BE_CLEARED;
      this._idleStart = -1;
    }
  }
  timers = {
    /**
     * The setTimeout() method sets a timer which executes a function once the
     * timer expires.
     * @param {Function} callback A function to be executed after the timer
     * expires.
     * @param {number} delay The time, in milliseconds that the timer should
     * wait before the specified function or code is executed.
     * @param {*} [arg] An optional argument to be passed to the callback function
     * when the timer expires.
     * @returns {NodeJS.Timeout|FastTimer}
     */
    setTimeout(callback, delay, arg) {
      return delay <= RESOLUTION_MS ? setTimeout(callback, delay, arg) : new FastTimer(callback, delay, arg);
    },
    /**
     * The clearTimeout method cancels an instantiated Timer previously created
     * by calling setTimeout.
     *
     * @param {NodeJS.Timeout|FastTimer} timeout
     */
    clearTimeout(timeout) {
      if (timeout[kFastTimer]) {
        timeout.clear();
      } else {
        clearTimeout(timeout);
      }
    },
    /**
     * The setFastTimeout() method sets a fastTimer which executes a function once
     * the timer expires.
     * @param {Function} callback A function to be executed after the timer
     * expires.
     * @param {number} delay The time, in milliseconds that the timer should
     * wait before the specified function or code is executed.
     * @param {*} [arg] An optional argument to be passed to the callback function
     * when the timer expires.
     * @returns {FastTimer}
     */
    setFastTimeout(callback, delay, arg) {
      return new FastTimer(callback, delay, arg);
    },
    /**
     * The clearTimeout method cancels an instantiated FastTimer previously
     * created by calling setFastTimeout.
     *
     * @param {FastTimer} timeout
     */
    clearFastTimeout(timeout) {
      timeout.clear();
    },
    /**
     * The now method returns the value of the internal fast timer clock.
     *
     * @returns {number}
     */
    now() {
      return fastNow;
    },
    /**
     * Trigger the onTick function to process the fastTimers array.
     * Exported for testing purposes only.
     * Marking as deprecated to discourage any use outside of testing.
     * @deprecated
     * @param {number} [delay=0] The delay in milliseconds to add to the now value.
     */
    tick(delay = 0) {
      fastNow += delay - RESOLUTION_MS + 1;
      onTick();
      onTick();
    },
    /**
     * Reset FastTimers.
     * Exported for testing purposes only.
     * Marking as deprecated to discourage any use outside of testing.
     * @deprecated
     */
    reset() {
      fastNow = 0;
      fastTimers.length = 0;
      clearTimeout(fastNowTimeout);
      fastNowTimeout = null;
    },
    /**
     * Exporting for testing purposes only.
     * Marking as deprecated to discourage any use outside of testing.
     * @deprecated
     */
    kFastTimer
  };
  return timers;
}
var errors;
var hasRequiredErrors;
function requireErrors() {
  if (hasRequiredErrors) return errors;
  hasRequiredErrors = 1;
  const kUndiciError = /* @__PURE__ */ Symbol.for("undici.error.UND_ERR");
  class UndiciError extends Error {
    constructor(message, options) {
      super(message, options);
      this.name = "UndiciError";
      this.code = "UND_ERR";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kUndiciError] === true;
    }
    get [kUndiciError]() {
      return true;
    }
  }
  const kConnectTimeoutError = /* @__PURE__ */ Symbol.for("undici.error.UND_ERR_CONNECT_TIMEOUT");
  class ConnectTimeoutError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "ConnectTimeoutError";
      this.message = message || "Connect Timeout Error";
      this.code = "UND_ERR_CONNECT_TIMEOUT";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kConnectTimeoutError] === true;
    }
    get [kConnectTimeoutError]() {
      return true;
    }
  }
  const kHeadersTimeoutError = /* @__PURE__ */ Symbol.for("undici.error.UND_ERR_HEADERS_TIMEOUT");
  class HeadersTimeoutError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "HeadersTimeoutError";
      this.message = message || "Headers Timeout Error";
      this.code = "UND_ERR_HEADERS_TIMEOUT";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kHeadersTimeoutError] === true;
    }
    get [kHeadersTimeoutError]() {
      return true;
    }
  }
  const kHeadersOverflowError = /* @__PURE__ */ Symbol.for("undici.error.UND_ERR_HEADERS_OVERFLOW");
  class HeadersOverflowError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "HeadersOverflowError";
      this.message = message || "Headers Overflow Error";
      this.code = "UND_ERR_HEADERS_OVERFLOW";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kHeadersOverflowError] === true;
    }
    get [kHeadersOverflowError]() {
      return true;
    }
  }
  const kBodyTimeoutError = /* @__PURE__ */ Symbol.for("undici.error.UND_ERR_BODY_TIMEOUT");
  class BodyTimeoutError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "BodyTimeoutError";
      this.message = message || "Body Timeout Error";
      this.code = "UND_ERR_BODY_TIMEOUT";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kBodyTimeoutError] === true;
    }
    get [kBodyTimeoutError]() {
      return true;
    }
  }
  const kInvalidArgumentError = /* @__PURE__ */ Symbol.for("undici.error.UND_ERR_INVALID_ARG");
  class InvalidArgumentError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "InvalidArgumentError";
      this.message = message || "Invalid Argument Error";
      this.code = "UND_ERR_INVALID_ARG";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kInvalidArgumentError] === true;
    }
    get [kInvalidArgumentError]() {
      return true;
    }
  }
  const kInvalidReturnValueError = /* @__PURE__ */ Symbol.for("undici.error.UND_ERR_INVALID_RETURN_VALUE");
  class InvalidReturnValueError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "InvalidReturnValueError";
      this.message = message || "Invalid Return Value Error";
      this.code = "UND_ERR_INVALID_RETURN_VALUE";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kInvalidReturnValueError] === true;
    }
    get [kInvalidReturnValueError]() {
      return true;
    }
  }
  const kAbortError = /* @__PURE__ */ Symbol.for("undici.error.UND_ERR_ABORT");
  class AbortError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "AbortError";
      this.message = message || "The operation was aborted";
      this.code = "UND_ERR_ABORT";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kAbortError] === true;
    }
    get [kAbortError]() {
      return true;
    }
  }
  const kRequestAbortedError = /* @__PURE__ */ Symbol.for("undici.error.UND_ERR_ABORTED");
  class RequestAbortedError extends AbortError {
    constructor(message) {
      super(message);
      this.name = "AbortError";
      this.message = message || "Request aborted";
      this.code = "UND_ERR_ABORTED";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kRequestAbortedError] === true;
    }
    get [kRequestAbortedError]() {
      return true;
    }
  }
  const kInformationalError = /* @__PURE__ */ Symbol.for("undici.error.UND_ERR_INFO");
  class InformationalError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "InformationalError";
      this.message = message || "Request information";
      this.code = "UND_ERR_INFO";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kInformationalError] === true;
    }
    get [kInformationalError]() {
      return true;
    }
  }
  const kRequestContentLengthMismatchError = /* @__PURE__ */ Symbol.for("undici.error.UND_ERR_REQ_CONTENT_LENGTH_MISMATCH");
  class RequestContentLengthMismatchError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "RequestContentLengthMismatchError";
      this.message = message || "Request body length does not match content-length header";
      this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kRequestContentLengthMismatchError] === true;
    }
    get [kRequestContentLengthMismatchError]() {
      return true;
    }
  }
  const kResponseContentLengthMismatchError = /* @__PURE__ */ Symbol.for("undici.error.UND_ERR_RES_CONTENT_LENGTH_MISMATCH");
  class ResponseContentLengthMismatchError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "ResponseContentLengthMismatchError";
      this.message = message || "Response body length does not match content-length header";
      this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kResponseContentLengthMismatchError] === true;
    }
    get [kResponseContentLengthMismatchError]() {
      return true;
    }
  }
  const kClientDestroyedError = /* @__PURE__ */ Symbol.for("undici.error.UND_ERR_DESTROYED");
  class ClientDestroyedError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "ClientDestroyedError";
      this.message = message || "The client is destroyed";
      this.code = "UND_ERR_DESTROYED";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kClientDestroyedError] === true;
    }
    get [kClientDestroyedError]() {
      return true;
    }
  }
  const kClientClosedError = /* @__PURE__ */ Symbol.for("undici.error.UND_ERR_CLOSED");
  class ClientClosedError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "ClientClosedError";
      this.message = message || "The client is closed";
      this.code = "UND_ERR_CLOSED";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kClientClosedError] === true;
    }
    get [kClientClosedError]() {
      return true;
    }
  }
  const kSocketError = /* @__PURE__ */ Symbol.for("undici.error.UND_ERR_SOCKET");
  class SocketError extends UndiciError {
    constructor(message, socket) {
      super(message);
      this.name = "SocketError";
      this.message = message || "Socket error";
      this.code = "UND_ERR_SOCKET";
      this.socket = socket;
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kSocketError] === true;
    }
    get [kSocketError]() {
      return true;
    }
  }
  const kNotSupportedError = /* @__PURE__ */ Symbol.for("undici.error.UND_ERR_NOT_SUPPORTED");
  class NotSupportedError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "NotSupportedError";
      this.message = message || "Not supported error";
      this.code = "UND_ERR_NOT_SUPPORTED";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kNotSupportedError] === true;
    }
    get [kNotSupportedError]() {
      return true;
    }
  }
  const kBalancedPoolMissingUpstreamError = /* @__PURE__ */ Symbol.for("undici.error.UND_ERR_BPL_MISSING_UPSTREAM");
  class BalancedPoolMissingUpstreamError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "MissingUpstreamError";
      this.message = message || "No upstream has been added to the BalancedPool";
      this.code = "UND_ERR_BPL_MISSING_UPSTREAM";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kBalancedPoolMissingUpstreamError] === true;
    }
    get [kBalancedPoolMissingUpstreamError]() {
      return true;
    }
  }
  const kHTTPParserError = /* @__PURE__ */ Symbol.for("undici.error.UND_ERR_HTTP_PARSER");
  class HTTPParserError extends Error {
    constructor(message, code, data2) {
      super(message);
      this.name = "HTTPParserError";
      this.code = code ? `HPE_${code}` : void 0;
      this.data = data2 ? data2.toString() : void 0;
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kHTTPParserError] === true;
    }
    get [kHTTPParserError]() {
      return true;
    }
  }
  const kResponseExceededMaxSizeError = /* @__PURE__ */ Symbol.for("undici.error.UND_ERR_RES_EXCEEDED_MAX_SIZE");
  class ResponseExceededMaxSizeError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "ResponseExceededMaxSizeError";
      this.message = message || "Response content exceeded max size";
      this.code = "UND_ERR_RES_EXCEEDED_MAX_SIZE";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kResponseExceededMaxSizeError] === true;
    }
    get [kResponseExceededMaxSizeError]() {
      return true;
    }
  }
  const kRequestRetryError = /* @__PURE__ */ Symbol.for("undici.error.UND_ERR_REQ_RETRY");
  class RequestRetryError extends UndiciError {
    constructor(message, code, { headers: headers2, data: data2 }) {
      super(message);
      this.name = "RequestRetryError";
      this.message = message || "Request retry error";
      this.code = "UND_ERR_REQ_RETRY";
      this.statusCode = code;
      this.data = data2;
      this.headers = headers2;
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kRequestRetryError] === true;
    }
    get [kRequestRetryError]() {
      return true;
    }
  }
  const kResponseError = /* @__PURE__ */ Symbol.for("undici.error.UND_ERR_RESPONSE");
  class ResponseError extends UndiciError {
    constructor(message, code, { headers: headers2, body: body2 }) {
      super(message);
      this.name = "ResponseError";
      this.message = message || "Response error";
      this.code = "UND_ERR_RESPONSE";
      this.statusCode = code;
      this.body = body2;
      this.headers = headers2;
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kResponseError] === true;
    }
    get [kResponseError]() {
      return true;
    }
  }
  const kSecureProxyConnectionError = /* @__PURE__ */ Symbol.for("undici.error.UND_ERR_PRX_TLS");
  class SecureProxyConnectionError extends UndiciError {
    constructor(cause, message, options = {}) {
      super(message, { cause, ...options });
      this.name = "SecureProxyConnectionError";
      this.message = message || "Secure Proxy Connection failed";
      this.code = "UND_ERR_PRX_TLS";
      this.cause = cause;
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kSecureProxyConnectionError] === true;
    }
    get [kSecureProxyConnectionError]() {
      return true;
    }
  }
  const kMaxOriginsReachedError = /* @__PURE__ */ Symbol.for("undici.error.UND_ERR_MAX_ORIGINS_REACHED");
  class MaxOriginsReachedError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "MaxOriginsReachedError";
      this.message = message || "Maximum allowed origins reached";
      this.code = "UND_ERR_MAX_ORIGINS_REACHED";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kMaxOriginsReachedError] === true;
    }
    get [kMaxOriginsReachedError]() {
      return true;
    }
  }
  errors = {
    AbortError,
    HTTPParserError,
    UndiciError,
    HeadersTimeoutError,
    HeadersOverflowError,
    BodyTimeoutError,
    RequestContentLengthMismatchError,
    ConnectTimeoutError,
    InvalidArgumentError,
    InvalidReturnValueError,
    RequestAbortedError,
    ClientDestroyedError,
    ClientClosedError,
    InformationalError,
    SocketError,
    NotSupportedError,
    ResponseContentLengthMismatchError,
    BalancedPoolMissingUpstreamError,
    ResponseExceededMaxSizeError,
    RequestRetryError,
    ResponseError,
    SecureProxyConnectionError,
    MaxOriginsReachedError
  };
  return errors;
}
var constants$4;
var hasRequiredConstants$4;
function requireConstants$4() {
  if (hasRequiredConstants$4) return constants$4;
  hasRequiredConstants$4 = 1;
  const wellknownHeaderNames = (
    /** @type {const} */
    [
      "Accept",
      "Accept-Encoding",
      "Accept-Language",
      "Accept-Ranges",
      "Access-Control-Allow-Credentials",
      "Access-Control-Allow-Headers",
      "Access-Control-Allow-Methods",
      "Access-Control-Allow-Origin",
      "Access-Control-Expose-Headers",
      "Access-Control-Max-Age",
      "Access-Control-Request-Headers",
      "Access-Control-Request-Method",
      "Age",
      "Allow",
      "Alt-Svc",
      "Alt-Used",
      "Authorization",
      "Cache-Control",
      "Clear-Site-Data",
      "Connection",
      "Content-Disposition",
      "Content-Encoding",
      "Content-Language",
      "Content-Length",
      "Content-Location",
      "Content-Range",
      "Content-Security-Policy",
      "Content-Security-Policy-Report-Only",
      "Content-Type",
      "Cookie",
      "Cross-Origin-Embedder-Policy",
      "Cross-Origin-Opener-Policy",
      "Cross-Origin-Resource-Policy",
      "Date",
      "Device-Memory",
      "Downlink",
      "ECT",
      "ETag",
      "Expect",
      "Expect-CT",
      "Expires",
      "Forwarded",
      "From",
      "Host",
      "If-Match",
      "If-Modified-Since",
      "If-None-Match",
      "If-Range",
      "If-Unmodified-Since",
      "Keep-Alive",
      "Last-Modified",
      "Link",
      "Location",
      "Max-Forwards",
      "Origin",
      "Permissions-Policy",
      "Pragma",
      "Proxy-Authenticate",
      "Proxy-Authorization",
      "RTT",
      "Range",
      "Referer",
      "Referrer-Policy",
      "Refresh",
      "Retry-After",
      "Sec-WebSocket-Accept",
      "Sec-WebSocket-Extensions",
      "Sec-WebSocket-Key",
      "Sec-WebSocket-Protocol",
      "Sec-WebSocket-Version",
      "Server",
      "Server-Timing",
      "Service-Worker-Allowed",
      "Service-Worker-Navigation-Preload",
      "Set-Cookie",
      "SourceMap",
      "Strict-Transport-Security",
      "Supports-Loading-Mode",
      "TE",
      "Timing-Allow-Origin",
      "Trailer",
      "Transfer-Encoding",
      "Upgrade",
      "Upgrade-Insecure-Requests",
      "User-Agent",
      "Vary",
      "Via",
      "WWW-Authenticate",
      "X-Content-Type-Options",
      "X-DNS-Prefetch-Control",
      "X-Frame-Options",
      "X-Permitted-Cross-Domain-Policies",
      "X-Powered-By",
      "X-Requested-With",
      "X-XSS-Protection"
    ]
  );
  const headerNameLowerCasedRecord = {};
  Object.setPrototypeOf(headerNameLowerCasedRecord, null);
  const wellknownHeaderNameBuffers = {};
  Object.setPrototypeOf(wellknownHeaderNameBuffers, null);
  function getHeaderNameAsBuffer(header) {
    let buffer = wellknownHeaderNameBuffers[header];
    if (buffer === void 0) {
      buffer = Buffer.from(header);
    }
    return buffer;
  }
  for (let i4 = 0; i4 < wellknownHeaderNames.length; ++i4) {
    const key = wellknownHeaderNames[i4];
    const lowerCasedKey = key.toLowerCase();
    headerNameLowerCasedRecord[key] = headerNameLowerCasedRecord[lowerCasedKey] = lowerCasedKey;
  }
  constants$4 = {
    wellknownHeaderNames,
    headerNameLowerCasedRecord,
    getHeaderNameAsBuffer
  };
  return constants$4;
}
var tree_1;
var hasRequiredTree;
function requireTree() {
  if (hasRequiredTree) return tree_1;
  hasRequiredTree = 1;
  const {
    wellknownHeaderNames,
    headerNameLowerCasedRecord
  } = requireConstants$4();
  class TstNode {
    /** @type {any} */
    value = null;
    /** @type {null | TstNode} */
    left = null;
    /** @type {null | TstNode} */
    middle = null;
    /** @type {null | TstNode} */
    right = null;
    /** @type {number} */
    code;
    /**
     * @param {string} key
     * @param {any} value
     * @param {number} index
     */
    constructor(key, value, index) {
      if (index === void 0 || index >= key.length) {
        throw new TypeError("Unreachable");
      }
      const code = this.code = key.charCodeAt(index);
      if (code > 127) {
        throw new TypeError("key must be ascii string");
      }
      if (key.length !== ++index) {
        this.middle = new TstNode(key, value, index);
      } else {
        this.value = value;
      }
    }
    /**
     * @param {string} key
     * @param {any} value
     * @returns {void}
     */
    add(key, value) {
      const length = key.length;
      if (length === 0) {
        throw new TypeError("Unreachable");
      }
      let index = 0;
      let node = this;
      while (true) {
        const code = key.charCodeAt(index);
        if (code > 127) {
          throw new TypeError("key must be ascii string");
        }
        if (node.code === code) {
          if (length === ++index) {
            node.value = value;
            break;
          } else if (node.middle !== null) {
            node = node.middle;
          } else {
            node.middle = new TstNode(key, value, index);
            break;
          }
        } else if (node.code < code) {
          if (node.left !== null) {
            node = node.left;
          } else {
            node.left = new TstNode(key, value, index);
            break;
          }
        } else if (node.right !== null) {
          node = node.right;
        } else {
          node.right = new TstNode(key, value, index);
          break;
        }
      }
    }
    /**
     * @param {Uint8Array} key
     * @returns {TstNode | null}
     */
    search(key) {
      const keylength = key.length;
      let index = 0;
      let node = this;
      while (node !== null && index < keylength) {
        let code = key[index];
        if (code <= 90 && code >= 65) {
          code |= 32;
        }
        while (node !== null) {
          if (code === node.code) {
            if (keylength === ++index) {
              return node;
            }
            node = node.middle;
            break;
          }
          node = node.code < code ? node.left : node.right;
        }
      }
      return null;
    }
  }
  class TernarySearchTree {
    /** @type {TstNode | null} */
    node = null;
    /**
     * @param {string} key
     * @param {any} value
     * @returns {void}
     * */
    insert(key, value) {
      if (this.node === null) {
        this.node = new TstNode(key, value, 0);
      } else {
        this.node.add(key, value);
      }
    }
    /**
     * @param {Uint8Array} key
     * @returns {any}
     */
    lookup(key) {
      return this.node?.search(key)?.value ?? null;
    }
  }
  const tree = new TernarySearchTree();
  for (let i4 = 0; i4 < wellknownHeaderNames.length; ++i4) {
    const key = headerNameLowerCasedRecord[wellknownHeaderNames[i4]];
    tree.insert(key, key);
  }
  tree_1 = {
    TernarySearchTree,
    tree
  };
  return tree_1;
}
var util$5;
var hasRequiredUtil$5;
function requireUtil$5() {
  if (hasRequiredUtil$5) return util$5;
  hasRequiredUtil$5 = 1;
  const assert = import_node_assert.default;
  const { kDestroyed, kBodyUsed, kListeners, kBody } = requireSymbols();
  const { IncomingMessage } = import_node_http.default;
  const stream = import_node_stream.default;
  const net$1 = import_node_net.default;
  const { stringify } = import_node_querystring.default;
  const { EventEmitter: EE } = import_node_events.default;
  const timers2 = requireTimers();
  const { InvalidArgumentError, ConnectTimeoutError } = requireErrors();
  const { headerNameLowerCasedRecord } = requireConstants$4();
  const { tree } = requireTree();
  const [nodeMajor, nodeMinor] = process.versions.node.split(".", 2).map((v4) => Number(v4));
  class BodyAsyncIterable {
    constructor(body2) {
      this[kBody] = body2;
      this[kBodyUsed] = false;
    }
    async *[Symbol.asyncIterator]() {
      assert(!this[kBodyUsed], "disturbed");
      this[kBodyUsed] = true;
      yield* this[kBody];
    }
  }
  function noop2() {
  }
  function wrapRequestBody(body2) {
    if (isStream(body2)) {
      if (bodyLength(body2) === 0) {
        body2.on("data", function() {
          assert(false);
        });
      }
      if (typeof body2.readableDidRead !== "boolean") {
        body2[kBodyUsed] = false;
        EE.prototype.on.call(body2, "data", function() {
          this[kBodyUsed] = true;
        });
      }
      return body2;
    } else if (body2 && typeof body2.pipeTo === "function") {
      return new BodyAsyncIterable(body2);
    } else if (body2 && typeof body2 !== "string" && !ArrayBuffer.isView(body2) && isIterable(body2)) {
      return new BodyAsyncIterable(body2);
    } else {
      return body2;
    }
  }
  function isStream(obj) {
    return obj && typeof obj === "object" && typeof obj.pipe === "function" && typeof obj.on === "function";
  }
  function isBlobLike(object) {
    if (object === null) {
      return false;
    } else if (object instanceof Blob) {
      return true;
    } else if (typeof object !== "object") {
      return false;
    } else {
      const sTag = object[Symbol.toStringTag];
      return (sTag === "Blob" || sTag === "File") && ("stream" in object && typeof object.stream === "function" || "arrayBuffer" in object && typeof object.arrayBuffer === "function");
    }
  }
  function pathHasQueryOrFragment(url) {
    return url.includes("?") || url.includes("#");
  }
  function serializePathWithQuery(url, queryParams) {
    if (pathHasQueryOrFragment(url)) {
      throw new Error('Query params cannot be passed when url already contains "?" or "#".');
    }
    const stringified = stringify(queryParams);
    if (stringified) {
      url += "?" + stringified;
    }
    return url;
  }
  function isValidPort(port) {
    const value = parseInt(port, 10);
    return value === Number(port) && value >= 0 && value <= 65535;
  }
  function isHttpOrHttpsPrefixed(value) {
    return value != null && value[0] === "h" && value[1] === "t" && value[2] === "t" && value[3] === "p" && (value[4] === ":" || value[4] === "s" && value[5] === ":");
  }
  function parseURL(url) {
    if (typeof url === "string") {
      url = new URL(url);
      if (!isHttpOrHttpsPrefixed(url.origin || url.protocol)) {
        throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
      }
      return url;
    }
    if (!url || typeof url !== "object") {
      throw new InvalidArgumentError("Invalid URL: The URL argument must be a non-null object.");
    }
    if (!(url instanceof URL)) {
      if (url.port != null && url.port !== "" && isValidPort(url.port) === false) {
        throw new InvalidArgumentError("Invalid URL: port must be a valid integer or a string representation of an integer.");
      }
      if (url.path != null && typeof url.path !== "string") {
        throw new InvalidArgumentError("Invalid URL path: the path must be a string or null/undefined.");
      }
      if (url.pathname != null && typeof url.pathname !== "string") {
        throw new InvalidArgumentError("Invalid URL pathname: the pathname must be a string or null/undefined.");
      }
      if (url.hostname != null && typeof url.hostname !== "string") {
        throw new InvalidArgumentError("Invalid URL hostname: the hostname must be a string or null/undefined.");
      }
      if (url.origin != null && typeof url.origin !== "string") {
        throw new InvalidArgumentError("Invalid URL origin: the origin must be a string or null/undefined.");
      }
      if (!isHttpOrHttpsPrefixed(url.origin || url.protocol)) {
        throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
      }
      const port = url.port != null ? url.port : url.protocol === "https:" ? 443 : 80;
      let origin = url.origin != null ? url.origin : `${url.protocol || ""}//${url.hostname || ""}:${port}`;
      let path3 = url.path != null ? url.path : `${url.pathname || ""}${url.search || ""}`;
      if (origin[origin.length - 1] === "/") {
        origin = origin.slice(0, origin.length - 1);
      }
      if (path3 && path3[0] !== "/") {
        path3 = `/${path3}`;
      }
      return new URL(`${origin}${path3}`);
    }
    if (!isHttpOrHttpsPrefixed(url.origin || url.protocol)) {
      throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
    }
    return url;
  }
  function parseOrigin(url) {
    url = parseURL(url);
    if (url.pathname !== "/" || url.search || url.hash) {
      throw new InvalidArgumentError("invalid url");
    }
    return url;
  }
  function getHostname(host) {
    if (host[0] === "[") {
      const idx2 = host.indexOf("]");
      assert(idx2 !== -1);
      return host.substring(1, idx2);
    }
    const idx = host.indexOf(":");
    if (idx === -1) return host;
    return host.substring(0, idx);
  }
  function getServerName(host) {
    if (!host) {
      return null;
    }
    assert(typeof host === "string");
    const servername = getHostname(host);
    if (net$1.isIP(servername)) {
      return "";
    }
    return servername;
  }
  function deepClone(obj) {
    return JSON.parse(JSON.stringify(obj));
  }
  function isAsyncIterable(obj) {
    return !!(obj != null && typeof obj[Symbol.asyncIterator] === "function");
  }
  function isIterable(obj) {
    return !!(obj != null && (typeof obj[Symbol.iterator] === "function" || typeof obj[Symbol.asyncIterator] === "function"));
  }
  function bodyLength(body2) {
    if (body2 == null) {
      return 0;
    } else if (isStream(body2)) {
      const state2 = body2._readableState;
      return state2 && state2.objectMode === false && state2.ended === true && Number.isFinite(state2.length) ? state2.length : null;
    } else if (isBlobLike(body2)) {
      return body2.size != null ? body2.size : null;
    } else if (isBuffer2(body2)) {
      return body2.byteLength;
    }
    return null;
  }
  function isDestroyed(body2) {
    return body2 && !!(body2.destroyed || body2[kDestroyed] || stream.isDestroyed?.(body2));
  }
  function destroy(stream2, err) {
    if (stream2 == null || !isStream(stream2) || isDestroyed(stream2)) {
      return;
    }
    if (typeof stream2.destroy === "function") {
      if (Object.getPrototypeOf(stream2).constructor === IncomingMessage) {
        stream2.socket = null;
      }
      stream2.destroy(err);
    } else if (err) {
      queueMicrotask(() => {
        stream2.emit("error", err);
      });
    }
    if (stream2.destroyed !== true) {
      stream2[kDestroyed] = true;
    }
  }
  const KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
  function parseKeepAliveTimeout(val) {
    const m4 = val.match(KEEPALIVE_TIMEOUT_EXPR);
    return m4 ? parseInt(m4[1], 10) * 1e3 : null;
  }
  function headerNameToString(value) {
    return typeof value === "string" ? headerNameLowerCasedRecord[value] ?? value.toLowerCase() : tree.lookup(value) ?? value.toString("latin1").toLowerCase();
  }
  function bufferToLowerCasedHeaderName(value) {
    return tree.lookup(value) ?? value.toString("latin1").toLowerCase();
  }
  function parseHeaders2(headers2, obj) {
    if (obj === void 0) obj = {};
    for (let i4 = 0; i4 < headers2.length; i4 += 2) {
      const key = headerNameToString(headers2[i4]);
      let val = obj[key];
      if (val) {
        if (typeof val === "string") {
          val = [val];
          obj[key] = val;
        }
        val.push(headers2[i4 + 1].toString("utf8"));
      } else {
        const headersValue = headers2[i4 + 1];
        if (typeof headersValue === "string") {
          obj[key] = headersValue;
        } else {
          obj[key] = Array.isArray(headersValue) ? headersValue.map((x4) => x4.toString("utf8")) : headersValue.toString("utf8");
        }
      }
    }
    if ("content-length" in obj && "content-disposition" in obj) {
      obj["content-disposition"] = Buffer.from(obj["content-disposition"]).toString("latin1");
    }
    return obj;
  }
  function parseRawHeaders(headers2) {
    const headersLength = headers2.length;
    const ret = new Array(headersLength);
    let hasContentLength = false;
    let contentDispositionIdx = -1;
    let key;
    let val;
    let kLen = 0;
    for (let n4 = 0; n4 < headersLength; n4 += 2) {
      key = headers2[n4];
      val = headers2[n4 + 1];
      typeof key !== "string" && (key = key.toString());
      typeof val !== "string" && (val = val.toString("utf8"));
      kLen = key.length;
      if (kLen === 14 && key[7] === "-" && (key === "content-length" || key.toLowerCase() === "content-length")) {
        hasContentLength = true;
      } else if (kLen === 19 && key[7] === "-" && (key === "content-disposition" || key.toLowerCase() === "content-disposition")) {
        contentDispositionIdx = n4 + 1;
      }
      ret[n4] = key;
      ret[n4 + 1] = val;
    }
    if (hasContentLength && contentDispositionIdx !== -1) {
      ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString("latin1");
    }
    return ret;
  }
  function encodeRawHeaders(headers2) {
    if (!Array.isArray(headers2)) {
      throw new TypeError("expected headers to be an array");
    }
    return headers2.map((x4) => Buffer.from(x4));
  }
  function isBuffer2(buffer) {
    return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);
  }
  function assertRequestHandler(handler, method, upgrade) {
    if (!handler || typeof handler !== "object") {
      throw new InvalidArgumentError("handler must be an object");
    }
    if (typeof handler.onRequestStart === "function") {
      return;
    }
    if (typeof handler.onConnect !== "function") {
      throw new InvalidArgumentError("invalid onConnect method");
    }
    if (typeof handler.onError !== "function") {
      throw new InvalidArgumentError("invalid onError method");
    }
    if (typeof handler.onBodySent !== "function" && handler.onBodySent !== void 0) {
      throw new InvalidArgumentError("invalid onBodySent method");
    }
    if (upgrade || method === "CONNECT") {
      if (typeof handler.onUpgrade !== "function") {
        throw new InvalidArgumentError("invalid onUpgrade method");
      }
    } else {
      if (typeof handler.onHeaders !== "function") {
        throw new InvalidArgumentError("invalid onHeaders method");
      }
      if (typeof handler.onData !== "function") {
        throw new InvalidArgumentError("invalid onData method");
      }
      if (typeof handler.onComplete !== "function") {
        throw new InvalidArgumentError("invalid onComplete method");
      }
    }
  }
  function isDisturbed(body2) {
    return !!(body2 && (stream.isDisturbed(body2) || body2[kBodyUsed]));
  }
  function getSocketInfo(socket) {
    return {
      localAddress: socket.localAddress,
      localPort: socket.localPort,
      remoteAddress: socket.remoteAddress,
      remotePort: socket.remotePort,
      remoteFamily: socket.remoteFamily,
      timeout: socket.timeout,
      bytesWritten: socket.bytesWritten,
      bytesRead: socket.bytesRead
    };
  }
  function ReadableStreamFrom(iterable) {
    let iterator;
    return new ReadableStream(
      {
        start() {
          iterator = iterable[Symbol.asyncIterator]();
        },
        pull(controller) {
          return iterator.next().then(({ done, value }) => {
            if (done) {
              return queueMicrotask(() => {
                controller.close();
                controller.byobRequest?.respond(0);
              });
            } else {
              const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);
              if (buf.byteLength) {
                return controller.enqueue(new Uint8Array(buf));
              } else {
                return this.pull(controller);
              }
            }
          });
        },
        cancel() {
          return iterator.return();
        },
        type: "bytes"
      }
    );
  }
  function isFormDataLike(object) {
    return object && typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && object[Symbol.toStringTag] === "FormData";
  }
  function addAbortListener(signal, listener) {
    if ("addEventListener" in signal) {
      signal.addEventListener("abort", listener, { once: true });
      return () => signal.removeEventListener("abort", listener);
    }
    signal.once("abort", listener);
    return () => signal.removeListener("abort", listener);
  }
  const validTokenChars = new Uint8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    // 0-15
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    // 16-31
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    // 32-47 (!"#$%&'()*+,-./)
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    // 48-63 (0-9:;<=>?)
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    // 64-79 (@A-O)
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    // 80-95 (P-Z[\]^_)
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    // 96-111 (`a-o)
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0,
    // 112-127 (p-z{|}~)
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    // 128-143
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    // 144-159
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    // 160-175
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    // 176-191
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    // 192-207
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    // 208-223
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    // 224-239
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
    // 240-255
  ]);
  function isTokenCharCode(c4) {
    return validTokenChars[c4] === 1;
  }
  const tokenRegExp = /^[\^_`a-zA-Z\-0-9!#$%&'*+.|~]+$/;
  function isValidHTTPToken(characters) {
    if (characters.length >= 12) return tokenRegExp.test(characters);
    if (characters.length === 0) return false;
    for (let i4 = 0; i4 < characters.length; i4++) {
      if (validTokenChars[characters.charCodeAt(i4)] !== 1) {
        return false;
      }
    }
    return true;
  }
  const headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
  function isValidHeaderValue(characters) {
    return !headerCharRegex.test(characters);
  }
  const rangeHeaderRegex = /^bytes (\d+)-(\d+)\/(\d+)?$/;
  function parseRangeHeader(range2) {
    if (range2 == null || range2 === "") return { start: 0, end: null, size: null };
    const m4 = range2 ? range2.match(rangeHeaderRegex) : null;
    return m4 ? {
      start: parseInt(m4[1]),
      end: m4[2] ? parseInt(m4[2]) : null,
      size: m4[3] ? parseInt(m4[3]) : null
    } : null;
  }
  function addListener(obj, name, listener) {
    const listeners = obj[kListeners] ??= [];
    listeners.push([name, listener]);
    obj.on(name, listener);
    return obj;
  }
  function removeAllListeners(obj) {
    if (obj[kListeners] != null) {
      for (const [name, listener] of obj[kListeners]) {
        obj.removeListener(name, listener);
      }
      obj[kListeners] = null;
    }
    return obj;
  }
  function errorRequest(client2, request2, err) {
    try {
      request2.onError(err);
      assert(request2.aborted);
    } catch (err2) {
      client2.emit("error", err2);
    }
  }
  const setupConnectTimeout = process.platform === "win32" ? (socketWeakRef, opts) => {
    if (!opts.timeout) {
      return noop2;
    }
    let s1 = null;
    let s22 = null;
    const fastTimer = timers2.setFastTimeout(() => {
      s1 = setImmediate(() => {
        s22 = setImmediate(() => onConnectTimeout(socketWeakRef.deref(), opts));
      });
    }, opts.timeout);
    return () => {
      timers2.clearFastTimeout(fastTimer);
      clearImmediate(s1);
      clearImmediate(s22);
    };
  } : (socketWeakRef, opts) => {
    if (!opts.timeout) {
      return noop2;
    }
    let s1 = null;
    const fastTimer = timers2.setFastTimeout(() => {
      s1 = setImmediate(() => {
        onConnectTimeout(socketWeakRef.deref(), opts);
      });
    }, opts.timeout);
    return () => {
      timers2.clearFastTimeout(fastTimer);
      clearImmediate(s1);
    };
  };
  function onConnectTimeout(socket, opts) {
    if (socket == null) {
      return;
    }
    let message = "Connect Timeout Error";
    if (Array.isArray(socket.autoSelectFamilyAttemptedAddresses)) {
      message += ` (attempted addresses: ${socket.autoSelectFamilyAttemptedAddresses.join(", ")},`;
    } else {
      message += ` (attempted address: ${opts.hostname}:${opts.port},`;
    }
    message += ` timeout: ${opts.timeout}ms)`;
    destroy(socket, new ConnectTimeoutError(message));
  }
  function getProtocolFromUrlString(urlString) {
    if (urlString[0] === "h" && urlString[1] === "t" && urlString[2] === "t" && urlString[3] === "p") {
      switch (urlString[4]) {
        case ":":
          return "http:";
        case "s":
          if (urlString[5] === ":") {
            return "https:";
          }
      }
    }
    return urlString.slice(0, urlString.indexOf(":") + 1);
  }
  const kEnumerableProperty = /* @__PURE__ */ Object.create(null);
  kEnumerableProperty.enumerable = true;
  const normalizedMethodRecordsBase = {
    delete: "DELETE",
    DELETE: "DELETE",
    get: "GET",
    GET: "GET",
    head: "HEAD",
    HEAD: "HEAD",
    options: "OPTIONS",
    OPTIONS: "OPTIONS",
    post: "POST",
    POST: "POST",
    put: "PUT",
    PUT: "PUT"
  };
  const normalizedMethodRecords = {
    ...normalizedMethodRecordsBase,
    patch: "patch",
    PATCH: "PATCH"
  };
  Object.setPrototypeOf(normalizedMethodRecordsBase, null);
  Object.setPrototypeOf(normalizedMethodRecords, null);
  util$5 = {
    kEnumerableProperty,
    isDisturbed,
    isBlobLike,
    parseOrigin,
    parseURL,
    getServerName,
    isStream,
    isIterable,
    isAsyncIterable,
    isDestroyed,
    headerNameToString,
    bufferToLowerCasedHeaderName,
    addListener,
    removeAllListeners,
    errorRequest,
    parseRawHeaders,
    encodeRawHeaders,
    parseHeaders: parseHeaders2,
    parseKeepAliveTimeout,
    destroy,
    bodyLength,
    deepClone,
    ReadableStreamFrom,
    isBuffer: isBuffer2,
    assertRequestHandler,
    getSocketInfo,
    isFormDataLike,
    pathHasQueryOrFragment,
    serializePathWithQuery,
    addAbortListener,
    isValidHTTPToken,
    isValidHeaderValue,
    isTokenCharCode,
    parseRangeHeader,
    normalizedMethodRecordsBase,
    normalizedMethodRecords,
    isValidPort,
    isHttpOrHttpsPrefixed,
    nodeMajor,
    nodeMinor,
    safeHTTPMethods: Object.freeze(["GET", "HEAD", "OPTIONS", "TRACE"]),
    wrapRequestBody,
    setupConnectTimeout,
    getProtocolFromUrlString
  };
  return util$5;
}
var stats;
var hasRequiredStats;
function requireStats() {
  if (hasRequiredStats) return stats;
  hasRequiredStats = 1;
  const {
    kConnected,
    kPending,
    kRunning,
    kSize,
    kFree,
    kQueued
  } = requireSymbols();
  class ClientStats {
    constructor(client2) {
      this.connected = client2[kConnected];
      this.pending = client2[kPending];
      this.running = client2[kRunning];
      this.size = client2[kSize];
    }
  }
  class PoolStats {
    constructor(pool3) {
      this.connected = pool3[kConnected];
      this.free = pool3[kFree];
      this.pending = pool3[kPending];
      this.queued = pool3[kQueued];
      this.running = pool3[kRunning];
      this.size = pool3[kSize];
    }
  }
  stats = { ClientStats, PoolStats };
  return stats;
}
var diagnostics;
var hasRequiredDiagnostics;
function requireDiagnostics() {
  if (hasRequiredDiagnostics) return diagnostics;
  hasRequiredDiagnostics = 1;
  const diagnosticsChannel = import_node_diagnostics_channel.default;
  const util2 = import_node_util.default;
  const undiciDebugLog = util2.debuglog("undici");
  const fetchDebuglog = util2.debuglog("fetch");
  const websocketDebuglog = util2.debuglog("websocket");
  const channels = {
    // Client
    beforeConnect: diagnosticsChannel.channel("undici:client:beforeConnect"),
    connected: diagnosticsChannel.channel("undici:client:connected"),
    connectError: diagnosticsChannel.channel("undici:client:connectError"),
    sendHeaders: diagnosticsChannel.channel("undici:client:sendHeaders"),
    // Request
    create: diagnosticsChannel.channel("undici:request:create"),
    bodySent: diagnosticsChannel.channel("undici:request:bodySent"),
    bodyChunkSent: diagnosticsChannel.channel("undici:request:bodyChunkSent"),
    bodyChunkReceived: diagnosticsChannel.channel("undici:request:bodyChunkReceived"),
    headers: diagnosticsChannel.channel("undici:request:headers"),
    trailers: diagnosticsChannel.channel("undici:request:trailers"),
    error: diagnosticsChannel.channel("undici:request:error"),
    // WebSocket
    open: diagnosticsChannel.channel("undici:websocket:open"),
    close: diagnosticsChannel.channel("undici:websocket:close"),
    socketError: diagnosticsChannel.channel("undici:websocket:socket_error"),
    ping: diagnosticsChannel.channel("undici:websocket:ping"),
    pong: diagnosticsChannel.channel("undici:websocket:pong"),
    // ProxyAgent
    proxyConnected: diagnosticsChannel.channel("undici:proxy:connected")
  };
  let isTrackingClientEvents = false;
  function trackClientEvents(debugLog = undiciDebugLog) {
    if (isTrackingClientEvents) {
      return;
    }
    if (channels.beforeConnect.hasSubscribers || channels.connected.hasSubscribers || channels.connectError.hasSubscribers || channels.sendHeaders.hasSubscribers) {
      isTrackingClientEvents = true;
      return;
    }
    isTrackingClientEvents = true;
    diagnosticsChannel.subscribe(
      "undici:client:beforeConnect",
      (evt) => {
        const {
          connectParams: { version, protocol, port, host }
        } = evt;
        debugLog(
          "connecting to %s%s using %s%s",
          host,
          port ? `:${port}` : "",
          protocol,
          version
        );
      }
    );
    diagnosticsChannel.subscribe(
      "undici:client:connected",
      (evt) => {
        const {
          connectParams: { version, protocol, port, host }
        } = evt;
        debugLog(
          "connected to %s%s using %s%s",
          host,
          port ? `:${port}` : "",
          protocol,
          version
        );
      }
    );
    diagnosticsChannel.subscribe(
      "undici:client:connectError",
      (evt) => {
        const {
          connectParams: { version, protocol, port, host },
          error: error2
        } = evt;
        debugLog(
          "connection to %s%s using %s%s errored - %s",
          host,
          port ? `:${port}` : "",
          protocol,
          version,
          error2.message
        );
      }
    );
    diagnosticsChannel.subscribe(
      "undici:client:sendHeaders",
      (evt) => {
        const {
          request: { method, path: path3, origin }
        } = evt;
        debugLog("sending request to %s %s%s", method, origin, path3);
      }
    );
  }
  let isTrackingRequestEvents = false;
  function trackRequestEvents(debugLog = undiciDebugLog) {
    if (isTrackingRequestEvents) {
      return;
    }
    if (channels.headers.hasSubscribers || channels.trailers.hasSubscribers || channels.error.hasSubscribers) {
      isTrackingRequestEvents = true;
      return;
    }
    isTrackingRequestEvents = true;
    diagnosticsChannel.subscribe(
      "undici:request:headers",
      (evt) => {
        const {
          request: { method, path: path3, origin },
          response: { statusCode }
        } = evt;
        debugLog(
          "received response to %s %s%s - HTTP %d",
          method,
          origin,
          path3,
          statusCode
        );
      }
    );
    diagnosticsChannel.subscribe(
      "undici:request:trailers",
      (evt) => {
        const {
          request: { method, path: path3, origin }
        } = evt;
        debugLog("trailers received from %s %s%s", method, origin, path3);
      }
    );
    diagnosticsChannel.subscribe(
      "undici:request:error",
      (evt) => {
        const {
          request: { method, path: path3, origin },
          error: error2
        } = evt;
        debugLog(
          "request to %s %s%s errored - %s",
          method,
          origin,
          path3,
          error2.message
        );
      }
    );
  }
  let isTrackingWebSocketEvents = false;
  function trackWebSocketEvents(debugLog = websocketDebuglog) {
    if (isTrackingWebSocketEvents) {
      return;
    }
    if (channels.open.hasSubscribers || channels.close.hasSubscribers || channels.socketError.hasSubscribers || channels.ping.hasSubscribers || channels.pong.hasSubscribers) {
      isTrackingWebSocketEvents = true;
      return;
    }
    isTrackingWebSocketEvents = true;
    diagnosticsChannel.subscribe(
      "undici:websocket:open",
      (evt) => {
        const {
          address: { address, port }
        } = evt;
        debugLog("connection opened %s%s", address, port ? `:${port}` : "");
      }
    );
    diagnosticsChannel.subscribe(
      "undici:websocket:close",
      (evt) => {
        const { websocket: websocket2, code, reason } = evt;
        debugLog(
          "closed connection to %s - %s %s",
          websocket2.url,
          code,
          reason
        );
      }
    );
    diagnosticsChannel.subscribe(
      "undici:websocket:socket_error",
      (err) => {
        debugLog("connection errored - %s", err.message);
      }
    );
    diagnosticsChannel.subscribe(
      "undici:websocket:ping",
      (evt) => {
        debugLog("ping received");
      }
    );
    diagnosticsChannel.subscribe(
      "undici:websocket:pong",
      (evt) => {
        debugLog("pong received");
      }
    );
  }
  if (undiciDebugLog.enabled || fetchDebuglog.enabled) {
    trackClientEvents(fetchDebuglog.enabled ? fetchDebuglog : undiciDebugLog);
    trackRequestEvents(fetchDebuglog.enabled ? fetchDebuglog : undiciDebugLog);
  }
  if (websocketDebuglog.enabled) {
    trackClientEvents(undiciDebugLog.enabled ? undiciDebugLog : websocketDebuglog);
    trackWebSocketEvents(websocketDebuglog);
  }
  diagnostics = {
    channels
  };
  return diagnostics;
}
var request$1;
var hasRequiredRequest$1;
function requireRequest$1() {
  if (hasRequiredRequest$1) return request$1;
  hasRequiredRequest$1 = 1;
  const {
    InvalidArgumentError,
    NotSupportedError
  } = requireErrors();
  const assert = import_node_assert.default;
  const {
    isValidHTTPToken,
    isValidHeaderValue,
    isStream,
    destroy,
    isBuffer: isBuffer2,
    isFormDataLike,
    isIterable,
    isBlobLike,
    serializePathWithQuery,
    assertRequestHandler,
    getServerName,
    normalizedMethodRecords,
    getProtocolFromUrlString
  } = requireUtil$5();
  const { channels } = requireDiagnostics();
  const { headerNameLowerCasedRecord } = requireConstants$4();
  const invalidPathRegex = /[^\u0021-\u00ff]/;
  const kHandler = /* @__PURE__ */ Symbol("handler");
  class Request2 {
    constructor(origin, {
      path: path3,
      method,
      body: body2,
      headers: headers2,
      query,
      idempotent,
      blocking,
      upgrade,
      headersTimeout,
      bodyTimeout,
      reset,
      expectContinue,
      servername,
      throwOnError,
      maxRedirections
    }, handler) {
      if (typeof path3 !== "string") {
        throw new InvalidArgumentError("path must be a string");
      } else if (path3[0] !== "/" && !(path3.startsWith("http://") || path3.startsWith("https://")) && method !== "CONNECT") {
        throw new InvalidArgumentError("path must be an absolute URL or start with a slash");
      } else if (invalidPathRegex.test(path3)) {
        throw new InvalidArgumentError("invalid request path");
      }
      if (typeof method !== "string") {
        throw new InvalidArgumentError("method must be a string");
      } else if (normalizedMethodRecords[method] === void 0 && !isValidHTTPToken(method)) {
        throw new InvalidArgumentError("invalid request method");
      }
      if (upgrade && typeof upgrade !== "string") {
        throw new InvalidArgumentError("upgrade must be a string");
      }
      if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {
        throw new InvalidArgumentError("invalid headersTimeout");
      }
      if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {
        throw new InvalidArgumentError("invalid bodyTimeout");
      }
      if (reset != null && typeof reset !== "boolean") {
        throw new InvalidArgumentError("invalid reset");
      }
      if (expectContinue != null && typeof expectContinue !== "boolean") {
        throw new InvalidArgumentError("invalid expectContinue");
      }
      if (throwOnError != null) {
        throw new InvalidArgumentError("invalid throwOnError");
      }
      if (maxRedirections != null && maxRedirections !== 0) {
        throw new InvalidArgumentError("maxRedirections is not supported, use the redirect interceptor");
      }
      this.headersTimeout = headersTimeout;
      this.bodyTimeout = bodyTimeout;
      this.method = method;
      this.abort = null;
      if (body2 == null) {
        this.body = null;
      } else if (isStream(body2)) {
        this.body = body2;
        const rState = this.body._readableState;
        if (!rState || !rState.autoDestroy) {
          this.endHandler = function autoDestroy() {
            destroy(this);
          };
          this.body.on("end", this.endHandler);
        }
        this.errorHandler = (err) => {
          if (this.abort) {
            this.abort(err);
          } else {
            this.error = err;
          }
        };
        this.body.on("error", this.errorHandler);
      } else if (isBuffer2(body2)) {
        this.body = body2.byteLength ? body2 : null;
      } else if (ArrayBuffer.isView(body2)) {
        this.body = body2.buffer.byteLength ? Buffer.from(body2.buffer, body2.byteOffset, body2.byteLength) : null;
      } else if (body2 instanceof ArrayBuffer) {
        this.body = body2.byteLength ? Buffer.from(body2) : null;
      } else if (typeof body2 === "string") {
        this.body = body2.length ? Buffer.from(body2) : null;
      } else if (isFormDataLike(body2) || isIterable(body2) || isBlobLike(body2)) {
        this.body = body2;
      } else {
        throw new InvalidArgumentError("body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable");
      }
      this.completed = false;
      this.aborted = false;
      this.upgrade = upgrade || null;
      this.path = query ? serializePathWithQuery(path3, query) : path3;
      this.origin = origin;
      this.protocol = getProtocolFromUrlString(origin);
      this.idempotent = idempotent == null ? method === "HEAD" || method === "GET" : idempotent;
      this.blocking = blocking ?? this.method !== "HEAD";
      this.reset = reset == null ? null : reset;
      this.host = null;
      this.contentLength = null;
      this.contentType = null;
      this.headers = [];
      this.expectContinue = expectContinue != null ? expectContinue : false;
      if (Array.isArray(headers2)) {
        if (headers2.length % 2 !== 0) {
          throw new InvalidArgumentError("headers array must be even");
        }
        for (let i4 = 0; i4 < headers2.length; i4 += 2) {
          processHeader(this, headers2[i4], headers2[i4 + 1]);
        }
      } else if (headers2 && typeof headers2 === "object") {
        if (headers2[Symbol.iterator]) {
          for (const header of headers2) {
            if (!Array.isArray(header) || header.length !== 2) {
              throw new InvalidArgumentError("headers must be in key-value pair format");
            }
            processHeader(this, header[0], header[1]);
          }
        } else {
          const keys2 = Object.keys(headers2);
          for (let i4 = 0; i4 < keys2.length; ++i4) {
            processHeader(this, keys2[i4], headers2[keys2[i4]]);
          }
        }
      } else if (headers2 != null) {
        throw new InvalidArgumentError("headers must be an object or an array");
      }
      assertRequestHandler(handler, method, upgrade);
      this.servername = servername || getServerName(this.host) || null;
      this[kHandler] = handler;
      if (channels.create.hasSubscribers) {
        channels.create.publish({ request: this });
      }
    }
    onBodySent(chunk2) {
      if (channels.bodyChunkSent.hasSubscribers) {
        channels.bodyChunkSent.publish({ request: this, chunk: chunk2 });
      }
      if (this[kHandler].onBodySent) {
        try {
          return this[kHandler].onBodySent(chunk2);
        } catch (err) {
          this.abort(err);
        }
      }
    }
    onRequestSent() {
      if (channels.bodySent.hasSubscribers) {
        channels.bodySent.publish({ request: this });
      }
      if (this[kHandler].onRequestSent) {
        try {
          return this[kHandler].onRequestSent();
        } catch (err) {
          this.abort(err);
        }
      }
    }
    onConnect(abort) {
      assert(!this.aborted);
      assert(!this.completed);
      if (this.error) {
        abort(this.error);
      } else {
        this.abort = abort;
        return this[kHandler].onConnect(abort);
      }
    }
    onResponseStarted() {
      return this[kHandler].onResponseStarted?.();
    }
    onHeaders(statusCode, headers2, resume, statusText) {
      assert(!this.aborted);
      assert(!this.completed);
      if (channels.headers.hasSubscribers) {
        channels.headers.publish({ request: this, response: { statusCode, headers: headers2, statusText } });
      }
      try {
        return this[kHandler].onHeaders(statusCode, headers2, resume, statusText);
      } catch (err) {
        this.abort(err);
      }
    }
    onData(chunk2) {
      assert(!this.aborted);
      assert(!this.completed);
      if (channels.bodyChunkReceived.hasSubscribers) {
        channels.bodyChunkReceived.publish({ request: this, chunk: chunk2 });
      }
      try {
        return this[kHandler].onData(chunk2);
      } catch (err) {
        this.abort(err);
        return false;
      }
    }
    onUpgrade(statusCode, headers2, socket) {
      assert(!this.aborted);
      assert(!this.completed);
      return this[kHandler].onUpgrade(statusCode, headers2, socket);
    }
    onComplete(trailers) {
      this.onFinally();
      assert(!this.aborted);
      assert(!this.completed);
      this.completed = true;
      if (channels.trailers.hasSubscribers) {
        channels.trailers.publish({ request: this, trailers });
      }
      try {
        return this[kHandler].onComplete(trailers);
      } catch (err) {
        this.onError(err);
      }
    }
    onError(error2) {
      this.onFinally();
      if (channels.error.hasSubscribers) {
        channels.error.publish({ request: this, error: error2 });
      }
      if (this.aborted) {
        return;
      }
      this.aborted = true;
      return this[kHandler].onError(error2);
    }
    onFinally() {
      if (this.errorHandler) {
        this.body.off("error", this.errorHandler);
        this.errorHandler = null;
      }
      if (this.endHandler) {
        this.body.off("end", this.endHandler);
        this.endHandler = null;
      }
    }
    addHeader(key, value) {
      processHeader(this, key, value);
      return this;
    }
  }
  function processHeader(request2, key, val) {
    if (val && (typeof val === "object" && !Array.isArray(val))) {
      throw new InvalidArgumentError(`invalid ${key} header`);
    } else if (val === void 0) {
      return;
    }
    let headerName = headerNameLowerCasedRecord[key];
    if (headerName === void 0) {
      headerName = key.toLowerCase();
      if (headerNameLowerCasedRecord[headerName] === void 0 && !isValidHTTPToken(headerName)) {
        throw new InvalidArgumentError("invalid header key");
      }
    }
    if (Array.isArray(val)) {
      const arr = [];
      for (let i4 = 0; i4 < val.length; i4++) {
        if (typeof val[i4] === "string") {
          if (!isValidHeaderValue(val[i4])) {
            throw new InvalidArgumentError(`invalid ${key} header`);
          }
          arr.push(val[i4]);
        } else if (val[i4] === null) {
          arr.push("");
        } else if (typeof val[i4] === "object") {
          throw new InvalidArgumentError(`invalid ${key} header`);
        } else {
          arr.push(`${val[i4]}`);
        }
      }
      val = arr;
    } else if (typeof val === "string") {
      if (!isValidHeaderValue(val)) {
        throw new InvalidArgumentError(`invalid ${key} header`);
      }
    } else if (val === null) {
      val = "";
    } else {
      val = `${val}`;
    }
    if (request2.host === null && headerName === "host") {
      if (typeof val !== "string") {
        throw new InvalidArgumentError("invalid host header");
      }
      request2.host = val;
    } else if (request2.contentLength === null && headerName === "content-length") {
      request2.contentLength = parseInt(val, 10);
      if (!Number.isFinite(request2.contentLength)) {
        throw new InvalidArgumentError("invalid content-length header");
      }
    } else if (request2.contentType === null && headerName === "content-type") {
      request2.contentType = val;
      request2.headers.push(key, val);
    } else if (headerName === "transfer-encoding" || headerName === "keep-alive" || headerName === "upgrade") {
      throw new InvalidArgumentError(`invalid ${headerName} header`);
    } else if (headerName === "connection") {
      const value = typeof val === "string" ? val.toLowerCase() : null;
      if (value !== "close" && value !== "keep-alive") {
        throw new InvalidArgumentError("invalid connection header");
      }
      if (value === "close") {
        request2.reset = true;
      }
    } else if (headerName === "expect") {
      throw new NotSupportedError("expect header not supported");
    } else {
      request2.headers.push(key, val);
    }
  }
  request$1 = Request2;
  return request$1;
}
var wrapHandler;
var hasRequiredWrapHandler;
function requireWrapHandler() {
  if (hasRequiredWrapHandler) return wrapHandler;
  hasRequiredWrapHandler = 1;
  const { InvalidArgumentError } = requireErrors();
  wrapHandler = class WrapHandler {
    #handler;
    constructor(handler) {
      this.#handler = handler;
    }
    static wrap(handler) {
      return handler.onRequestStart ? handler : new WrapHandler(handler);
    }
    // Unwrap Interface
    onConnect(abort, context) {
      return this.#handler.onConnect?.(abort, context);
    }
    onHeaders(statusCode, rawHeaders, resume, statusMessage) {
      return this.#handler.onHeaders?.(statusCode, rawHeaders, resume, statusMessage);
    }
    onUpgrade(statusCode, rawHeaders, socket) {
      return this.#handler.onUpgrade?.(statusCode, rawHeaders, socket);
    }
    onData(data2) {
      return this.#handler.onData?.(data2);
    }
    onComplete(trailers) {
      return this.#handler.onComplete?.(trailers);
    }
    onError(err) {
      if (!this.#handler.onError) {
        throw err;
      }
      return this.#handler.onError?.(err);
    }
    // Wrap Interface
    onRequestStart(controller, context) {
      this.#handler.onConnect?.((reason) => controller.abort(reason), context);
    }
    onRequestUpgrade(controller, statusCode, headers2, socket) {
      const rawHeaders = [];
      for (const [key, val] of Object.entries(headers2)) {
        rawHeaders.push(Buffer.from(key), Array.isArray(val) ? val.map((v4) => Buffer.from(v4)) : Buffer.from(val));
      }
      this.#handler.onUpgrade?.(statusCode, rawHeaders, socket);
    }
    onResponseStart(controller, statusCode, headers2, statusMessage) {
      const rawHeaders = [];
      for (const [key, val] of Object.entries(headers2)) {
        rawHeaders.push(Buffer.from(key), Array.isArray(val) ? val.map((v4) => Buffer.from(v4)) : Buffer.from(val));
      }
      if (this.#handler.onHeaders?.(statusCode, rawHeaders, () => controller.resume(), statusMessage) === false) {
        controller.pause();
      }
    }
    onResponseData(controller, data2) {
      if (this.#handler.onData?.(data2) === false) {
        controller.pause();
      }
    }
    onResponseEnd(controller, trailers) {
      const rawTrailers = [];
      for (const [key, val] of Object.entries(trailers)) {
        rawTrailers.push(Buffer.from(key), Array.isArray(val) ? val.map((v4) => Buffer.from(v4)) : Buffer.from(val));
      }
      this.#handler.onComplete?.(rawTrailers);
    }
    onResponseError(controller, err) {
      if (!this.#handler.onError) {
        throw new InvalidArgumentError("invalid onError method");
      }
      this.#handler.onError?.(err);
    }
  };
  return wrapHandler;
}
var dispatcher;
var hasRequiredDispatcher;
function requireDispatcher() {
  if (hasRequiredDispatcher) return dispatcher;
  hasRequiredDispatcher = 1;
  const EventEmitter2 = import_node_events.default;
  const WrapHandler = requireWrapHandler();
  const wrapInterceptor = (dispatch) => (opts, handler) => dispatch(opts, WrapHandler.wrap(handler));
  class Dispatcher extends EventEmitter2 {
    dispatch() {
      throw new Error("not implemented");
    }
    close() {
      throw new Error("not implemented");
    }
    destroy() {
      throw new Error("not implemented");
    }
    compose(...args) {
      const interceptors = Array.isArray(args[0]) ? args[0] : args;
      let dispatch = this.dispatch.bind(this);
      for (const interceptor of interceptors) {
        if (interceptor == null) {
          continue;
        }
        if (typeof interceptor !== "function") {
          throw new TypeError(`invalid interceptor, expected function received ${typeof interceptor}`);
        }
        dispatch = interceptor(dispatch);
        dispatch = wrapInterceptor(dispatch);
        if (dispatch == null || typeof dispatch !== "function" || dispatch.length !== 2) {
          throw new TypeError("invalid interceptor");
        }
      }
      return new Proxy(this, {
        get: (target, key) => key === "dispatch" ? dispatch : target[key]
      });
    }
  }
  dispatcher = Dispatcher;
  return dispatcher;
}
var unwrapHandler;
var hasRequiredUnwrapHandler;
function requireUnwrapHandler() {
  if (hasRequiredUnwrapHandler) return unwrapHandler;
  hasRequiredUnwrapHandler = 1;
  const { parseHeaders: parseHeaders2 } = requireUtil$5();
  const { InvalidArgumentError } = requireErrors();
  const kResume = /* @__PURE__ */ Symbol("resume");
  class UnwrapController {
    #paused = false;
    #reason = null;
    #aborted = false;
    #abort;
    [kResume] = null;
    constructor(abort) {
      this.#abort = abort;
    }
    pause() {
      this.#paused = true;
    }
    resume() {
      if (this.#paused) {
        this.#paused = false;
        this[kResume]?.();
      }
    }
    abort(reason) {
      if (!this.#aborted) {
        this.#aborted = true;
        this.#reason = reason;
        this.#abort(reason);
      }
    }
    get aborted() {
      return this.#aborted;
    }
    get reason() {
      return this.#reason;
    }
    get paused() {
      return this.#paused;
    }
  }
  unwrapHandler = class UnwrapHandler {
    #handler;
    #controller;
    constructor(handler) {
      this.#handler = handler;
    }
    static unwrap(handler) {
      return !handler.onRequestStart ? handler : new UnwrapHandler(handler);
    }
    onConnect(abort, context) {
      this.#controller = new UnwrapController(abort);
      this.#handler.onRequestStart?.(this.#controller, context);
    }
    onUpgrade(statusCode, rawHeaders, socket) {
      this.#handler.onRequestUpgrade?.(this.#controller, statusCode, parseHeaders2(rawHeaders), socket);
    }
    onHeaders(statusCode, rawHeaders, resume, statusMessage) {
      this.#controller[kResume] = resume;
      this.#handler.onResponseStart?.(this.#controller, statusCode, parseHeaders2(rawHeaders), statusMessage);
      return !this.#controller.paused;
    }
    onData(data2) {
      this.#handler.onResponseData?.(this.#controller, data2);
      return !this.#controller.paused;
    }
    onComplete(rawTrailers) {
      this.#handler.onResponseEnd?.(this.#controller, parseHeaders2(rawTrailers));
    }
    onError(err) {
      if (!this.#handler.onResponseError) {
        throw new InvalidArgumentError("invalid onError method");
      }
      this.#handler.onResponseError?.(this.#controller, err);
    }
  };
  return unwrapHandler;
}
var dispatcherBase;
var hasRequiredDispatcherBase;
function requireDispatcherBase() {
  if (hasRequiredDispatcherBase) return dispatcherBase;
  hasRequiredDispatcherBase = 1;
  const Dispatcher = requireDispatcher();
  const UnwrapHandler = requireUnwrapHandler();
  const {
    ClientDestroyedError,
    ClientClosedError,
    InvalidArgumentError
  } = requireErrors();
  const { kDestroy, kClose, kClosed, kDestroyed, kDispatch } = requireSymbols();
  const kOnDestroyed = /* @__PURE__ */ Symbol("onDestroyed");
  const kOnClosed = /* @__PURE__ */ Symbol("onClosed");
  class DispatcherBase extends Dispatcher {
    /** @type {boolean} */
    [kDestroyed] = false;
    /** @type {Array<Function|null} */
    [kOnDestroyed] = null;
    /** @type {boolean} */
    [kClosed] = false;
    /** @type {Array<Function>|null} */
    [kOnClosed] = null;
    /** @returns {boolean} */
    get destroyed() {
      return this[kDestroyed];
    }
    /** @returns {boolean} */
    get closed() {
      return this[kClosed];
    }
    close(callback) {
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          this.close((err, data2) => {
            return err ? reject(err) : resolve(data2);
          });
        });
      }
      if (typeof callback !== "function") {
        throw new InvalidArgumentError("invalid callback");
      }
      if (this[kDestroyed]) {
        const err = new ClientDestroyedError();
        queueMicrotask(() => callback(err, null));
        return;
      }
      if (this[kClosed]) {
        if (this[kOnClosed]) {
          this[kOnClosed].push(callback);
        } else {
          queueMicrotask(() => callback(null, null));
        }
        return;
      }
      this[kClosed] = true;
      this[kOnClosed] ??= [];
      this[kOnClosed].push(callback);
      const onClosed = () => {
        const callbacks = this[kOnClosed];
        this[kOnClosed] = null;
        for (let i4 = 0; i4 < callbacks.length; i4++) {
          callbacks[i4](null, null);
        }
      };
      this[kClose]().then(() => this.destroy()).then(() => queueMicrotask(onClosed));
    }
    destroy(err, callback) {
      if (typeof err === "function") {
        callback = err;
        err = null;
      }
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          this.destroy(err, (err2, data2) => {
            return err2 ? reject(err2) : resolve(data2);
          });
        });
      }
      if (typeof callback !== "function") {
        throw new InvalidArgumentError("invalid callback");
      }
      if (this[kDestroyed]) {
        if (this[kOnDestroyed]) {
          this[kOnDestroyed].push(callback);
        } else {
          queueMicrotask(() => callback(null, null));
        }
        return;
      }
      if (!err) {
        err = new ClientDestroyedError();
      }
      this[kDestroyed] = true;
      this[kOnDestroyed] ??= [];
      this[kOnDestroyed].push(callback);
      const onDestroyed = () => {
        const callbacks = this[kOnDestroyed];
        this[kOnDestroyed] = null;
        for (let i4 = 0; i4 < callbacks.length; i4++) {
          callbacks[i4](null, null);
        }
      };
      this[kDestroy](err).then(() => queueMicrotask(onDestroyed));
    }
    dispatch(opts, handler) {
      if (!handler || typeof handler !== "object") {
        throw new InvalidArgumentError("handler must be an object");
      }
      handler = UnwrapHandler.unwrap(handler);
      try {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("opts must be an object.");
        }
        if (this[kDestroyed] || this[kOnDestroyed]) {
          throw new ClientDestroyedError();
        }
        if (this[kClosed]) {
          throw new ClientClosedError();
        }
        return this[kDispatch](opts, handler);
      } catch (err) {
        if (typeof handler.onError !== "function") {
          throw err;
        }
        handler.onError(err);
        return false;
      }
    }
  }
  dispatcherBase = DispatcherBase;
  return dispatcherBase;
}
var connect;
var hasRequiredConnect;
function requireConnect() {
  if (hasRequiredConnect) return connect;
  hasRequiredConnect = 1;
  const net$1 = import_node_net.default;
  const assert = import_node_assert.default;
  const util2 = requireUtil$5();
  const { InvalidArgumentError } = requireErrors();
  let tls;
  const SessionCache = class WeakSessionCache {
    constructor(maxCachedSessions) {
      this._maxCachedSessions = maxCachedSessions;
      this._sessionCache = /* @__PURE__ */ new Map();
      this._sessionRegistry = new FinalizationRegistry((key) => {
        if (this._sessionCache.size < this._maxCachedSessions) {
          return;
        }
        const ref = this._sessionCache.get(key);
        if (ref !== void 0 && ref.deref() === void 0) {
          this._sessionCache.delete(key);
        }
      });
    }
    get(sessionKey) {
      const ref = this._sessionCache.get(sessionKey);
      return ref ? ref.deref() : null;
    }
    set(sessionKey, session) {
      if (this._maxCachedSessions === 0) {
        return;
      }
      this._sessionCache.set(sessionKey, new WeakRef(session));
      this._sessionRegistry.register(session, sessionKey);
    }
  };
  function buildConnector({ allowH2, useH2c, maxCachedSessions, socketPath, timeout, session: customSession, ...opts }) {
    if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {
      throw new InvalidArgumentError("maxCachedSessions must be a positive integer or zero");
    }
    const options = { path: socketPath, ...opts };
    const sessionCache2 = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions);
    timeout = timeout == null ? 1e4 : timeout;
    allowH2 = allowH2 != null ? allowH2 : false;
    return function connect2({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {
      let socket;
      if (protocol === "https:") {
        if (!tls) {
          tls = import_node_tls.default;
        }
        servername = servername || options.servername || util2.getServerName(host) || null;
        const sessionKey = servername || hostname;
        assert(sessionKey);
        const session = customSession || sessionCache2.get(sessionKey) || null;
        port = port || 443;
        socket = tls.connect({
          highWaterMark: 16384,
          // TLS in node can't have bigger HWM anyway...
          ...options,
          servername,
          session,
          localAddress,
          ALPNProtocols: allowH2 ? ["http/1.1", "h2"] : ["http/1.1"],
          socket: httpSocket,
          // upgrade socket connection
          port,
          host: hostname
        });
        socket.on("session", function(session2) {
          sessionCache2.set(sessionKey, session2);
        });
      } else {
        assert(!httpSocket, "httpSocket can only be sent on TLS update");
        port = port || 80;
        socket = net$1.connect({
          highWaterMark: 64 * 1024,
          // Same as nodejs fs streams.
          ...options,
          localAddress,
          port,
          host: hostname
        });
        if (useH2c === true) {
          socket.alpnProtocol = "h2";
        }
      }
      if (options.keepAlive == null || options.keepAlive) {
        const keepAliveInitialDelay = options.keepAliveInitialDelay === void 0 ? 6e4 : options.keepAliveInitialDelay;
        socket.setKeepAlive(true, keepAliveInitialDelay);
      }
      const clearConnectTimeout = util2.setupConnectTimeout(new WeakRef(socket), { timeout, hostname, port });
      socket.setNoDelay(true).once(protocol === "https:" ? "secureConnect" : "connect", function() {
        queueMicrotask(clearConnectTimeout);
        if (callback) {
          const cb = callback;
          callback = null;
          cb(null, this);
        }
      }).on("error", function(err) {
        queueMicrotask(clearConnectTimeout);
        if (callback) {
          const cb = callback;
          callback = null;
          cb(err);
        }
      });
      return socket;
    };
  }
  connect = buildConnector;
  return connect;
}
var constants$3 = {};
var utils = {};
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils;
  hasRequiredUtils = 1;
  Object.defineProperty(utils, "__esModule", { value: true });
  utils.enumToMap = enumToMap;
  function enumToMap(obj, filter2 = [], exceptions = []) {
    const emptyFilter = (filter2?.length ?? 0) === 0;
    const emptyExceptions = (exceptions?.length ?? 0) === 0;
    return Object.fromEntries(Object.entries(obj).filter(([, value]) => {
      return typeof value === "number" && (emptyFilter || filter2.includes(value)) && (emptyExceptions || !exceptions.includes(value));
    }));
  }
  return utils;
}
var hasRequiredConstants$3;
function requireConstants$3() {
  if (hasRequiredConstants$3) return constants$3;
  hasRequiredConstants$3 = 1;
  (function(exports$1) {
    Object.defineProperty(exports$1, "__esModule", { value: true });
    exports$1.SPECIAL_HEADERS = exports$1.MINOR = exports$1.MAJOR = exports$1.HTAB_SP_VCHAR_OBS_TEXT = exports$1.QUOTED_STRING = exports$1.CONNECTION_TOKEN_CHARS = exports$1.HEADER_CHARS = exports$1.TOKEN = exports$1.HEX = exports$1.URL_CHAR = exports$1.USERINFO_CHARS = exports$1.MARK = exports$1.ALPHANUM = exports$1.NUM = exports$1.HEX_MAP = exports$1.NUM_MAP = exports$1.ALPHA = exports$1.STATUSES_HTTP = exports$1.H_METHOD_MAP = exports$1.METHOD_MAP = exports$1.METHODS_RTSP = exports$1.METHODS_ICE = exports$1.METHODS_HTTP = exports$1.HEADER_STATE = exports$1.FINISH = exports$1.STATUSES = exports$1.METHODS = exports$1.LENIENT_FLAGS = exports$1.FLAGS = exports$1.TYPE = exports$1.ERROR = void 0;
    const utils_1 = requireUtils();
    exports$1.ERROR = {
      OK: 0,
      INTERNAL: 1,
      STRICT: 2,
      CR_EXPECTED: 25,
      LF_EXPECTED: 3,
      UNEXPECTED_CONTENT_LENGTH: 4,
      UNEXPECTED_SPACE: 30,
      CLOSED_CONNECTION: 5,
      INVALID_METHOD: 6,
      INVALID_URL: 7,
      INVALID_CONSTANT: 8,
      INVALID_VERSION: 9,
      INVALID_HEADER_TOKEN: 10,
      INVALID_CONTENT_LENGTH: 11,
      INVALID_CHUNK_SIZE: 12,
      INVALID_STATUS: 13,
      INVALID_EOF_STATE: 14,
      INVALID_TRANSFER_ENCODING: 15,
      CB_MESSAGE_BEGIN: 16,
      CB_HEADERS_COMPLETE: 17,
      CB_MESSAGE_COMPLETE: 18,
      CB_CHUNK_HEADER: 19,
      CB_CHUNK_COMPLETE: 20,
      PAUSED: 21,
      PAUSED_UPGRADE: 22,
      PAUSED_H2_UPGRADE: 23,
      USER: 24,
      CB_URL_COMPLETE: 26,
      CB_STATUS_COMPLETE: 27,
      CB_METHOD_COMPLETE: 32,
      CB_VERSION_COMPLETE: 33,
      CB_HEADER_FIELD_COMPLETE: 28,
      CB_HEADER_VALUE_COMPLETE: 29,
      CB_CHUNK_EXTENSION_NAME_COMPLETE: 34,
      CB_CHUNK_EXTENSION_VALUE_COMPLETE: 35,
      CB_RESET: 31,
      CB_PROTOCOL_COMPLETE: 38
    };
    exports$1.TYPE = {
      BOTH: 0,
      // default
      REQUEST: 1,
      RESPONSE: 2
    };
    exports$1.FLAGS = {
      CONNECTION_KEEP_ALIVE: 1 << 0,
      CONNECTION_CLOSE: 1 << 1,
      CONNECTION_UPGRADE: 1 << 2,
      CHUNKED: 1 << 3,
      UPGRADE: 1 << 4,
      CONTENT_LENGTH: 1 << 5,
      SKIPBODY: 1 << 6,
      TRAILING: 1 << 7,
      // 1 << 8 is unused
      TRANSFER_ENCODING: 1 << 9
    };
    exports$1.LENIENT_FLAGS = {
      HEADERS: 1 << 0,
      CHUNKED_LENGTH: 1 << 1,
      KEEP_ALIVE: 1 << 2,
      TRANSFER_ENCODING: 1 << 3,
      VERSION: 1 << 4,
      DATA_AFTER_CLOSE: 1 << 5,
      OPTIONAL_LF_AFTER_CR: 1 << 6,
      OPTIONAL_CRLF_AFTER_CHUNK: 1 << 7,
      OPTIONAL_CR_BEFORE_LF: 1 << 8,
      SPACES_AFTER_CHUNK_SIZE: 1 << 9
    };
    exports$1.METHODS = {
      "DELETE": 0,
      "GET": 1,
      "HEAD": 2,
      "POST": 3,
      "PUT": 4,
      /* pathological */
      "CONNECT": 5,
      "OPTIONS": 6,
      "TRACE": 7,
      /* WebDAV */
      "COPY": 8,
      "LOCK": 9,
      "MKCOL": 10,
      "MOVE": 11,
      "PROPFIND": 12,
      "PROPPATCH": 13,
      "SEARCH": 14,
      "UNLOCK": 15,
      "BIND": 16,
      "REBIND": 17,
      "UNBIND": 18,
      "ACL": 19,
      /* subversion */
      "REPORT": 20,
      "MKACTIVITY": 21,
      "CHECKOUT": 22,
      "MERGE": 23,
      /* upnp */
      "M-SEARCH": 24,
      "NOTIFY": 25,
      "SUBSCRIBE": 26,
      "UNSUBSCRIBE": 27,
      /* RFC-5789 */
      "PATCH": 28,
      "PURGE": 29,
      /* CalDAV */
      "MKCALENDAR": 30,
      /* RFC-2068, section 19.6.1.2 */
      "LINK": 31,
      "UNLINK": 32,
      /* icecast */
      "SOURCE": 33,
      /* RFC-7540, section 11.6 */
      "PRI": 34,
      /* RFC-2326 RTSP */
      "DESCRIBE": 35,
      "ANNOUNCE": 36,
      "SETUP": 37,
      "PLAY": 38,
      "PAUSE": 39,
      "TEARDOWN": 40,
      "GET_PARAMETER": 41,
      "SET_PARAMETER": 42,
      "REDIRECT": 43,
      "RECORD": 44,
      /* RAOP */
      "FLUSH": 45,
      /* DRAFT https://www.ietf.org/archive/id/draft-ietf-httpbis-safe-method-w-body-02.html */
      "QUERY": 46
    };
    exports$1.STATUSES = {
      CONTINUE: 100,
      SWITCHING_PROTOCOLS: 101,
      PROCESSING: 102,
      EARLY_HINTS: 103,
      RESPONSE_IS_STALE: 110,
      // Unofficial
      REVALIDATION_FAILED: 111,
      // Unofficial
      DISCONNECTED_OPERATION: 112,
      // Unofficial
      HEURISTIC_EXPIRATION: 113,
      // Unofficial
      MISCELLANEOUS_WARNING: 199,
      // Unofficial
      OK: 200,
      CREATED: 201,
      ACCEPTED: 202,
      NON_AUTHORITATIVE_INFORMATION: 203,
      NO_CONTENT: 204,
      RESET_CONTENT: 205,
      PARTIAL_CONTENT: 206,
      MULTI_STATUS: 207,
      ALREADY_REPORTED: 208,
      TRANSFORMATION_APPLIED: 214,
      // Unofficial
      IM_USED: 226,
      MISCELLANEOUS_PERSISTENT_WARNING: 299,
      // Unofficial
      MULTIPLE_CHOICES: 300,
      MOVED_PERMANENTLY: 301,
      FOUND: 302,
      SEE_OTHER: 303,
      NOT_MODIFIED: 304,
      USE_PROXY: 305,
      SWITCH_PROXY: 306,
      // No longer used
      TEMPORARY_REDIRECT: 307,
      PERMANENT_REDIRECT: 308,
      BAD_REQUEST: 400,
      UNAUTHORIZED: 401,
      PAYMENT_REQUIRED: 402,
      FORBIDDEN: 403,
      NOT_FOUND: 404,
      METHOD_NOT_ALLOWED: 405,
      NOT_ACCEPTABLE: 406,
      PROXY_AUTHENTICATION_REQUIRED: 407,
      REQUEST_TIMEOUT: 408,
      CONFLICT: 409,
      GONE: 410,
      LENGTH_REQUIRED: 411,
      PRECONDITION_FAILED: 412,
      PAYLOAD_TOO_LARGE: 413,
      URI_TOO_LONG: 414,
      UNSUPPORTED_MEDIA_TYPE: 415,
      RANGE_NOT_SATISFIABLE: 416,
      EXPECTATION_FAILED: 417,
      IM_A_TEAPOT: 418,
      PAGE_EXPIRED: 419,
      // Unofficial
      ENHANCE_YOUR_CALM: 420,
      // Unofficial
      MISDIRECTED_REQUEST: 421,
      UNPROCESSABLE_ENTITY: 422,
      LOCKED: 423,
      FAILED_DEPENDENCY: 424,
      TOO_EARLY: 425,
      UPGRADE_REQUIRED: 426,
      PRECONDITION_REQUIRED: 428,
      TOO_MANY_REQUESTS: 429,
      REQUEST_HEADER_FIELDS_TOO_LARGE_UNOFFICIAL: 430,
      // Unofficial
      REQUEST_HEADER_FIELDS_TOO_LARGE: 431,
      LOGIN_TIMEOUT: 440,
      // Unofficial
      NO_RESPONSE: 444,
      // Unofficial
      RETRY_WITH: 449,
      // Unofficial
      BLOCKED_BY_PARENTAL_CONTROL: 450,
      // Unofficial
      UNAVAILABLE_FOR_LEGAL_REASONS: 451,
      CLIENT_CLOSED_LOAD_BALANCED_REQUEST: 460,
      // Unofficial
      INVALID_X_FORWARDED_FOR: 463,
      // Unofficial
      REQUEST_HEADER_TOO_LARGE: 494,
      // Unofficial
      SSL_CERTIFICATE_ERROR: 495,
      // Unofficial
      SSL_CERTIFICATE_REQUIRED: 496,
      // Unofficial
      HTTP_REQUEST_SENT_TO_HTTPS_PORT: 497,
      // Unofficial
      INVALID_TOKEN: 498,
      // Unofficial
      CLIENT_CLOSED_REQUEST: 499,
      // Unofficial
      INTERNAL_SERVER_ERROR: 500,
      NOT_IMPLEMENTED: 501,
      BAD_GATEWAY: 502,
      SERVICE_UNAVAILABLE: 503,
      GATEWAY_TIMEOUT: 504,
      HTTP_VERSION_NOT_SUPPORTED: 505,
      VARIANT_ALSO_NEGOTIATES: 506,
      INSUFFICIENT_STORAGE: 507,
      LOOP_DETECTED: 508,
      BANDWIDTH_LIMIT_EXCEEDED: 509,
      NOT_EXTENDED: 510,
      NETWORK_AUTHENTICATION_REQUIRED: 511,
      WEB_SERVER_UNKNOWN_ERROR: 520,
      // Unofficial
      WEB_SERVER_IS_DOWN: 521,
      // Unofficial
      CONNECTION_TIMEOUT: 522,
      // Unofficial
      ORIGIN_IS_UNREACHABLE: 523,
      // Unofficial
      TIMEOUT_OCCURED: 524,
      // Unofficial
      SSL_HANDSHAKE_FAILED: 525,
      // Unofficial
      INVALID_SSL_CERTIFICATE: 526,
      // Unofficial
      RAILGUN_ERROR: 527,
      // Unofficial
      SITE_IS_OVERLOADED: 529,
      // Unofficial
      SITE_IS_FROZEN: 530,
      // Unofficial
      IDENTITY_PROVIDER_AUTHENTICATION_ERROR: 561,
      // Unofficial
      NETWORK_READ_TIMEOUT: 598,
      // Unofficial
      NETWORK_CONNECT_TIMEOUT: 599
      // Unofficial
    };
    exports$1.FINISH = {
      SAFE: 0,
      SAFE_WITH_CB: 1,
      UNSAFE: 2
    };
    exports$1.HEADER_STATE = {
      GENERAL: 0,
      CONNECTION: 1,
      CONTENT_LENGTH: 2,
      TRANSFER_ENCODING: 3,
      UPGRADE: 4,
      CONNECTION_KEEP_ALIVE: 5,
      CONNECTION_CLOSE: 6,
      CONNECTION_UPGRADE: 7,
      TRANSFER_ENCODING_CHUNKED: 8
    };
    exports$1.METHODS_HTTP = [
      exports$1.METHODS.DELETE,
      exports$1.METHODS.GET,
      exports$1.METHODS.HEAD,
      exports$1.METHODS.POST,
      exports$1.METHODS.PUT,
      exports$1.METHODS.CONNECT,
      exports$1.METHODS.OPTIONS,
      exports$1.METHODS.TRACE,
      exports$1.METHODS.COPY,
      exports$1.METHODS.LOCK,
      exports$1.METHODS.MKCOL,
      exports$1.METHODS.MOVE,
      exports$1.METHODS.PROPFIND,
      exports$1.METHODS.PROPPATCH,
      exports$1.METHODS.SEARCH,
      exports$1.METHODS.UNLOCK,
      exports$1.METHODS.BIND,
      exports$1.METHODS.REBIND,
      exports$1.METHODS.UNBIND,
      exports$1.METHODS.ACL,
      exports$1.METHODS.REPORT,
      exports$1.METHODS.MKACTIVITY,
      exports$1.METHODS.CHECKOUT,
      exports$1.METHODS.MERGE,
      exports$1.METHODS["M-SEARCH"],
      exports$1.METHODS.NOTIFY,
      exports$1.METHODS.SUBSCRIBE,
      exports$1.METHODS.UNSUBSCRIBE,
      exports$1.METHODS.PATCH,
      exports$1.METHODS.PURGE,
      exports$1.METHODS.MKCALENDAR,
      exports$1.METHODS.LINK,
      exports$1.METHODS.UNLINK,
      exports$1.METHODS.PRI,
      // TODO(indutny): should we allow it with HTTP?
      exports$1.METHODS.SOURCE,
      exports$1.METHODS.QUERY
    ];
    exports$1.METHODS_ICE = [
      exports$1.METHODS.SOURCE
    ];
    exports$1.METHODS_RTSP = [
      exports$1.METHODS.OPTIONS,
      exports$1.METHODS.DESCRIBE,
      exports$1.METHODS.ANNOUNCE,
      exports$1.METHODS.SETUP,
      exports$1.METHODS.PLAY,
      exports$1.METHODS.PAUSE,
      exports$1.METHODS.TEARDOWN,
      exports$1.METHODS.GET_PARAMETER,
      exports$1.METHODS.SET_PARAMETER,
      exports$1.METHODS.REDIRECT,
      exports$1.METHODS.RECORD,
      exports$1.METHODS.FLUSH,
      // For AirPlay
      exports$1.METHODS.GET,
      exports$1.METHODS.POST
    ];
    exports$1.METHOD_MAP = (0, utils_1.enumToMap)(exports$1.METHODS);
    exports$1.H_METHOD_MAP = Object.fromEntries(Object.entries(exports$1.METHODS).filter(([k4]) => k4.startsWith("H")));
    exports$1.STATUSES_HTTP = [
      exports$1.STATUSES.CONTINUE,
      exports$1.STATUSES.SWITCHING_PROTOCOLS,
      exports$1.STATUSES.PROCESSING,
      exports$1.STATUSES.EARLY_HINTS,
      exports$1.STATUSES.RESPONSE_IS_STALE,
      exports$1.STATUSES.REVALIDATION_FAILED,
      exports$1.STATUSES.DISCONNECTED_OPERATION,
      exports$1.STATUSES.HEURISTIC_EXPIRATION,
      exports$1.STATUSES.MISCELLANEOUS_WARNING,
      exports$1.STATUSES.OK,
      exports$1.STATUSES.CREATED,
      exports$1.STATUSES.ACCEPTED,
      exports$1.STATUSES.NON_AUTHORITATIVE_INFORMATION,
      exports$1.STATUSES.NO_CONTENT,
      exports$1.STATUSES.RESET_CONTENT,
      exports$1.STATUSES.PARTIAL_CONTENT,
      exports$1.STATUSES.MULTI_STATUS,
      exports$1.STATUSES.ALREADY_REPORTED,
      exports$1.STATUSES.TRANSFORMATION_APPLIED,
      exports$1.STATUSES.IM_USED,
      exports$1.STATUSES.MISCELLANEOUS_PERSISTENT_WARNING,
      exports$1.STATUSES.MULTIPLE_CHOICES,
      exports$1.STATUSES.MOVED_PERMANENTLY,
      exports$1.STATUSES.FOUND,
      exports$1.STATUSES.SEE_OTHER,
      exports$1.STATUSES.NOT_MODIFIED,
      exports$1.STATUSES.USE_PROXY,
      exports$1.STATUSES.SWITCH_PROXY,
      exports$1.STATUSES.TEMPORARY_REDIRECT,
      exports$1.STATUSES.PERMANENT_REDIRECT,
      exports$1.STATUSES.BAD_REQUEST,
      exports$1.STATUSES.UNAUTHORIZED,
      exports$1.STATUSES.PAYMENT_REQUIRED,
      exports$1.STATUSES.FORBIDDEN,
      exports$1.STATUSES.NOT_FOUND,
      exports$1.STATUSES.METHOD_NOT_ALLOWED,
      exports$1.STATUSES.NOT_ACCEPTABLE,
      exports$1.STATUSES.PROXY_AUTHENTICATION_REQUIRED,
      exports$1.STATUSES.REQUEST_TIMEOUT,
      exports$1.STATUSES.CONFLICT,
      exports$1.STATUSES.GONE,
      exports$1.STATUSES.LENGTH_REQUIRED,
      exports$1.STATUSES.PRECONDITION_FAILED,
      exports$1.STATUSES.PAYLOAD_TOO_LARGE,
      exports$1.STATUSES.URI_TOO_LONG,
      exports$1.STATUSES.UNSUPPORTED_MEDIA_TYPE,
      exports$1.STATUSES.RANGE_NOT_SATISFIABLE,
      exports$1.STATUSES.EXPECTATION_FAILED,
      exports$1.STATUSES.IM_A_TEAPOT,
      exports$1.STATUSES.PAGE_EXPIRED,
      exports$1.STATUSES.ENHANCE_YOUR_CALM,
      exports$1.STATUSES.MISDIRECTED_REQUEST,
      exports$1.STATUSES.UNPROCESSABLE_ENTITY,
      exports$1.STATUSES.LOCKED,
      exports$1.STATUSES.FAILED_DEPENDENCY,
      exports$1.STATUSES.TOO_EARLY,
      exports$1.STATUSES.UPGRADE_REQUIRED,
      exports$1.STATUSES.PRECONDITION_REQUIRED,
      exports$1.STATUSES.TOO_MANY_REQUESTS,
      exports$1.STATUSES.REQUEST_HEADER_FIELDS_TOO_LARGE_UNOFFICIAL,
      exports$1.STATUSES.REQUEST_HEADER_FIELDS_TOO_LARGE,
      exports$1.STATUSES.LOGIN_TIMEOUT,
      exports$1.STATUSES.NO_RESPONSE,
      exports$1.STATUSES.RETRY_WITH,
      exports$1.STATUSES.BLOCKED_BY_PARENTAL_CONTROL,
      exports$1.STATUSES.UNAVAILABLE_FOR_LEGAL_REASONS,
      exports$1.STATUSES.CLIENT_CLOSED_LOAD_BALANCED_REQUEST,
      exports$1.STATUSES.INVALID_X_FORWARDED_FOR,
      exports$1.STATUSES.REQUEST_HEADER_TOO_LARGE,
      exports$1.STATUSES.SSL_CERTIFICATE_ERROR,
      exports$1.STATUSES.SSL_CERTIFICATE_REQUIRED,
      exports$1.STATUSES.HTTP_REQUEST_SENT_TO_HTTPS_PORT,
      exports$1.STATUSES.INVALID_TOKEN,
      exports$1.STATUSES.CLIENT_CLOSED_REQUEST,
      exports$1.STATUSES.INTERNAL_SERVER_ERROR,
      exports$1.STATUSES.NOT_IMPLEMENTED,
      exports$1.STATUSES.BAD_GATEWAY,
      exports$1.STATUSES.SERVICE_UNAVAILABLE,
      exports$1.STATUSES.GATEWAY_TIMEOUT,
      exports$1.STATUSES.HTTP_VERSION_NOT_SUPPORTED,
      exports$1.STATUSES.VARIANT_ALSO_NEGOTIATES,
      exports$1.STATUSES.INSUFFICIENT_STORAGE,
      exports$1.STATUSES.LOOP_DETECTED,
      exports$1.STATUSES.BANDWIDTH_LIMIT_EXCEEDED,
      exports$1.STATUSES.NOT_EXTENDED,
      exports$1.STATUSES.NETWORK_AUTHENTICATION_REQUIRED,
      exports$1.STATUSES.WEB_SERVER_UNKNOWN_ERROR,
      exports$1.STATUSES.WEB_SERVER_IS_DOWN,
      exports$1.STATUSES.CONNECTION_TIMEOUT,
      exports$1.STATUSES.ORIGIN_IS_UNREACHABLE,
      exports$1.STATUSES.TIMEOUT_OCCURED,
      exports$1.STATUSES.SSL_HANDSHAKE_FAILED,
      exports$1.STATUSES.INVALID_SSL_CERTIFICATE,
      exports$1.STATUSES.RAILGUN_ERROR,
      exports$1.STATUSES.SITE_IS_OVERLOADED,
      exports$1.STATUSES.SITE_IS_FROZEN,
      exports$1.STATUSES.IDENTITY_PROVIDER_AUTHENTICATION_ERROR,
      exports$1.STATUSES.NETWORK_READ_TIMEOUT,
      exports$1.STATUSES.NETWORK_CONNECT_TIMEOUT
    ];
    exports$1.ALPHA = [];
    for (let i4 = "A".charCodeAt(0); i4 <= "Z".charCodeAt(0); i4++) {
      exports$1.ALPHA.push(String.fromCharCode(i4));
      exports$1.ALPHA.push(String.fromCharCode(i4 + 32));
    }
    exports$1.NUM_MAP = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9
    };
    exports$1.HEX_MAP = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      A: 10,
      B: 11,
      C: 12,
      D: 13,
      E: 14,
      F: 15,
      a: 10,
      b: 11,
      c: 12,
      d: 13,
      e: 14,
      f: 15
    };
    exports$1.NUM = [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9"
    ];
    exports$1.ALPHANUM = exports$1.ALPHA.concat(exports$1.NUM);
    exports$1.MARK = ["-", "_", ".", "!", "~", "*", "'", "(", ")"];
    exports$1.USERINFO_CHARS = exports$1.ALPHANUM.concat(exports$1.MARK).concat(["%", ";", ":", "&", "=", "+", "$", ","]);
    exports$1.URL_CHAR = [
      "!",
      '"',
      "$",
      "%",
      "&",
      "'",
      "(",
      ")",
      "*",
      "+",
      ",",
      "-",
      ".",
      "/",
      ":",
      ";",
      "<",
      "=",
      ">",
      "@",
      "[",
      "\\",
      "]",
      "^",
      "_",
      "`",
      "{",
      "|",
      "}",
      "~"
    ].concat(exports$1.ALPHANUM);
    exports$1.HEX = exports$1.NUM.concat(["a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"]);
    exports$1.TOKEN = [
      "!",
      "#",
      "$",
      "%",
      "&",
      "'",
      "*",
      "+",
      "-",
      ".",
      "^",
      "_",
      "`",
      "|",
      "~"
    ].concat(exports$1.ALPHANUM);
    exports$1.HEADER_CHARS = ["	"];
    for (let i4 = 32; i4 <= 255; i4++) {
      if (i4 !== 127) {
        exports$1.HEADER_CHARS.push(i4);
      }
    }
    exports$1.CONNECTION_TOKEN_CHARS = exports$1.HEADER_CHARS.filter((c4) => c4 !== 44);
    exports$1.QUOTED_STRING = ["	", " "];
    for (let i4 = 33; i4 <= 255; i4++) {
      if (i4 !== 34 && i4 !== 92) {
        exports$1.QUOTED_STRING.push(i4);
      }
    }
    exports$1.HTAB_SP_VCHAR_OBS_TEXT = ["	", " "];
    for (let i4 = 33; i4 <= 126; i4++) {
      exports$1.HTAB_SP_VCHAR_OBS_TEXT.push(i4);
    }
    for (let i4 = 128; i4 <= 255; i4++) {
      exports$1.HTAB_SP_VCHAR_OBS_TEXT.push(i4);
    }
    exports$1.MAJOR = exports$1.NUM_MAP;
    exports$1.MINOR = exports$1.MAJOR;
    exports$1.SPECIAL_HEADERS = {
      "connection": exports$1.HEADER_STATE.CONNECTION,
      "content-length": exports$1.HEADER_STATE.CONTENT_LENGTH,
      "proxy-connection": exports$1.HEADER_STATE.CONNECTION,
      "transfer-encoding": exports$1.HEADER_STATE.TRANSFER_ENCODING,
      "upgrade": exports$1.HEADER_STATE.UPGRADE
    };
    exports$1.default = {
      ERROR: exports$1.ERROR,
      TYPE: exports$1.TYPE,
      FLAGS: exports$1.FLAGS,
      LENIENT_FLAGS: exports$1.LENIENT_FLAGS,
      METHODS: exports$1.METHODS,
      STATUSES: exports$1.STATUSES,
      FINISH: exports$1.FINISH,
      HEADER_STATE: exports$1.HEADER_STATE,
      ALPHA: exports$1.ALPHA,
      NUM_MAP: exports$1.NUM_MAP,
      HEX_MAP: exports$1.HEX_MAP,
      NUM: exports$1.NUM,
      ALPHANUM: exports$1.ALPHANUM,
      MARK: exports$1.MARK,
      USERINFO_CHARS: exports$1.USERINFO_CHARS,
      URL_CHAR: exports$1.URL_CHAR,
      HEX: exports$1.HEX,
      TOKEN: exports$1.TOKEN,
      HEADER_CHARS: exports$1.HEADER_CHARS,
      CONNECTION_TOKEN_CHARS: exports$1.CONNECTION_TOKEN_CHARS,
      QUOTED_STRING: exports$1.QUOTED_STRING,
      HTAB_SP_VCHAR_OBS_TEXT: exports$1.HTAB_SP_VCHAR_OBS_TEXT,
      MAJOR: exports$1.MAJOR,
      MINOR: exports$1.MINOR,
      SPECIAL_HEADERS: exports$1.SPECIAL_HEADERS,
      METHODS_HTTP: exports$1.METHODS_HTTP,
      METHODS_ICE: exports$1.METHODS_ICE,
      METHODS_RTSP: exports$1.METHODS_RTSP,
      METHOD_MAP: exports$1.METHOD_MAP,
      H_METHOD_MAP: exports$1.H_METHOD_MAP,
      STATUSES_HTTP: exports$1.STATUSES_HTTP
    };
  })(constants$3);
  return constants$3;
}
var llhttpWasm = { exports: {} };
llhttpWasm.exports;
var hasRequiredLlhttpWasm;
function requireLlhttpWasm() {
  if (hasRequiredLlhttpWasm) return llhttpWasm.exports;
  hasRequiredLlhttpWasm = 1;
  (function(module2) {
    const { Buffer: Buffer4 } = import_node_buffer.default;
    const wasmBase64 = "AGFzbQEAAAABJwdgAX8Bf2ADf39/AX9gAn9/AGABfwBgBH9/f38Bf2AAAGADf39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQAEA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAzU0BQYAAAMAAAAAAAADAQMAAwMDAAACAAAAAAICAgICAgICAgIBAQEBAQEBAQEBAwAAAwAAAAQFAXABExMFAwEAAgYIAX8BQcDZBAsHxQcoBm1lbW9yeQIAC19pbml0aWFsaXplAAgZX19pbmRpcmVjdF9mdW5jdGlvbl90YWJsZQEAC2xsaHR0cF9pbml0AAkYbGxodHRwX3Nob3VsZF9rZWVwX2FsaXZlADcMbGxodHRwX2FsbG9jAAsGbWFsbG9jADkLbGxodHRwX2ZyZWUADARmcmVlAAwPbGxodHRwX2dldF90eXBlAA0VbGxodHRwX2dldF9odHRwX21ham9yAA4VbGxodHRwX2dldF9odHRwX21pbm9yAA8RbGxodHRwX2dldF9tZXRob2QAEBZsbGh0dHBfZ2V0X3N0YXR1c19jb2RlABESbGxodHRwX2dldF91cGdyYWRlABIMbGxodHRwX3Jlc2V0ABMObGxodHRwX2V4ZWN1dGUAFBRsbGh0dHBfc2V0dGluZ3NfaW5pdAAVDWxsaHR0cF9maW5pc2gAFgxsbGh0dHBfcGF1c2UAFw1sbGh0dHBfcmVzdW1lABgbbGxodHRwX3Jlc3VtZV9hZnRlcl91cGdyYWRlABkQbGxodHRwX2dldF9lcnJubwAaF2xsaHR0cF9nZXRfZXJyb3JfcmVhc29uABsXbGxodHRwX3NldF9lcnJvcl9yZWFzb24AHBRsbGh0dHBfZ2V0X2Vycm9yX3BvcwAdEWxsaHR0cF9lcnJub19uYW1lAB4SbGxodHRwX21ldGhvZF9uYW1lAB8SbGxodHRwX3N0YXR1c19uYW1lACAabGxodHRwX3NldF9sZW5pZW50X2hlYWRlcnMAISFsbGh0dHBfc2V0X2xlbmllbnRfY2h1bmtlZF9sZW5ndGgAIh1sbGh0dHBfc2V0X2xlbmllbnRfa2VlcF9hbGl2ZQAjJGxsaHR0cF9zZXRfbGVuaWVudF90cmFuc2Zlcl9lbmNvZGluZwAkGmxsaHR0cF9zZXRfbGVuaWVudF92ZXJzaW9uACUjbGxodHRwX3NldF9sZW5pZW50X2RhdGFfYWZ0ZXJfY2xvc2UAJidsbGh0dHBfc2V0X2xlbmllbnRfb3B0aW9uYWxfbGZfYWZ0ZXJfY3IAJyxsbGh0dHBfc2V0X2xlbmllbnRfb3B0aW9uYWxfY3JsZl9hZnRlcl9jaHVuawAoKGxsaHR0cF9zZXRfbGVuaWVudF9vcHRpb25hbF9jcl9iZWZvcmVfbGYAKSpsbGh0dHBfc2V0X2xlbmllbnRfc3BhY2VzX2FmdGVyX2NodW5rX3NpemUAKhhsbGh0dHBfbWVzc2FnZV9uZWVkc19lb2YANgkYAQBBAQsSAQIDBAUKBgcyNDMuKy8tLDAxCq/ZAjQWAEHA1QAoAgAEQAALQcDVAEEBNgIACxQAIAAQOCAAIAI2AjggACABOgAoCxQAIAAgAC8BNCAALQAwIAAQNxAACx4BAX9BwAAQOiIBEDggAUGACDYCOCABIAA6ACggAQuPDAEHfwJAIABFDQAgAEEIayIBIABBBGsoAgAiAEF4cSIEaiEFAkAgAEEBcQ0AIABBA3FFDQEgASABKAIAIgBrIgFB1NUAKAIASQ0BIAAgBGohBAJAAkBB2NUAKAIAIAFHBEAgAEH/AU0EQCAAQQN2IQMgASgCCCIAIAEoAgwiAkYEQEHE1QBBxNUAKAIAQX4gA3dxNgIADAULIAIgADYCCCAAIAI2AgwMBAsgASgCGCEGIAEgASgCDCIARwRAIAAgASgCCCICNgIIIAIgADYCDAwDCyABQRRqIgMoAgAiAkUEQCABKAIQIgJFDQIgAUEQaiEDCwNAIAMhByACIgBBFGoiAygCACICDQAgAEEQaiEDIAAoAhAiAg0ACyAHQQA2AgAMAgsgBSgCBCIAQQNxQQNHDQIgBSAAQX5xNgIEQczVACAENgIAIAUgBDYCACABIARBAXI2AgQMAwtBACEACyAGRQ0AAkAgASgCHCICQQJ0QfTXAGoiAygCACABRgRAIAMgADYCACAADQFByNUAQcjVACgCAEF+IAJ3cTYCAAwCCyAGQRBBFCAGKAIQIAFGG2ogADYCACAARQ0BCyAAIAY2AhggASgCECICBEAgACACNgIQIAIgADYCGAsgAUEUaigCACICRQ0AIABBFGogAjYCACACIAA2AhgLIAEgBU8NACAFKAIEIgBBAXFFDQACQAJAAkACQCAAQQJxRQRAQdzVACgCACAFRgRAQdzVACABNgIAQdDVAEHQ1QAoAgAgBGoiADYCACABIABBAXI2AgQgAUHY1QAoAgBHDQZBzNUAQQA2AgBB2NUAQQA2AgAMBgtB2NUAKAIAIAVGBEBB2NUAIAE2AgBBzNUAQczVACgCACAEaiIANgIAIAEgAEEBcjYCBCAAIAFqIAA2AgAMBgsgAEF4cSAEaiEEIABB/wFNBEAgAEEDdiEDIAUoAggiACAFKAIMIgJGBEBBxNUAQcTVACgCAEF+IAN3cTYCAAwFCyACIAA2AgggACACNgIMDAQLIAUoAhghBiAFIAUoAgwiAEcEQEHU1QAoAgAaIAAgBSgCCCICNgIIIAIgADYCDAwDCyAFQRRqIgMoAgAiAkUEQCAFKAIQIgJFDQIgBUEQaiEDCwNAIAMhByACIgBBFGoiAygCACICDQAgAEEQaiEDIAAoAhAiAg0ACyAHQQA2AgAMAgsgBSAAQX5xNgIEIAEgBGogBDYCACABIARBAXI2AgQMAwtBACEACyAGRQ0AAkAgBSgCHCICQQJ0QfTXAGoiAygCACAFRgRAIAMgADYCACAADQFByNUAQcjVACgCAEF+IAJ3cTYCAAwCCyAGQRBBFCAGKAIQIAVGG2ogADYCACAARQ0BCyAAIAY2AhggBSgCECICBEAgACACNgIQIAIgADYCGAsgBUEUaigCACICRQ0AIABBFGogAjYCACACIAA2AhgLIAEgBGogBDYCACABIARBAXI2AgQgAUHY1QAoAgBHDQBBzNUAIAQ2AgAMAQsgBEH/AU0EQCAEQXhxQezVAGohAAJ/QcTVACgCACICQQEgBEEDdnQiA3FFBEBBxNUAIAIgA3I2AgAgAAwBCyAAKAIICyICIAE2AgwgACABNgIIIAEgADYCDCABIAI2AggMAQtBHyECIARB////B00EQCAEQSYgBEEIdmciAGt2QQFxIABBAXRrQT5qIQILIAEgAjYCHCABQgA3AhAgAkECdEH01wBqIQACQEHI1QAoAgAiA0EBIAJ0IgdxRQRAIAAgATYCAEHI1QAgAyAHcjYCACABIAA2AhggASABNgIIIAEgATYCDAwBCyAEQRkgAkEBdmtBACACQR9HG3QhAiAAKAIAIQACQANAIAAiAygCBEF4cSAERg0BIAJBHXYhACACQQF0IQIgAyAAQQRxakEQaiIHKAIAIgANAAsgByABNgIAIAEgAzYCGCABIAE2AgwgASABNgIIDAELIAMoAggiACABNgIMIAMgATYCCCABQQA2AhggASADNgIMIAEgADYCCAtB5NUAQeTVACgCAEEBayIAQX8gABs2AgALCwcAIAAtACgLBwAgAC0AKgsHACAALQArCwcAIAAtACkLBwAgAC8BNAsHACAALQAwC0ABBH8gACgCGCEBIAAvAS4hAiAALQAoIQMgACgCOCEEIAAQOCAAIAQ2AjggACADOgAoIAAgAjsBLiAAIAE2AhgL5YUCAgd/A34gASACaiEEAkAgACIDKAIMIgANACADKAIEBEAgAyABNgIECyMAQRBrIgkkAAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAygCHCICQQJrDvwBAfkBAgMEBQYHCAkKCwwNDg8QERL4ARP3ARQV9gEWF/UBGBkaGxwdHh8g/QH7ASH0ASIjJCUmJygpKivzASwtLi8wMTLyAfEBMzTwAe8BNTY3ODk6Ozw9Pj9AQUJDREVGR0hJSktMTU5P+gFQUVJT7gHtAVTsAVXrAVZXWFla6gFbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakBqgGrAawBrQGuAa8BsAGxAbIBswG0AbUBtgG3AbgBuQG6AbsBvAG9Ab4BvwHAAcEBwgHDAcQBxQHGAccByAHJAcoBywHMAc0BzgHpAegBzwHnAdAB5gHRAdIB0wHUAeUB1QHWAdcB2AHZAdoB2wHcAd0B3gHfAeAB4QHiAeMBAPwBC0EADOMBC0EODOIBC0ENDOEBC0EPDOABC0EQDN8BC0ETDN4BC0EUDN0BC0EVDNwBC0EWDNsBC0EXDNoBC0EYDNkBC0EZDNgBC0EaDNcBC0EbDNYBC0EcDNUBC0EdDNQBC0EeDNMBC0EfDNIBC0EgDNEBC0EhDNABC0EIDM8BC0EiDM4BC0EkDM0BC0EjDMwBC0EHDMsBC0ElDMoBC0EmDMkBC0EnDMgBC0EoDMcBC0ESDMYBC0ERDMUBC0EpDMQBC0EqDMMBC0ErDMIBC0EsDMEBC0HeAQzAAQtBLgy/AQtBLwy+AQtBMAy9AQtBMQy8AQtBMgy7AQtBMwy6AQtBNAy5AQtB3wEMuAELQTUMtwELQTkMtgELQQwMtQELQTYMtAELQTcMswELQTgMsgELQT4MsQELQToMsAELQeABDK8BC0ELDK4BC0E/DK0BC0E7DKwBC0EKDKsBC0E8DKoBC0E9DKkBC0HhAQyoAQtBwQAMpwELQcAADKYBC0HCAAylAQtBCQykAQtBLQyjAQtBwwAMogELQcQADKEBC0HFAAygAQtBxgAMnwELQccADJ4BC0HIAAydAQtByQAMnAELQcoADJsBC0HLAAyaAQtBzAAMmQELQc0ADJgBC0HOAAyXAQtBzwAMlgELQdAADJUBC0HRAAyUAQtB0gAMkwELQdMADJIBC0HVAAyRAQtB1AAMkAELQdYADI8BC0HXAAyOAQtB2AAMjQELQdkADIwBC0HaAAyLAQtB2wAMigELQdwADIkBC0HdAAyIAQtB3gAMhwELQd8ADIYBC0HgAAyFAQtB4QAMhAELQeIADIMBC0HjAAyCAQtB5AAMgQELQeUADIABC0HiAQx/C0HmAAx+C0HnAAx9C0EGDHwLQegADHsLQQUMegtB6QAMeQtBBAx4C0HqAAx3C0HrAAx2C0HsAAx1C0HtAAx0C0EDDHMLQe4ADHILQe8ADHELQfAADHALQfIADG8LQfEADG4LQfMADG0LQfQADGwLQfUADGsLQfYADGoLQQIMaQtB9wAMaAtB+AAMZwtB+QAMZgtB+gAMZQtB+wAMZAtB/AAMYwtB/QAMYgtB/gAMYQtB/wAMYAtBgAEMXwtBgQEMXgtBggEMXQtBgwEMXAtBhAEMWwtBhQEMWgtBhgEMWQtBhwEMWAtBiAEMVwtBiQEMVgtBigEMVQtBiwEMVAtBjAEMUwtBjQEMUgtBjgEMUQtBjwEMUAtBkAEMTwtBkQEMTgtBkgEMTQtBkwEMTAtBlAEMSwtBlQEMSgtBlgEMSQtBlwEMSAtBmAEMRwtBmQEMRgtBmgEMRQtBmwEMRAtBnAEMQwtBnQEMQgtBngEMQQtBnwEMQAtBoAEMPwtBoQEMPgtBogEMPQtBowEMPAtBpAEMOwtBpQEMOgtBpgEMOQtBpwEMOAtBqAEMNwtBqQEMNgtBqgEMNQtBqwEMNAtBrAEMMwtBrQEMMgtBrgEMMQtBrwEMMAtBsAEMLwtBsQEMLgtBsgEMLQtBswEMLAtBtAEMKwtBtQEMKgtBtgEMKQtBtwEMKAtBuAEMJwtBuQEMJgtBugEMJQtBuwEMJAtBvAEMIwtBvQEMIgtBvgEMIQtBvwEMIAtBwAEMHwtBwQEMHgtBwgEMHQtBAQwcC0HDAQwbC0HEAQwaC0HFAQwZC0HGAQwYC0HHAQwXC0HIAQwWC0HJAQwVC0HKAQwUC0HLAQwTC0HMAQwSC0HNAQwRC0HOAQwQC0HPAQwPC0HQAQwOC0HRAQwNC0HSAQwMC0HTAQwLC0HUAQwKC0HVAQwJC0HWAQwIC0HjAQwHC0HXAQwGC0HYAQwFC0HZAQwEC0HaAQwDC0HbAQwCC0HdAQwBC0HcAQshAgNAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCADAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQAJ/AkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAMCfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAg7jAQABAgMEBQYHCAkKCwwNDg8QERITFBUWFxgZGhscHR4fICEjJCUnKCmeA5sDmgORA4oDgwOAA/0C+wL4AvIC8QLvAu0C6ALnAuYC5QLkAtwC2wLaAtkC2ALXAtYC1QLPAs4CzALLAsoCyQLIAscCxgLEAsMCvgK8AroCuQK4ArcCtgK1ArQCswKyArECsAKuAq0CqQKoAqcCpgKlAqQCowKiAqECoAKfApgCkAKMAosCigKBAv4B/QH8AfsB+gH5AfgB9wH1AfMB8AHrAekB6AHnAeYB5QHkAeMB4gHhAeAB3wHeAd0B3AHaAdkB2AHXAdYB1QHUAdMB0gHRAdABzwHOAc0BzAHLAcoByQHIAccBxgHFAcQBwwHCAcEBwAG/Ab4BvQG8AbsBugG5AbgBtwG2AbUBtAGzAbIBsQGwAa8BrgGtAawBqwGqAakBqAGnAaYBpQGkAaMBogGfAZ4BmQGYAZcBlgGVAZQBkwGSAZEBkAGPAY0BjAGHAYYBhQGEAYMBggF9fHt6eXZ1dFBRUlNUVQsgASAERw1yQf0BIQIMvgMLIAEgBEcNmAFB2wEhAgy9AwsgASAERw3xAUGOASECDLwDCyABIARHDfwBQYQBIQIMuwMLIAEgBEcNigJB/wAhAgy6AwsgASAERw2RAkH9ACECDLkDCyABIARHDZQCQfsAIQIMuAMLIAEgBEcNHkEeIQIMtwMLIAEgBEcNGUEYIQIMtgMLIAEgBEcNygJBzQAhAgy1AwsgASAERw3VAkHGACECDLQDCyABIARHDdYCQcMAIQIMswMLIAEgBEcN3AJBOCECDLIDCyADLQAwQQFGDa0DDIkDC0EAIQACQAJAAkAgAy0AKkUNACADLQArRQ0AIAMvATIiAkECcUUNAQwCCyADLwEyIgJBAXFFDQELQQEhACADLQAoQQFGDQAgAy8BNCIGQeQAa0HkAEkNACAGQcwBRg0AIAZBsAJGDQAgAkHAAHENAEEAIQAgAkGIBHFBgARGDQAgAkEocUEARyEACyADQQA7ATIgA0EAOgAxAkAgAEUEQCADQQA6ADEgAy0ALkEEcQ0BDLEDCyADQgA3AyALIANBADoAMSADQQE6ADYMSAtBACEAAkAgAygCOCICRQ0AIAIoAjAiAkUNACADIAIRAAAhAAsgAEUNSCAAQRVHDWIgA0EENgIcIAMgATYCFCADQdIbNgIQIANBFTYCDEEAIQIMrwMLIAEgBEYEQEEGIQIMrwMLIAEtAABBCkcNGSABQQFqIQEMGgsgA0IANwMgQRIhAgyUAwsgASAERw2KA0EjIQIMrAMLIAEgBEYEQEEHIQIMrAMLAkACQCABLQAAQQprDgQBGBgAGAsgAUEBaiEBQRAhAgyTAwsgAUEBaiEBIANBL2otAABBAXENF0EAIQIgA0EANgIcIAMgATYCFCADQZkgNgIQIANBGTYCDAyrAwsgAyADKQMgIgwgBCABa60iCn0iC0IAIAsgDFgbNwMgIAogDFoNGEEIIQIMqgMLIAEgBEcEQCADQQk2AgggAyABNgIEQRQhAgyRAwtBCSECDKkDCyADKQMgUA2uAgxDCyABIARGBEBBCyECDKgDCyABLQAAQQpHDRYgAUEBaiEBDBcLIANBL2otAABBAXFFDRkMJgtBACEAAkAgAygCOCICRQ0AIAIoAlAiAkUNACADIAIRAAAhAAsgAA0ZDEILQQAhAAJAIAMoAjgiAkUNACACKAJQIgJFDQAgAyACEQAAIQALIAANGgwkC0EAIQACQCADKAI4IgJFDQAgAigCUCICRQ0AIAMgAhEAACEACyAADRsMMgsgA0Evai0AAEEBcUUNHAwiC0EAIQACQCADKAI4IgJFDQAgAigCVCICRQ0AIAMgAhEAACEACyAADRwMQgtBACEAAkAgAygCOCICRQ0AIAIoAlQiAkUNACADIAIRAAAhAAsgAA0dDCALIAEgBEYEQEETIQIMoAMLAkAgAS0AACIAQQprDgQfIyMAIgsgAUEBaiEBDB8LQQAhAAJAIAMoAjgiAkUNACACKAJUIgJFDQAgAyACEQAAIQALIAANIgxCCyABIARGBEBBFiECDJ4DCyABLQAAQcDBAGotAABBAUcNIwyDAwsCQANAIAEtAABBsDtqLQAAIgBBAUcEQAJAIABBAmsOAgMAJwsgAUEBaiEBQSEhAgyGAwsgBCABQQFqIgFHDQALQRghAgydAwsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAFBAWoiARA0IgANIQxBC0EAIQACQCADKAI4IgJFDQAgAigCVCICRQ0AIAMgAhEAACEACyAADSMMKgsgASAERgRAQRwhAgybAwsgA0EKNgIIIAMgATYCBEEAIQACQCADKAI4IgJFDQAgAigCUCICRQ0AIAMgAhEAACEACyAADSVBJCECDIEDCyABIARHBEADQCABLQAAQbA9ai0AACIAQQNHBEAgAEEBaw4FGBomggMlJgsgBCABQQFqIgFHDQALQRshAgyaAwtBGyECDJkDCwNAIAEtAABBsD9qLQAAIgBBA0cEQCAAQQFrDgUPEScTJicLIAQgAUEBaiIBRw0AC0EeIQIMmAMLIAEgBEcEQCADQQs2AgggAyABNgIEQQchAgz/AgtBHyECDJcDCyABIARGBEBBICECDJcDCwJAIAEtAABBDWsOFC4/Pz8/Pz8/Pz8/Pz8/Pz8/Pz8APwtBACECIANBADYCHCADQb8LNgIQIANBAjYCDCADIAFBAWo2AhQMlgMLIANBL2ohAgNAIAEgBEYEQEEhIQIMlwMLAkACQAJAIAEtAAAiAEEJaw4YAgApKQEpKSkpKSkpKSkpKSkpKSkpKSkCJwsgAUEBaiEBIANBL2otAABBAXFFDQoMGAsgAUEBaiEBDBcLIAFBAWohASACLQAAQQJxDQALQQAhAiADQQA2AhwgAyABNgIUIANBnxU2AhAgA0EMNgIMDJUDCyADLQAuQYABcUUNAQtBACEAAkAgAygCOCICRQ0AIAIoAlwiAkUNACADIAIRAAAhAAsgAEUN5gIgAEEVRgRAIANBJDYCHCADIAE2AhQgA0GbGzYCECADQRU2AgxBACECDJQDC0EAIQIgA0EANgIcIAMgATYCFCADQZAONgIQIANBFDYCDAyTAwtBACECIANBADYCHCADIAE2AhQgA0G+IDYCECADQQI2AgwMkgMLIAMoAgQhAEEAIQIgA0EANgIEIAMgACABIAynaiIBEDIiAEUNKyADQQc2AhwgAyABNgIUIAMgADYCDAyRAwsgAy0ALkHAAHFFDQELQQAhAAJAIAMoAjgiAkUNACACKAJYIgJFDQAgAyACEQAAIQALIABFDSsgAEEVRgRAIANBCjYCHCADIAE2AhQgA0HrGTYCECADQRU2AgxBACECDJADC0EAIQIgA0EANgIcIAMgATYCFCADQZMMNgIQIANBEzYCDAyPAwtBACECIANBADYCHCADIAE2AhQgA0GCFTYCECADQQI2AgwMjgMLQQAhAiADQQA2AhwgAyABNgIUIANB3RQ2AhAgA0EZNgIMDI0DC0EAIQIgA0EANgIcIAMgATYCFCADQeYdNgIQIANBGTYCDAyMAwsgAEEVRg09QQAhAiADQQA2AhwgAyABNgIUIANB0A82AhAgA0EiNgIMDIsDCyADKAIEIQBBACECIANBADYCBCADIAAgARAzIgBFDSggA0ENNgIcIAMgATYCFCADIAA2AgwMigMLIABBFUYNOkEAIQIgA0EANgIcIAMgATYCFCADQdAPNgIQIANBIjYCDAyJAwsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAEQMyIARQRAIAFBAWohAQwoCyADQQ42AhwgAyAANgIMIAMgAUEBajYCFAyIAwsgAEEVRg03QQAhAiADQQA2AhwgAyABNgIUIANB0A82AhAgA0EiNgIMDIcDCyADKAIEIQBBACECIANBADYCBCADIAAgARAzIgBFBEAgAUEBaiEBDCcLIANBDzYCHCADIAA2AgwgAyABQQFqNgIUDIYDC0EAIQIgA0EANgIcIAMgATYCFCADQeIXNgIQIANBGTYCDAyFAwsgAEEVRg0zQQAhAiADQQA2AhwgAyABNgIUIANB1gw2AhAgA0EjNgIMDIQDCyADKAIEIQBBACECIANBADYCBCADIAAgARA0IgBFDSUgA0ERNgIcIAMgATYCFCADIAA2AgwMgwMLIABBFUYNMEEAIQIgA0EANgIcIAMgATYCFCADQdYMNgIQIANBIzYCDAyCAwsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAEQNCIARQRAIAFBAWohAQwlCyADQRI2AhwgAyAANgIMIAMgAUEBajYCFAyBAwsgA0Evai0AAEEBcUUNAQtBFyECDOYCC0EAIQIgA0EANgIcIAMgATYCFCADQeIXNgIQIANBGTYCDAz+AgsgAEE7Rw0AIAFBAWohAQwMC0EAIQIgA0EANgIcIAMgATYCFCADQZIYNgIQIANBAjYCDAz8AgsgAEEVRg0oQQAhAiADQQA2AhwgAyABNgIUIANB1gw2AhAgA0EjNgIMDPsCCyADQRQ2AhwgAyABNgIUIAMgADYCDAz6AgsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAEQNCIARQRAIAFBAWohAQz1AgsgA0EVNgIcIAMgADYCDCADIAFBAWo2AhQM+QILIAMoAgQhAEEAIQIgA0EANgIEIAMgACABEDQiAEUEQCABQQFqIQEM8wILIANBFzYCHCADIAA2AgwgAyABQQFqNgIUDPgCCyAAQRVGDSNBACECIANBADYCHCADIAE2AhQgA0HWDDYCECADQSM2AgwM9wILIAMoAgQhAEEAIQIgA0EANgIEIAMgACABEDQiAEUEQCABQQFqIQEMHQsgA0EZNgIcIAMgADYCDCADIAFBAWo2AhQM9gILIAMoAgQhAEEAIQIgA0EANgIEIAMgACABEDQiAEUEQCABQQFqIQEM7wILIANBGjYCHCADIAA2AgwgAyABQQFqNgIUDPUCCyAAQRVGDR9BACECIANBADYCHCADIAE2AhQgA0HQDzYCECADQSI2AgwM9AILIAMoAgQhACADQQA2AgQgAyAAIAEQMyIARQRAIAFBAWohAQwbCyADQRw2AhwgAyAANgIMIAMgAUEBajYCFEEAIQIM8wILIAMoAgQhACADQQA2AgQgAyAAIAEQMyIARQRAIAFBAWohAQzrAgsgA0EdNgIcIAMgADYCDCADIAFBAWo2AhRBACECDPICCyAAQTtHDQEgAUEBaiEBC0EmIQIM1wILQQAhAiADQQA2AhwgAyABNgIUIANBnxU2AhAgA0EMNgIMDO8CCyABIARHBEADQCABLQAAQSBHDYQCIAQgAUEBaiIBRw0AC0EsIQIM7wILQSwhAgzuAgsgASAERgRAQTQhAgzuAgsCQAJAA0ACQCABLQAAQQprDgQCAAADAAsgBCABQQFqIgFHDQALQTQhAgzvAgsgAygCBCEAIANBADYCBCADIAAgARAxIgBFDZ8CIANBMjYCHCADIAE2AhQgAyAANgIMQQAhAgzuAgsgAygCBCEAIANBADYCBCADIAAgARAxIgBFBEAgAUEBaiEBDJ8CCyADQTI2AhwgAyAANgIMIAMgAUEBajYCFEEAIQIM7QILIAEgBEcEQAJAA0AgAS0AAEEwayIAQf8BcUEKTwRAQTohAgzXAgsgAykDICILQpmz5syZs+bMGVYNASADIAtCCn4iCjcDICAKIACtQv8BgyILQn+FVg0BIAMgCiALfDcDICAEIAFBAWoiAUcNAAtBwAAhAgzuAgsgAygCBCEAIANBADYCBCADIAAgAUEBaiIBEDEiAA0XDOICC0HAACECDOwCCyABIARGBEBByQAhAgzsAgsCQANAAkAgAS0AAEEJaw4YAAKiAqICqQKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogIAogILIAQgAUEBaiIBRw0AC0HJACECDOwCCyABQQFqIQEgA0Evai0AAEEBcQ2lAiADQQA2AhwgAyABNgIUIANBlxA2AhAgA0EKNgIMQQAhAgzrAgsgASAERwRAA0AgAS0AAEEgRw0VIAQgAUEBaiIBRw0AC0H4ACECDOsCC0H4ACECDOoCCyADQQI6ACgMOAtBACECIANBADYCHCADQb8LNgIQIANBAjYCDCADIAFBAWo2AhQM6AILQQAhAgzOAgtBDSECDM0CC0ETIQIMzAILQRUhAgzLAgtBFiECDMoCC0EYIQIMyQILQRkhAgzIAgtBGiECDMcCC0EbIQIMxgILQRwhAgzFAgtBHSECDMQCC0EeIQIMwwILQR8hAgzCAgtBICECDMECC0EiIQIMwAILQSMhAgy/AgtBJSECDL4CC0HlACECDL0CCyADQT02AhwgAyABNgIUIAMgADYCDEEAIQIM1QILIANBGzYCHCADIAE2AhQgA0GkHDYCECADQRU2AgxBACECDNQCCyADQSA2AhwgAyABNgIUIANBmBo2AhAgA0EVNgIMQQAhAgzTAgsgA0ETNgIcIAMgATYCFCADQZgaNgIQIANBFTYCDEEAIQIM0gILIANBCzYCHCADIAE2AhQgA0GYGjYCECADQRU2AgxBACECDNECCyADQRA2AhwgAyABNgIUIANBmBo2AhAgA0EVNgIMQQAhAgzQAgsgA0EgNgIcIAMgATYCFCADQaQcNgIQIANBFTYCDEEAIQIMzwILIANBCzYCHCADIAE2AhQgA0GkHDYCECADQRU2AgxBACECDM4CCyADQQw2AhwgAyABNgIUIANBpBw2AhAgA0EVNgIMQQAhAgzNAgtBACECIANBADYCHCADIAE2AhQgA0HdDjYCECADQRI2AgwMzAILAkADQAJAIAEtAABBCmsOBAACAgACCyAEIAFBAWoiAUcNAAtB/QEhAgzMAgsCQAJAIAMtADZBAUcNAEEAIQACQCADKAI4IgJFDQAgAigCYCICRQ0AIAMgAhEAACEACyAARQ0AIABBFUcNASADQfwBNgIcIAMgATYCFCADQdwZNgIQIANBFTYCDEEAIQIMzQILQdwBIQIMswILIANBADYCHCADIAE2AhQgA0H5CzYCECADQR82AgxBACECDMsCCwJAAkAgAy0AKEEBaw4CBAEAC0HbASECDLICC0HUASECDLECCyADQQI6ADFBACEAAkAgAygCOCICRQ0AIAIoAgAiAkUNACADIAIRAAAhAAsgAEUEQEHdASECDLECCyAAQRVHBEAgA0EANgIcIAMgATYCFCADQbQMNgIQIANBEDYCDEEAIQIMygILIANB+wE2AhwgAyABNgIUIANBgRo2AhAgA0EVNgIMQQAhAgzJAgsgASAERgRAQfoBIQIMyQILIAEtAABByABGDQEgA0EBOgAoC0HAASECDK4CC0HaASECDK0CCyABIARHBEAgA0EMNgIIIAMgATYCBEHZASECDK0CC0H5ASECDMUCCyABIARGBEBB+AEhAgzFAgsgAS0AAEHIAEcNBCABQQFqIQFB2AEhAgyrAgsgASAERgRAQfcBIQIMxAILAkACQCABLQAAQcUAaw4QAAUFBQUFBQUFBQUFBQUFAQULIAFBAWohAUHWASECDKsCCyABQQFqIQFB1wEhAgyqAgtB9gEhAiABIARGDcICIAMoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQbrVAGotAABHDQMgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADMMCCyADKAIEIQAgA0IANwMAIAMgACAGQQFqIgEQLiIARQRAQeMBIQIMqgILIANB9QE2AhwgAyABNgIUIAMgADYCDEEAIQIMwgILQfQBIQIgASAERg3BAiADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEG41QBqLQAARw0CIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzCAgsgA0GBBDsBKCADKAIEIQAgA0IANwMAIAMgACAGQQFqIgEQLiIADQMMAgsgA0EANgIAC0EAIQIgA0EANgIcIAMgATYCFCADQeUfNgIQIANBCDYCDAy/AgtB1QEhAgylAgsgA0HzATYCHCADIAE2AhQgAyAANgIMQQAhAgy9AgtBACEAAkAgAygCOCICRQ0AIAIoAkAiAkUNACADIAIRAAAhAAsgAEUNbiAAQRVHBEAgA0EANgIcIAMgATYCFCADQYIPNgIQIANBIDYCDEEAIQIMvQILIANBjwE2AhwgAyABNgIUIANB7Bs2AhAgA0EVNgIMQQAhAgy8AgsgASAERwRAIANBDTYCCCADIAE2AgRB0wEhAgyjAgtB8gEhAgy7AgsgASAERgRAQfEBIQIMuwILAkACQAJAIAEtAABByABrDgsAAQgICAgICAgIAggLIAFBAWohAUHQASECDKMCCyABQQFqIQFB0QEhAgyiAgsgAUEBaiEBQdIBIQIMoQILQfABIQIgASAERg25AiADKAIAIgAgBCABa2ohBiABIABrQQJqIQUDQCABLQAAIABBtdUAai0AAEcNBCAAQQJGDQMgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAY2AgAMuQILQe8BIQIgASAERg24AiADKAIAIgAgBCABa2ohBiABIABrQQFqIQUDQCABLQAAIABBs9UAai0AAEcNAyAAQQFGDQIgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAY2AgAMuAILQe4BIQIgASAERg23AiADKAIAIgAgBCABa2ohBiABIABrQQJqIQUDQCABLQAAIABBsNUAai0AAEcNAiAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAY2AgAMtwILIAMoAgQhACADQgA3AwAgAyAAIAVBAWoiARArIgBFDQIgA0HsATYCHCADIAE2AhQgAyAANgIMQQAhAgy2AgsgA0EANgIACyADKAIEIQAgA0EANgIEIAMgACABECsiAEUNnAIgA0HtATYCHCADIAE2AhQgAyAANgIMQQAhAgy0AgtBzwEhAgyaAgtBACEAAkAgAygCOCICRQ0AIAIoAjQiAkUNACADIAIRAAAhAAsCQCAABEAgAEEVRg0BIANBADYCHCADIAE2AhQgA0HqDTYCECADQSY2AgxBACECDLQCC0HOASECDJoCCyADQesBNgIcIAMgATYCFCADQYAbNgIQIANBFTYCDEEAIQIMsgILIAEgBEYEQEHrASECDLICCyABLQAAQS9GBEAgAUEBaiEBDAELIANBADYCHCADIAE2AhQgA0GyODYCECADQQg2AgxBACECDLECC0HNASECDJcCCyABIARHBEAgA0EONgIIIAMgATYCBEHMASECDJcCC0HqASECDK8CCyABIARGBEBB6QEhAgyvAgsgAS0AAEEwayIAQf8BcUEKSQRAIAMgADoAKiABQQFqIQFBywEhAgyWAgsgAygCBCEAIANBADYCBCADIAAgARAvIgBFDZcCIANB6AE2AhwgAyABNgIUIAMgADYCDEEAIQIMrgILIAEgBEYEQEHnASECDK4CCwJAIAEtAABBLkYEQCABQQFqIQEMAQsgAygCBCEAIANBADYCBCADIAAgARAvIgBFDZgCIANB5gE2AhwgAyABNgIUIAMgADYCDEEAIQIMrgILQcoBIQIMlAILIAEgBEYEQEHlASECDK0CC0EAIQBBASEFQQEhB0EAIQICQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQCABLQAAQTBrDgoKCQABAgMEBQYICwtBAgwGC0EDDAULQQQMBAtBBQwDC0EGDAILQQcMAQtBCAshAkEAIQVBACEHDAILQQkhAkEBIQBBACEFQQAhBwwBC0EAIQVBASECCyADIAI6ACsgAUEBaiEBAkACQCADLQAuQRBxDQACQAJAAkAgAy0AKg4DAQACBAsgB0UNAwwCCyAADQEMAgsgBUUNAQsgAygCBCEAIANBADYCBCADIAAgARAvIgBFDQIgA0HiATYCHCADIAE2AhQgAyAANgIMQQAhAgyvAgsgAygCBCEAIANBADYCBCADIAAgARAvIgBFDZoCIANB4wE2AhwgAyABNgIUIAMgADYCDEEAIQIMrgILIAMoAgQhACADQQA2AgQgAyAAIAEQLyIARQ2YAiADQeQBNgIcIAMgATYCFCADIAA2AgwMrQILQckBIQIMkwILQQAhAAJAIAMoAjgiAkUNACACKAJEIgJFDQAgAyACEQAAIQALAkAgAARAIABBFUYNASADQQA2AhwgAyABNgIUIANBpA02AhAgA0EhNgIMQQAhAgytAgtByAEhAgyTAgsgA0HhATYCHCADIAE2AhQgA0HQGjYCECADQRU2AgxBACECDKsCCyABIARGBEBB4QEhAgyrAgsCQCABLQAAQSBGBEAgA0EAOwE0IAFBAWohAQwBCyADQQA2AhwgAyABNgIUIANBmRE2AhAgA0EJNgIMQQAhAgyrAgtBxwEhAgyRAgsgASAERgRAQeABIQIMqgILAkAgAS0AAEEwa0H/AXEiAkEKSQRAIAFBAWohAQJAIAMvATQiAEGZM0sNACADIABBCmwiADsBNCAAQf7/A3EgAkH//wNzSw0AIAMgACACajsBNAwCC0EAIQIgA0EANgIcIAMgATYCFCADQZUeNgIQIANBDTYCDAyrAgsgA0EANgIcIAMgATYCFCADQZUeNgIQIANBDTYCDEEAIQIMqgILQcYBIQIMkAILIAEgBEYEQEHfASECDKkCCwJAIAEtAABBMGtB/wFxIgJBCkkEQCABQQFqIQECQCADLwE0IgBBmTNLDQAgAyAAQQpsIgA7ATQgAEH+/wNxIAJB//8Dc0sNACADIAAgAmo7ATQMAgtBACECIANBADYCHCADIAE2AhQgA0GVHjYCECADQQ02AgwMqgILIANBADYCHCADIAE2AhQgA0GVHjYCECADQQ02AgxBACECDKkCC0HFASECDI8CCyABIARGBEBB3gEhAgyoAgsCQCABLQAAQTBrQf8BcSICQQpJBEAgAUEBaiEBAkAgAy8BNCIAQZkzSw0AIAMgAEEKbCIAOwE0IABB/v8DcSACQf//A3NLDQAgAyAAIAJqOwE0DAILQQAhAiADQQA2AhwgAyABNgIUIANBlR42AhAgA0ENNgIMDKkCCyADQQA2AhwgAyABNgIUIANBlR42AhAgA0ENNgIMQQAhAgyoAgtBxAEhAgyOAgsgASAERgRAQd0BIQIMpwILAkACQAJAAkAgAS0AAEEKaw4XAgMDAAMDAwMDAwMDAwMDAwMDAwMDAwEDCyABQQFqDAULIAFBAWohAUHDASECDI8CCyABQQFqIQEgA0Evai0AAEEBcQ0IIANBADYCHCADIAE2AhQgA0GNCzYCECADQQ02AgxBACECDKcCCyADQQA2AhwgAyABNgIUIANBjQs2AhAgA0ENNgIMQQAhAgymAgsgASAERwRAIANBDzYCCCADIAE2AgRBASECDI0CC0HcASECDKUCCwJAAkADQAJAIAEtAABBCmsOBAIAAAMACyAEIAFBAWoiAUcNAAtB2wEhAgymAgsgAygCBCEAIANBADYCBCADIAAgARAtIgBFBEAgAUEBaiEBDAQLIANB2gE2AhwgAyAANgIMIAMgAUEBajYCFEEAIQIMpQILIAMoAgQhACADQQA2AgQgAyAAIAEQLSIADQEgAUEBagshAUHBASECDIoCCyADQdkBNgIcIAMgADYCDCADIAFBAWo2AhRBACECDKICC0HCASECDIgCCyADQS9qLQAAQQFxDQEgA0EANgIcIAMgATYCFCADQeQcNgIQIANBGTYCDEEAIQIMoAILIAEgBEYEQEHZASECDKACCwJAAkACQCABLQAAQQprDgQBAgIAAgsgAUEBaiEBDAILIAFBAWohAQwBCyADLQAuQcAAcUUNAQtBACEAAkAgAygCOCICRQ0AIAIoAjwiAkUNACADIAIRAAAhAAsgAEUNoAEgAEEVRgRAIANB2QA2AhwgAyABNgIUIANBtxo2AhAgA0EVNgIMQQAhAgyfAgsgA0EANgIcIAMgATYCFCADQYANNgIQIANBGzYCDEEAIQIMngILIANBADYCHCADIAE2AhQgA0HcKDYCECADQQI2AgxBACECDJ0CCyABIARHBEAgA0EMNgIIIAMgATYCBEG/ASECDIQCC0HYASECDJwCCyABIARGBEBB1wEhAgycAgsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAEtAABBwQBrDhUAAQIDWgQFBlpaWgcICQoLDA0ODxBaCyABQQFqIQFB+wAhAgySAgsgAUEBaiEBQfwAIQIMkQILIAFBAWohAUGBASECDJACCyABQQFqIQFBhQEhAgyPAgsgAUEBaiEBQYYBIQIMjgILIAFBAWohAUGJASECDI0CCyABQQFqIQFBigEhAgyMAgsgAUEBaiEBQY0BIQIMiwILIAFBAWohAUGWASECDIoCCyABQQFqIQFBlwEhAgyJAgsgAUEBaiEBQZgBIQIMiAILIAFBAWohAUGlASECDIcCCyABQQFqIQFBpgEhAgyGAgsgAUEBaiEBQawBIQIMhQILIAFBAWohAUG0ASECDIQCCyABQQFqIQFBtwEhAgyDAgsgAUEBaiEBQb4BIQIMggILIAEgBEYEQEHWASECDJsCCyABLQAAQc4ARw1IIAFBAWohAUG9ASECDIECCyABIARGBEBB1QEhAgyaAgsCQAJAAkAgAS0AAEHCAGsOEgBKSkpKSkpKSkoBSkpKSkpKAkoLIAFBAWohAUG4ASECDIICCyABQQFqIQFBuwEhAgyBAgsgAUEBaiEBQbwBIQIMgAILQdQBIQIgASAERg2YAiADKAIAIgAgBCABa2ohBSABIABrQQdqIQYCQANAIAEtAAAgAEGo1QBqLQAARw1FIABBB0YNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyZAgsgA0EANgIAIAZBAWohAUEbDEULIAEgBEYEQEHTASECDJgCCwJAAkAgAS0AAEHJAGsOBwBHR0dHRwFHCyABQQFqIQFBuQEhAgz/AQsgAUEBaiEBQboBIQIM/gELQdIBIQIgASAERg2WAiADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGm1QBqLQAARw1DIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyXAgsgA0EANgIAIAZBAWohAUEPDEMLQdEBIQIgASAERg2VAiADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGk1QBqLQAARw1CIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyWAgsgA0EANgIAIAZBAWohAUEgDEILQdABIQIgASAERg2UAiADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGh1QBqLQAARw1BIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyVAgsgA0EANgIAIAZBAWohAUESDEELIAEgBEYEQEHPASECDJQCCwJAAkAgAS0AAEHFAGsODgBDQ0NDQ0NDQ0NDQ0MBQwsgAUEBaiEBQbUBIQIM+wELIAFBAWohAUG2ASECDPoBC0HOASECIAEgBEYNkgIgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBntUAai0AAEcNPyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMkwILIANBADYCACAGQQFqIQFBBww/C0HNASECIAEgBEYNkQIgAygCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABBmNUAai0AAEcNPiAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMkgILIANBADYCACAGQQFqIQFBKAw+CyABIARGBEBBzAEhAgyRAgsCQAJAAkAgAS0AAEHFAGsOEQBBQUFBQUFBQUEBQUFBQUECQQsgAUEBaiEBQbEBIQIM+QELIAFBAWohAUGyASECDPgBCyABQQFqIQFBswEhAgz3AQtBywEhAiABIARGDY8CIAMoAgAiACAEIAFraiEFIAEgAGtBBmohBgJAA0AgAS0AACAAQZHVAGotAABHDTwgAEEGRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADJACCyADQQA2AgAgBkEBaiEBQRoMPAtBygEhAiABIARGDY4CIAMoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQY3VAGotAABHDTsgAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADI8CCyADQQA2AgAgBkEBaiEBQSEMOwsgASAERgRAQckBIQIMjgILAkACQCABLQAAQcEAaw4UAD09PT09PT09PT09PT09PT09PQE9CyABQQFqIQFBrQEhAgz1AQsgAUEBaiEBQbABIQIM9AELIAEgBEYEQEHIASECDI0CCwJAAkAgAS0AAEHVAGsOCwA8PDw8PDw8PDwBPAsgAUEBaiEBQa4BIQIM9AELIAFBAWohAUGvASECDPMBC0HHASECIAEgBEYNiwIgAygCACIAIAQgAWtqIQUgASAAa0EIaiEGAkADQCABLQAAIABBhNUAai0AAEcNOCAAQQhGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMjAILIANBADYCACAGQQFqIQFBKgw4CyABIARGBEBBxgEhAgyLAgsgAS0AAEHQAEcNOCABQQFqIQFBJQw3C0HFASECIAEgBEYNiQIgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBgdUAai0AAEcNNiAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMigILIANBADYCACAGQQFqIQFBDgw2CyABIARGBEBBxAEhAgyJAgsgAS0AAEHFAEcNNiABQQFqIQFBqwEhAgzvAQsgASAERgRAQcMBIQIMiAILAkACQAJAAkAgAS0AAEHCAGsODwABAjk5OTk5OTk5OTk5AzkLIAFBAWohAUGnASECDPEBCyABQQFqIQFBqAEhAgzwAQsgAUEBaiEBQakBIQIM7wELIAFBAWohAUGqASECDO4BC0HCASECIAEgBEYNhgIgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB/tQAai0AAEcNMyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMhwILIANBADYCACAGQQFqIQFBFAwzC0HBASECIAEgBEYNhQIgAygCACIAIAQgAWtqIQUgASAAa0EEaiEGAkADQCABLQAAIABB+dQAai0AAEcNMiAAQQRGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMhgILIANBADYCACAGQQFqIQFBKwwyC0HAASECIAEgBEYNhAIgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABB9tQAai0AAEcNMSAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMhQILIANBADYCACAGQQFqIQFBLAwxC0G/ASECIAEgBEYNgwIgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBodUAai0AAEcNMCAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMhAILIANBADYCACAGQQFqIQFBEQwwC0G+ASECIAEgBEYNggIgAygCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABB8tQAai0AAEcNLyAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMgwILIANBADYCACAGQQFqIQFBLgwvCyABIARGBEBBvQEhAgyCAgsCQAJAAkACQAJAIAEtAABBwQBrDhUANDQ0NDQ0NDQ0NAE0NAI0NAM0NAQ0CyABQQFqIQFBmwEhAgzsAQsgAUEBaiEBQZwBIQIM6wELIAFBAWohAUGdASECDOoBCyABQQFqIQFBogEhAgzpAQsgAUEBaiEBQaQBIQIM6AELIAEgBEYEQEG8ASECDIECCwJAAkAgAS0AAEHSAGsOAwAwATALIAFBAWohAUGjASECDOgBCyABQQFqIQFBBAwtC0G7ASECIAEgBEYN/wEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB8NQAai0AAEcNLCAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMgAILIANBADYCACAGQQFqIQFBHQwsCyABIARGBEBBugEhAgz/AQsCQAJAIAEtAABByQBrDgcBLi4uLi4ALgsgAUEBaiEBQaEBIQIM5gELIAFBAWohAUEiDCsLIAEgBEYEQEG5ASECDP4BCyABLQAAQdAARw0rIAFBAWohAUGgASECDOQBCyABIARGBEBBuAEhAgz9AQsCQAJAIAEtAABBxgBrDgsALCwsLCwsLCwsASwLIAFBAWohAUGeASECDOQBCyABQQFqIQFBnwEhAgzjAQtBtwEhAiABIARGDfsBIAMoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQezUAGotAABHDSggAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADPwBCyADQQA2AgAgBkEBaiEBQQ0MKAtBtgEhAiABIARGDfoBIAMoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQaHVAGotAABHDScgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADPsBCyADQQA2AgAgBkEBaiEBQQwMJwtBtQEhAiABIARGDfkBIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQerUAGotAABHDSYgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADPoBCyADQQA2AgAgBkEBaiEBQQMMJgtBtAEhAiABIARGDfgBIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQejUAGotAABHDSUgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADPkBCyADQQA2AgAgBkEBaiEBQSYMJQsgASAERgRAQbMBIQIM+AELAkACQCABLQAAQdQAaw4CAAEnCyABQQFqIQFBmQEhAgzfAQsgAUEBaiEBQZoBIQIM3gELQbIBIQIgASAERg32ASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHm1ABqLQAARw0jIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAz3AQsgA0EANgIAIAZBAWohAUEnDCMLQbEBIQIgASAERg31ASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHk1ABqLQAARw0iIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAz2AQsgA0EANgIAIAZBAWohAUEcDCILQbABIQIgASAERg30ASADKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEHe1ABqLQAARw0hIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAz1AQsgA0EANgIAIAZBAWohAUEGDCELQa8BIQIgASAERg3zASADKAIAIgAgBCABa2ohBSABIABrQQRqIQYCQANAIAEtAAAgAEHZ1ABqLQAARw0gIABBBEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAz0AQsgA0EANgIAIAZBAWohAUEZDCALIAEgBEYEQEGuASECDPMBCwJAAkACQAJAIAEtAABBLWsOIwAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAEkJCQkJAIkJCQDJAsgAUEBaiEBQY4BIQIM3AELIAFBAWohAUGPASECDNsBCyABQQFqIQFBlAEhAgzaAQsgAUEBaiEBQZUBIQIM2QELQa0BIQIgASAERg3xASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHX1ABqLQAARw0eIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzyAQsgA0EANgIAIAZBAWohAUELDB4LIAEgBEYEQEGsASECDPEBCwJAAkAgAS0AAEHBAGsOAwAgASALIAFBAWohAUGQASECDNgBCyABQQFqIQFBkwEhAgzXAQsgASAERgRAQasBIQIM8AELAkACQCABLQAAQcEAaw4PAB8fHx8fHx8fHx8fHx8BHwsgAUEBaiEBQZEBIQIM1wELIAFBAWohAUGSASECDNYBCyABIARGBEBBqgEhAgzvAQsgAS0AAEHMAEcNHCABQQFqIQFBCgwbC0GpASECIAEgBEYN7QEgAygCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABB0dQAai0AAEcNGiAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM7gELIANBADYCACAGQQFqIQFBHgwaC0GoASECIAEgBEYN7AEgAygCACIAIAQgAWtqIQUgASAAa0EGaiEGAkADQCABLQAAIABBytQAai0AAEcNGSAAQQZGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM7QELIANBADYCACAGQQFqIQFBFQwZC0GnASECIAEgBEYN6wEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBx9QAai0AAEcNGCAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM7AELIANBADYCACAGQQFqIQFBFwwYC0GmASECIAEgBEYN6gEgAygCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABBwdQAai0AAEcNFyAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM6wELIANBADYCACAGQQFqIQFBGAwXCyABIARGBEBBpQEhAgzqAQsCQAJAIAEtAABByQBrDgcAGRkZGRkBGQsgAUEBaiEBQYsBIQIM0QELIAFBAWohAUGMASECDNABC0GkASECIAEgBEYN6AEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABBptUAai0AAEcNFSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM6QELIANBADYCACAGQQFqIQFBCQwVC0GjASECIAEgBEYN5wEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABBpNUAai0AAEcNFCAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM6AELIANBADYCACAGQQFqIQFBHwwUC0GiASECIAEgBEYN5gEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBvtQAai0AAEcNEyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM5wELIANBADYCACAGQQFqIQFBAgwTC0GhASECIAEgBEYN5QEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGA0AgAS0AACAAQbzUAGotAABHDREgAEEBRg0CIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADOUBCyABIARGBEBBoAEhAgzlAQtBASABLQAAQd8ARw0RGiABQQFqIQFBhwEhAgzLAQsgA0EANgIAIAZBAWohAUGIASECDMoBC0GfASECIAEgBEYN4gEgAygCACIAIAQgAWtqIQUgASAAa0EIaiEGAkADQCABLQAAIABBhNUAai0AAEcNDyAAQQhGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM4wELIANBADYCACAGQQFqIQFBKQwPC0GeASECIAEgBEYN4QEgAygCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABBuNQAai0AAEcNDiAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM4gELIANBADYCACAGQQFqIQFBLQwOCyABIARGBEBBnQEhAgzhAQsgAS0AAEHFAEcNDiABQQFqIQFBhAEhAgzHAQsgASAERgRAQZwBIQIM4AELAkACQCABLQAAQcwAaw4IAA8PDw8PDwEPCyABQQFqIQFBggEhAgzHAQsgAUEBaiEBQYMBIQIMxgELQZsBIQIgASAERg3eASADKAIAIgAgBCABa2ohBSABIABrQQRqIQYCQANAIAEtAAAgAEGz1ABqLQAARw0LIABBBEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzfAQsgA0EANgIAIAZBAWohAUEjDAsLQZoBIQIgASAERg3dASADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGw1ABqLQAARw0KIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzeAQsgA0EANgIAIAZBAWohAUEADAoLIAEgBEYEQEGZASECDN0BCwJAAkAgAS0AAEHIAGsOCAAMDAwMDAwBDAsgAUEBaiEBQf0AIQIMxAELIAFBAWohAUGAASECDMMBCyABIARGBEBBmAEhAgzcAQsCQAJAIAEtAABBzgBrDgMACwELCyABQQFqIQFB/gAhAgzDAQsgAUEBaiEBQf8AIQIMwgELIAEgBEYEQEGXASECDNsBCyABLQAAQdkARw0IIAFBAWohAUEIDAcLQZYBIQIgASAERg3ZASADKAIAIgAgBCABa2ohBSABIABrQQNqIQYCQANAIAEtAAAgAEGs1ABqLQAARw0GIABBA0YNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzaAQsgA0EANgIAIAZBAWohAUEFDAYLQZUBIQIgASAERg3YASADKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGm1ABqLQAARw0FIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzZAQsgA0EANgIAIAZBAWohAUEWDAULQZQBIQIgASAERg3XASADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGh1QBqLQAARw0EIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzYAQsgA0EANgIAIAZBAWohAUEQDAQLIAEgBEYEQEGTASECDNcBCwJAAkAgAS0AAEHDAGsODAAGBgYGBgYGBgYGAQYLIAFBAWohAUH5ACECDL4BCyABQQFqIQFB+gAhAgy9AQtBkgEhAiABIARGDdUBIAMoAgAiACAEIAFraiEFIAEgAGtBBWohBgJAA0AgAS0AACAAQaDUAGotAABHDQIgAEEFRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADNYBCyADQQA2AgAgBkEBaiEBQSQMAgsgA0EANgIADAILIAEgBEYEQEGRASECDNQBCyABLQAAQcwARw0BIAFBAWohAUETCzoAKSADKAIEIQAgA0EANgIEIAMgACABEC4iAA0CDAELQQAhAiADQQA2AhwgAyABNgIUIANB/h82AhAgA0EGNgIMDNEBC0H4ACECDLcBCyADQZABNgIcIAMgATYCFCADIAA2AgxBACECDM8BC0EAIQACQCADKAI4IgJFDQAgAigCQCICRQ0AIAMgAhEAACEACyAARQ0AIABBFUYNASADQQA2AhwgAyABNgIUIANBgg82AhAgA0EgNgIMQQAhAgzOAQtB9wAhAgy0AQsgA0GPATYCHCADIAE2AhQgA0HsGzYCECADQRU2AgxBACECDMwBCyABIARGBEBBjwEhAgzMAQsCQCABLQAAQSBGBEAgAUEBaiEBDAELIANBADYCHCADIAE2AhQgA0GbHzYCECADQQY2AgxBACECDMwBC0ECIQIMsgELA0AgAS0AAEEgRw0CIAQgAUEBaiIBRw0AC0GOASECDMoBCyABIARGBEBBjQEhAgzKAQsCQCABLQAAQQlrDgRKAABKAAtB9QAhAgywAQsgAy0AKUEFRgRAQfYAIQIMsAELQfQAIQIMrwELIAEgBEYEQEGMASECDMgBCyADQRA2AgggAyABNgIEDAoLIAEgBEYEQEGLASECDMcBCwJAIAEtAABBCWsOBEcAAEcAC0HzACECDK0BCyABIARHBEAgA0EQNgIIIAMgATYCBEHxACECDK0BC0GKASECDMUBCwJAIAEgBEcEQANAIAEtAABBoNAAai0AACIAQQNHBEACQCAAQQFrDgJJAAQLQfAAIQIMrwELIAQgAUEBaiIBRw0AC0GIASECDMYBC0GIASECDMUBCyADQQA2AhwgAyABNgIUIANB2yA2AhAgA0EHNgIMQQAhAgzEAQsgASAERgRAQYkBIQIMxAELAkACQAJAIAEtAABBoNIAai0AAEEBaw4DRgIAAQtB8gAhAgysAQsgA0EANgIcIAMgATYCFCADQbQSNgIQIANBBzYCDEEAIQIMxAELQeoAIQIMqgELIAEgBEcEQCABQQFqIQFB7wAhAgyqAQtBhwEhAgzCAQsgBCABIgBGBEBBhgEhAgzCAQsgAC0AACIBQS9GBEAgAEEBaiEBQe4AIQIMqQELIAFBCWsiAkEXSw0BIAAhAUEBIAJ0QZuAgARxDUEMAQsgBCABIgBGBEBBhQEhAgzBAQsgAC0AAEEvRw0AIABBAWohAQwDC0EAIQIgA0EANgIcIAMgADYCFCADQdsgNgIQIANBBzYCDAy/AQsCQAJAAkACQAJAA0AgAS0AAEGgzgBqLQAAIgBBBUcEQAJAAkAgAEEBaw4IRwUGBwgABAEIC0HrACECDK0BCyABQQFqIQFB7QAhAgysAQsgBCABQQFqIgFHDQALQYQBIQIMwwELIAFBAWoMFAsgAygCBCEAIANBADYCBCADIAAgARAsIgBFDR4gA0HbADYCHCADIAE2AhQgAyAANgIMQQAhAgzBAQsgAygCBCEAIANBADYCBCADIAAgARAsIgBFDR4gA0HdADYCHCADIAE2AhQgAyAANgIMQQAhAgzAAQsgAygCBCEAIANBADYCBCADIAAgARAsIgBFDR4gA0H6ADYCHCADIAE2AhQgAyAANgIMQQAhAgy/AQsgA0EANgIcIAMgATYCFCADQfkPNgIQIANBBzYCDEEAIQIMvgELIAEgBEYEQEGDASECDL4BCwJAIAEtAABBoM4Aai0AAEEBaw4IPgQFBgAIAgMHCyABQQFqIQELQQMhAgyjAQsgAUEBagwNC0EAIQIgA0EANgIcIANB0RI2AhAgA0EHNgIMIAMgAUEBajYCFAy6AQsgAygCBCEAIANBADYCBCADIAAgARAsIgBFDRYgA0HbADYCHCADIAE2AhQgAyAANgIMQQAhAgy5AQsgAygCBCEAIANBADYCBCADIAAgARAsIgBFDRYgA0HdADYCHCADIAE2AhQgAyAANgIMQQAhAgy4AQsgAygCBCEAIANBADYCBCADIAAgARAsIgBFDRYgA0H6ADYCHCADIAE2AhQgAyAANgIMQQAhAgy3AQsgA0EANgIcIAMgATYCFCADQfkPNgIQIANBBzYCDEEAIQIMtgELQewAIQIMnAELIAEgBEYEQEGCASECDLUBCyABQQFqDAILIAEgBEYEQEGBASECDLQBCyABQQFqDAELIAEgBEYNASABQQFqCyEBQQQhAgyYAQtBgAEhAgywAQsDQCABLQAAQaDMAGotAAAiAEECRwRAIABBAUcEQEHpACECDJkBCwwxCyAEIAFBAWoiAUcNAAtB/wAhAgyvAQsgASAERgRAQf4AIQIMrwELAkAgAS0AAEEJaw43LwMGLwQGBgYGBgYGBgYGBgYGBgYGBgYFBgYCBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGAAYLIAFBAWoLIQFBBSECDJQBCyABQQFqDAYLIAMoAgQhACADQQA2AgQgAyAAIAEQLCIARQ0IIANB2wA2AhwgAyABNgIUIAMgADYCDEEAIQIMqwELIAMoAgQhACADQQA2AgQgAyAAIAEQLCIARQ0IIANB3QA2AhwgAyABNgIUIAMgADYCDEEAIQIMqgELIAMoAgQhACADQQA2AgQgAyAAIAEQLCIARQ0IIANB+gA2AhwgAyABNgIUIAMgADYCDEEAIQIMqQELIANBADYCHCADIAE2AhQgA0GNFDYCECADQQc2AgxBACECDKgBCwJAAkACQAJAA0AgAS0AAEGgygBqLQAAIgBBBUcEQAJAIABBAWsOBi4DBAUGAAYLQegAIQIMlAELIAQgAUEBaiIBRw0AC0H9ACECDKsBCyADKAIEIQAgA0EANgIEIAMgACABECwiAEUNByADQdsANgIcIAMgATYCFCADIAA2AgxBACECDKoBCyADKAIEIQAgA0EANgIEIAMgACABECwiAEUNByADQd0ANgIcIAMgATYCFCADIAA2AgxBACECDKkBCyADKAIEIQAgA0EANgIEIAMgACABECwiAEUNByADQfoANgIcIAMgATYCFCADIAA2AgxBACECDKgBCyADQQA2AhwgAyABNgIUIANB5Ag2AhAgA0EHNgIMQQAhAgynAQsgASAERg0BIAFBAWoLIQFBBiECDIwBC0H8ACECDKQBCwJAAkACQAJAA0AgAS0AAEGgyABqLQAAIgBBBUcEQCAAQQFrDgQpAgMEBQsgBCABQQFqIgFHDQALQfsAIQIMpwELIAMoAgQhACADQQA2AgQgAyAAIAEQLCIARQ0DIANB2wA2AhwgAyABNgIUIAMgADYCDEEAIQIMpgELIAMoAgQhACADQQA2AgQgAyAAIAEQLCIARQ0DIANB3QA2AhwgAyABNgIUIAMgADYCDEEAIQIMpQELIAMoAgQhACADQQA2AgQgAyAAIAEQLCIARQ0DIANB+gA2AhwgAyABNgIUIAMgADYCDEEAIQIMpAELIANBADYCHCADIAE2AhQgA0G8CjYCECADQQc2AgxBACECDKMBC0HPACECDIkBC0HRACECDIgBC0HnACECDIcBCyABIARGBEBB+gAhAgygAQsCQCABLQAAQQlrDgQgAAAgAAsgAUEBaiEBQeYAIQIMhgELIAEgBEYEQEH5ACECDJ8BCwJAIAEtAABBCWsOBB8AAB8AC0EAIQACQCADKAI4IgJFDQAgAigCOCICRQ0AIAMgAhEAACEACyAARQRAQeIBIQIMhgELIABBFUcEQCADQQA2AhwgAyABNgIUIANByQ02AhAgA0EaNgIMQQAhAgyfAQsgA0H4ADYCHCADIAE2AhQgA0HqGjYCECADQRU2AgxBACECDJ4BCyABIARHBEAgA0ENNgIIIAMgATYCBEHkACECDIUBC0H3ACECDJ0BCyABIARGBEBB9gAhAgydAQsCQAJAAkAgAS0AAEHIAGsOCwABCwsLCwsLCwsCCwsgAUEBaiEBQd0AIQIMhQELIAFBAWohAUHgACECDIQBCyABQQFqIQFB4wAhAgyDAQtB9QAhAiABIARGDZsBIAMoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQbXVAGotAABHDQggAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADJwBCyADKAIEIQAgA0IANwMAIAMgACAGQQFqIgEQKyIABEAgA0H0ADYCHCADIAE2AhQgAyAANgIMQQAhAgycAQtB4gAhAgyCAQtBACEAAkAgAygCOCICRQ0AIAIoAjQiAkUNACADIAIRAAAhAAsCQCAABEAgAEEVRg0BIANBADYCHCADIAE2AhQgA0HqDTYCECADQSY2AgxBACECDJwBC0HhACECDIIBCyADQfMANgIcIAMgATYCFCADQYAbNgIQIANBFTYCDEEAIQIMmgELIAMtACkiAEEja0ELSQ0JAkAgAEEGSw0AQQEgAHRBygBxRQ0ADAoLQQAhAiADQQA2AhwgAyABNgIUIANB7Qk2AhAgA0EINgIMDJkBC0HyACECIAEgBEYNmAEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABBs9UAai0AAEcNBSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMmQELIAMoAgQhACADQgA3AwAgAyAAIAZBAWoiARArIgAEQCADQfEANgIcIAMgATYCFCADIAA2AgxBACECDJkBC0HfACECDH8LQQAhAAJAIAMoAjgiAkUNACACKAI0IgJFDQAgAyACEQAAIQALAkAgAARAIABBFUYNASADQQA2AhwgAyABNgIUIANB6g02AhAgA0EmNgIMQQAhAgyZAQtB3gAhAgx/CyADQfAANgIcIAMgATYCFCADQYAbNgIQIANBFTYCDEEAIQIMlwELIAMtAClBIUYNBiADQQA2AhwgAyABNgIUIANBkQo2AhAgA0EINgIMQQAhAgyWAQtB7wAhAiABIARGDZUBIAMoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQbDVAGotAABHDQIgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADJYBCyADKAIEIQAgA0IANwMAIAMgACAGQQFqIgEQKyIARQ0CIANB7QA2AhwgAyABNgIUIAMgADYCDEEAIQIMlQELIANBADYCAAsgAygCBCEAIANBADYCBCADIAAgARArIgBFDYABIANB7gA2AhwgAyABNgIUIAMgADYCDEEAIQIMkwELQdwAIQIMeQtBACEAAkAgAygCOCICRQ0AIAIoAjQiAkUNACADIAIRAAAhAAsCQCAABEAgAEEVRg0BIANBADYCHCADIAE2AhQgA0HqDTYCECADQSY2AgxBACECDJMBC0HbACECDHkLIANB7AA2AhwgAyABNgIUIANBgBs2AhAgA0EVNgIMQQAhAgyRAQsgAy0AKSIAQSNJDQAgAEEuRg0AIANBADYCHCADIAE2AhQgA0HJCTYCECADQQg2AgxBACECDJABC0HaACECDHYLIAEgBEYEQEHrACECDI8BCwJAIAEtAABBL0YEQCABQQFqIQEMAQsgA0EANgIcIAMgATYCFCADQbI4NgIQIANBCDYCDEEAIQIMjwELQdkAIQIMdQsgASAERwRAIANBDjYCCCADIAE2AgRB2AAhAgx1C0HqACECDI0BCyABIARGBEBB6QAhAgyNAQsgAS0AAEEwayIAQf8BcUEKSQRAIAMgADoAKiABQQFqIQFB1wAhAgx0CyADKAIEIQAgA0EANgIEIAMgACABEC8iAEUNeiADQegANgIcIAMgATYCFCADIAA2AgxBACECDIwBCyABIARGBEBB5wAhAgyMAQsCQCABLQAAQS5GBEAgAUEBaiEBDAELIAMoAgQhACADQQA2AgQgAyAAIAEQLyIARQ17IANB5gA2AhwgAyABNgIUIAMgADYCDEEAIQIMjAELQdYAIQIMcgsgASAERgRAQeUAIQIMiwELQQAhAEEBIQVBASEHQQAhAgJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAIAEtAABBMGsOCgoJAAECAwQFBggLC0ECDAYLQQMMBQtBBAwEC0EFDAMLQQYMAgtBBwwBC0EICyECQQAhBUEAIQcMAgtBCSECQQEhAEEAIQVBACEHDAELQQAhBUEBIQILIAMgAjoAKyABQQFqIQECQAJAIAMtAC5BEHENAAJAAkACQCADLQAqDgMBAAIECyAHRQ0DDAILIAANAQwCCyAFRQ0BCyADKAIEIQAgA0EANgIEIAMgACABEC8iAEUNAiADQeIANgIcIAMgATYCFCADIAA2AgxBACECDI0BCyADKAIEIQAgA0EANgIEIAMgACABEC8iAEUNfSADQeMANgIcIAMgATYCFCADIAA2AgxBACECDIwBCyADKAIEIQAgA0EANgIEIAMgACABEC8iAEUNeyADQeQANgIcIAMgATYCFCADIAA2AgwMiwELQdQAIQIMcQsgAy0AKUEiRg2GAUHTACECDHALQQAhAAJAIAMoAjgiAkUNACACKAJEIgJFDQAgAyACEQAAIQALIABFBEBB1QAhAgxwCyAAQRVHBEAgA0EANgIcIAMgATYCFCADQaQNNgIQIANBITYCDEEAIQIMiQELIANB4QA2AhwgAyABNgIUIANB0Bo2AhAgA0EVNgIMQQAhAgyIAQsgASAERgRAQeAAIQIMiAELAkACQAJAAkACQCABLQAAQQprDgQBBAQABAsgAUEBaiEBDAELIAFBAWohASADQS9qLQAAQQFxRQ0BC0HSACECDHALIANBADYCHCADIAE2AhQgA0G2ETYCECADQQk2AgxBACECDIgBCyADQQA2AhwgAyABNgIUIANBthE2AhAgA0EJNgIMQQAhAgyHAQsgASAERgRAQd8AIQIMhwELIAEtAABBCkYEQCABQQFqIQEMCQsgAy0ALkHAAHENCCADQQA2AhwgAyABNgIUIANBthE2AhAgA0ECNgIMQQAhAgyGAQsgASAERgRAQd0AIQIMhgELIAEtAAAiAkENRgRAIAFBAWohAUHQACECDG0LIAEhACACQQlrDgQFAQEFAQsgBCABIgBGBEBB3AAhAgyFAQsgAC0AAEEKRw0AIABBAWoMAgtBACECIANBADYCHCADIAA2AhQgA0HKLTYCECADQQc2AgwMgwELIAEgBEYEQEHbACECDIMBCwJAIAEtAABBCWsOBAMAAAMACyABQQFqCyEBQc4AIQIMaAsgASAERgRAQdoAIQIMgQELIAEtAABBCWsOBAABAQABC0EAIQIgA0EANgIcIANBmhI2AhAgA0EHNgIMIAMgAUEBajYCFAx/CyADQYASOwEqQQAhAAJAIAMoAjgiAkUNACACKAI4IgJFDQAgAyACEQAAIQALIABFDQAgAEEVRw0BIANB2QA2AhwgAyABNgIUIANB6ho2AhAgA0EVNgIMQQAhAgx+C0HNACECDGQLIANBADYCHCADIAE2AhQgA0HJDTYCECADQRo2AgxBACECDHwLIAEgBEYEQEHZACECDHwLIAEtAABBIEcNPSABQQFqIQEgAy0ALkEBcQ09IANBADYCHCADIAE2AhQgA0HCHDYCECADQR42AgxBACECDHsLIAEgBEYEQEHYACECDHsLAkACQAJAAkACQCABLQAAIgBBCmsOBAIDAwABCyABQQFqIQFBLCECDGULIABBOkcNASADQQA2AhwgAyABNgIUIANB5xE2AhAgA0EKNgIMQQAhAgx9CyABQQFqIQEgA0Evai0AAEEBcUUNcyADLQAyQYABcUUEQCADQTJqIQIgAxA1QQAhAAJAIAMoAjgiBkUNACAGKAIoIgZFDQAgAyAGEQAAIQALAkACQCAADhZNTEsBAQEBAQEBAQEBAQEBAQEBAQEAAQsgA0EpNgIcIAMgATYCFCADQawZNgIQIANBFTYCDEEAIQIMfgsgA0EANgIcIAMgATYCFCADQeULNgIQIANBETYCDEEAIQIMfQtBACEAAkAgAygCOCICRQ0AIAIoAlwiAkUNACADIAIRAAAhAAsgAEUNWSAAQRVHDQEgA0EFNgIcIAMgATYCFCADQZsbNgIQIANBFTYCDEEAIQIMfAtBywAhAgxiC0EAIQIgA0EANgIcIAMgATYCFCADQZAONgIQIANBFDYCDAx6CyADIAMvATJBgAFyOwEyDDsLIAEgBEcEQCADQRE2AgggAyABNgIEQcoAIQIMYAtB1wAhAgx4CyABIARGBEBB1gAhAgx4CwJAAkACQAJAIAEtAAAiAEEgciAAIABBwQBrQf8BcUEaSRtB/wFxQeMAaw4TAEBAQEBAQEBAQEBAQAFAQEACA0ALIAFBAWohAUHGACECDGELIAFBAWohAUHHACECDGALIAFBAWohAUHIACECDF8LIAFBAWohAUHJACECDF4LQdUAIQIgBCABIgBGDXYgBCABayADKAIAIgFqIQYgACABa0EFaiEHA0AgAUGQyABqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0IQQQgAUEFRg0KGiABQQFqIQEgBCAAQQFqIgBHDQALIAMgBjYCAAx2C0HUACECIAQgASIARg11IAQgAWsgAygCACIBaiEGIAAgAWtBD2ohBwNAIAFBgMgAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNB0EDIAFBD0YNCRogAUEBaiEBIAQgAEEBaiIARw0ACyADIAY2AgAMdQtB0wAhAiAEIAEiAEYNdCAEIAFrIAMoAgAiAWohBiAAIAFrQQ5qIQcDQCABQeLHAGotAAAgAC0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDQYgAUEORg0HIAFBAWohASAEIABBAWoiAEcNAAsgAyAGNgIADHQLQdIAIQIgBCABIgBGDXMgBCABayADKAIAIgFqIQUgACABa0EBaiEGA0AgAUHgxwBqLQAAIAAtAAAiB0EgciAHIAdBwQBrQf8BcUEaSRtB/wFxRw0FIAFBAUYNAiABQQFqIQEgBCAAQQFqIgBHDQALIAMgBTYCAAxzCyABIARGBEBB0QAhAgxzCwJAAkAgAS0AACIAQSByIAAgAEHBAGtB/wFxQRpJG0H/AXFB7gBrDgcAOTk5OTkBOQsgAUEBaiEBQcMAIQIMWgsgAUEBaiEBQcQAIQIMWQsgA0EANgIAIAZBAWohAUHFACECDFgLQdAAIQIgBCABIgBGDXAgBCABayADKAIAIgFqIQYgACABa0EJaiEHA0AgAUHWxwBqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0CQQIgAUEJRg0EGiABQQFqIQEgBCAAQQFqIgBHDQALIAMgBjYCAAxwC0HPACECIAQgASIARg1vIAQgAWsgAygCACIBaiEGIAAgAWtBBWohBwNAIAFB0McAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNASABQQVGDQIgAUEBaiEBIAQgAEEBaiIARw0ACyADIAY2AgAMbwsgACEBIANBADYCAAwzC0EBCzoALCADQQA2AgAgB0EBaiEBC0EtIQIMUgsCQANAIAEtAABB0MUAai0AAEEBRw0BIAQgAUEBaiIBRw0AC0HNACECDGsLQcIAIQIMUQsgASAERgRAQcwAIQIMagsgAS0AAEE6RgRAIAMoAgQhACADQQA2AgQgAyAAIAEQMCIARQ0zIANBywA2AhwgAyAANgIMIAMgAUEBajYCFEEAIQIMagsgA0EANgIcIAMgATYCFCADQecRNgIQIANBCjYCDEEAIQIMaQsCQAJAIAMtACxBAmsOAgABJwsgA0Ezai0AAEECcUUNJiADLQAuQQJxDSYgA0EANgIcIAMgATYCFCADQaYUNgIQIANBCzYCDEEAIQIMaQsgAy0AMkEgcUUNJSADLQAuQQJxDSUgA0EANgIcIAMgATYCFCADQb0TNgIQIANBDzYCDEEAIQIMaAtBACEAAkAgAygCOCICRQ0AIAIoAkgiAkUNACADIAIRAAAhAAsgAEUEQEHBACECDE8LIABBFUcEQCADQQA2AhwgAyABNgIUIANBpg82AhAgA0EcNgIMQQAhAgxoCyADQcoANgIcIAMgATYCFCADQYUcNgIQIANBFTYCDEEAIQIMZwsgASAERwRAA0AgAS0AAEHAwQBqLQAAQQFHDRcgBCABQQFqIgFHDQALQcQAIQIMZwtBxAAhAgxmCyABIARHBEADQAJAIAEtAAAiAEEgciAAIABBwQBrQf8BcUEaSRtB/wFxIgBBCUYNACAAQSBGDQACQAJAAkACQCAAQeMAaw4TAAMDAwMDAwMBAwMDAwMDAwMDAgMLIAFBAWohAUE2IQIMUgsgAUEBaiEBQTchAgxRCyABQQFqIQFBOCECDFALDBULIAQgAUEBaiIBRw0AC0E8IQIMZgtBPCECDGULIAEgBEYEQEHIACECDGULIANBEjYCCCADIAE2AgQCQAJAAkACQAJAIAMtACxBAWsOBBQAAQIJCyADLQAyQSBxDQNB4AEhAgxPCwJAIAMvATIiAEEIcUUNACADLQAoQQFHDQAgAy0ALkEIcUUNAgsgAyAAQff7A3FBgARyOwEyDAsLIAMgAy8BMkEQcjsBMgwECyADQQA2AgQgAyABIAEQMSIABEAgA0HBADYCHCADIAA2AgwgAyABQQFqNgIUQQAhAgxmCyABQQFqIQEMWAsgA0EANgIcIAMgATYCFCADQfQTNgIQIANBBDYCDEEAIQIMZAtBxwAhAiABIARGDWMgAygCACIAIAQgAWtqIQUgASAAa0EGaiEGAkADQCAAQcDFAGotAAAgAS0AAEEgckcNASAAQQZGDUogAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMZAsgA0EANgIADAULAkAgASAERwRAA0AgAS0AAEHAwwBqLQAAIgBBAUcEQCAAQQJHDQMgAUEBaiEBDAULIAQgAUEBaiIBRw0AC0HFACECDGQLQcUAIQIMYwsLIANBADoALAwBC0ELIQIMRwtBPyECDEYLAkACQANAIAEtAAAiAEEgRwRAAkAgAEEKaw4EAwUFAwALIABBLEYNAwwECyAEIAFBAWoiAUcNAAtBxgAhAgxgCyADQQg6ACwMDgsgAy0AKEEBRw0CIAMtAC5BCHENAiADKAIEIQAgA0EANgIEIAMgACABEDEiAARAIANBwgA2AhwgAyAANgIMIAMgAUEBajYCFEEAIQIMXwsgAUEBaiEBDFALQTshAgxECwJAA0AgAS0AACIAQSBHIABBCUdxDQEgBCABQQFqIgFHDQALQcMAIQIMXQsLQTwhAgxCCwJAAkAgASAERwRAA0AgAS0AACIAQSBHBEAgAEEKaw4EAwQEAwQLIAQgAUEBaiIBRw0AC0E/IQIMXQtBPyECDFwLIAMgAy8BMkEgcjsBMgwKCyADKAIEIQAgA0EANgIEIAMgACABEDEiAEUNTiADQT42AhwgAyABNgIUIAMgADYCDEEAIQIMWgsCQCABIARHBEADQCABLQAAQcDDAGotAAAiAEEBRwRAIABBAkYNAwwMCyAEIAFBAWoiAUcNAAtBNyECDFsLQTchAgxaCyABQQFqIQEMBAtBOyECIAQgASIARg1YIAQgAWsgAygCACIBaiEGIAAgAWtBBWohBwJAA0AgAUGQyABqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0BIAFBBUYEQEEHIQEMPwsgAUEBaiEBIAQgAEEBaiIARw0ACyADIAY2AgAMWQsgA0EANgIAIAAhAQwFC0E6IQIgBCABIgBGDVcgBCABayADKAIAIgFqIQYgACABa0EIaiEHAkADQCABQbTBAGotAAAgAC0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDQEgAUEIRgRAQQUhAQw+CyABQQFqIQEgBCAAQQFqIgBHDQALIAMgBjYCAAxYCyADQQA2AgAgACEBDAQLQTkhAiAEIAEiAEYNViAEIAFrIAMoAgAiAWohBiAAIAFrQQNqIQcCQANAIAFBsMEAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNASABQQNGBEBBBiEBDD0LIAFBAWohASAEIABBAWoiAEcNAAsgAyAGNgIADFcLIANBADYCACAAIQEMAwsCQANAIAEtAAAiAEEgRwRAIABBCmsOBAcEBAcCCyAEIAFBAWoiAUcNAAtBOCECDFYLIABBLEcNASABQQFqIQBBASEBAkACQAJAAkACQCADLQAsQQVrDgQDAQIEAAsgACEBDAQLQQIhAQwBC0EEIQELIANBAToALCADIAMvATIgAXI7ATIgACEBDAELIAMgAy8BMkEIcjsBMiAAIQELQT4hAgw7CyADQQA6ACwLQTkhAgw5CyABIARGBEBBNiECDFILAkACQAJAAkACQCABLQAAQQprDgQAAgIBAgsgAygCBCEAIANBADYCBCADIAAgARAxIgBFDQIgA0EzNgIcIAMgATYCFCADIAA2AgxBACECDFULIAMoAgQhACADQQA2AgQgAyAAIAEQMSIARQRAIAFBAWohAQwGCyADQTI2AhwgAyAANgIMIAMgAUEBajYCFEEAIQIMVAsgAy0ALkEBcQRAQd8BIQIMOwsgAygCBCEAIANBADYCBCADIAAgARAxIgANAQxJC0E0IQIMOQsgA0E1NgIcIAMgATYCFCADIAA2AgxBACECDFELQTUhAgw3CyADQS9qLQAAQQFxDQAgA0EANgIcIAMgATYCFCADQesWNgIQIANBGTYCDEEAIQIMTwtBMyECDDULIAEgBEYEQEEyIQIMTgsCQCABLQAAQQpGBEAgAUEBaiEBDAELIANBADYCHCADIAE2AhQgA0GSFzYCECADQQM2AgxBACECDE4LQTIhAgw0CyABIARGBEBBMSECDE0LAkAgAS0AACIAQQlGDQAgAEEgRg0AQQEhAgJAIAMtACxBBWsOBAYEBQANCyADIAMvATJBCHI7ATIMDAsgAy0ALkEBcUUNASADLQAsQQhHDQAgA0EAOgAsC0E9IQIMMgsgA0EANgIcIAMgATYCFCADQcIWNgIQIANBCjYCDEEAIQIMSgtBAiECDAELQQQhAgsgA0EBOgAsIAMgAy8BMiACcjsBMgwGCyABIARGBEBBMCECDEcLIAEtAABBCkYEQCABQQFqIQEMAQsgAy0ALkEBcQ0AIANBADYCHCADIAE2AhQgA0HcKDYCECADQQI2AgxBACECDEYLQTAhAgwsCyABQQFqIQFBMSECDCsLIAEgBEYEQEEvIQIMRAsgAS0AACIAQQlHIABBIEdxRQRAIAFBAWohASADLQAuQQFxDQEgA0EANgIcIAMgATYCFCADQZcQNgIQIANBCjYCDEEAIQIMRAtBASECAkACQAJAAkACQAJAIAMtACxBAmsOBwUEBAMBAgAECyADIAMvATJBCHI7ATIMAwtBAiECDAELQQQhAgsgA0EBOgAsIAMgAy8BMiACcjsBMgtBLyECDCsLIANBADYCHCADIAE2AhQgA0GEEzYCECADQQs2AgxBACECDEMLQeEBIQIMKQsgASAERgRAQS4hAgxCCyADQQA2AgQgA0ESNgIIIAMgASABEDEiAA0BC0EuIQIMJwsgA0EtNgIcIAMgATYCFCADIAA2AgxBACECDD8LQQAhAAJAIAMoAjgiAkUNACACKAJMIgJFDQAgAyACEQAAIQALIABFDQAgAEEVRw0BIANB2AA2AhwgAyABNgIUIANBsxs2AhAgA0EVNgIMQQAhAgw+C0HMACECDCQLIANBADYCHCADIAE2AhQgA0GzDjYCECADQR02AgxBACECDDwLIAEgBEYEQEHOACECDDwLIAEtAAAiAEEgRg0CIABBOkYNAQsgA0EAOgAsQQkhAgwhCyADKAIEIQAgA0EANgIEIAMgACABEDAiAA0BDAILIAMtAC5BAXEEQEHeASECDCALIAMoAgQhACADQQA2AgQgAyAAIAEQMCIARQ0CIANBKjYCHCADIAA2AgwgAyABQQFqNgIUQQAhAgw4CyADQcsANgIcIAMgADYCDCADIAFBAWo2AhRBACECDDcLIAFBAWohAUHAACECDB0LIAFBAWohAQwsCyABIARGBEBBKyECDDULAkAgAS0AAEEKRgRAIAFBAWohAQwBCyADLQAuQcAAcUUNBgsgAy0AMkGAAXEEQEEAIQACQCADKAI4IgJFDQAgAigCXCICRQ0AIAMgAhEAACEACyAARQ0SIABBFUYEQCADQQU2AhwgAyABNgIUIANBmxs2AhAgA0EVNgIMQQAhAgw2CyADQQA2AhwgAyABNgIUIANBkA42AhAgA0EUNgIMQQAhAgw1CyADQTJqIQIgAxA1QQAhAAJAIAMoAjgiBkUNACAGKAIoIgZFDQAgAyAGEQAAIQALIAAOFgIBAAQEBAQEBAQEBAQEBAQEBAQEBAMECyADQQE6ADALIAIgAi8BAEHAAHI7AQALQSshAgwYCyADQSk2AhwgAyABNgIUIANBrBk2AhAgA0EVNgIMQQAhAgwwCyADQQA2AhwgAyABNgIUIANB5Qs2AhAgA0ERNgIMQQAhAgwvCyADQQA2AhwgAyABNgIUIANBpQs2AhAgA0ECNgIMQQAhAgwuC0EBIQcgAy8BMiIFQQhxRQRAIAMpAyBCAFIhBwsCQCADLQAwBEBBASEAIAMtAClBBUYNASAFQcAAcUUgB3FFDQELAkAgAy0AKCICQQJGBEBBASEAIAMvATQiBkHlAEYNAkEAIQAgBUHAAHENAiAGQeQARg0CIAZB5gBrQQJJDQIgBkHMAUYNAiAGQbACRg0CDAELQQAhACAFQcAAcQ0BC0ECIQAgBUEIcQ0AIAVBgARxBEACQCACQQFHDQAgAy0ALkEKcQ0AQQUhAAwCC0EEIQAMAQsgBUEgcUUEQCADEDZBAEdBAnQhAAwBC0EAQQMgAykDIFAbIQALIABBAWsOBQIABwEDBAtBESECDBMLIANBAToAMQwpC0EAIQICQCADKAI4IgBFDQAgACgCMCIARQ0AIAMgABEAACECCyACRQ0mIAJBFUYEQCADQQM2AhwgAyABNgIUIANB0hs2AhAgA0EVNgIMQQAhAgwrC0EAIQIgA0EANgIcIAMgATYCFCADQd0ONgIQIANBEjYCDAwqCyADQQA2AhwgAyABNgIUIANB+SA2AhAgA0EPNgIMQQAhAgwpC0EAIQACQCADKAI4IgJFDQAgAigCMCICRQ0AIAMgAhEAACEACyAADQELQQ4hAgwOCyAAQRVGBEAgA0ECNgIcIAMgATYCFCADQdIbNgIQIANBFTYCDEEAIQIMJwsgA0EANgIcIAMgATYCFCADQd0ONgIQIANBEjYCDEEAIQIMJgtBKiECDAwLIAEgBEcEQCADQQk2AgggAyABNgIEQSkhAgwMC0EmIQIMJAsgAyADKQMgIgwgBCABa60iCn0iC0IAIAsgDFgbNwMgIAogDFQEQEElIQIMJAsgAygCBCEAIANBADYCBCADIAAgASAMp2oiARAyIgBFDQAgA0EFNgIcIAMgATYCFCADIAA2AgxBACECDCMLQQ8hAgwJC0IAIQoCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAS0AAEEwaw43FxYAAQIDBAUGBxQUFBQUFBQICQoLDA0UFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFA4PEBESExQLQgIhCgwWC0IDIQoMFQtCBCEKDBQLQgUhCgwTC0IGIQoMEgtCByEKDBELQgghCgwQC0IJIQoMDwtCCiEKDA4LQgshCgwNC0IMIQoMDAtCDSEKDAsLQg4hCgwKC0IPIQoMCQtCCiEKDAgLQgshCgwHC0IMIQoMBgtCDSEKDAULQg4hCgwEC0IPIQoMAwsgA0EANgIcIAMgATYCFCADQZ8VNgIQIANBDDYCDEEAIQIMIQsgASAERgRAQSIhAgwhC0IAIQoCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAEtAABBMGsONxUUAAECAwQFBgcWFhYWFhYWCAkKCwwNFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYODxAREhMWC0ICIQoMFAtCAyEKDBMLQgQhCgwSC0IFIQoMEQtCBiEKDBALQgchCgwPC0IIIQoMDgtCCSEKDA0LQgohCgwMC0ILIQoMCwtCDCEKDAoLQg0hCgwJC0IOIQoMCAtCDyEKDAcLQgohCgwGC0ILIQoMBQtCDCEKDAQLQg0hCgwDC0IOIQoMAgtCDyEKDAELQgEhCgsgAUEBaiEBIAMpAyAiC0L//////////w9YBEAgAyALQgSGIAqENwMgDAILIANBADYCHCADIAE2AhQgA0G1CTYCECADQQw2AgxBACECDB4LQSchAgwEC0EoIQIMAwsgAyABOgAsIANBADYCACAHQQFqIQFBDCECDAILIANBADYCACAGQQFqIQFBCiECDAELIAFBAWohAUEIIQIMAAsAC0EAIQIgA0EANgIcIAMgATYCFCADQbI4NgIQIANBCDYCDAwXC0EAIQIgA0EANgIcIAMgATYCFCADQYMRNgIQIANBCTYCDAwWC0EAIQIgA0EANgIcIAMgATYCFCADQd8KNgIQIANBCTYCDAwVC0EAIQIgA0EANgIcIAMgATYCFCADQe0QNgIQIANBCTYCDAwUC0EAIQIgA0EANgIcIAMgATYCFCADQdIRNgIQIANBCTYCDAwTC0EAIQIgA0EANgIcIAMgATYCFCADQbI4NgIQIANBCDYCDAwSC0EAIQIgA0EANgIcIAMgATYCFCADQYMRNgIQIANBCTYCDAwRC0EAIQIgA0EANgIcIAMgATYCFCADQd8KNgIQIANBCTYCDAwQC0EAIQIgA0EANgIcIAMgATYCFCADQe0QNgIQIANBCTYCDAwPC0EAIQIgA0EANgIcIAMgATYCFCADQdIRNgIQIANBCTYCDAwOC0EAIQIgA0EANgIcIAMgATYCFCADQbkXNgIQIANBDzYCDAwNC0EAIQIgA0EANgIcIAMgATYCFCADQbkXNgIQIANBDzYCDAwMC0EAIQIgA0EANgIcIAMgATYCFCADQZkTNgIQIANBCzYCDAwLC0EAIQIgA0EANgIcIAMgATYCFCADQZ0JNgIQIANBCzYCDAwKC0EAIQIgA0EANgIcIAMgATYCFCADQZcQNgIQIANBCjYCDAwJC0EAIQIgA0EANgIcIAMgATYCFCADQbEQNgIQIANBCjYCDAwIC0EAIQIgA0EANgIcIAMgATYCFCADQbsdNgIQIANBAjYCDAwHC0EAIQIgA0EANgIcIAMgATYCFCADQZYWNgIQIANBAjYCDAwGC0EAIQIgA0EANgIcIAMgATYCFCADQfkYNgIQIANBAjYCDAwFC0EAIQIgA0EANgIcIAMgATYCFCADQcQYNgIQIANBAjYCDAwECyADQQI2AhwgAyABNgIUIANBqR42AhAgA0EWNgIMQQAhAgwDC0HeACECIAEgBEYNAiAJQQhqIQcgAygCACEFAkACQCABIARHBEAgBUGWyABqIQggBCAFaiABayEGIAVBf3NBCmoiBSABaiEAA0AgAS0AACAILQAARwRAQQIhCAwDCyAFRQRAQQAhCCAAIQEMAwsgBUEBayEFIAhBAWohCCAEIAFBAWoiAUcNAAsgBiEFIAQhAQsgB0EBNgIAIAMgBTYCAAwBCyADQQA2AgAgByAINgIACyAHIAE2AgQgCSgCDCEAAkACQCAJKAIIQQFrDgIEAQALIANBADYCHCADQcIeNgIQIANBFzYCDCADIABBAWo2AhRBACECDAMLIANBADYCHCADIAA2AhQgA0HXHjYCECADQQk2AgxBACECDAILIAEgBEYEQEEoIQIMAgsgA0EJNgIIIAMgATYCBEEnIQIMAQsgASAERgRAQQEhAgwBCwNAAkACQAJAIAEtAABBCmsOBAABAQABCyABQQFqIQEMAQsgAUEBaiEBIAMtAC5BIHENAEEAIQIgA0EANgIcIAMgATYCFCADQaEhNgIQIANBBTYCDAwCC0EBIQIgASAERw0ACwsgCUEQaiQAIAJFBEAgAygCDCEADAELIAMgAjYCHEEAIQAgAygCBCIBRQ0AIAMgASAEIAMoAggRAQAiAUUNACADIAQ2AhQgAyABNgIMIAEhAAsgAAu+AgECfyAAQQA6AAAgAEHkAGoiAUEBa0EAOgAAIABBADoAAiAAQQA6AAEgAUEDa0EAOgAAIAFBAmtBADoAACAAQQA6AAMgAUEEa0EAOgAAQQAgAGtBA3EiASAAaiIAQQA2AgBB5AAgAWtBfHEiAiAAaiIBQQRrQQA2AgACQCACQQlJDQAgAEEANgIIIABBADYCBCABQQhrQQA2AgAgAUEMa0EANgIAIAJBGUkNACAAQQA2AhggAEEANgIUIABBADYCECAAQQA2AgwgAUEQa0EANgIAIAFBFGtBADYCACABQRhrQQA2AgAgAUEca0EANgIAIAIgAEEEcUEYciICayIBQSBJDQAgACACaiEAA0AgAEIANwMYIABCADcDECAAQgA3AwggAEIANwMAIABBIGohACABQSBrIgFBH0sNAAsLC1YBAX8CQCAAKAIMDQACQAJAAkACQCAALQAxDgMBAAMCCyAAKAI4IgFFDQAgASgCMCIBRQ0AIAAgAREAACIBDQMLQQAPCwALIABByhk2AhBBDiEBCyABCxoAIAAoAgxFBEAgAEHeHzYCECAAQRU2AgwLCxQAIAAoAgxBFUYEQCAAQQA2AgwLCxQAIAAoAgxBFkYEQCAAQQA2AgwLCwcAIAAoAgwLBwAgACgCEAsJACAAIAE2AhALBwAgACgCFAsrAAJAIABBJ08NAEL//////wkgAK2IQgGDUA0AIABBAnRB0DhqKAIADwsACxcAIABBL08EQAALIABBAnRB7DlqKAIAC78JAQF/QfQtIQECQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAQeQAaw70A2NiAAFhYWFhYWECAwQFYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYQYHCAkKCwwNDg9hYWFhYRBhYWFhYWFhYWFhYRFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWESExQVFhcYGRobYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1NmE3ODk6YWFhYWFhYWE7YWFhPGFhYWE9Pj9hYWFhYWFhYUBhYUFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFCQ0RFRkdISUpLTE1OT1BRUlNhYWFhYWFhYVRVVldYWVpbYVxdYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhXmFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYV9gYQtB6iwPC0GYJg8LQe0xDwtBoDcPC0HJKQ8LQbQpDwtBli0PC0HrKw8LQaI1DwtB2zQPC0HgKQ8LQeMkDwtB1SQPC0HuJA8LQeYlDwtByjQPC0HQNw8LQao1DwtB9SwPC0H2Jg8LQYIiDwtB8jMPC0G+KA8LQec3DwtBzSEPC0HAIQ8LQbglDwtByyUPC0GWJA8LQY80DwtBzTUPC0HdKg8LQe4zDwtBnDQPC0GeMQ8LQfQ1DwtB5SIPC0GvJQ8LQZkxDwtBsjYPC0H5Ng8LQcQyDwtB3SwPC0GCMQ8LQcExDwtBjTcPC0HJJA8LQew2DwtB5yoPC0HIIw8LQeIhDwtByTcPC0GlIg8LQZQiDwtB2zYPC0HeNQ8LQYYmDwtBvCsPC0GLMg8LQaAjDwtB9jAPC0GALA8LQYkrDwtBpCYPC0HyIw8LQYEoDwtBqzIPC0HrJw8LQcI2DwtBoiQPC0HPKg8LQdwjDwtBhycPC0HkNA8LQbciDwtBrTEPC0HVIg8LQa80DwtB3iYPC0HWMg8LQfQ0DwtBgTgPC0H0Nw8LQZI2DwtBnScPC0GCKQ8LQY0jDwtB1zEPC0G9NQ8LQbQ3DwtB2DAPC0G2Jw8LQZo4DwtBpyoPC0HEJw8LQa4jDwtB9SIPCwALQcomIQELIAELFwAgACAALwEuQf7/A3EgAUEAR3I7AS4LGgAgACAALwEuQf3/A3EgAUEAR0EBdHI7AS4LGgAgACAALwEuQfv/A3EgAUEAR0ECdHI7AS4LGgAgACAALwEuQff/A3EgAUEAR0EDdHI7AS4LGgAgACAALwEuQe//A3EgAUEAR0EEdHI7AS4LGgAgACAALwEuQd//A3EgAUEAR0EFdHI7AS4LGgAgACAALwEuQb//A3EgAUEAR0EGdHI7AS4LGgAgACAALwEuQf/+A3EgAUEAR0EHdHI7AS4LGgAgACAALwEuQf/9A3EgAUEAR0EIdHI7AS4LGgAgACAALwEuQf/7A3EgAUEAR0EJdHI7AS4LPgECfwJAIAAoAjgiA0UNACADKAIEIgNFDQAgACABIAIgAWsgAxEBACIEQX9HDQAgAEHhEjYCEEEYIQQLIAQLPgECfwJAIAAoAjgiA0UNACADKAIIIgNFDQAgACABIAIgAWsgAxEBACIEQX9HDQAgAEH8ETYCEEEYIQQLIAQLPgECfwJAIAAoAjgiA0UNACADKAIMIgNFDQAgACABIAIgAWsgAxEBACIEQX9HDQAgAEHsCjYCEEEYIQQLIAQLPgECfwJAIAAoAjgiA0UNACADKAIQIgNFDQAgACABIAIgAWsgAxEBACIEQX9HDQAgAEH6HjYCEEEYIQQLIAQLPgECfwJAIAAoAjgiA0UNACADKAIUIgNFDQAgACABIAIgAWsgAxEBACIEQX9HDQAgAEHLEDYCEEEYIQQLIAQLPgECfwJAIAAoAjgiA0UNACADKAIYIgNFDQAgACABIAIgAWsgAxEBACIEQX9HDQAgAEG3HzYCEEEYIQQLIAQLPgECfwJAIAAoAjgiA0UNACADKAIcIgNFDQAgACABIAIgAWsgAxEBACIEQX9HDQAgAEG/FTYCEEEYIQQLIAQLPgECfwJAIAAoAjgiA0UNACADKAIsIgNFDQAgACABIAIgAWsgAxEBACIEQX9HDQAgAEH+CDYCEEEYIQQLIAQLPgECfwJAIAAoAjgiA0UNACADKAIgIgNFDQAgACABIAIgAWsgAxEBACIEQX9HDQAgAEGMHTYCEEEYIQQLIAQLPgECfwJAIAAoAjgiA0UNACADKAIkIgNFDQAgACABIAIgAWsgAxEBACIEQX9HDQAgAEHmFTYCEEEYIQQLIAQLOAAgAAJ/IAAvATJBFHFBFEYEQEEBIAAtAChBAUYNARogAC8BNEHlAEYMAQsgAC0AKUEFRgs6ADALWQECfwJAIAAtAChBAUYNACAALwE0IgFB5ABrQeQASQ0AIAFBzAFGDQAgAUGwAkYNACAALwEyIgBBwABxDQBBASECIABBiARxQYAERg0AIABBKHFFIQILIAILjAEBAn8CQAJAAkAgAC0AKkUNACAALQArRQ0AIAAvATIiAUECcUUNAQwCCyAALwEyIgFBAXFFDQELQQEhAiAALQAoQQFGDQAgAC8BNCIAQeQAa0HkAEkNACAAQcwBRg0AIABBsAJGDQAgAUHAAHENAEEAIQIgAUGIBHFBgARGDQAgAUEocUEARyECCyACC1cAIABBGGpCADcDACAAQgA3AwAgAEE4akIANwMAIABBMGpCADcDACAAQShqQgA3AwAgAEEgakIANwMAIABBEGpCADcDACAAQQhqQgA3AwAgAEH9ATYCHAsGACAAEDoLmi0BC38jAEEQayIKJABB3NUAKAIAIglFBEBBnNkAKAIAIgVFBEBBqNkAQn83AgBBoNkAQoCAhICAgMAANwIAQZzZACAKQQhqQXBxQdiq1aoFcyIFNgIAQbDZAEEANgIAQYDZAEEANgIAC0GE2QBBwNkENgIAQdTVAEHA2QQ2AgBB6NUAIAU2AgBB5NUAQX82AgBBiNkAQcCmAzYCAANAIAFBgNYAaiABQfTVAGoiAjYCACACIAFB7NUAaiIDNgIAIAFB+NUAaiADNgIAIAFBiNYAaiABQfzVAGoiAzYCACADIAI2AgAgAUGQ1gBqIAFBhNYAaiICNgIAIAIgAzYCACABQYzWAGogAjYCACABQSBqIgFBgAJHDQALQczZBEGBpgM2AgBB4NUAQazZACgCADYCAEHQ1QBBgKYDNgIAQdzVAEHI2QQ2AgBBzP8HQTg2AgBByNkEIQkLAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAEHsAU0EQEHE1QAoAgAiBkEQIABBE2pBcHEgAEELSRsiBEEDdiIAdiIBQQNxBEACQCABQQFxIAByQQFzIgJBA3QiAEHs1QBqIgEgAEH01QBqKAIAIgAoAggiA0YEQEHE1QAgBkF+IAJ3cTYCAAwBCyABIAM2AgggAyABNgIMCyAAQQhqIQEgACACQQN0IgJBA3I2AgQgACACaiIAIAAoAgRBAXI2AgQMEQtBzNUAKAIAIgggBE8NASABBEACQEECIAB0IgJBACACa3IgASAAdHFoIgBBA3QiAkHs1QBqIgEgAkH01QBqKAIAIgIoAggiA0YEQEHE1QAgBkF+IAB3cSIGNgIADAELIAEgAzYCCCADIAE2AgwLIAIgBEEDcjYCBCAAQQN0IgAgBGshBSAAIAJqIAU2AgAgAiAEaiIEIAVBAXI2AgQgCARAIAhBeHFB7NUAaiEAQdjVACgCACEDAn9BASAIQQN2dCIBIAZxRQRAQcTVACABIAZyNgIAIAAMAQsgACgCCAsiASADNgIMIAAgAzYCCCADIAA2AgwgAyABNgIICyACQQhqIQFB2NUAIAQ2AgBBzNUAIAU2AgAMEQtByNUAKAIAIgtFDQEgC2hBAnRB9NcAaigCACIAKAIEQXhxIARrIQUgACECA0ACQCACKAIQIgFFBEAgAkEUaigCACIBRQ0BCyABKAIEQXhxIARrIgMgBUkhAiADIAUgAhshBSABIAAgAhshACABIQIMAQsLIAAoAhghCSAAKAIMIgMgAEcEQEHU1QAoAgAaIAMgACgCCCIBNgIIIAEgAzYCDAwQCyAAQRRqIgIoAgAiAUUEQCAAKAIQIgFFDQMgAEEQaiECCwNAIAIhByABIgNBFGoiAigCACIBDQAgA0EQaiECIAMoAhAiAQ0ACyAHQQA2AgAMDwtBfyEEIABBv39LDQAgAEETaiIBQXBxIQRByNUAKAIAIghFDQBBACAEayEFAkACQAJAAn9BACAEQYACSQ0AGkEfIARB////B0sNABogBEEmIAFBCHZnIgBrdkEBcSAAQQF0a0E+agsiBkECdEH01wBqKAIAIgJFBEBBACEBQQAhAwwBC0EAIQEgBEEZIAZBAXZrQQAgBkEfRxt0IQBBACEDA0ACQCACKAIEQXhxIARrIgcgBU8NACACIQMgByIFDQBBACEFIAIhAQwDCyABIAJBFGooAgAiByAHIAIgAEEddkEEcWpBEGooAgAiAkYbIAEgBxshASAAQQF0IQAgAg0ACwsgASADckUEQEEAIQNBAiAGdCIAQQAgAGtyIAhxIgBFDQMgAGhBAnRB9NcAaigCACEBCyABRQ0BCwNAIAEoAgRBeHEgBGsiAiAFSSEAIAIgBSAAGyEFIAEgAyAAGyEDIAEoAhAiAAR/IAAFIAFBFGooAgALIgENAAsLIANFDQAgBUHM1QAoAgAgBGtPDQAgAygCGCEHIAMgAygCDCIARwRAQdTVACgCABogACADKAIIIgE2AgggASAANgIMDA4LIANBFGoiAigCACIBRQRAIAMoAhAiAUUNAyADQRBqIQILA0AgAiEGIAEiAEEUaiICKAIAIgENACAAQRBqIQIgACgCECIBDQALIAZBADYCAAwNC0HM1QAoAgAiAyAETwRAQdjVACgCACEBAkAgAyAEayICQRBPBEAgASAEaiIAIAJBAXI2AgQgASADaiACNgIAIAEgBEEDcjYCBAwBCyABIANBA3I2AgQgASADaiIAIAAoAgRBAXI2AgRBACEAQQAhAgtBzNUAIAI2AgBB2NUAIAA2AgAgAUEIaiEBDA8LQdDVACgCACIDIARLBEAgBCAJaiIAIAMgBGsiAUEBcjYCBEHc1QAgADYCAEHQ1QAgATYCACAJIARBA3I2AgQgCUEIaiEBDA8LQQAhASAEAn9BnNkAKAIABEBBpNkAKAIADAELQajZAEJ/NwIAQaDZAEKAgISAgIDAADcCAEGc2QAgCkEMakFwcUHYqtWqBXM2AgBBsNkAQQA2AgBBgNkAQQA2AgBBgIAECyIAIARBxwBqIgVqIgZBACAAayIHcSICTwRAQbTZAEEwNgIADA8LAkBB/NgAKAIAIgFFDQBB9NgAKAIAIgggAmohACAAIAFNIAAgCEtxDQBBACEBQbTZAEEwNgIADA8LQYDZAC0AAEEEcQ0EAkACQCAJBEBBhNkAIQEDQCABKAIAIgAgCU0EQCAAIAEoAgRqIAlLDQMLIAEoAggiAQ0ACwtBABA7IgBBf0YNBSACIQZBoNkAKAIAIgFBAWsiAyAAcQRAIAIgAGsgACADakEAIAFrcWohBgsgBCAGTw0FIAZB/v///wdLDQVB/NgAKAIAIgMEQEH02AAoAgAiByAGaiEBIAEgB00NBiABIANLDQYLIAYQOyIBIABHDQEMBwsgBiADayAHcSIGQf7///8HSw0EIAYQOyEAIAAgASgCACABKAIEakYNAyAAIQELAkAgBiAEQcgAak8NACABQX9GDQBBpNkAKAIAIgAgBSAGa2pBACAAa3EiAEH+////B0sEQCABIQAMBwsgABA7QX9HBEAgACAGaiEGIAEhAAwHC0EAIAZrEDsaDAQLIAEiAEF/Rw0FDAMLQQAhAwwMC0EAIQAMCgsgAEF/Rw0CC0GA2QBBgNkAKAIAQQRyNgIACyACQf7///8HSw0BIAIQOyEAQQAQOyEBIABBf0YNASABQX9GDQEgACABTw0BIAEgAGsiBiAEQThqTQ0BC0H02ABB9NgAKAIAIAZqIgE2AgBB+NgAKAIAIAFJBEBB+NgAIAE2AgALAkACQAJAQdzVACgCACICBEBBhNkAIQEDQCAAIAEoAgAiAyABKAIEIgVqRg0CIAEoAggiAQ0ACwwCC0HU1QAoAgAiAUEARyAAIAFPcUUEQEHU1QAgADYCAAtBACEBQYjZACAGNgIAQYTZACAANgIAQeTVAEF/NgIAQejVAEGc2QAoAgA2AgBBkNkAQQA2AgADQCABQYDWAGogAUH01QBqIgI2AgAgAiABQezVAGoiAzYCACABQfjVAGogAzYCACABQYjWAGogAUH81QBqIgM2AgAgAyACNgIAIAFBkNYAaiABQYTWAGoiAjYCACACIAM2AgAgAUGM1gBqIAI2AgAgAUEgaiIBQYACRw0AC0F4IABrQQ9xIgEgAGoiAiAGQThrIgMgAWsiAUEBcjYCBEHg1QBBrNkAKAIANgIAQdDVACABNgIAQdzVACACNgIAIAAgA2pBODYCBAwCCyAAIAJNDQAgAiADSQ0AIAEoAgxBCHENAEF4IAJrQQ9xIgAgAmoiA0HQ1QAoAgAgBmoiByAAayIAQQFyNgIEIAEgBSAGajYCBEHg1QBBrNkAKAIANgIAQdDVACAANgIAQdzVACADNgIAIAIgB2pBODYCBAwBCyAAQdTVACgCAEkEQEHU1QAgADYCAAsgACAGaiEDQYTZACEBAkACQAJAA0AgAyABKAIARwRAIAEoAggiAQ0BDAILCyABLQAMQQhxRQ0BC0GE2QAhAQNAIAEoAgAiAyACTQRAIAMgASgCBGoiBSACSw0DCyABKAIIIQEMAAsACyABIAA2AgAgASABKAIEIAZqNgIEIABBeCAAa0EPcWoiCSAEQQNyNgIEIANBeCADa0EPcWoiBiAEIAlqIgRrIQEgAiAGRgRAQdzVACAENgIAQdDVAEHQ1QAoAgAgAWoiADYCACAEIABBAXI2AgQMCAtB2NUAKAIAIAZGBEBB2NUAIAQ2AgBBzNUAQczVACgCACABaiIANgIAIAQgAEEBcjYCBCAAIARqIAA2AgAMCAsgBigCBCIFQQNxQQFHDQYgBUF4cSEIIAVB/wFNBEAgBUEDdiEDIAYoAggiACAGKAIMIgJGBEBBxNUAQcTVACgCAEF+IAN3cTYCAAwHCyACIAA2AgggACACNgIMDAYLIAYoAhghByAGIAYoAgwiAEcEQCAAIAYoAggiAjYCCCACIAA2AgwMBQsgBkEUaiICKAIAIgVFBEAgBigCECIFRQ0EIAZBEGohAgsDQCACIQMgBSIAQRRqIgIoAgAiBQ0AIABBEGohAiAAKAIQIgUNAAsgA0EANgIADAQLQXggAGtBD3EiASAAaiIHIAZBOGsiAyABayIBQQFyNgIEIAAgA2pBODYCBCACIAVBNyAFa0EPcWpBP2siAyADIAJBEGpJGyIDQSM2AgRB4NUAQazZACgCADYCAEHQ1QAgATYCAEHc1QAgBzYCACADQRBqQYzZACkCADcCACADQYTZACkCADcCCEGM2QAgA0EIajYCAEGI2QAgBjYCAEGE2QAgADYCAEGQ2QBBADYCACADQSRqIQEDQCABQQc2AgAgBSABQQRqIgFLDQALIAIgA0YNACADIAMoAgRBfnE2AgQgAyADIAJrIgU2AgAgAiAFQQFyNgIEIAVB/wFNBEAgBUF4cUHs1QBqIQACf0HE1QAoAgAiAUEBIAVBA3Z0IgNxRQRAQcTVACABIANyNgIAIAAMAQsgACgCCAsiASACNgIMIAAgAjYCCCACIAA2AgwgAiABNgIIDAELQR8hASAFQf///wdNBEAgBUEmIAVBCHZnIgBrdkEBcSAAQQF0a0E+aiEBCyACIAE2AhwgAkIANwIQIAFBAnRB9NcAaiEAQcjVACgCACIDQQEgAXQiBnFFBEAgACACNgIAQcjVACADIAZyNgIAIAIgADYCGCACIAI2AgggAiACNgIMDAELIAVBGSABQQF2a0EAIAFBH0cbdCEBIAAoAgAhAwJAA0AgAyIAKAIEQXhxIAVGDQEgAUEddiEDIAFBAXQhASAAIANBBHFqQRBqIgYoAgAiAw0ACyAGIAI2AgAgAiAANgIYIAIgAjYCDCACIAI2AggMAQsgACgCCCIBIAI2AgwgACACNgIIIAJBADYCGCACIAA2AgwgAiABNgIIC0HQ1QAoAgAiASAETQ0AQdzVACgCACIAIARqIgIgASAEayIBQQFyNgIEQdDVACABNgIAQdzVACACNgIAIAAgBEEDcjYCBCAAQQhqIQEMCAtBACEBQbTZAEEwNgIADAcLQQAhAAsgB0UNAAJAIAYoAhwiAkECdEH01wBqIgMoAgAgBkYEQCADIAA2AgAgAA0BQcjVAEHI1QAoAgBBfiACd3E2AgAMAgsgB0EQQRQgBygCECAGRhtqIAA2AgAgAEUNAQsgACAHNgIYIAYoAhAiAgRAIAAgAjYCECACIAA2AhgLIAZBFGooAgAiAkUNACAAQRRqIAI2AgAgAiAANgIYCyABIAhqIQEgBiAIaiIGKAIEIQULIAYgBUF+cTYCBCABIARqIAE2AgAgBCABQQFyNgIEIAFB/wFNBEAgAUF4cUHs1QBqIQACf0HE1QAoAgAiAkEBIAFBA3Z0IgFxRQRAQcTVACABIAJyNgIAIAAMAQsgACgCCAsiASAENgIMIAAgBDYCCCAEIAA2AgwgBCABNgIIDAELQR8hBSABQf///wdNBEAgAUEmIAFBCHZnIgBrdkEBcSAAQQF0a0E+aiEFCyAEIAU2AhwgBEIANwIQIAVBAnRB9NcAaiEAQcjVACgCACICQQEgBXQiA3FFBEAgACAENgIAQcjVACACIANyNgIAIAQgADYCGCAEIAQ2AgggBCAENgIMDAELIAFBGSAFQQF2a0EAIAVBH0cbdCEFIAAoAgAhAAJAA0AgACICKAIEQXhxIAFGDQEgBUEddiEAIAVBAXQhBSACIABBBHFqQRBqIgMoAgAiAA0ACyADIAQ2AgAgBCACNgIYIAQgBDYCDCAEIAQ2AggMAQsgAigCCCIAIAQ2AgwgAiAENgIIIARBADYCGCAEIAI2AgwgBCAANgIICyAJQQhqIQEMAgsCQCAHRQ0AAkAgAygCHCIBQQJ0QfTXAGoiAigCACADRgRAIAIgADYCACAADQFByNUAIAhBfiABd3EiCDYCAAwCCyAHQRBBFCAHKAIQIANGG2ogADYCACAARQ0BCyAAIAc2AhggAygCECIBBEAgACABNgIQIAEgADYCGAsgA0EUaigCACIBRQ0AIABBFGogATYCACABIAA2AhgLAkAgBUEPTQRAIAMgBCAFaiIAQQNyNgIEIAAgA2oiACAAKAIEQQFyNgIEDAELIAMgBGoiAiAFQQFyNgIEIAMgBEEDcjYCBCACIAVqIAU2AgAgBUH/AU0EQCAFQXhxQezVAGohAAJ/QcTVACgCACIBQQEgBUEDdnQiBXFFBEBBxNUAIAEgBXI2AgAgAAwBCyAAKAIICyIBIAI2AgwgACACNgIIIAIgADYCDCACIAE2AggMAQtBHyEBIAVB////B00EQCAFQSYgBUEIdmciAGt2QQFxIABBAXRrQT5qIQELIAIgATYCHCACQgA3AhAgAUECdEH01wBqIQBBASABdCIEIAhxRQRAIAAgAjYCAEHI1QAgBCAIcjYCACACIAA2AhggAiACNgIIIAIgAjYCDAwBCyAFQRkgAUEBdmtBACABQR9HG3QhASAAKAIAIQQCQANAIAQiACgCBEF4cSAFRg0BIAFBHXYhBCABQQF0IQEgACAEQQRxakEQaiIGKAIAIgQNAAsgBiACNgIAIAIgADYCGCACIAI2AgwgAiACNgIIDAELIAAoAggiASACNgIMIAAgAjYCCCACQQA2AhggAiAANgIMIAIgATYCCAsgA0EIaiEBDAELAkAgCUUNAAJAIAAoAhwiAUECdEH01wBqIgIoAgAgAEYEQCACIAM2AgAgAw0BQcjVACALQX4gAXdxNgIADAILIAlBEEEUIAkoAhAgAEYbaiADNgIAIANFDQELIAMgCTYCGCAAKAIQIgEEQCADIAE2AhAgASADNgIYCyAAQRRqKAIAIgFFDQAgA0EUaiABNgIAIAEgAzYCGAsCQCAFQQ9NBEAgACAEIAVqIgFBA3I2AgQgACABaiIBIAEoAgRBAXI2AgQMAQsgACAEaiIHIAVBAXI2AgQgACAEQQNyNgIEIAUgB2ogBTYCACAIBEAgCEF4cUHs1QBqIQFB2NUAKAIAIQMCf0EBIAhBA3Z0IgIgBnFFBEBBxNUAIAIgBnI2AgAgAQwBCyABKAIICyICIAM2AgwgASADNgIIIAMgATYCDCADIAI2AggLQdjVACAHNgIAQczVACAFNgIACyAAQQhqIQELIApBEGokACABC0MAIABFBEA/AEEQdA8LAkAgAEH//wNxDQAgAEEASA0AIABBEHZAACIAQX9GBEBBtNkAQTA2AgBBfw8LIABBEHQPCwALC5lCIgBBgAgLDQEAAAAAAAAAAgAAAAMAQZgICwUEAAAABQBBqAgLCQYAAAAHAAAACABB5AgLwjJJbnZhbGlkIGNoYXIgaW4gdXJsIHF1ZXJ5AFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fYm9keQBDb250ZW50LUxlbmd0aCBvdmVyZmxvdwBDaHVuayBzaXplIG92ZXJmbG93AEludmFsaWQgbWV0aG9kIGZvciBIVFRQL3gueCByZXF1ZXN0AEludmFsaWQgbWV0aG9kIGZvciBSVFNQL3gueCByZXF1ZXN0AEV4cGVjdGVkIFNPVVJDRSBtZXRob2QgZm9yIElDRS94LnggcmVxdWVzdABJbnZhbGlkIGNoYXIgaW4gdXJsIGZyYWdtZW50IHN0YXJ0AEV4cGVjdGVkIGRvdABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3N0YXR1cwBJbnZhbGlkIHJlc3BvbnNlIHN0YXR1cwBFeHBlY3RlZCBMRiBhZnRlciBoZWFkZXJzAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMAVXNlciBjYWxsYmFjayBlcnJvcgBgb25fcmVzZXRgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19oZWFkZXJgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3Byb3RvY29sX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fcHJvdG9jb2wARW1wdHkgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyYWN0ZXIgaW4gQ29udGVudC1MZW5ndGgAVHJhbnNmZXItRW5jb2RpbmcgY2FuJ3QgYmUgcHJlc2VudCB3aXRoIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgY2h1bmsgc2l6ZQBFeHBlY3RlZCBMRiBhZnRlciBjaHVuayBzaXplAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBVbmV4cGVjdGVkIHdoaXRlc3BhY2UgYWZ0ZXIgaGVhZGVyIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgaGVhZGVyIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgTEYgYWZ0ZXIgaGVhZGVyIHZhbHVlAEludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYCBoZWFkZXIgdmFsdWUATWlzc2luZyBleHBlY3RlZCBDUiBhZnRlciBjaHVuayBleHRlbnNpb24gdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZSB2YWx1ZQBJbnZhbGlkIHF1b3RlZC1wYWlyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fcHJvdG9jb2xfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUATWlzc2luZyBleHBlY3RlZCBDUiBhZnRlciByZXNwb25zZSBsaW5lAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBuYW1lAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgY2h1bmsgZXh0ZW5zaW9uIG5hbWUASW52YWxpZCBzdGF0dXMgY29kZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABNaXNzaW5nIGV4cGVjdGVkIENSIGFmdGVyIGNodW5rIGRhdGEARXhwZWN0ZWQgTEYgYWZ0ZXIgY2h1bmsgZGF0YQBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AARGF0YSBhZnRlciBgQ29ubmVjdGlvbjogY2xvc2VgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBRVUVSWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAEV4cGVjdGVkIExGIGFmdGVyIENSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX1BST1RPQ09MX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19DT01QTEVURQBIUEVfQ0JfSEVBREVSX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9OQU1FX0NPTVBMRVRFAEhQRV9DQl9NRVNTQUdFX0NPTVBMRVRFAEhQRV9DQl9NRVRIT0RfQ09NUExFVEUASFBFX0NCX0hFQURFUl9GSUVMRF9DT01QTEVURQBERUxFVEUASFBFX0lOVkFMSURfRU9GX1NUQVRFAElOVkFMSURfU1NMX0NFUlRJRklDQVRFAFBBVVNFAE5PX1JFU1BPTlNFAFVOU1VQUE9SVEVEX01FRElBX1RZUEUAR09ORQBOT1RfQUNDRVBUQUJMRQBTRVJWSUNFX1VOQVZBSUxBQkxFAFJBTkdFX05PVF9TQVRJU0ZJQUJMRQBPUklHSU5fSVNfVU5SRUFDSEFCTEUAUkVTUE9OU0VfSVNfU1RBTEUAUFVSR0UATUVSR0UAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRQBSRVFVRVNUX0hFQURFUl9UT09fTEFSR0UAUEFZTE9BRF9UT09fTEFSR0UASU5TVUZGSUNJRU5UX1NUT1JBR0UASFBFX1BBVVNFRF9VUEdSQURFAEhQRV9QQVVTRURfSDJfVVBHUkFERQBTT1VSQ0UAQU5OT1VOQ0UAVFJBQ0UASFBFX1VORVhQRUNURURfU1BBQ0UAREVTQ1JJQkUAVU5TVUJTQ1JJQkUAUkVDT1JEAEhQRV9JTlZBTElEX01FVEhPRABOT1RfRk9VTkQAUFJPUEZJTkQAVU5CSU5EAFJFQklORABVTkFVVEhPUklaRUQATUVUSE9EX05PVF9BTExPV0VEAEhUVFBfVkVSU0lPTl9OT1RfU1VQUE9SVEVEAEFMUkVBRFlfUkVQT1JURUQAQUNDRVBURUQATk9UX0lNUExFTUVOVEVEAExPT1BfREVURUNURUQASFBFX0NSX0VYUEVDVEVEAEhQRV9MRl9FWFBFQ1RFRABDUkVBVEVEAElNX1VTRUQASFBFX1BBVVNFRABUSU1FT1VUX09DQ1VSRUQAUEFZTUVOVF9SRVFVSVJFRABQUkVDT05ESVRJT05fUkVRVUlSRUQAUFJPWFlfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATkVUV09SS19BVVRIRU5USUNBVElPTl9SRVFVSVJFRABMRU5HVEhfUkVRVUlSRUQAU1NMX0NFUlRJRklDQVRFX1JFUVVJUkVEAFVQR1JBREVfUkVRVUlSRUQAUEFHRV9FWFBJUkVEAFBSRUNPTkRJVElPTl9GQUlMRUQARVhQRUNUQVRJT05fRkFJTEVEAFJFVkFMSURBVElPTl9GQUlMRUQAU1NMX0hBTkRTSEFLRV9GQUlMRUQATE9DS0VEAFRSQU5TRk9STUFUSU9OX0FQUExJRUQATk9UX01PRElGSUVEAE5PVF9FWFRFTkRFRABCQU5EV0lEVEhfTElNSVRfRVhDRUVERUQAU0lURV9JU19PVkVSTE9BREVEAEhFQUQARXhwZWN0ZWQgSFRUUC8sIFJUU1AvIG9yIElDRS8A5xUAAK8VAACkEgAAkhoAACYWAACeFAAA2xkAAHkVAAB+EgAA/hQAADYVAAALFgAA2BYAAPMSAABCGAAArBYAABIVAAAUFwAA7xcAAEgUAABxFwAAshoAAGsZAAB+GQAANRQAAIIaAABEFwAA/RYAAB4YAACHFwAAqhkAAJMSAAAHGAAALBcAAMoXAACkFwAA5xUAAOcVAABYFwAAOxgAAKASAAAtHAAAwxEAAEgRAADeEgAAQhMAAKQZAAD9EAAA9xUAAKUVAADvFgAA+BkAAEoWAABWFgAA9RUAAAoaAAAIGgAAARoAAKsVAABCEgAA1xAAAEwRAAAFGQAAVBYAAB4RAADKGQAAyBkAAE4WAAD/GAAAcRQAAPAVAADuFQAAlBkAAPwVAAC/GQAAmxkAAHwUAABDEQAAcBgAAJUUAAAnFAAAGRQAANUSAADUGQAARBYAAPcQAEG5OwsBAQBB0DsL4AEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBBuj0LBAEAAAIAQdE9C14DBAMDAwMDAAADAwADAwADAwMDAwMDAwMDAAUAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAwADAEG6PwsEAQAAAgBB0T8LXgMAAwMDAwMAAAMDAAMDAAMDAwMDAwMDAwMABAAFAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwADAAMAQbDBAAsNbG9zZWVlcC1hbGl2ZQBBycEACwEBAEHgwQAL4AEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBBycMACwEBAEHgwwAL5wEBAQEBAQEBAQEBAQECAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAWNodW5rZWQAQfHFAAteAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQBB0McACyFlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AQYDIAAsgcmFuc2Zlci1lbmNvZGluZ3BncmFkZQ0KDQpTTQ0KDQoAQanIAAsFAQIAAQMAQcDIAAtfBAUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUAQanKAAsFAQIAAQMAQcDKAAtfBAUFBgUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUAQanMAAsEAQAAAQBBwcwAC14CAgACAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAEGpzgALBQECAAEDAEHAzgALXwQFAAAFBQUFBQUFBQUFBQYFBQUFBQUFBQUFBQUABQAHCAUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQAFAAUABQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUAAAAFAEGp0AALBQEBAAEBAEHA0AALAQEAQdrQAAtBAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAQanSAAsFAQEAAQEAQcDSAAsBAQBBytIACwYCAAAAAAIAQeHSAAs6AwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwBBoNQAC50BTk9VTkNFRUNLT1VUTkVDVEVURUNSSUJFTFVTSEVURUFEU0VBUkNIUkdFQ1RJVklUWUxFTkRBUlZFT1RJRllQVElPTlNDSFNFQVlTVEFUQ0hHRVVFUllPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFVFRQQ0VUU1BBRFRQLw==";
    let wasmBuffer;
    Object.defineProperty(module2, "exports", {
      get: () => {
        return wasmBuffer ? wasmBuffer : wasmBuffer = Buffer4.from(wasmBase64, "base64");
      }
    });
  })(llhttpWasm);
  return llhttpWasm.exports;
}
var llhttp_simdWasm = { exports: {} };
llhttp_simdWasm.exports;
var hasRequiredLlhttp_simdWasm;
function requireLlhttp_simdWasm() {
  if (hasRequiredLlhttp_simdWasm) return llhttp_simdWasm.exports;
  hasRequiredLlhttp_simdWasm = 1;
  (function(module2) {
    const { Buffer: Buffer4 } = import_node_buffer.default;
    const wasmBase64 = "AGFzbQEAAAABJwdgAX8Bf2ADf39/AX9gAn9/AGABfwBgBH9/f38Bf2AAAGADf39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQAEA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAzU0BQYAAAMAAAAAAAADAQMAAwMDAAACAAAAAAICAgICAgICAgIBAQEBAQEBAQEBAwAAAwAAAAQFAXABExMFAwEAAgYIAX8BQcDZBAsHxQcoBm1lbW9yeQIAC19pbml0aWFsaXplAAgZX19pbmRpcmVjdF9mdW5jdGlvbl90YWJsZQEAC2xsaHR0cF9pbml0AAkYbGxodHRwX3Nob3VsZF9rZWVwX2FsaXZlADcMbGxodHRwX2FsbG9jAAsGbWFsbG9jADkLbGxodHRwX2ZyZWUADARmcmVlAAwPbGxodHRwX2dldF90eXBlAA0VbGxodHRwX2dldF9odHRwX21ham9yAA4VbGxodHRwX2dldF9odHRwX21pbm9yAA8RbGxodHRwX2dldF9tZXRob2QAEBZsbGh0dHBfZ2V0X3N0YXR1c19jb2RlABESbGxodHRwX2dldF91cGdyYWRlABIMbGxodHRwX3Jlc2V0ABMObGxodHRwX2V4ZWN1dGUAFBRsbGh0dHBfc2V0dGluZ3NfaW5pdAAVDWxsaHR0cF9maW5pc2gAFgxsbGh0dHBfcGF1c2UAFw1sbGh0dHBfcmVzdW1lABgbbGxodHRwX3Jlc3VtZV9hZnRlcl91cGdyYWRlABkQbGxodHRwX2dldF9lcnJubwAaF2xsaHR0cF9nZXRfZXJyb3JfcmVhc29uABsXbGxodHRwX3NldF9lcnJvcl9yZWFzb24AHBRsbGh0dHBfZ2V0X2Vycm9yX3BvcwAdEWxsaHR0cF9lcnJub19uYW1lAB4SbGxodHRwX21ldGhvZF9uYW1lAB8SbGxodHRwX3N0YXR1c19uYW1lACAabGxodHRwX3NldF9sZW5pZW50X2hlYWRlcnMAISFsbGh0dHBfc2V0X2xlbmllbnRfY2h1bmtlZF9sZW5ndGgAIh1sbGh0dHBfc2V0X2xlbmllbnRfa2VlcF9hbGl2ZQAjJGxsaHR0cF9zZXRfbGVuaWVudF90cmFuc2Zlcl9lbmNvZGluZwAkGmxsaHR0cF9zZXRfbGVuaWVudF92ZXJzaW9uACUjbGxodHRwX3NldF9sZW5pZW50X2RhdGFfYWZ0ZXJfY2xvc2UAJidsbGh0dHBfc2V0X2xlbmllbnRfb3B0aW9uYWxfbGZfYWZ0ZXJfY3IAJyxsbGh0dHBfc2V0X2xlbmllbnRfb3B0aW9uYWxfY3JsZl9hZnRlcl9jaHVuawAoKGxsaHR0cF9zZXRfbGVuaWVudF9vcHRpb25hbF9jcl9iZWZvcmVfbGYAKSpsbGh0dHBfc2V0X2xlbmllbnRfc3BhY2VzX2FmdGVyX2NodW5rX3NpemUAKhhsbGh0dHBfbWVzc2FnZV9uZWVkc19lb2YANgkYAQBBAQsSAQIDBAUKBgcyNDMuKy8tLDAxCuzaAjQWAEHA1QAoAgAEQAALQcDVAEEBNgIACxQAIAAQOCAAIAI2AjggACABOgAoCxQAIAAgAC8BNCAALQAwIAAQNxAACx4BAX9BwAAQOiIBEDggAUGACDYCOCABIAA6ACggAQuPDAEHfwJAIABFDQAgAEEIayIBIABBBGsoAgAiAEF4cSIEaiEFAkAgAEEBcQ0AIABBA3FFDQEgASABKAIAIgBrIgFB1NUAKAIASQ0BIAAgBGohBAJAAkBB2NUAKAIAIAFHBEAgAEH/AU0EQCAAQQN2IQMgASgCCCIAIAEoAgwiAkYEQEHE1QBBxNUAKAIAQX4gA3dxNgIADAULIAIgADYCCCAAIAI2AgwMBAsgASgCGCEGIAEgASgCDCIARwRAIAAgASgCCCICNgIIIAIgADYCDAwDCyABQRRqIgMoAgAiAkUEQCABKAIQIgJFDQIgAUEQaiEDCwNAIAMhByACIgBBFGoiAygCACICDQAgAEEQaiEDIAAoAhAiAg0ACyAHQQA2AgAMAgsgBSgCBCIAQQNxQQNHDQIgBSAAQX5xNgIEQczVACAENgIAIAUgBDYCACABIARBAXI2AgQMAwtBACEACyAGRQ0AAkAgASgCHCICQQJ0QfTXAGoiAygCACABRgRAIAMgADYCACAADQFByNUAQcjVACgCAEF+IAJ3cTYCAAwCCyAGQRBBFCAGKAIQIAFGG2ogADYCACAARQ0BCyAAIAY2AhggASgCECICBEAgACACNgIQIAIgADYCGAsgAUEUaigCACICRQ0AIABBFGogAjYCACACIAA2AhgLIAEgBU8NACAFKAIEIgBBAXFFDQACQAJAAkACQCAAQQJxRQRAQdzVACgCACAFRgRAQdzVACABNgIAQdDVAEHQ1QAoAgAgBGoiADYCACABIABBAXI2AgQgAUHY1QAoAgBHDQZBzNUAQQA2AgBB2NUAQQA2AgAMBgtB2NUAKAIAIAVGBEBB2NUAIAE2AgBBzNUAQczVACgCACAEaiIANgIAIAEgAEEBcjYCBCAAIAFqIAA2AgAMBgsgAEF4cSAEaiEEIABB/wFNBEAgAEEDdiEDIAUoAggiACAFKAIMIgJGBEBBxNUAQcTVACgCAEF+IAN3cTYCAAwFCyACIAA2AgggACACNgIMDAQLIAUoAhghBiAFIAUoAgwiAEcEQEHU1QAoAgAaIAAgBSgCCCICNgIIIAIgADYCDAwDCyAFQRRqIgMoAgAiAkUEQCAFKAIQIgJFDQIgBUEQaiEDCwNAIAMhByACIgBBFGoiAygCACICDQAgAEEQaiEDIAAoAhAiAg0ACyAHQQA2AgAMAgsgBSAAQX5xNgIEIAEgBGogBDYCACABIARBAXI2AgQMAwtBACEACyAGRQ0AAkAgBSgCHCICQQJ0QfTXAGoiAygCACAFRgRAIAMgADYCACAADQFByNUAQcjVACgCAEF+IAJ3cTYCAAwCCyAGQRBBFCAGKAIQIAVGG2ogADYCACAARQ0BCyAAIAY2AhggBSgCECICBEAgACACNgIQIAIgADYCGAsgBUEUaigCACICRQ0AIABBFGogAjYCACACIAA2AhgLIAEgBGogBDYCACABIARBAXI2AgQgAUHY1QAoAgBHDQBBzNUAIAQ2AgAMAQsgBEH/AU0EQCAEQXhxQezVAGohAAJ/QcTVACgCACICQQEgBEEDdnQiA3FFBEBBxNUAIAIgA3I2AgAgAAwBCyAAKAIICyICIAE2AgwgACABNgIIIAEgADYCDCABIAI2AggMAQtBHyECIARB////B00EQCAEQSYgBEEIdmciAGt2QQFxIABBAXRrQT5qIQILIAEgAjYCHCABQgA3AhAgAkECdEH01wBqIQACQEHI1QAoAgAiA0EBIAJ0IgdxRQRAIAAgATYCAEHI1QAgAyAHcjYCACABIAA2AhggASABNgIIIAEgATYCDAwBCyAEQRkgAkEBdmtBACACQR9HG3QhAiAAKAIAIQACQANAIAAiAygCBEF4cSAERg0BIAJBHXYhACACQQF0IQIgAyAAQQRxakEQaiIHKAIAIgANAAsgByABNgIAIAEgAzYCGCABIAE2AgwgASABNgIIDAELIAMoAggiACABNgIMIAMgATYCCCABQQA2AhggASADNgIMIAEgADYCCAtB5NUAQeTVACgCAEEBayIAQX8gABs2AgALCwcAIAAtACgLBwAgAC0AKgsHACAALQArCwcAIAAtACkLBwAgAC8BNAsHACAALQAwC0ABBH8gACgCGCEBIAAvAS4hAiAALQAoIQMgACgCOCEEIAAQOCAAIAQ2AjggACADOgAoIAAgAjsBLiAAIAE2AhgLhocCAwd/A34BeyABIAJqIQQCQCAAIgMoAgwiAA0AIAMoAgQEQCADIAE2AgQLIwBBEGsiCSQAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCADKAIcIgJBAmsO/AEB+QECAwQFBgcICQoLDA0ODxAREvgBE/cBFBX2ARYX9QEYGRobHB0eHyD9AfsBIfQBIiMkJSYnKCkqK/MBLC0uLzAxMvIB8QEzNPAB7wE1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk/6AVBRUlPuAe0BVOwBVesBVldYWVrqAVtcXV5fYGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6e3x9fn+AAYEBggGDAYQBhQGGAYcBiAGJAYoBiwGMAY0BjgGPAZABkQGSAZMBlAGVAZYBlwGYAZkBmgGbAZwBnQGeAZ8BoAGhAaIBowGkAaUBpgGnAagBqQGqAasBrAGtAa4BrwGwAbEBsgGzAbQBtQG2AbcBuAG5AboBuwG8Ab0BvgG/AcABwQHCAcMBxAHFAcYBxwHIAckBygHLAcwBzQHOAekB6AHPAecB0AHmAdEB0gHTAdQB5QHVAdYB1wHYAdkB2gHbAdwB3QHeAd8B4AHhAeIB4wEA/AELQQAM4wELQQ4M4gELQQ0M4QELQQ8M4AELQRAM3wELQRMM3gELQRQM3QELQRUM3AELQRYM2wELQRcM2gELQRgM2QELQRkM2AELQRoM1wELQRsM1gELQRwM1QELQR0M1AELQR4M0wELQR8M0gELQSAM0QELQSEM0AELQQgMzwELQSIMzgELQSQMzQELQSMMzAELQQcMywELQSUMygELQSYMyQELQScMyAELQSgMxwELQRIMxgELQREMxQELQSkMxAELQSoMwwELQSsMwgELQSwMwQELQd4BDMABC0EuDL8BC0EvDL4BC0EwDL0BC0ExDLwBC0EyDLsBC0EzDLoBC0E0DLkBC0HfAQy4AQtBNQy3AQtBOQy2AQtBDAy1AQtBNgy0AQtBNwyzAQtBOAyyAQtBPgyxAQtBOgywAQtB4AEMrwELQQsMrgELQT8MrQELQTsMrAELQQoMqwELQTwMqgELQT0MqQELQeEBDKgBC0HBAAynAQtBwAAMpgELQcIADKUBC0EJDKQBC0EtDKMBC0HDAAyiAQtBxAAMoQELQcUADKABC0HGAAyfAQtBxwAMngELQcgADJ0BC0HJAAycAQtBygAMmwELQcsADJoBC0HMAAyZAQtBzQAMmAELQc4ADJcBC0HPAAyWAQtB0AAMlQELQdEADJQBC0HSAAyTAQtB0wAMkgELQdUADJEBC0HUAAyQAQtB1gAMjwELQdcADI4BC0HYAAyNAQtB2QAMjAELQdoADIsBC0HbAAyKAQtB3AAMiQELQd0ADIgBC0HeAAyHAQtB3wAMhgELQeAADIUBC0HhAAyEAQtB4gAMgwELQeMADIIBC0HkAAyBAQtB5QAMgAELQeIBDH8LQeYADH4LQecADH0LQQYMfAtB6AAMewtBBQx6C0HpAAx5C0EEDHgLQeoADHcLQesADHYLQewADHULQe0ADHQLQQMMcwtB7gAMcgtB7wAMcQtB8AAMcAtB8gAMbwtB8QAMbgtB8wAMbQtB9AAMbAtB9QAMawtB9gAMagtBAgxpC0H3AAxoC0H4AAxnC0H5AAxmC0H6AAxlC0H7AAxkC0H8AAxjC0H9AAxiC0H+AAxhC0H/AAxgC0GAAQxfC0GBAQxeC0GCAQxdC0GDAQxcC0GEAQxbC0GFAQxaC0GGAQxZC0GHAQxYC0GIAQxXC0GJAQxWC0GKAQxVC0GLAQxUC0GMAQxTC0GNAQxSC0GOAQxRC0GPAQxQC0GQAQxPC0GRAQxOC0GSAQxNC0GTAQxMC0GUAQxLC0GVAQxKC0GWAQxJC0GXAQxIC0GYAQxHC0GZAQxGC0GaAQxFC0GbAQxEC0GcAQxDC0GdAQxCC0GeAQxBC0GfAQxAC0GgAQw/C0GhAQw+C0GiAQw9C0GjAQw8C0GkAQw7C0GlAQw6C0GmAQw5C0GnAQw4C0GoAQw3C0GpAQw2C0GqAQw1C0GrAQw0C0GsAQwzC0GtAQwyC0GuAQwxC0GvAQwwC0GwAQwvC0GxAQwuC0GyAQwtC0GzAQwsC0G0AQwrC0G1AQwqC0G2AQwpC0G3AQwoC0G4AQwnC0G5AQwmC0G6AQwlC0G7AQwkC0G8AQwjC0G9AQwiC0G+AQwhC0G/AQwgC0HAAQwfC0HBAQweC0HCAQwdC0EBDBwLQcMBDBsLQcQBDBoLQcUBDBkLQcYBDBgLQccBDBcLQcgBDBYLQckBDBULQcoBDBQLQcsBDBMLQcwBDBILQc0BDBELQc4BDBALQc8BDA8LQdABDA4LQdEBDA0LQdIBDAwLQdMBDAsLQdQBDAoLQdUBDAkLQdYBDAgLQeMBDAcLQdcBDAYLQdgBDAULQdkBDAQLQdoBDAMLQdsBDAILQd0BDAELQdwBCyECA0ACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAMCfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAAn8CQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAwJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCACDuMBAAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISMkJScoKZ4DmwOaA5EDigODA4AD/QL7AvgC8gLxAu8C7QLoAucC5gLlAuQC3ALbAtoC2QLYAtcC1gLVAs8CzgLMAssCygLJAsgCxwLGAsQCwwK+ArwCugK5ArgCtwK2ArUCtAKzArICsQKwAq4CrQKpAqgCpwKmAqUCpAKjAqICoQKgAp8CmAKQAowCiwKKAoEC/gH9AfwB+wH6AfkB+AH3AfUB8wHwAesB6QHoAecB5gHlAeQB4wHiAeEB4AHfAd4B3QHcAdoB2QHYAdcB1gHVAdQB0wHSAdEB0AHPAc4BzQHMAcsBygHJAcgBxwHGAcUBxAHDAcIBwQHAAb8BvgG9AbwBuwG6AbkBuAG3AbYBtQG0AbMBsgGxAbABrwGuAa0BrAGrAaoBqQGoAacBpgGlAaQBowGiAZ8BngGZAZgBlwGWAZUBlAGTAZIBkQGQAY8BjQGMAYcBhgGFAYQBgwGCAX18e3p5dnV0UFFSU1RVCyABIARHDXJB/QEhAgy+AwsgASAERw2YAUHbASECDL0DCyABIARHDfEBQY4BIQIMvAMLIAEgBEcN/AFBhAEhAgy7AwsgASAERw2KAkH/ACECDLoDCyABIARHDZECQf0AIQIMuQMLIAEgBEcNlAJB+wAhAgy4AwsgASAERw0eQR4hAgy3AwsgASAERw0ZQRghAgy2AwsgASAERw3KAkHNACECDLUDCyABIARHDdUCQcYAIQIMtAMLIAEgBEcN1gJBwwAhAgyzAwsgASAERw3cAkE4IQIMsgMLIAMtADBBAUYNrQMMiQMLQQAhAAJAAkACQCADLQAqRQ0AIAMtACtFDQAgAy8BMiICQQJxRQ0BDAILIAMvATIiAkEBcUUNAQtBASEAIAMtAChBAUYNACADLwE0IgZB5ABrQeQASQ0AIAZBzAFGDQAgBkGwAkYNACACQcAAcQ0AQQAhACACQYgEcUGABEYNACACQShxQQBHIQALIANBADsBMiADQQA6ADECQCAARQRAIANBADoAMSADLQAuQQRxDQEMsQMLIANCADcDIAsgA0EAOgAxIANBAToANgxIC0EAIQACQCADKAI4IgJFDQAgAigCMCICRQ0AIAMgAhEAACEACyAARQ1IIABBFUcNYiADQQQ2AhwgAyABNgIUIANB0hs2AhAgA0EVNgIMQQAhAgyvAwsgASAERgRAQQYhAgyvAwsgAS0AAEEKRw0ZIAFBAWohAQwaCyADQgA3AyBBEiECDJQDCyABIARHDYoDQSMhAgysAwsgASAERgRAQQchAgysAwsCQAJAIAEtAABBCmsOBAEYGAAYCyABQQFqIQFBECECDJMDCyABQQFqIQEgA0Evai0AAEEBcQ0XQQAhAiADQQA2AhwgAyABNgIUIANBmSA2AhAgA0EZNgIMDKsDCyADIAMpAyAiDCAEIAFrrSIKfSILQgAgCyAMWBs3AyAgCiAMWg0YQQghAgyqAwsgASAERwRAIANBCTYCCCADIAE2AgRBFCECDJEDC0EJIQIMqQMLIAMpAyBQDa4CDEMLIAEgBEYEQEELIQIMqAMLIAEtAABBCkcNFiABQQFqIQEMFwsgA0Evai0AAEEBcUUNGQwmC0EAIQACQCADKAI4IgJFDQAgAigCUCICRQ0AIAMgAhEAACEACyAADRkMQgtBACEAAkAgAygCOCICRQ0AIAIoAlAiAkUNACADIAIRAAAhAAsgAA0aDCQLQQAhAAJAIAMoAjgiAkUNACACKAJQIgJFDQAgAyACEQAAIQALIAANGwwyCyADQS9qLQAAQQFxRQ0cDCILQQAhAAJAIAMoAjgiAkUNACACKAJUIgJFDQAgAyACEQAAIQALIAANHAxCC0EAIQACQCADKAI4IgJFDQAgAigCVCICRQ0AIAMgAhEAACEACyAADR0MIAsgASAERgRAQRMhAgygAwsCQCABLQAAIgBBCmsOBB8jIwAiCyABQQFqIQEMHwtBACEAAkAgAygCOCICRQ0AIAIoAlQiAkUNACADIAIRAAAhAAsgAA0iDEILIAEgBEYEQEEWIQIMngMLIAEtAABBwMEAai0AAEEBRw0jDIMDCwJAA0AgAS0AAEGwO2otAAAiAEEBRwRAAkAgAEECaw4CAwAnCyABQQFqIQFBISECDIYDCyAEIAFBAWoiAUcNAAtBGCECDJ0DCyADKAIEIQBBACECIANBADYCBCADIAAgAUEBaiIBEDQiAA0hDEELQQAhAAJAIAMoAjgiAkUNACACKAJUIgJFDQAgAyACEQAAIQALIAANIwwqCyABIARGBEBBHCECDJsDCyADQQo2AgggAyABNgIEQQAhAAJAIAMoAjgiAkUNACACKAJQIgJFDQAgAyACEQAAIQALIAANJUEkIQIMgQMLIAEgBEcEQANAIAEtAABBsD1qLQAAIgBBA0cEQCAAQQFrDgUYGiaCAyUmCyAEIAFBAWoiAUcNAAtBGyECDJoDC0EbIQIMmQMLA0AgAS0AAEGwP2otAAAiAEEDRwRAIABBAWsOBQ8RJxMmJwsgBCABQQFqIgFHDQALQR4hAgyYAwsgASAERwRAIANBCzYCCCADIAE2AgRBByECDP8CC0EfIQIMlwMLIAEgBEYEQEEgIQIMlwMLAkAgAS0AAEENaw4ULj8/Pz8/Pz8/Pz8/Pz8/Pz8/PwA/C0EAIQIgA0EANgIcIANBvws2AhAgA0ECNgIMIAMgAUEBajYCFAyWAwsgA0EvaiECA0AgASAERgRAQSEhAgyXAwsCQAJAAkAgAS0AACIAQQlrDhgCACkpASkpKSkpKSkpKSkpKSkpKSkpKQInCyABQQFqIQEgA0Evai0AAEEBcUUNCgwYCyABQQFqIQEMFwsgAUEBaiEBIAItAABBAnENAAtBACECIANBADYCHCADIAE2AhQgA0GfFTYCECADQQw2AgwMlQMLIAMtAC5BgAFxRQ0BC0EAIQACQCADKAI4IgJFDQAgAigCXCICRQ0AIAMgAhEAACEACyAARQ3mAiAAQRVGBEAgA0EkNgIcIAMgATYCFCADQZsbNgIQIANBFTYCDEEAIQIMlAMLQQAhAiADQQA2AhwgAyABNgIUIANBkA42AhAgA0EUNgIMDJMDC0EAIQIgA0EANgIcIAMgATYCFCADQb4gNgIQIANBAjYCDAySAwsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAEgDKdqIgEQMiIARQ0rIANBBzYCHCADIAE2AhQgAyAANgIMDJEDCyADLQAuQcAAcUUNAQtBACEAAkAgAygCOCICRQ0AIAIoAlgiAkUNACADIAIRAAAhAAsgAEUNKyAAQRVGBEAgA0EKNgIcIAMgATYCFCADQesZNgIQIANBFTYCDEEAIQIMkAMLQQAhAiADQQA2AhwgAyABNgIUIANBkww2AhAgA0ETNgIMDI8DC0EAIQIgA0EANgIcIAMgATYCFCADQYIVNgIQIANBAjYCDAyOAwtBACECIANBADYCHCADIAE2AhQgA0HdFDYCECADQRk2AgwMjQMLQQAhAiADQQA2AhwgAyABNgIUIANB5h02AhAgA0EZNgIMDIwDCyAAQRVGDT1BACECIANBADYCHCADIAE2AhQgA0HQDzYCECADQSI2AgwMiwMLIAMoAgQhAEEAIQIgA0EANgIEIAMgACABEDMiAEUNKCADQQ02AhwgAyABNgIUIAMgADYCDAyKAwsgAEEVRg06QQAhAiADQQA2AhwgAyABNgIUIANB0A82AhAgA0EiNgIMDIkDCyADKAIEIQBBACECIANBADYCBCADIAAgARAzIgBFBEAgAUEBaiEBDCgLIANBDjYCHCADIAA2AgwgAyABQQFqNgIUDIgDCyAAQRVGDTdBACECIANBADYCHCADIAE2AhQgA0HQDzYCECADQSI2AgwMhwMLIAMoAgQhAEEAIQIgA0EANgIEIAMgACABEDMiAEUEQCABQQFqIQEMJwsgA0EPNgIcIAMgADYCDCADIAFBAWo2AhQMhgMLQQAhAiADQQA2AhwgAyABNgIUIANB4hc2AhAgA0EZNgIMDIUDCyAAQRVGDTNBACECIANBADYCHCADIAE2AhQgA0HWDDYCECADQSM2AgwMhAMLIAMoAgQhAEEAIQIgA0EANgIEIAMgACABEDQiAEUNJSADQRE2AhwgAyABNgIUIAMgADYCDAyDAwsgAEEVRg0wQQAhAiADQQA2AhwgAyABNgIUIANB1gw2AhAgA0EjNgIMDIIDCyADKAIEIQBBACECIANBADYCBCADIAAgARA0IgBFBEAgAUEBaiEBDCULIANBEjYCHCADIAA2AgwgAyABQQFqNgIUDIEDCyADQS9qLQAAQQFxRQ0BC0EXIQIM5gILQQAhAiADQQA2AhwgAyABNgIUIANB4hc2AhAgA0EZNgIMDP4CCyAAQTtHDQAgAUEBaiEBDAwLQQAhAiADQQA2AhwgAyABNgIUIANBkhg2AhAgA0ECNgIMDPwCCyAAQRVGDShBACECIANBADYCHCADIAE2AhQgA0HWDDYCECADQSM2AgwM+wILIANBFDYCHCADIAE2AhQgAyAANgIMDPoCCyADKAIEIQBBACECIANBADYCBCADIAAgARA0IgBFBEAgAUEBaiEBDPUCCyADQRU2AhwgAyAANgIMIAMgAUEBajYCFAz5AgsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAEQNCIARQRAIAFBAWohAQzzAgsgA0EXNgIcIAMgADYCDCADIAFBAWo2AhQM+AILIABBFUYNI0EAIQIgA0EANgIcIAMgATYCFCADQdYMNgIQIANBIzYCDAz3AgsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAEQNCIARQRAIAFBAWohAQwdCyADQRk2AhwgAyAANgIMIAMgAUEBajYCFAz2AgsgAygCBCEAQQAhAiADQQA2AgQgAyAAIAEQNCIARQRAIAFBAWohAQzvAgsgA0EaNgIcIAMgADYCDCADIAFBAWo2AhQM9QILIABBFUYNH0EAIQIgA0EANgIcIAMgATYCFCADQdAPNgIQIANBIjYCDAz0AgsgAygCBCEAIANBADYCBCADIAAgARAzIgBFBEAgAUEBaiEBDBsLIANBHDYCHCADIAA2AgwgAyABQQFqNgIUQQAhAgzzAgsgAygCBCEAIANBADYCBCADIAAgARAzIgBFBEAgAUEBaiEBDOsCCyADQR02AhwgAyAANgIMIAMgAUEBajYCFEEAIQIM8gILIABBO0cNASABQQFqIQELQSYhAgzXAgtBACECIANBADYCHCADIAE2AhQgA0GfFTYCECADQQw2AgwM7wILIAEgBEcEQANAIAEtAABBIEcNhAIgBCABQQFqIgFHDQALQSwhAgzvAgtBLCECDO4CCyABIARGBEBBNCECDO4CCwJAAkADQAJAIAEtAABBCmsOBAIAAAMACyAEIAFBAWoiAUcNAAtBNCECDO8CCyADKAIEIQAgA0EANgIEIAMgACABEDEiAEUNnwIgA0EyNgIcIAMgATYCFCADIAA2AgxBACECDO4CCyADKAIEIQAgA0EANgIEIAMgACABEDEiAEUEQCABQQFqIQEMnwILIANBMjYCHCADIAA2AgwgAyABQQFqNgIUQQAhAgztAgsgASAERwRAAkADQCABLQAAQTBrIgBB/wFxQQpPBEBBOiECDNcCCyADKQMgIgtCmbPmzJmz5swZVg0BIAMgC0IKfiIKNwMgIAogAK1C/wGDIgtCf4VWDQEgAyAKIAt8NwMgIAQgAUEBaiIBRw0AC0HAACECDO4CCyADKAIEIQAgA0EANgIEIAMgACABQQFqIgEQMSIADRcM4gILQcAAIQIM7AILIAEgBEYEQEHJACECDOwCCwJAA0ACQCABLQAAQQlrDhgAAqICogKpAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAgCiAgsgBCABQQFqIgFHDQALQckAIQIM7AILIAFBAWohASADQS9qLQAAQQFxDaUCIANBADYCHCADIAE2AhQgA0GXEDYCECADQQo2AgxBACECDOsCCyABIARHBEADQCABLQAAQSBHDRUgBCABQQFqIgFHDQALQfgAIQIM6wILQfgAIQIM6gILIANBAjoAKAw4C0EAIQIgA0EANgIcIANBvws2AhAgA0ECNgIMIAMgAUEBajYCFAzoAgtBACECDM4CC0ENIQIMzQILQRMhAgzMAgtBFSECDMsCC0EWIQIMygILQRghAgzJAgtBGSECDMgCC0EaIQIMxwILQRshAgzGAgtBHCECDMUCC0EdIQIMxAILQR4hAgzDAgtBHyECDMICC0EgIQIMwQILQSIhAgzAAgtBIyECDL8CC0ElIQIMvgILQeUAIQIMvQILIANBPTYCHCADIAE2AhQgAyAANgIMQQAhAgzVAgsgA0EbNgIcIAMgATYCFCADQaQcNgIQIANBFTYCDEEAIQIM1AILIANBIDYCHCADIAE2AhQgA0GYGjYCECADQRU2AgxBACECDNMCCyADQRM2AhwgAyABNgIUIANBmBo2AhAgA0EVNgIMQQAhAgzSAgsgA0ELNgIcIAMgATYCFCADQZgaNgIQIANBFTYCDEEAIQIM0QILIANBEDYCHCADIAE2AhQgA0GYGjYCECADQRU2AgxBACECDNACCyADQSA2AhwgAyABNgIUIANBpBw2AhAgA0EVNgIMQQAhAgzPAgsgA0ELNgIcIAMgATYCFCADQaQcNgIQIANBFTYCDEEAIQIMzgILIANBDDYCHCADIAE2AhQgA0GkHDYCECADQRU2AgxBACECDM0CC0EAIQIgA0EANgIcIAMgATYCFCADQd0ONgIQIANBEjYCDAzMAgsCQANAAkAgAS0AAEEKaw4EAAICAAILIAQgAUEBaiIBRw0AC0H9ASECDMwCCwJAAkAgAy0ANkEBRw0AQQAhAAJAIAMoAjgiAkUNACACKAJgIgJFDQAgAyACEQAAIQALIABFDQAgAEEVRw0BIANB/AE2AhwgAyABNgIUIANB3Bk2AhAgA0EVNgIMQQAhAgzNAgtB3AEhAgyzAgsgA0EANgIcIAMgATYCFCADQfkLNgIQIANBHzYCDEEAIQIMywILAkACQCADLQAoQQFrDgIEAQALQdsBIQIMsgILQdQBIQIMsQILIANBAjoAMUEAIQACQCADKAI4IgJFDQAgAigCACICRQ0AIAMgAhEAACEACyAARQRAQd0BIQIMsQILIABBFUcEQCADQQA2AhwgAyABNgIUIANBtAw2AhAgA0EQNgIMQQAhAgzKAgsgA0H7ATYCHCADIAE2AhQgA0GBGjYCECADQRU2AgxBACECDMkCCyABIARGBEBB+gEhAgzJAgsgAS0AAEHIAEYNASADQQE6ACgLQcABIQIMrgILQdoBIQIMrQILIAEgBEcEQCADQQw2AgggAyABNgIEQdkBIQIMrQILQfkBIQIMxQILIAEgBEYEQEH4ASECDMUCCyABLQAAQcgARw0EIAFBAWohAUHYASECDKsCCyABIARGBEBB9wEhAgzEAgsCQAJAIAEtAABBxQBrDhAABQUFBQUFBQUFBQUFBQUBBQsgAUEBaiEBQdYBIQIMqwILIAFBAWohAUHXASECDKoCC0H2ASECIAEgBEYNwgIgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABButUAai0AAEcNAyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMwwILIAMoAgQhACADQgA3AwAgAyAAIAZBAWoiARAuIgBFBEBB4wEhAgyqAgsgA0H1ATYCHCADIAE2AhQgAyAANgIMQQAhAgzCAgtB9AEhAiABIARGDcECIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQbjVAGotAABHDQIgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADMICCyADQYEEOwEoIAMoAgQhACADQgA3AwAgAyAAIAZBAWoiARAuIgANAwwCCyADQQA2AgALQQAhAiADQQA2AhwgAyABNgIUIANB5R82AhAgA0EINgIMDL8CC0HVASECDKUCCyADQfMBNgIcIAMgATYCFCADIAA2AgxBACECDL0CC0EAIQACQCADKAI4IgJFDQAgAigCQCICRQ0AIAMgAhEAACEACyAARQ1uIABBFUcEQCADQQA2AhwgAyABNgIUIANBgg82AhAgA0EgNgIMQQAhAgy9AgsgA0GPATYCHCADIAE2AhQgA0HsGzYCECADQRU2AgxBACECDLwCCyABIARHBEAgA0ENNgIIIAMgATYCBEHTASECDKMCC0HyASECDLsCCyABIARGBEBB8QEhAgy7AgsCQAJAAkAgAS0AAEHIAGsOCwABCAgICAgICAgCCAsgAUEBaiEBQdABIQIMowILIAFBAWohAUHRASECDKICCyABQQFqIQFB0gEhAgyhAgtB8AEhAiABIARGDbkCIAMoAgAiACAEIAFraiEGIAEgAGtBAmohBQNAIAEtAAAgAEG11QBqLQAARw0EIABBAkYNAyAAQQFqIQAgBCABQQFqIgFHDQALIAMgBjYCAAy5AgtB7wEhAiABIARGDbgCIAMoAgAiACAEIAFraiEGIAEgAGtBAWohBQNAIAEtAAAgAEGz1QBqLQAARw0DIABBAUYNAiAAQQFqIQAgBCABQQFqIgFHDQALIAMgBjYCAAy4AgtB7gEhAiABIARGDbcCIAMoAgAiACAEIAFraiEGIAEgAGtBAmohBQNAIAEtAAAgAEGw1QBqLQAARw0CIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBjYCAAy3AgsgAygCBCEAIANCADcDACADIAAgBUEBaiIBECsiAEUNAiADQewBNgIcIAMgATYCFCADIAA2AgxBACECDLYCCyADQQA2AgALIAMoAgQhACADQQA2AgQgAyAAIAEQKyIARQ2cAiADQe0BNgIcIAMgATYCFCADIAA2AgxBACECDLQCC0HPASECDJoCC0EAIQACQCADKAI4IgJFDQAgAigCNCICRQ0AIAMgAhEAACEACwJAIAAEQCAAQRVGDQEgA0EANgIcIAMgATYCFCADQeoNNgIQIANBJjYCDEEAIQIMtAILQc4BIQIMmgILIANB6wE2AhwgAyABNgIUIANBgBs2AhAgA0EVNgIMQQAhAgyyAgsgASAERgRAQesBIQIMsgILIAEtAABBL0YEQCABQQFqIQEMAQsgA0EANgIcIAMgATYCFCADQbI4NgIQIANBCDYCDEEAIQIMsQILQc0BIQIMlwILIAEgBEcEQCADQQ42AgggAyABNgIEQcwBIQIMlwILQeoBIQIMrwILIAEgBEYEQEHpASECDK8CCyABLQAAQTBrIgBB/wFxQQpJBEAgAyAAOgAqIAFBAWohAUHLASECDJYCCyADKAIEIQAgA0EANgIEIAMgACABEC8iAEUNlwIgA0HoATYCHCADIAE2AhQgAyAANgIMQQAhAgyuAgsgASAERgRAQecBIQIMrgILAkAgAS0AAEEuRgRAIAFBAWohAQwBCyADKAIEIQAgA0EANgIEIAMgACABEC8iAEUNmAIgA0HmATYCHCADIAE2AhQgAyAANgIMQQAhAgyuAgtBygEhAgyUAgsgASAERgRAQeUBIQIMrQILQQAhAEEBIQVBASEHQQAhAgJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAIAEtAABBMGsOCgoJAAECAwQFBggLC0ECDAYLQQMMBQtBBAwEC0EFDAMLQQYMAgtBBwwBC0EICyECQQAhBUEAIQcMAgtBCSECQQEhAEEAIQVBACEHDAELQQAhBUEBIQILIAMgAjoAKyABQQFqIQECQAJAIAMtAC5BEHENAAJAAkACQCADLQAqDgMBAAIECyAHRQ0DDAILIAANAQwCCyAFRQ0BCyADKAIEIQAgA0EANgIEIAMgACABEC8iAEUNAiADQeIBNgIcIAMgATYCFCADIAA2AgxBACECDK8CCyADKAIEIQAgA0EANgIEIAMgACABEC8iAEUNmgIgA0HjATYCHCADIAE2AhQgAyAANgIMQQAhAgyuAgsgAygCBCEAIANBADYCBCADIAAgARAvIgBFDZgCIANB5AE2AhwgAyABNgIUIAMgADYCDAytAgtByQEhAgyTAgtBACEAAkAgAygCOCICRQ0AIAIoAkQiAkUNACADIAIRAAAhAAsCQCAABEAgAEEVRg0BIANBADYCHCADIAE2AhQgA0GkDTYCECADQSE2AgxBACECDK0CC0HIASECDJMCCyADQeEBNgIcIAMgATYCFCADQdAaNgIQIANBFTYCDEEAIQIMqwILIAEgBEYEQEHhASECDKsCCwJAIAEtAABBIEYEQCADQQA7ATQgAUEBaiEBDAELIANBADYCHCADIAE2AhQgA0GZETYCECADQQk2AgxBACECDKsCC0HHASECDJECCyABIARGBEBB4AEhAgyqAgsCQCABLQAAQTBrQf8BcSICQQpJBEAgAUEBaiEBAkAgAy8BNCIAQZkzSw0AIAMgAEEKbCIAOwE0IABB/v8DcSACQf//A3NLDQAgAyAAIAJqOwE0DAILQQAhAiADQQA2AhwgAyABNgIUIANBlR42AhAgA0ENNgIMDKsCCyADQQA2AhwgAyABNgIUIANBlR42AhAgA0ENNgIMQQAhAgyqAgtBxgEhAgyQAgsgASAERgRAQd8BIQIMqQILAkAgAS0AAEEwa0H/AXEiAkEKSQRAIAFBAWohAQJAIAMvATQiAEGZM0sNACADIABBCmwiADsBNCAAQf7/A3EgAkH//wNzSw0AIAMgACACajsBNAwCC0EAIQIgA0EANgIcIAMgATYCFCADQZUeNgIQIANBDTYCDAyqAgsgA0EANgIcIAMgATYCFCADQZUeNgIQIANBDTYCDEEAIQIMqQILQcUBIQIMjwILIAEgBEYEQEHeASECDKgCCwJAIAEtAABBMGtB/wFxIgJBCkkEQCABQQFqIQECQCADLwE0IgBBmTNLDQAgAyAAQQpsIgA7ATQgAEH+/wNxIAJB//8Dc0sNACADIAAgAmo7ATQMAgtBACECIANBADYCHCADIAE2AhQgA0GVHjYCECADQQ02AgwMqQILIANBADYCHCADIAE2AhQgA0GVHjYCECADQQ02AgxBACECDKgCC0HEASECDI4CCyABIARGBEBB3QEhAgynAgsCQAJAAkACQCABLQAAQQprDhcCAwMAAwMDAwMDAwMDAwMDAwMDAwMDAQMLIAFBAWoMBQsgAUEBaiEBQcMBIQIMjwILIAFBAWohASADQS9qLQAAQQFxDQggA0EANgIcIAMgATYCFCADQY0LNgIQIANBDTYCDEEAIQIMpwILIANBADYCHCADIAE2AhQgA0GNCzYCECADQQ02AgxBACECDKYCCyABIARHBEAgA0EPNgIIIAMgATYCBEEBIQIMjQILQdwBIQIMpQILAkACQANAAkAgAS0AAEEKaw4EAgAAAwALIAQgAUEBaiIBRw0AC0HbASECDKYCCyADKAIEIQAgA0EANgIEIAMgACABEC0iAEUEQCABQQFqIQEMBAsgA0HaATYCHCADIAA2AgwgAyABQQFqNgIUQQAhAgylAgsgAygCBCEAIANBADYCBCADIAAgARAtIgANASABQQFqCyEBQcEBIQIMigILIANB2QE2AhwgAyAANgIMIAMgAUEBajYCFEEAIQIMogILQcIBIQIMiAILIANBL2otAABBAXENASADQQA2AhwgAyABNgIUIANB5Bw2AhAgA0EZNgIMQQAhAgygAgsgASAERgRAQdkBIQIMoAILAkACQAJAIAEtAABBCmsOBAECAgACCyABQQFqIQEMAgsgAUEBaiEBDAELIAMtAC5BwABxRQ0BC0EAIQACQCADKAI4IgJFDQAgAigCPCICRQ0AIAMgAhEAACEACyAARQ2gASAAQRVGBEAgA0HZADYCHCADIAE2AhQgA0G3GjYCECADQRU2AgxBACECDJ8CCyADQQA2AhwgAyABNgIUIANBgA02AhAgA0EbNgIMQQAhAgyeAgsgA0EANgIcIAMgATYCFCADQdwoNgIQIANBAjYCDEEAIQIMnQILIAEgBEcEQCADQQw2AgggAyABNgIEQb8BIQIMhAILQdgBIQIMnAILIAEgBEYEQEHXASECDJwCCwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAS0AAEHBAGsOFQABAgNaBAUGWlpaBwgJCgsMDQ4PEFoLIAFBAWohAUH7ACECDJICCyABQQFqIQFB/AAhAgyRAgsgAUEBaiEBQYEBIQIMkAILIAFBAWohAUGFASECDI8CCyABQQFqIQFBhgEhAgyOAgsgAUEBaiEBQYkBIQIMjQILIAFBAWohAUGKASECDIwCCyABQQFqIQFBjQEhAgyLAgsgAUEBaiEBQZYBIQIMigILIAFBAWohAUGXASECDIkCCyABQQFqIQFBmAEhAgyIAgsgAUEBaiEBQaUBIQIMhwILIAFBAWohAUGmASECDIYCCyABQQFqIQFBrAEhAgyFAgsgAUEBaiEBQbQBIQIMhAILIAFBAWohAUG3ASECDIMCCyABQQFqIQFBvgEhAgyCAgsgASAERgRAQdYBIQIMmwILIAEtAABBzgBHDUggAUEBaiEBQb0BIQIMgQILIAEgBEYEQEHVASECDJoCCwJAAkACQCABLQAAQcIAaw4SAEpKSkpKSkpKSgFKSkpKSkoCSgsgAUEBaiEBQbgBIQIMggILIAFBAWohAUG7ASECDIECCyABQQFqIQFBvAEhAgyAAgtB1AEhAiABIARGDZgCIAMoAgAiACAEIAFraiEFIAEgAGtBB2ohBgJAA0AgAS0AACAAQajVAGotAABHDUUgAEEHRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADJkCCyADQQA2AgAgBkEBaiEBQRsMRQsgASAERgRAQdMBIQIMmAILAkACQCABLQAAQckAaw4HAEdHR0dHAUcLIAFBAWohAUG5ASECDP8BCyABQQFqIQFBugEhAgz+AQtB0gEhAiABIARGDZYCIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQabVAGotAABHDUMgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADJcCCyADQQA2AgAgBkEBaiEBQQ8MQwtB0QEhAiABIARGDZUCIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQaTVAGotAABHDUIgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADJYCCyADQQA2AgAgBkEBaiEBQSAMQgtB0AEhAiABIARGDZQCIAMoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQaHVAGotAABHDUEgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADJUCCyADQQA2AgAgBkEBaiEBQRIMQQsgASAERgRAQc8BIQIMlAILAkACQCABLQAAQcUAaw4OAENDQ0NDQ0NDQ0NDQwFDCyABQQFqIQFBtQEhAgz7AQsgAUEBaiEBQbYBIQIM+gELQc4BIQIgASAERg2SAiADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGe1QBqLQAARw0/IABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyTAgsgA0EANgIAIAZBAWohAUEHDD8LQc0BIQIgASAERg2RAiADKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGY1QBqLQAARw0+IABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAySAgsgA0EANgIAIAZBAWohAUEoDD4LIAEgBEYEQEHMASECDJECCwJAAkACQCABLQAAQcUAaw4RAEFBQUFBQUFBQQFBQUFBQQJBCyABQQFqIQFBsQEhAgz5AQsgAUEBaiEBQbIBIQIM+AELIAFBAWohAUGzASECDPcBC0HLASECIAEgBEYNjwIgAygCACIAIAQgAWtqIQUgASAAa0EGaiEGAkADQCABLQAAIABBkdUAai0AAEcNPCAAQQZGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMkAILIANBADYCACAGQQFqIQFBGgw8C0HKASECIAEgBEYNjgIgAygCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABBjdUAai0AAEcNOyAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMjwILIANBADYCACAGQQFqIQFBIQw7CyABIARGBEBByQEhAgyOAgsCQAJAIAEtAABBwQBrDhQAPT09PT09PT09PT09PT09PT09AT0LIAFBAWohAUGtASECDPUBCyABQQFqIQFBsAEhAgz0AQsgASAERgRAQcgBIQIMjQILAkACQCABLQAAQdUAaw4LADw8PDw8PDw8PAE8CyABQQFqIQFBrgEhAgz0AQsgAUEBaiEBQa8BIQIM8wELQccBIQIgASAERg2LAiADKAIAIgAgBCABa2ohBSABIABrQQhqIQYCQANAIAEtAAAgAEGE1QBqLQAARw04IABBCEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyMAgsgA0EANgIAIAZBAWohAUEqDDgLIAEgBEYEQEHGASECDIsCCyABLQAAQdAARw04IAFBAWohAUElDDcLQcUBIQIgASAERg2JAiADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGB1QBqLQAARw02IABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyKAgsgA0EANgIAIAZBAWohAUEODDYLIAEgBEYEQEHEASECDIkCCyABLQAAQcUARw02IAFBAWohAUGrASECDO8BCyABIARGBEBBwwEhAgyIAgsCQAJAAkACQCABLQAAQcIAaw4PAAECOTk5OTk5OTk5OTkDOQsgAUEBaiEBQacBIQIM8QELIAFBAWohAUGoASECDPABCyABQQFqIQFBqQEhAgzvAQsgAUEBaiEBQaoBIQIM7gELQcIBIQIgASAERg2GAiADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEH+1ABqLQAARw0zIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyHAgsgA0EANgIAIAZBAWohAUEUDDMLQcEBIQIgASAERg2FAiADKAIAIgAgBCABa2ohBSABIABrQQRqIQYCQANAIAEtAAAgAEH51ABqLQAARw0yIABBBEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyGAgsgA0EANgIAIAZBAWohAUErDDILQcABIQIgASAERg2EAiADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEH21ABqLQAARw0xIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyFAgsgA0EANgIAIAZBAWohAUEsDDELQb8BIQIgASAERg2DAiADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGh1QBqLQAARw0wIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyEAgsgA0EANgIAIAZBAWohAUERDDALQb4BIQIgASAERg2CAiADKAIAIgAgBCABa2ohBSABIABrQQNqIQYCQANAIAEtAAAgAEHy1ABqLQAARw0vIABBA0YNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyDAgsgA0EANgIAIAZBAWohAUEuDC8LIAEgBEYEQEG9ASECDIICCwJAAkACQAJAAkAgAS0AAEHBAGsOFQA0NDQ0NDQ0NDQ0ATQ0AjQ0AzQ0BDQLIAFBAWohAUGbASECDOwBCyABQQFqIQFBnAEhAgzrAQsgAUEBaiEBQZ0BIQIM6gELIAFBAWohAUGiASECDOkBCyABQQFqIQFBpAEhAgzoAQsgASAERgRAQbwBIQIMgQILAkACQCABLQAAQdIAaw4DADABMAsgAUEBaiEBQaMBIQIM6AELIAFBAWohAUEEDC0LQbsBIQIgASAERg3/ASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHw1ABqLQAARw0sIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyAAgsgA0EANgIAIAZBAWohAUEdDCwLIAEgBEYEQEG6ASECDP8BCwJAAkAgAS0AAEHJAGsOBwEuLi4uLgAuCyABQQFqIQFBoQEhAgzmAQsgAUEBaiEBQSIMKwsgASAERgRAQbkBIQIM/gELIAEtAABB0ABHDSsgAUEBaiEBQaABIQIM5AELIAEgBEYEQEG4ASECDP0BCwJAAkAgAS0AAEHGAGsOCwAsLCwsLCwsLCwBLAsgAUEBaiEBQZ4BIQIM5AELIAFBAWohAUGfASECDOMBC0G3ASECIAEgBEYN+wEgAygCACIAIAQgAWtqIQUgASAAa0EDaiEGAkADQCABLQAAIABB7NQAai0AAEcNKCAAQQNGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM/AELIANBADYCACAGQQFqIQFBDQwoC0G2ASECIAEgBEYN+gEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBodUAai0AAEcNJyAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM+wELIANBADYCACAGQQFqIQFBDAwnC0G1ASECIAEgBEYN+QEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB6tQAai0AAEcNJiAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM+gELIANBADYCACAGQQFqIQFBAwwmC0G0ASECIAEgBEYN+AEgAygCACIAIAQgAWtqIQUgASAAa0EBaiEGAkADQCABLQAAIABB6NQAai0AAEcNJSAAQQFGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM+QELIANBADYCACAGQQFqIQFBJgwlCyABIARGBEBBswEhAgz4AQsCQAJAIAEtAABB1ABrDgIAAScLIAFBAWohAUGZASECDN8BCyABQQFqIQFBmgEhAgzeAQtBsgEhAiABIARGDfYBIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQebUAGotAABHDSMgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADPcBCyADQQA2AgAgBkEBaiEBQScMIwtBsQEhAiABIARGDfUBIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQeTUAGotAABHDSIgAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADPYBCyADQQA2AgAgBkEBaiEBQRwMIgtBsAEhAiABIARGDfQBIAMoAgAiACAEIAFraiEFIAEgAGtBBWohBgJAA0AgAS0AACAAQd7UAGotAABHDSEgAEEFRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADPUBCyADQQA2AgAgBkEBaiEBQQYMIQtBrwEhAiABIARGDfMBIAMoAgAiACAEIAFraiEFIAEgAGtBBGohBgJAA0AgAS0AACAAQdnUAGotAABHDSAgAEEERg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADPQBCyADQQA2AgAgBkEBaiEBQRkMIAsgASAERgRAQa4BIQIM8wELAkACQAJAAkAgAS0AAEEtaw4jACQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkASQkJCQkAiQkJAMkCyABQQFqIQFBjgEhAgzcAQsgAUEBaiEBQY8BIQIM2wELIAFBAWohAUGUASECDNoBCyABQQFqIQFBlQEhAgzZAQtBrQEhAiABIARGDfEBIAMoAgAiACAEIAFraiEFIAEgAGtBAWohBgJAA0AgAS0AACAAQdfUAGotAABHDR4gAEEBRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADPIBCyADQQA2AgAgBkEBaiEBQQsMHgsgASAERgRAQawBIQIM8QELAkACQCABLQAAQcEAaw4DACABIAsgAUEBaiEBQZABIQIM2AELIAFBAWohAUGTASECDNcBCyABIARGBEBBqwEhAgzwAQsCQAJAIAEtAABBwQBrDg8AHx8fHx8fHx8fHx8fHwEfCyABQQFqIQFBkQEhAgzXAQsgAUEBaiEBQZIBIQIM1gELIAEgBEYEQEGqASECDO8BCyABLQAAQcwARw0cIAFBAWohAUEKDBsLQakBIQIgASAERg3tASADKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEHR1ABqLQAARw0aIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzuAQsgA0EANgIAIAZBAWohAUEeDBoLQagBIQIgASAERg3sASADKAIAIgAgBCABa2ohBSABIABrQQZqIQYCQANAIAEtAAAgAEHK1ABqLQAARw0ZIABBBkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAztAQsgA0EANgIAIAZBAWohAUEVDBkLQacBIQIgASAERg3rASADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEHH1ABqLQAARw0YIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzsAQsgA0EANgIAIAZBAWohAUEXDBgLQaYBIQIgASAERg3qASADKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEHB1ABqLQAARw0XIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzrAQsgA0EANgIAIAZBAWohAUEYDBcLIAEgBEYEQEGlASECDOoBCwJAAkAgAS0AAEHJAGsOBwAZGRkZGQEZCyABQQFqIQFBiwEhAgzRAQsgAUEBaiEBQYwBIQIM0AELQaQBIQIgASAERg3oASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGm1QBqLQAARw0VIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzpAQsgA0EANgIAIAZBAWohAUEJDBULQaMBIQIgASAERg3nASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGk1QBqLQAARw0UIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzoAQsgA0EANgIAIAZBAWohAUEfDBQLQaIBIQIgASAERg3mASADKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEG+1ABqLQAARw0TIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAznAQsgA0EANgIAIAZBAWohAUECDBMLQaEBIQIgASAERg3lASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYDQCABLQAAIABBvNQAai0AAEcNESAAQQFGDQIgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM5QELIAEgBEYEQEGgASECDOUBC0EBIAEtAABB3wBHDREaIAFBAWohAUGHASECDMsBCyADQQA2AgAgBkEBaiEBQYgBIQIMygELQZ8BIQIgASAERg3iASADKAIAIgAgBCABa2ohBSABIABrQQhqIQYCQANAIAEtAAAgAEGE1QBqLQAARw0PIABBCEYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAzjAQsgA0EANgIAIAZBAWohAUEpDA8LQZ4BIQIgASAERg3hASADKAIAIgAgBCABa2ohBSABIABrQQNqIQYCQANAIAEtAAAgAEG41ABqLQAARw0OIABBA0YNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAziAQsgA0EANgIAIAZBAWohAUEtDA4LIAEgBEYEQEGdASECDOEBCyABLQAAQcUARw0OIAFBAWohAUGEASECDMcBCyABIARGBEBBnAEhAgzgAQsCQAJAIAEtAABBzABrDggADw8PDw8PAQ8LIAFBAWohAUGCASECDMcBCyABQQFqIQFBgwEhAgzGAQtBmwEhAiABIARGDd4BIAMoAgAiACAEIAFraiEFIAEgAGtBBGohBgJAA0AgAS0AACAAQbPUAGotAABHDQsgAEEERg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADN8BCyADQQA2AgAgBkEBaiEBQSMMCwtBmgEhAiABIARGDd0BIAMoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQbDUAGotAABHDQogAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADN4BCyADQQA2AgAgBkEBaiEBQQAMCgsgASAERgRAQZkBIQIM3QELAkACQCABLQAAQcgAaw4IAAwMDAwMDAEMCyABQQFqIQFB/QAhAgzEAQsgAUEBaiEBQYABIQIMwwELIAEgBEYEQEGYASECDNwBCwJAAkAgAS0AAEHOAGsOAwALAQsLIAFBAWohAUH+ACECDMMBCyABQQFqIQFB/wAhAgzCAQsgASAERgRAQZcBIQIM2wELIAEtAABB2QBHDQggAUEBaiEBQQgMBwtBlgEhAiABIARGDdkBIAMoAgAiACAEIAFraiEFIAEgAGtBA2ohBgJAA0AgAS0AACAAQazUAGotAABHDQYgAEEDRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADNoBCyADQQA2AgAgBkEBaiEBQQUMBgtBlQEhAiABIARGDdgBIAMoAgAiACAEIAFraiEFIAEgAGtBBWohBgJAA0AgAS0AACAAQabUAGotAABHDQUgAEEFRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADNkBCyADQQA2AgAgBkEBaiEBQRYMBQtBlAEhAiABIARGDdcBIAMoAgAiACAEIAFraiEFIAEgAGtBAmohBgJAA0AgAS0AACAAQaHVAGotAABHDQQgAEECRg0BIABBAWohACAEIAFBAWoiAUcNAAsgAyAFNgIADNgBCyADQQA2AgAgBkEBaiEBQRAMBAsgASAERgRAQZMBIQIM1wELAkACQCABLQAAQcMAaw4MAAYGBgYGBgYGBgYBBgsgAUEBaiEBQfkAIQIMvgELIAFBAWohAUH6ACECDL0BC0GSASECIAEgBEYN1QEgAygCACIAIAQgAWtqIQUgASAAa0EFaiEGAkADQCABLQAAIABBoNQAai0AAEcNAiAAQQVGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAM1gELIANBADYCACAGQQFqIQFBJAwCCyADQQA2AgAMAgsgASAERgRAQZEBIQIM1AELIAEtAABBzABHDQEgAUEBaiEBQRMLOgApIAMoAgQhACADQQA2AgQgAyAAIAEQLiIADQIMAQtBACECIANBADYCHCADIAE2AhQgA0H+HzYCECADQQY2AgwM0QELQfgAIQIMtwELIANBkAE2AhwgAyABNgIUIAMgADYCDEEAIQIMzwELQQAhAAJAIAMoAjgiAkUNACACKAJAIgJFDQAgAyACEQAAIQALIABFDQAgAEEVRg0BIANBADYCHCADIAE2AhQgA0GCDzYCECADQSA2AgxBACECDM4BC0H3ACECDLQBCyADQY8BNgIcIAMgATYCFCADQewbNgIQIANBFTYCDEEAIQIMzAELIAEgBEYEQEGPASECDMwBCwJAIAEtAABBIEYEQCABQQFqIQEMAQsgA0EANgIcIAMgATYCFCADQZsfNgIQIANBBjYCDEEAIQIMzAELQQIhAgyyAQsDQCABLQAAQSBHDQIgBCABQQFqIgFHDQALQY4BIQIMygELIAEgBEYEQEGNASECDMoBCwJAIAEtAABBCWsOBEoAAEoAC0H1ACECDLABCyADLQApQQVGBEBB9gAhAgywAQtB9AAhAgyvAQsgASAERgRAQYwBIQIMyAELIANBEDYCCCADIAE2AgQMCgsgASAERgRAQYsBIQIMxwELAkAgAS0AAEEJaw4ERwAARwALQfMAIQIMrQELIAEgBEcEQCADQRA2AgggAyABNgIEQfEAIQIMrQELQYoBIQIMxQELAkAgASAERwRAA0AgAS0AAEGg0ABqLQAAIgBBA0cEQAJAIABBAWsOAkkABAtB8AAhAgyvAQsgBCABQQFqIgFHDQALQYgBIQIMxgELQYgBIQIMxQELIANBADYCHCADIAE2AhQgA0HbIDYCECADQQc2AgxBACECDMQBCyABIARGBEBBiQEhAgzEAQsCQAJAAkAgAS0AAEGg0gBqLQAAQQFrDgNGAgABC0HyACECDKwBCyADQQA2AhwgAyABNgIUIANBtBI2AhAgA0EHNgIMQQAhAgzEAQtB6gAhAgyqAQsgASAERwRAIAFBAWohAUHvACECDKoBC0GHASECDMIBCyAEIAEiAEYEQEGGASECDMIBCyAALQAAIgFBL0YEQCAAQQFqIQFB7gAhAgypAQsgAUEJayICQRdLDQEgACEBQQEgAnRBm4CABHENQQwBCyAEIAEiAEYEQEGFASECDMEBCyAALQAAQS9HDQAgAEEBaiEBDAMLQQAhAiADQQA2AhwgAyAANgIUIANB2yA2AhAgA0EHNgIMDL8BCwJAAkACQAJAAkADQCABLQAAQaDOAGotAAAiAEEFRwRAAkACQCAAQQFrDghHBQYHCAAEAQgLQesAIQIMrQELIAFBAWohAUHtACECDKwBCyAEIAFBAWoiAUcNAAtBhAEhAgzDAQsgAUEBagwUCyADKAIEIQAgA0EANgIEIAMgACABECwiAEUNHiADQdsANgIcIAMgATYCFCADIAA2AgxBACECDMEBCyADKAIEIQAgA0EANgIEIAMgACABECwiAEUNHiADQd0ANgIcIAMgATYCFCADIAA2AgxBACECDMABCyADKAIEIQAgA0EANgIEIAMgACABECwiAEUNHiADQfoANgIcIAMgATYCFCADIAA2AgxBACECDL8BCyADQQA2AhwgAyABNgIUIANB+Q82AhAgA0EHNgIMQQAhAgy+AQsgASAERgRAQYMBIQIMvgELAkAgAS0AAEGgzgBqLQAAQQFrDgg+BAUGAAgCAwcLIAFBAWohAQtBAyECDKMBCyABQQFqDA0LQQAhAiADQQA2AhwgA0HREjYCECADQQc2AgwgAyABQQFqNgIUDLoBCyADKAIEIQAgA0EANgIEIAMgACABECwiAEUNFiADQdsANgIcIAMgATYCFCADIAA2AgxBACECDLkBCyADKAIEIQAgA0EANgIEIAMgACABECwiAEUNFiADQd0ANgIcIAMgATYCFCADIAA2AgxBACECDLgBCyADKAIEIQAgA0EANgIEIAMgACABECwiAEUNFiADQfoANgIcIAMgATYCFCADIAA2AgxBACECDLcBCyADQQA2AhwgAyABNgIUIANB+Q82AhAgA0EHNgIMQQAhAgy2AQtB7AAhAgycAQsgASAERgRAQYIBIQIMtQELIAFBAWoMAgsgASAERgRAQYEBIQIMtAELIAFBAWoMAQsgASAERg0BIAFBAWoLIQFBBCECDJgBC0GAASECDLABCwNAIAEtAABBoMwAai0AACIAQQJHBEAgAEEBRwRAQekAIQIMmQELDDELIAQgAUEBaiIBRw0AC0H/ACECDK8BCyABIARGBEBB/gAhAgyvAQsCQCABLQAAQQlrDjcvAwYvBAYGBgYGBgYGBgYGBgYGBgYGBgUGBgIGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYABgsgAUEBagshAUEFIQIMlAELIAFBAWoMBgsgAygCBCEAIANBADYCBCADIAAgARAsIgBFDQggA0HbADYCHCADIAE2AhQgAyAANgIMQQAhAgyrAQsgAygCBCEAIANBADYCBCADIAAgARAsIgBFDQggA0HdADYCHCADIAE2AhQgAyAANgIMQQAhAgyqAQsgAygCBCEAIANBADYCBCADIAAgARAsIgBFDQggA0H6ADYCHCADIAE2AhQgAyAANgIMQQAhAgypAQsgA0EANgIcIAMgATYCFCADQY0UNgIQIANBBzYCDEEAIQIMqAELAkACQAJAAkADQCABLQAAQaDKAGotAAAiAEEFRwRAAkAgAEEBaw4GLgMEBQYABgtB6AAhAgyUAQsgBCABQQFqIgFHDQALQf0AIQIMqwELIAMoAgQhACADQQA2AgQgAyAAIAEQLCIARQ0HIANB2wA2AhwgAyABNgIUIAMgADYCDEEAIQIMqgELIAMoAgQhACADQQA2AgQgAyAAIAEQLCIARQ0HIANB3QA2AhwgAyABNgIUIAMgADYCDEEAIQIMqQELIAMoAgQhACADQQA2AgQgAyAAIAEQLCIARQ0HIANB+gA2AhwgAyABNgIUIAMgADYCDEEAIQIMqAELIANBADYCHCADIAE2AhQgA0HkCDYCECADQQc2AgxBACECDKcBCyABIARGDQEgAUEBagshAUEGIQIMjAELQfwAIQIMpAELAkACQAJAAkADQCABLQAAQaDIAGotAAAiAEEFRwRAIABBAWsOBCkCAwQFCyAEIAFBAWoiAUcNAAtB+wAhAgynAQsgAygCBCEAIANBADYCBCADIAAgARAsIgBFDQMgA0HbADYCHCADIAE2AhQgAyAANgIMQQAhAgymAQsgAygCBCEAIANBADYCBCADIAAgARAsIgBFDQMgA0HdADYCHCADIAE2AhQgAyAANgIMQQAhAgylAQsgAygCBCEAIANBADYCBCADIAAgARAsIgBFDQMgA0H6ADYCHCADIAE2AhQgAyAANgIMQQAhAgykAQsgA0EANgIcIAMgATYCFCADQbwKNgIQIANBBzYCDEEAIQIMowELQc8AIQIMiQELQdEAIQIMiAELQecAIQIMhwELIAEgBEYEQEH6ACECDKABCwJAIAEtAABBCWsOBCAAACAACyABQQFqIQFB5gAhAgyGAQsgASAERgRAQfkAIQIMnwELAkAgAS0AAEEJaw4EHwAAHwALQQAhAAJAIAMoAjgiAkUNACACKAI4IgJFDQAgAyACEQAAIQALIABFBEBB4gEhAgyGAQsgAEEVRwRAIANBADYCHCADIAE2AhQgA0HJDTYCECADQRo2AgxBACECDJ8BCyADQfgANgIcIAMgATYCFCADQeoaNgIQIANBFTYCDEEAIQIMngELIAEgBEcEQCADQQ02AgggAyABNgIEQeQAIQIMhQELQfcAIQIMnQELIAEgBEYEQEH2ACECDJ0BCwJAAkACQCABLQAAQcgAaw4LAAELCwsLCwsLCwILCyABQQFqIQFB3QAhAgyFAQsgAUEBaiEBQeAAIQIMhAELIAFBAWohAUHjACECDIMBC0H1ACECIAEgBEYNmwEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBtdUAai0AAEcNCCAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMnAELIAMoAgQhACADQgA3AwAgAyAAIAZBAWoiARArIgAEQCADQfQANgIcIAMgATYCFCADIAA2AgxBACECDJwBC0HiACECDIIBC0EAIQACQCADKAI4IgJFDQAgAigCNCICRQ0AIAMgAhEAACEACwJAIAAEQCAAQRVGDQEgA0EANgIcIAMgATYCFCADQeoNNgIQIANBJjYCDEEAIQIMnAELQeEAIQIMggELIANB8wA2AhwgAyABNgIUIANBgBs2AhAgA0EVNgIMQQAhAgyaAQsgAy0AKSIAQSNrQQtJDQkCQCAAQQZLDQBBASAAdEHKAHFFDQAMCgtBACECIANBADYCHCADIAE2AhQgA0HtCTYCECADQQg2AgwMmQELQfIAIQIgASAERg2YASADKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEGz1QBqLQAARw0FIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAyZAQsgAygCBCEAIANCADcDACADIAAgBkEBaiIBECsiAARAIANB8QA2AhwgAyABNgIUIAMgADYCDEEAIQIMmQELQd8AIQIMfwtBACEAAkAgAygCOCICRQ0AIAIoAjQiAkUNACADIAIRAAAhAAsCQCAABEAgAEEVRg0BIANBADYCHCADIAE2AhQgA0HqDTYCECADQSY2AgxBACECDJkBC0HeACECDH8LIANB8AA2AhwgAyABNgIUIANBgBs2AhAgA0EVNgIMQQAhAgyXAQsgAy0AKUEhRg0GIANBADYCHCADIAE2AhQgA0GRCjYCECADQQg2AgxBACECDJYBC0HvACECIAEgBEYNlQEgAygCACIAIAQgAWtqIQUgASAAa0ECaiEGAkADQCABLQAAIABBsNUAai0AAEcNAiAAQQJGDQEgAEEBaiEAIAQgAUEBaiIBRw0ACyADIAU2AgAMlgELIAMoAgQhACADQgA3AwAgAyAAIAZBAWoiARArIgBFDQIgA0HtADYCHCADIAE2AhQgAyAANgIMQQAhAgyVAQsgA0EANgIACyADKAIEIQAgA0EANgIEIAMgACABECsiAEUNgAEgA0HuADYCHCADIAE2AhQgAyAANgIMQQAhAgyTAQtB3AAhAgx5C0EAIQACQCADKAI4IgJFDQAgAigCNCICRQ0AIAMgAhEAACEACwJAIAAEQCAAQRVGDQEgA0EANgIcIAMgATYCFCADQeoNNgIQIANBJjYCDEEAIQIMkwELQdsAIQIMeQsgA0HsADYCHCADIAE2AhQgA0GAGzYCECADQRU2AgxBACECDJEBCyADLQApIgBBI0kNACAAQS5GDQAgA0EANgIcIAMgATYCFCADQckJNgIQIANBCDYCDEEAIQIMkAELQdoAIQIMdgsgASAERgRAQesAIQIMjwELAkAgAS0AAEEvRgRAIAFBAWohAQwBCyADQQA2AhwgAyABNgIUIANBsjg2AhAgA0EINgIMQQAhAgyPAQtB2QAhAgx1CyABIARHBEAgA0EONgIIIAMgATYCBEHYACECDHULQeoAIQIMjQELIAEgBEYEQEHpACECDI0BCyABLQAAQTBrIgBB/wFxQQpJBEAgAyAAOgAqIAFBAWohAUHXACECDHQLIAMoAgQhACADQQA2AgQgAyAAIAEQLyIARQ16IANB6AA2AhwgAyABNgIUIAMgADYCDEEAIQIMjAELIAEgBEYEQEHnACECDIwBCwJAIAEtAABBLkYEQCABQQFqIQEMAQsgAygCBCEAIANBADYCBCADIAAgARAvIgBFDXsgA0HmADYCHCADIAE2AhQgAyAANgIMQQAhAgyMAQtB1gAhAgxyCyABIARGBEBB5QAhAgyLAQtBACEAQQEhBUEBIQdBACECAkACQAJAAkACQAJ/AkACQAJAAkACQAJAAkAgAS0AAEEwaw4KCgkAAQIDBAUGCAsLQQIMBgtBAwwFC0EEDAQLQQUMAwtBBgwCC0EHDAELQQgLIQJBACEFQQAhBwwCC0EJIQJBASEAQQAhBUEAIQcMAQtBACEFQQEhAgsgAyACOgArIAFBAWohAQJAAkAgAy0ALkEQcQ0AAkACQAJAIAMtACoOAwEAAgQLIAdFDQMMAgsgAA0BDAILIAVFDQELIAMoAgQhACADQQA2AgQgAyAAIAEQLyIARQ0CIANB4gA2AhwgAyABNgIUIAMgADYCDEEAIQIMjQELIAMoAgQhACADQQA2AgQgAyAAIAEQLyIARQ19IANB4wA2AhwgAyABNgIUIAMgADYCDEEAIQIMjAELIAMoAgQhACADQQA2AgQgAyAAIAEQLyIARQ17IANB5AA2AhwgAyABNgIUIAMgADYCDAyLAQtB1AAhAgxxCyADLQApQSJGDYYBQdMAIQIMcAtBACEAAkAgAygCOCICRQ0AIAIoAkQiAkUNACADIAIRAAAhAAsgAEUEQEHVACECDHALIABBFUcEQCADQQA2AhwgAyABNgIUIANBpA02AhAgA0EhNgIMQQAhAgyJAQsgA0HhADYCHCADIAE2AhQgA0HQGjYCECADQRU2AgxBACECDIgBCyABIARGBEBB4AAhAgyIAQsCQAJAAkACQAJAIAEtAABBCmsOBAEEBAAECyABQQFqIQEMAQsgAUEBaiEBIANBL2otAABBAXFFDQELQdIAIQIMcAsgA0EANgIcIAMgATYCFCADQbYRNgIQIANBCTYCDEEAIQIMiAELIANBADYCHCADIAE2AhQgA0G2ETYCECADQQk2AgxBACECDIcBCyABIARGBEBB3wAhAgyHAQsgAS0AAEEKRgRAIAFBAWohAQwJCyADLQAuQcAAcQ0IIANBADYCHCADIAE2AhQgA0G2ETYCECADQQI2AgxBACECDIYBCyABIARGBEBB3QAhAgyGAQsgAS0AACICQQ1GBEAgAUEBaiEBQdAAIQIMbQsgASEAIAJBCWsOBAUBAQUBCyAEIAEiAEYEQEHcACECDIUBCyAALQAAQQpHDQAgAEEBagwCC0EAIQIgA0EANgIcIAMgADYCFCADQcotNgIQIANBBzYCDAyDAQsgASAERgRAQdsAIQIMgwELAkAgAS0AAEEJaw4EAwAAAwALIAFBAWoLIQFBzgAhAgxoCyABIARGBEBB2gAhAgyBAQsgAS0AAEEJaw4EAAEBAAELQQAhAiADQQA2AhwgA0GaEjYCECADQQc2AgwgAyABQQFqNgIUDH8LIANBgBI7ASpBACEAAkAgAygCOCICRQ0AIAIoAjgiAkUNACADIAIRAAAhAAsgAEUNACAAQRVHDQEgA0HZADYCHCADIAE2AhQgA0HqGjYCECADQRU2AgxBACECDH4LQc0AIQIMZAsgA0EANgIcIAMgATYCFCADQckNNgIQIANBGjYCDEEAIQIMfAsgASAERgRAQdkAIQIMfAsgAS0AAEEgRw09IAFBAWohASADLQAuQQFxDT0gA0EANgIcIAMgATYCFCADQcIcNgIQIANBHjYCDEEAIQIMewsgASAERgRAQdgAIQIMewsCQAJAAkACQAJAIAEtAAAiAEEKaw4EAgMDAAELIAFBAWohAUEsIQIMZQsgAEE6Rw0BIANBADYCHCADIAE2AhQgA0HnETYCECADQQo2AgxBACECDH0LIAFBAWohASADQS9qLQAAQQFxRQ1zIAMtADJBgAFxRQRAIANBMmohAiADEDVBACEAAkAgAygCOCIGRQ0AIAYoAigiBkUNACADIAYRAAAhAAsCQAJAIAAOFk1MSwEBAQEBAQEBAQEBAQEBAQEBAQABCyADQSk2AhwgAyABNgIUIANBrBk2AhAgA0EVNgIMQQAhAgx+CyADQQA2AhwgAyABNgIUIANB5Qs2AhAgA0ERNgIMQQAhAgx9C0EAIQACQCADKAI4IgJFDQAgAigCXCICRQ0AIAMgAhEAACEACyAARQ1ZIABBFUcNASADQQU2AhwgAyABNgIUIANBmxs2AhAgA0EVNgIMQQAhAgx8C0HLACECDGILQQAhAiADQQA2AhwgAyABNgIUIANBkA42AhAgA0EUNgIMDHoLIAMgAy8BMkGAAXI7ATIMOwsgASAERwRAIANBETYCCCADIAE2AgRBygAhAgxgC0HXACECDHgLIAEgBEYEQEHWACECDHgLAkACQAJAAkAgAS0AACIAQSByIAAgAEHBAGtB/wFxQRpJG0H/AXFB4wBrDhMAQEBAQEBAQEBAQEBAAUBAQAIDQAsgAUEBaiEBQcYAIQIMYQsgAUEBaiEBQccAIQIMYAsgAUEBaiEBQcgAIQIMXwsgAUEBaiEBQckAIQIMXgtB1QAhAiAEIAEiAEYNdiAEIAFrIAMoAgAiAWohBiAAIAFrQQVqIQcDQCABQZDIAGotAAAgAC0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDQhBBCABQQVGDQoaIAFBAWohASAEIABBAWoiAEcNAAsgAyAGNgIADHYLQdQAIQIgBCABIgBGDXUgBCABayADKAIAIgFqIQYgACABa0EPaiEHA0AgAUGAyABqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0HQQMgAUEPRg0JGiABQQFqIQEgBCAAQQFqIgBHDQALIAMgBjYCAAx1C0HTACECIAQgASIARg10IAQgAWsgAygCACIBaiEGIAAgAWtBDmohBwNAIAFB4scAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNBiABQQ5GDQcgAUEBaiEBIAQgAEEBaiIARw0ACyADIAY2AgAMdAtB0gAhAiAEIAEiAEYNcyAEIAFrIAMoAgAiAWohBSAAIAFrQQFqIQYDQCABQeDHAGotAAAgAC0AACIHQSByIAcgB0HBAGtB/wFxQRpJG0H/AXFHDQUgAUEBRg0CIAFBAWohASAEIABBAWoiAEcNAAsgAyAFNgIADHMLIAEgBEYEQEHRACECDHMLAkACQCABLQAAIgBBIHIgACAAQcEAa0H/AXFBGkkbQf8BcUHuAGsOBwA5OTk5OQE5CyABQQFqIQFBwwAhAgxaCyABQQFqIQFBxAAhAgxZCyADQQA2AgAgBkEBaiEBQcUAIQIMWAtB0AAhAiAEIAEiAEYNcCAEIAFrIAMoAgAiAWohBiAAIAFrQQlqIQcDQCABQdbHAGotAAAgAC0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDQJBAiABQQlGDQQaIAFBAWohASAEIABBAWoiAEcNAAsgAyAGNgIADHALQc8AIQIgBCABIgBGDW8gBCABayADKAIAIgFqIQYgACABa0EFaiEHA0AgAUHQxwBqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0BIAFBBUYNAiABQQFqIQEgBCAAQQFqIgBHDQALIAMgBjYCAAxvCyAAIQEgA0EANgIADDMLQQELOgAsIANBADYCACAHQQFqIQELQS0hAgxSCwJAA0AgAS0AAEHQxQBqLQAAQQFHDQEgBCABQQFqIgFHDQALQc0AIQIMawtBwgAhAgxRCyABIARGBEBBzAAhAgxqCyABLQAAQTpGBEAgAygCBCEAIANBADYCBCADIAAgARAwIgBFDTMgA0HLADYCHCADIAA2AgwgAyABQQFqNgIUQQAhAgxqCyADQQA2AhwgAyABNgIUIANB5xE2AhAgA0EKNgIMQQAhAgxpCwJAAkAgAy0ALEECaw4CAAEnCyADQTNqLQAAQQJxRQ0mIAMtAC5BAnENJiADQQA2AhwgAyABNgIUIANBphQ2AhAgA0ELNgIMQQAhAgxpCyADLQAyQSBxRQ0lIAMtAC5BAnENJSADQQA2AhwgAyABNgIUIANBvRM2AhAgA0EPNgIMQQAhAgxoC0EAIQACQCADKAI4IgJFDQAgAigCSCICRQ0AIAMgAhEAACEACyAARQRAQcEAIQIMTwsgAEEVRwRAIANBADYCHCADIAE2AhQgA0GmDzYCECADQRw2AgxBACECDGgLIANBygA2AhwgAyABNgIUIANBhRw2AhAgA0EVNgIMQQAhAgxnCyABIARHBEAgASECA0AgBCACIgFrQRBOBEAgAUEQaiEC/Qz/////////////////////IAH9AAAAIg1BB/1sIA39DODg4ODg4ODg4ODg4ODg4OD9bv0MX19fX19fX19fX19fX19fX/0mIA39DAkJCQkJCQkJCQkJCQkJCQn9I/1Q/VL9ZEF/c2giAEEQRg0BIAAgAWohAQwYCyABIARGBEBBxAAhAgxpCyABLQAAQcDBAGotAABBAUcNFyAEIAFBAWoiAkcNAAtBxAAhAgxnC0HEACECDGYLIAEgBEcEQANAAkAgAS0AACIAQSByIAAgAEHBAGtB/wFxQRpJG0H/AXEiAEEJRg0AIABBIEYNAAJAAkACQAJAIABB4wBrDhMAAwMDAwMDAwEDAwMDAwMDAwMCAwsgAUEBaiEBQTYhAgxSCyABQQFqIQFBNyECDFELIAFBAWohAUE4IQIMUAsMFQsgBCABQQFqIgFHDQALQTwhAgxmC0E8IQIMZQsgASAERgRAQcgAIQIMZQsgA0ESNgIIIAMgATYCBAJAAkACQAJAAkAgAy0ALEEBaw4EFAABAgkLIAMtADJBIHENA0HgASECDE8LAkAgAy8BMiIAQQhxRQ0AIAMtAChBAUcNACADLQAuQQhxRQ0CCyADIABB9/sDcUGABHI7ATIMCwsgAyADLwEyQRByOwEyDAQLIANBADYCBCADIAEgARAxIgAEQCADQcEANgIcIAMgADYCDCADIAFBAWo2AhRBACECDGYLIAFBAWohAQxYCyADQQA2AhwgAyABNgIUIANB9BM2AhAgA0EENgIMQQAhAgxkC0HHACECIAEgBEYNYyADKAIAIgAgBCABa2ohBSABIABrQQZqIQYCQANAIABBwMUAai0AACABLQAAQSByRw0BIABBBkYNSiAAQQFqIQAgBCABQQFqIgFHDQALIAMgBTYCAAxkCyADQQA2AgAMBQsCQCABIARHBEADQCABLQAAQcDDAGotAAAiAEEBRwRAIABBAkcNAyABQQFqIQEMBQsgBCABQQFqIgFHDQALQcUAIQIMZAtBxQAhAgxjCwsgA0EAOgAsDAELQQshAgxHC0E/IQIMRgsCQAJAA0AgAS0AACIAQSBHBEACQCAAQQprDgQDBQUDAAsgAEEsRg0DDAQLIAQgAUEBaiIBRw0AC0HGACECDGALIANBCDoALAwOCyADLQAoQQFHDQIgAy0ALkEIcQ0CIAMoAgQhACADQQA2AgQgAyAAIAEQMSIABEAgA0HCADYCHCADIAA2AgwgAyABQQFqNgIUQQAhAgxfCyABQQFqIQEMUAtBOyECDEQLAkADQCABLQAAIgBBIEcgAEEJR3ENASAEIAFBAWoiAUcNAAtBwwAhAgxdCwtBPCECDEILAkACQCABIARHBEADQCABLQAAIgBBIEcEQCAAQQprDgQDBAQDBAsgBCABQQFqIgFHDQALQT8hAgxdC0E/IQIMXAsgAyADLwEyQSByOwEyDAoLIAMoAgQhACADQQA2AgQgAyAAIAEQMSIARQ1OIANBPjYCHCADIAE2AhQgAyAANgIMQQAhAgxaCwJAIAEgBEcEQANAIAEtAABBwMMAai0AACIAQQFHBEAgAEECRg0DDAwLIAQgAUEBaiIBRw0AC0E3IQIMWwtBNyECDFoLIAFBAWohAQwEC0E7IQIgBCABIgBGDVggBCABayADKAIAIgFqIQYgACABa0EFaiEHAkADQCABQZDIAGotAAAgAC0AACIFQSByIAUgBUHBAGtB/wFxQRpJG0H/AXFHDQEgAUEFRgRAQQchAQw/CyABQQFqIQEgBCAAQQFqIgBHDQALIAMgBjYCAAxZCyADQQA2AgAgACEBDAULQTohAiAEIAEiAEYNVyAEIAFrIAMoAgAiAWohBiAAIAFrQQhqIQcCQANAIAFBtMEAai0AACAALQAAIgVBIHIgBSAFQcEAa0H/AXFBGkkbQf8BcUcNASABQQhGBEBBBSEBDD4LIAFBAWohASAEIABBAWoiAEcNAAsgAyAGNgIADFgLIANBADYCACAAIQEMBAtBOSECIAQgASIARg1WIAQgAWsgAygCACIBaiEGIAAgAWtBA2ohBwJAA0AgAUGwwQBqLQAAIAAtAAAiBUEgciAFIAVBwQBrQf8BcUEaSRtB/wFxRw0BIAFBA0YEQEEGIQEMPQsgAUEBaiEBIAQgAEEBaiIARw0ACyADIAY2AgAMVwsgA0EANgIAIAAhAQwDCwJAA0AgAS0AACIAQSBHBEAgAEEKaw4EBwQEBwILIAQgAUEBaiIBRw0AC0E4IQIMVgsgAEEsRw0BIAFBAWohAEEBIQECQAJAAkACQAJAIAMtACxBBWsOBAMBAgQACyAAIQEMBAtBAiEBDAELQQQhAQsgA0EBOgAsIAMgAy8BMiABcjsBMiAAIQEMAQsgAyADLwEyQQhyOwEyIAAhAQtBPiECDDsLIANBADoALAtBOSECDDkLIAEgBEYEQEE2IQIMUgsCQAJAAkACQAJAIAEtAABBCmsOBAACAgECCyADKAIEIQAgA0EANgIEIAMgACABEDEiAEUNAiADQTM2AhwgAyABNgIUIAMgADYCDEEAIQIMVQsgAygCBCEAIANBADYCBCADIAAgARAxIgBFBEAgAUEBaiEBDAYLIANBMjYCHCADIAA2AgwgAyABQQFqNgIUQQAhAgxUCyADLQAuQQFxBEBB3wEhAgw7CyADKAIEIQAgA0EANgIEIAMgACABEDEiAA0BDEkLQTQhAgw5CyADQTU2AhwgAyABNgIUIAMgADYCDEEAIQIMUQtBNSECDDcLIANBL2otAABBAXENACADQQA2AhwgAyABNgIUIANB6xY2AhAgA0EZNgIMQQAhAgxPC0EzIQIMNQsgASAERgRAQTIhAgxOCwJAIAEtAABBCkYEQCABQQFqIQEMAQsgA0EANgIcIAMgATYCFCADQZIXNgIQIANBAzYCDEEAIQIMTgtBMiECDDQLIAEgBEYEQEExIQIMTQsCQCABLQAAIgBBCUYNACAAQSBGDQBBASECAkAgAy0ALEEFaw4EBgQFAA0LIAMgAy8BMkEIcjsBMgwMCyADLQAuQQFxRQ0BIAMtACxBCEcNACADQQA6ACwLQT0hAgwyCyADQQA2AhwgAyABNgIUIANBwhY2AhAgA0EKNgIMQQAhAgxKC0ECIQIMAQtBBCECCyADQQE6ACwgAyADLwEyIAJyOwEyDAYLIAEgBEYEQEEwIQIMRwsgAS0AAEEKRgRAIAFBAWohAQwBCyADLQAuQQFxDQAgA0EANgIcIAMgATYCFCADQdwoNgIQIANBAjYCDEEAIQIMRgtBMCECDCwLIAFBAWohAUExIQIMKwsgASAERgRAQS8hAgxECyABLQAAIgBBCUcgAEEgR3FFBEAgAUEBaiEBIAMtAC5BAXENASADQQA2AhwgAyABNgIUIANBlxA2AhAgA0EKNgIMQQAhAgxEC0EBIQICQAJAAkACQAJAAkAgAy0ALEECaw4HBQQEAwECAAQLIAMgAy8BMkEIcjsBMgwDC0ECIQIMAQtBBCECCyADQQE6ACwgAyADLwEyIAJyOwEyC0EvIQIMKwsgA0EANgIcIAMgATYCFCADQYQTNgIQIANBCzYCDEEAIQIMQwtB4QEhAgwpCyABIARGBEBBLiECDEILIANBADYCBCADQRI2AgggAyABIAEQMSIADQELQS4hAgwnCyADQS02AhwgAyABNgIUIAMgADYCDEEAIQIMPwtBACEAAkAgAygCOCICRQ0AIAIoAkwiAkUNACADIAIRAAAhAAsgAEUNACAAQRVHDQEgA0HYADYCHCADIAE2AhQgA0GzGzYCECADQRU2AgxBACECDD4LQcwAIQIMJAsgA0EANgIcIAMgATYCFCADQbMONgIQIANBHTYCDEEAIQIMPAsgASAERgRAQc4AIQIMPAsgAS0AACIAQSBGDQIgAEE6Rg0BCyADQQA6ACxBCSECDCELIAMoAgQhACADQQA2AgQgAyAAIAEQMCIADQEMAgsgAy0ALkEBcQRAQd4BIQIMIAsgAygCBCEAIANBADYCBCADIAAgARAwIgBFDQIgA0EqNgIcIAMgADYCDCADIAFBAWo2AhRBACECDDgLIANBywA2AhwgAyAANgIMIAMgAUEBajYCFEEAIQIMNwsgAUEBaiEBQcAAIQIMHQsgAUEBaiEBDCwLIAEgBEYEQEErIQIMNQsCQCABLQAAQQpGBEAgAUEBaiEBDAELIAMtAC5BwABxRQ0GCyADLQAyQYABcQRAQQAhAAJAIAMoAjgiAkUNACACKAJcIgJFDQAgAyACEQAAIQALIABFDRIgAEEVRgRAIANBBTYCHCADIAE2AhQgA0GbGzYCECADQRU2AgxBACECDDYLIANBADYCHCADIAE2AhQgA0GQDjYCECADQRQ2AgxBACECDDULIANBMmohAiADEDVBACEAAkAgAygCOCIGRQ0AIAYoAigiBkUNACADIAYRAAAhAAsgAA4WAgEABAQEBAQEBAQEBAQEBAQEBAQEAwQLIANBAToAMAsgAiACLwEAQcAAcjsBAAtBKyECDBgLIANBKTYCHCADIAE2AhQgA0GsGTYCECADQRU2AgxBACECDDALIANBADYCHCADIAE2AhQgA0HlCzYCECADQRE2AgxBACECDC8LIANBADYCHCADIAE2AhQgA0GlCzYCECADQQI2AgxBACECDC4LQQEhByADLwEyIgVBCHFFBEAgAykDIEIAUiEHCwJAIAMtADAEQEEBIQAgAy0AKUEFRg0BIAVBwABxRSAHcUUNAQsCQCADLQAoIgJBAkYEQEEBIQAgAy8BNCIGQeUARg0CQQAhACAFQcAAcQ0CIAZB5ABGDQIgBkHmAGtBAkkNAiAGQcwBRg0CIAZBsAJGDQIMAQtBACEAIAVBwABxDQELQQIhACAFQQhxDQAgBUGABHEEQAJAIAJBAUcNACADLQAuQQpxDQBBBSEADAILQQQhAAwBCyAFQSBxRQRAIAMQNkEAR0ECdCEADAELQQBBAyADKQMgUBshAAsgAEEBaw4FAgAHAQMEC0ERIQIMEwsgA0EBOgAxDCkLQQAhAgJAIAMoAjgiAEUNACAAKAIwIgBFDQAgAyAAEQAAIQILIAJFDSYgAkEVRgRAIANBAzYCHCADIAE2AhQgA0HSGzYCECADQRU2AgxBACECDCsLQQAhAiADQQA2AhwgAyABNgIUIANB3Q42AhAgA0ESNgIMDCoLIANBADYCHCADIAE2AhQgA0H5IDYCECADQQ82AgxBACECDCkLQQAhAAJAIAMoAjgiAkUNACACKAIwIgJFDQAgAyACEQAAIQALIAANAQtBDiECDA4LIABBFUYEQCADQQI2AhwgAyABNgIUIANB0hs2AhAgA0EVNgIMQQAhAgwnCyADQQA2AhwgAyABNgIUIANB3Q42AhAgA0ESNgIMQQAhAgwmC0EqIQIMDAsgASAERwRAIANBCTYCCCADIAE2AgRBKSECDAwLQSYhAgwkCyADIAMpAyAiDCAEIAFrrSIKfSILQgAgCyAMWBs3AyAgCiAMVARAQSUhAgwkCyADKAIEIQAgA0EANgIEIAMgACABIAynaiIBEDIiAEUNACADQQU2AhwgAyABNgIUIAMgADYCDEEAIQIMIwtBDyECDAkLQgAhCgJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABLQAAQTBrDjcXFgABAgMEBQYHFBQUFBQUFAgJCgsMDRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUDg8QERITFAtCAiEKDBYLQgMhCgwVC0IEIQoMFAtCBSEKDBMLQgYhCgwSC0IHIQoMEQtCCCEKDBALQgkhCgwPC0IKIQoMDgtCCyEKDA0LQgwhCgwMC0INIQoMCwtCDiEKDAoLQg8hCgwJC0IKIQoMCAtCCyEKDAcLQgwhCgwGC0INIQoMBQtCDiEKDAQLQg8hCgwDCyADQQA2AhwgAyABNgIUIANBnxU2AhAgA0EMNgIMQQAhAgwhCyABIARGBEBBIiECDCELQgAhCgJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAS0AAEEwaw43FRQAAQIDBAUGBxYWFhYWFhYICQoLDA0WFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFg4PEBESExYLQgIhCgwUC0IDIQoMEwtCBCEKDBILQgUhCgwRC0IGIQoMEAtCByEKDA8LQgghCgwOC0IJIQoMDQtCCiEKDAwLQgshCgwLC0IMIQoMCgtCDSEKDAkLQg4hCgwIC0IPIQoMBwtCCiEKDAYLQgshCgwFC0IMIQoMBAtCDSEKDAMLQg4hCgwCC0IPIQoMAQtCASEKCyABQQFqIQEgAykDICILQv//////////D1gEQCADIAtCBIYgCoQ3AyAMAgsgA0EANgIcIAMgATYCFCADQbUJNgIQIANBDDYCDEEAIQIMHgtBJyECDAQLQSghAgwDCyADIAE6ACwgA0EANgIAIAdBAWohAUEMIQIMAgsgA0EANgIAIAZBAWohAUEKIQIMAQsgAUEBaiEBQQghAgwACwALQQAhAiADQQA2AhwgAyABNgIUIANBsjg2AhAgA0EINgIMDBcLQQAhAiADQQA2AhwgAyABNgIUIANBgxE2AhAgA0EJNgIMDBYLQQAhAiADQQA2AhwgAyABNgIUIANB3wo2AhAgA0EJNgIMDBULQQAhAiADQQA2AhwgAyABNgIUIANB7RA2AhAgA0EJNgIMDBQLQQAhAiADQQA2AhwgAyABNgIUIANB0hE2AhAgA0EJNgIMDBMLQQAhAiADQQA2AhwgAyABNgIUIANBsjg2AhAgA0EINgIMDBILQQAhAiADQQA2AhwgAyABNgIUIANBgxE2AhAgA0EJNgIMDBELQQAhAiADQQA2AhwgAyABNgIUIANB3wo2AhAgA0EJNgIMDBALQQAhAiADQQA2AhwgAyABNgIUIANB7RA2AhAgA0EJNgIMDA8LQQAhAiADQQA2AhwgAyABNgIUIANB0hE2AhAgA0EJNgIMDA4LQQAhAiADQQA2AhwgAyABNgIUIANBuRc2AhAgA0EPNgIMDA0LQQAhAiADQQA2AhwgAyABNgIUIANBuRc2AhAgA0EPNgIMDAwLQQAhAiADQQA2AhwgAyABNgIUIANBmRM2AhAgA0ELNgIMDAsLQQAhAiADQQA2AhwgAyABNgIUIANBnQk2AhAgA0ELNgIMDAoLQQAhAiADQQA2AhwgAyABNgIUIANBlxA2AhAgA0EKNgIMDAkLQQAhAiADQQA2AhwgAyABNgIUIANBsRA2AhAgA0EKNgIMDAgLQQAhAiADQQA2AhwgAyABNgIUIANBux02AhAgA0ECNgIMDAcLQQAhAiADQQA2AhwgAyABNgIUIANBlhY2AhAgA0ECNgIMDAYLQQAhAiADQQA2AhwgAyABNgIUIANB+Rg2AhAgA0ECNgIMDAULQQAhAiADQQA2AhwgAyABNgIUIANBxBg2AhAgA0ECNgIMDAQLIANBAjYCHCADIAE2AhQgA0GpHjYCECADQRY2AgxBACECDAMLQd4AIQIgASAERg0CIAlBCGohByADKAIAIQUCQAJAIAEgBEcEQCAFQZbIAGohCCAEIAVqIAFrIQYgBUF/c0EKaiIFIAFqIQADQCABLQAAIAgtAABHBEBBAiEIDAMLIAVFBEBBACEIIAAhAQwDCyAFQQFrIQUgCEEBaiEIIAQgAUEBaiIBRw0ACyAGIQUgBCEBCyAHQQE2AgAgAyAFNgIADAELIANBADYCACAHIAg2AgALIAcgATYCBCAJKAIMIQACQAJAIAkoAghBAWsOAgQBAAsgA0EANgIcIANBwh42AhAgA0EXNgIMIAMgAEEBajYCFEEAIQIMAwsgA0EANgIcIAMgADYCFCADQdceNgIQIANBCTYCDEEAIQIMAgsgASAERgRAQSghAgwCCyADQQk2AgggAyABNgIEQSchAgwBCyABIARGBEBBASECDAELA0ACQAJAAkAgAS0AAEEKaw4EAAEBAAELIAFBAWohAQwBCyABQQFqIQEgAy0ALkEgcQ0AQQAhAiADQQA2AhwgAyABNgIUIANBoSE2AhAgA0EFNgIMDAILQQEhAiABIARHDQALCyAJQRBqJAAgAkUEQCADKAIMIQAMAQsgAyACNgIcQQAhACADKAIEIgFFDQAgAyABIAQgAygCCBEBACIBRQ0AIAMgBDYCFCADIAE2AgwgASEACyAAC74CAQJ/IABBADoAACAAQeQAaiIBQQFrQQA6AAAgAEEAOgACIABBADoAASABQQNrQQA6AAAgAUECa0EAOgAAIABBADoAAyABQQRrQQA6AABBACAAa0EDcSIBIABqIgBBADYCAEHkACABa0F8cSICIABqIgFBBGtBADYCAAJAIAJBCUkNACAAQQA2AgggAEEANgIEIAFBCGtBADYCACABQQxrQQA2AgAgAkEZSQ0AIABBADYCGCAAQQA2AhQgAEEANgIQIABBADYCDCABQRBrQQA2AgAgAUEUa0EANgIAIAFBGGtBADYCACABQRxrQQA2AgAgAiAAQQRxQRhyIgJrIgFBIEkNACAAIAJqIQADQCAAQgA3AxggAEIANwMQIABCADcDCCAAQgA3AwAgAEEgaiEAIAFBIGsiAUEfSw0ACwsLVgEBfwJAIAAoAgwNAAJAAkACQAJAIAAtADEOAwEAAwILIAAoAjgiAUUNACABKAIwIgFFDQAgACABEQAAIgENAwtBAA8LAAsgAEHKGTYCEEEOIQELIAELGgAgACgCDEUEQCAAQd4fNgIQIABBFTYCDAsLFAAgACgCDEEVRgRAIABBADYCDAsLFAAgACgCDEEWRgRAIABBADYCDAsLBwAgACgCDAsHACAAKAIQCwkAIAAgATYCEAsHACAAKAIUCysAAkAgAEEnTw0AQv//////CSAArYhCAYNQDQAgAEECdEHQOGooAgAPCwALFwAgAEEvTwRAAAsgAEECdEHsOWooAgALvwkBAX9B9C0hAQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB5ABrDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0HqLA8LQZgmDwtB7TEPC0GgNw8LQckpDwtBtCkPC0GWLQ8LQesrDwtBojUPC0HbNA8LQeApDwtB4yQPC0HVJA8LQe4kDwtB5iUPC0HKNA8LQdA3DwtBqjUPC0H1LA8LQfYmDwtBgiIPC0HyMw8LQb4oDwtB5zcPC0HNIQ8LQcAhDwtBuCUPC0HLJQ8LQZYkDwtBjzQPC0HNNQ8LQd0qDwtB7jMPC0GcNA8LQZ4xDwtB9DUPC0HlIg8LQa8lDwtBmTEPC0GyNg8LQfk2DwtBxDIPC0HdLA8LQYIxDwtBwTEPC0GNNw8LQckkDwtB7DYPC0HnKg8LQcgjDwtB4iEPC0HJNw8LQaUiDwtBlCIPC0HbNg8LQd41DwtBhiYPC0G8Kw8LQYsyDwtBoCMPC0H2MA8LQYAsDwtBiSsPC0GkJg8LQfIjDwtBgSgPC0GrMg8LQesnDwtBwjYPC0GiJA8LQc8qDwtB3CMPC0GHJw8LQeQ0DwtBtyIPC0GtMQ8LQdUiDwtBrzQPC0HeJg8LQdYyDwtB9DQPC0GBOA8LQfQ3DwtBkjYPC0GdJw8LQYIpDwtBjSMPC0HXMQ8LQb01DwtBtDcPC0HYMA8LQbYnDwtBmjgPC0GnKg8LQcQnDwtBriMPC0H1Ig8LAAtByiYhAQsgAQsXACAAIAAvAS5B/v8DcSABQQBHcjsBLgsaACAAIAAvAS5B/f8DcSABQQBHQQF0cjsBLgsaACAAIAAvAS5B+/8DcSABQQBHQQJ0cjsBLgsaACAAIAAvAS5B9/8DcSABQQBHQQN0cjsBLgsaACAAIAAvAS5B7/8DcSABQQBHQQR0cjsBLgsaACAAIAAvAS5B3/8DcSABQQBHQQV0cjsBLgsaACAAIAAvAS5Bv/8DcSABQQBHQQZ0cjsBLgsaACAAIAAvAS5B//4DcSABQQBHQQd0cjsBLgsaACAAIAAvAS5B//0DcSABQQBHQQh0cjsBLgsaACAAIAAvAS5B//sDcSABQQBHQQl0cjsBLgs+AQJ/AkAgACgCOCIDRQ0AIAMoAgQiA0UNACAAIAEgAiABayADEQEAIgRBf0cNACAAQeESNgIQQRghBAsgBAs+AQJ/AkAgACgCOCIDRQ0AIAMoAggiA0UNACAAIAEgAiABayADEQEAIgRBf0cNACAAQfwRNgIQQRghBAsgBAs+AQJ/AkAgACgCOCIDRQ0AIAMoAgwiA0UNACAAIAEgAiABayADEQEAIgRBf0cNACAAQewKNgIQQRghBAsgBAs+AQJ/AkAgACgCOCIDRQ0AIAMoAhAiA0UNACAAIAEgAiABayADEQEAIgRBf0cNACAAQfoeNgIQQRghBAsgBAs+AQJ/AkAgACgCOCIDRQ0AIAMoAhQiA0UNACAAIAEgAiABayADEQEAIgRBf0cNACAAQcsQNgIQQRghBAsgBAs+AQJ/AkAgACgCOCIDRQ0AIAMoAhgiA0UNACAAIAEgAiABayADEQEAIgRBf0cNACAAQbcfNgIQQRghBAsgBAs+AQJ/AkAgACgCOCIDRQ0AIAMoAhwiA0UNACAAIAEgAiABayADEQEAIgRBf0cNACAAQb8VNgIQQRghBAsgBAs+AQJ/AkAgACgCOCIDRQ0AIAMoAiwiA0UNACAAIAEgAiABayADEQEAIgRBf0cNACAAQf4INgIQQRghBAsgBAs+AQJ/AkAgACgCOCIDRQ0AIAMoAiAiA0UNACAAIAEgAiABayADEQEAIgRBf0cNACAAQYwdNgIQQRghBAsgBAs+AQJ/AkAgACgCOCIDRQ0AIAMoAiQiA0UNACAAIAEgAiABayADEQEAIgRBf0cNACAAQeYVNgIQQRghBAsgBAs4ACAAAn8gAC8BMkEUcUEURgRAQQEgAC0AKEEBRg0BGiAALwE0QeUARgwBCyAALQApQQVGCzoAMAtZAQJ/AkAgAC0AKEEBRg0AIAAvATQiAUHkAGtB5ABJDQAgAUHMAUYNACABQbACRg0AIAAvATIiAEHAAHENAEEBIQIgAEGIBHFBgARGDQAgAEEocUUhAgsgAguMAQECfwJAAkACQCAALQAqRQ0AIAAtACtFDQAgAC8BMiIBQQJxRQ0BDAILIAAvATIiAUEBcUUNAQtBASECIAAtAChBAUYNACAALwE0IgBB5ABrQeQASQ0AIABBzAFGDQAgAEGwAkYNACABQcAAcQ0AQQAhAiABQYgEcUGABEYNACABQShxQQBHIQILIAILcwAgAEEQav0MAAAAAAAAAAAAAAAAAAAAAP0LAwAgAP0MAAAAAAAAAAAAAAAAAAAAAP0LAwAgAEEwav0MAAAAAAAAAAAAAAAAAAAAAP0LAwAgAEEgav0MAAAAAAAAAAAAAAAAAAAAAP0LAwAgAEH9ATYCHAsGACAAEDoLmi0BC38jAEEQayIKJABB3NUAKAIAIglFBEBBnNkAKAIAIgVFBEBBqNkAQn83AgBBoNkAQoCAhICAgMAANwIAQZzZACAKQQhqQXBxQdiq1aoFcyIFNgIAQbDZAEEANgIAQYDZAEEANgIAC0GE2QBBwNkENgIAQdTVAEHA2QQ2AgBB6NUAIAU2AgBB5NUAQX82AgBBiNkAQcCmAzYCAANAIAFBgNYAaiABQfTVAGoiAjYCACACIAFB7NUAaiIDNgIAIAFB+NUAaiADNgIAIAFBiNYAaiABQfzVAGoiAzYCACADIAI2AgAgAUGQ1gBqIAFBhNYAaiICNgIAIAIgAzYCACABQYzWAGogAjYCACABQSBqIgFBgAJHDQALQczZBEGBpgM2AgBB4NUAQazZACgCADYCAEHQ1QBBgKYDNgIAQdzVAEHI2QQ2AgBBzP8HQTg2AgBByNkEIQkLAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAEHsAU0EQEHE1QAoAgAiBkEQIABBE2pBcHEgAEELSRsiBEEDdiIAdiIBQQNxBEACQCABQQFxIAByQQFzIgJBA3QiAEHs1QBqIgEgAEH01QBqKAIAIgAoAggiA0YEQEHE1QAgBkF+IAJ3cTYCAAwBCyABIAM2AgggAyABNgIMCyAAQQhqIQEgACACQQN0IgJBA3I2AgQgACACaiIAIAAoAgRBAXI2AgQMEQtBzNUAKAIAIgggBE8NASABBEACQEECIAB0IgJBACACa3IgASAAdHFoIgBBA3QiAkHs1QBqIgEgAkH01QBqKAIAIgIoAggiA0YEQEHE1QAgBkF+IAB3cSIGNgIADAELIAEgAzYCCCADIAE2AgwLIAIgBEEDcjYCBCAAQQN0IgAgBGshBSAAIAJqIAU2AgAgAiAEaiIEIAVBAXI2AgQgCARAIAhBeHFB7NUAaiEAQdjVACgCACEDAn9BASAIQQN2dCIBIAZxRQRAQcTVACABIAZyNgIAIAAMAQsgACgCCAsiASADNgIMIAAgAzYCCCADIAA2AgwgAyABNgIICyACQQhqIQFB2NUAIAQ2AgBBzNUAIAU2AgAMEQtByNUAKAIAIgtFDQEgC2hBAnRB9NcAaigCACIAKAIEQXhxIARrIQUgACECA0ACQCACKAIQIgFFBEAgAkEUaigCACIBRQ0BCyABKAIEQXhxIARrIgMgBUkhAiADIAUgAhshBSABIAAgAhshACABIQIMAQsLIAAoAhghCSAAKAIMIgMgAEcEQEHU1QAoAgAaIAMgACgCCCIBNgIIIAEgAzYCDAwQCyAAQRRqIgIoAgAiAUUEQCAAKAIQIgFFDQMgAEEQaiECCwNAIAIhByABIgNBFGoiAigCACIBDQAgA0EQaiECIAMoAhAiAQ0ACyAHQQA2AgAMDwtBfyEEIABBv39LDQAgAEETaiIBQXBxIQRByNUAKAIAIghFDQBBACAEayEFAkACQAJAAn9BACAEQYACSQ0AGkEfIARB////B0sNABogBEEmIAFBCHZnIgBrdkEBcSAAQQF0a0E+agsiBkECdEH01wBqKAIAIgJFBEBBACEBQQAhAwwBC0EAIQEgBEEZIAZBAXZrQQAgBkEfRxt0IQBBACEDA0ACQCACKAIEQXhxIARrIgcgBU8NACACIQMgByIFDQBBACEFIAIhAQwDCyABIAJBFGooAgAiByAHIAIgAEEddkEEcWpBEGooAgAiAkYbIAEgBxshASAAQQF0IQAgAg0ACwsgASADckUEQEEAIQNBAiAGdCIAQQAgAGtyIAhxIgBFDQMgAGhBAnRB9NcAaigCACEBCyABRQ0BCwNAIAEoAgRBeHEgBGsiAiAFSSEAIAIgBSAAGyEFIAEgAyAAGyEDIAEoAhAiAAR/IAAFIAFBFGooAgALIgENAAsLIANFDQAgBUHM1QAoAgAgBGtPDQAgAygCGCEHIAMgAygCDCIARwRAQdTVACgCABogACADKAIIIgE2AgggASAANgIMDA4LIANBFGoiAigCACIBRQRAIAMoAhAiAUUNAyADQRBqIQILA0AgAiEGIAEiAEEUaiICKAIAIgENACAAQRBqIQIgACgCECIBDQALIAZBADYCAAwNC0HM1QAoAgAiAyAETwRAQdjVACgCACEBAkAgAyAEayICQRBPBEAgASAEaiIAIAJBAXI2AgQgASADaiACNgIAIAEgBEEDcjYCBAwBCyABIANBA3I2AgQgASADaiIAIAAoAgRBAXI2AgRBACEAQQAhAgtBzNUAIAI2AgBB2NUAIAA2AgAgAUEIaiEBDA8LQdDVACgCACIDIARLBEAgBCAJaiIAIAMgBGsiAUEBcjYCBEHc1QAgADYCAEHQ1QAgATYCACAJIARBA3I2AgQgCUEIaiEBDA8LQQAhASAEAn9BnNkAKAIABEBBpNkAKAIADAELQajZAEJ/NwIAQaDZAEKAgISAgIDAADcCAEGc2QAgCkEMakFwcUHYqtWqBXM2AgBBsNkAQQA2AgBBgNkAQQA2AgBBgIAECyIAIARBxwBqIgVqIgZBACAAayIHcSICTwRAQbTZAEEwNgIADA8LAkBB/NgAKAIAIgFFDQBB9NgAKAIAIgggAmohACAAIAFNIAAgCEtxDQBBACEBQbTZAEEwNgIADA8LQYDZAC0AAEEEcQ0EAkACQCAJBEBBhNkAIQEDQCABKAIAIgAgCU0EQCAAIAEoAgRqIAlLDQMLIAEoAggiAQ0ACwtBABA7IgBBf0YNBSACIQZBoNkAKAIAIgFBAWsiAyAAcQRAIAIgAGsgACADakEAIAFrcWohBgsgBCAGTw0FIAZB/v///wdLDQVB/NgAKAIAIgMEQEH02AAoAgAiByAGaiEBIAEgB00NBiABIANLDQYLIAYQOyIBIABHDQEMBwsgBiADayAHcSIGQf7///8HSw0EIAYQOyEAIAAgASgCACABKAIEakYNAyAAIQELAkAgBiAEQcgAak8NACABQX9GDQBBpNkAKAIAIgAgBSAGa2pBACAAa3EiAEH+////B0sEQCABIQAMBwsgABA7QX9HBEAgACAGaiEGIAEhAAwHC0EAIAZrEDsaDAQLIAEiAEF/Rw0FDAMLQQAhAwwMC0EAIQAMCgsgAEF/Rw0CC0GA2QBBgNkAKAIAQQRyNgIACyACQf7///8HSw0BIAIQOyEAQQAQOyEBIABBf0YNASABQX9GDQEgACABTw0BIAEgAGsiBiAEQThqTQ0BC0H02ABB9NgAKAIAIAZqIgE2AgBB+NgAKAIAIAFJBEBB+NgAIAE2AgALAkACQAJAQdzVACgCACICBEBBhNkAIQEDQCAAIAEoAgAiAyABKAIEIgVqRg0CIAEoAggiAQ0ACwwCC0HU1QAoAgAiAUEARyAAIAFPcUUEQEHU1QAgADYCAAtBACEBQYjZACAGNgIAQYTZACAANgIAQeTVAEF/NgIAQejVAEGc2QAoAgA2AgBBkNkAQQA2AgADQCABQYDWAGogAUH01QBqIgI2AgAgAiABQezVAGoiAzYCACABQfjVAGogAzYCACABQYjWAGogAUH81QBqIgM2AgAgAyACNgIAIAFBkNYAaiABQYTWAGoiAjYCACACIAM2AgAgAUGM1gBqIAI2AgAgAUEgaiIBQYACRw0AC0F4IABrQQ9xIgEgAGoiAiAGQThrIgMgAWsiAUEBcjYCBEHg1QBBrNkAKAIANgIAQdDVACABNgIAQdzVACACNgIAIAAgA2pBODYCBAwCCyAAIAJNDQAgAiADSQ0AIAEoAgxBCHENAEF4IAJrQQ9xIgAgAmoiA0HQ1QAoAgAgBmoiByAAayIAQQFyNgIEIAEgBSAGajYCBEHg1QBBrNkAKAIANgIAQdDVACAANgIAQdzVACADNgIAIAIgB2pBODYCBAwBCyAAQdTVACgCAEkEQEHU1QAgADYCAAsgACAGaiEDQYTZACEBAkACQAJAA0AgAyABKAIARwRAIAEoAggiAQ0BDAILCyABLQAMQQhxRQ0BC0GE2QAhAQNAIAEoAgAiAyACTQRAIAMgASgCBGoiBSACSw0DCyABKAIIIQEMAAsACyABIAA2AgAgASABKAIEIAZqNgIEIABBeCAAa0EPcWoiCSAEQQNyNgIEIANBeCADa0EPcWoiBiAEIAlqIgRrIQEgAiAGRgRAQdzVACAENgIAQdDVAEHQ1QAoAgAgAWoiADYCACAEIABBAXI2AgQMCAtB2NUAKAIAIAZGBEBB2NUAIAQ2AgBBzNUAQczVACgCACABaiIANgIAIAQgAEEBcjYCBCAAIARqIAA2AgAMCAsgBigCBCIFQQNxQQFHDQYgBUF4cSEIIAVB/wFNBEAgBUEDdiEDIAYoAggiACAGKAIMIgJGBEBBxNUAQcTVACgCAEF+IAN3cTYCAAwHCyACIAA2AgggACACNgIMDAYLIAYoAhghByAGIAYoAgwiAEcEQCAAIAYoAggiAjYCCCACIAA2AgwMBQsgBkEUaiICKAIAIgVFBEAgBigCECIFRQ0EIAZBEGohAgsDQCACIQMgBSIAQRRqIgIoAgAiBQ0AIABBEGohAiAAKAIQIgUNAAsgA0EANgIADAQLQXggAGtBD3EiASAAaiIHIAZBOGsiAyABayIBQQFyNgIEIAAgA2pBODYCBCACIAVBNyAFa0EPcWpBP2siAyADIAJBEGpJGyIDQSM2AgRB4NUAQazZACgCADYCAEHQ1QAgATYCAEHc1QAgBzYCACADQRBqQYzZACkCADcCACADQYTZACkCADcCCEGM2QAgA0EIajYCAEGI2QAgBjYCAEGE2QAgADYCAEGQ2QBBADYCACADQSRqIQEDQCABQQc2AgAgBSABQQRqIgFLDQALIAIgA0YNACADIAMoAgRBfnE2AgQgAyADIAJrIgU2AgAgAiAFQQFyNgIEIAVB/wFNBEAgBUF4cUHs1QBqIQACf0HE1QAoAgAiAUEBIAVBA3Z0IgNxRQRAQcTVACABIANyNgIAIAAMAQsgACgCCAsiASACNgIMIAAgAjYCCCACIAA2AgwgAiABNgIIDAELQR8hASAFQf///wdNBEAgBUEmIAVBCHZnIgBrdkEBcSAAQQF0a0E+aiEBCyACIAE2AhwgAkIANwIQIAFBAnRB9NcAaiEAQcjVACgCACIDQQEgAXQiBnFFBEAgACACNgIAQcjVACADIAZyNgIAIAIgADYCGCACIAI2AgggAiACNgIMDAELIAVBGSABQQF2a0EAIAFBH0cbdCEBIAAoAgAhAwJAA0AgAyIAKAIEQXhxIAVGDQEgAUEddiEDIAFBAXQhASAAIANBBHFqQRBqIgYoAgAiAw0ACyAGIAI2AgAgAiAANgIYIAIgAjYCDCACIAI2AggMAQsgACgCCCIBIAI2AgwgACACNgIIIAJBADYCGCACIAA2AgwgAiABNgIIC0HQ1QAoAgAiASAETQ0AQdzVACgCACIAIARqIgIgASAEayIBQQFyNgIEQdDVACABNgIAQdzVACACNgIAIAAgBEEDcjYCBCAAQQhqIQEMCAtBACEBQbTZAEEwNgIADAcLQQAhAAsgB0UNAAJAIAYoAhwiAkECdEH01wBqIgMoAgAgBkYEQCADIAA2AgAgAA0BQcjVAEHI1QAoAgBBfiACd3E2AgAMAgsgB0EQQRQgBygCECAGRhtqIAA2AgAgAEUNAQsgACAHNgIYIAYoAhAiAgRAIAAgAjYCECACIAA2AhgLIAZBFGooAgAiAkUNACAAQRRqIAI2AgAgAiAANgIYCyABIAhqIQEgBiAIaiIGKAIEIQULIAYgBUF+cTYCBCABIARqIAE2AgAgBCABQQFyNgIEIAFB/wFNBEAgAUF4cUHs1QBqIQACf0HE1QAoAgAiAkEBIAFBA3Z0IgFxRQRAQcTVACABIAJyNgIAIAAMAQsgACgCCAsiASAENgIMIAAgBDYCCCAEIAA2AgwgBCABNgIIDAELQR8hBSABQf///wdNBEAgAUEmIAFBCHZnIgBrdkEBcSAAQQF0a0E+aiEFCyAEIAU2AhwgBEIANwIQIAVBAnRB9NcAaiEAQcjVACgCACICQQEgBXQiA3FFBEAgACAENgIAQcjVACACIANyNgIAIAQgADYCGCAEIAQ2AgggBCAENgIMDAELIAFBGSAFQQF2a0EAIAVBH0cbdCEFIAAoAgAhAAJAA0AgACICKAIEQXhxIAFGDQEgBUEddiEAIAVBAXQhBSACIABBBHFqQRBqIgMoAgAiAA0ACyADIAQ2AgAgBCACNgIYIAQgBDYCDCAEIAQ2AggMAQsgAigCCCIAIAQ2AgwgAiAENgIIIARBADYCGCAEIAI2AgwgBCAANgIICyAJQQhqIQEMAgsCQCAHRQ0AAkAgAygCHCIBQQJ0QfTXAGoiAigCACADRgRAIAIgADYCACAADQFByNUAIAhBfiABd3EiCDYCAAwCCyAHQRBBFCAHKAIQIANGG2ogADYCACAARQ0BCyAAIAc2AhggAygCECIBBEAgACABNgIQIAEgADYCGAsgA0EUaigCACIBRQ0AIABBFGogATYCACABIAA2AhgLAkAgBUEPTQRAIAMgBCAFaiIAQQNyNgIEIAAgA2oiACAAKAIEQQFyNgIEDAELIAMgBGoiAiAFQQFyNgIEIAMgBEEDcjYCBCACIAVqIAU2AgAgBUH/AU0EQCAFQXhxQezVAGohAAJ/QcTVACgCACIBQQEgBUEDdnQiBXFFBEBBxNUAIAEgBXI2AgAgAAwBCyAAKAIICyIBIAI2AgwgACACNgIIIAIgADYCDCACIAE2AggMAQtBHyEBIAVB////B00EQCAFQSYgBUEIdmciAGt2QQFxIABBAXRrQT5qIQELIAIgATYCHCACQgA3AhAgAUECdEH01wBqIQBBASABdCIEIAhxRQRAIAAgAjYCAEHI1QAgBCAIcjYCACACIAA2AhggAiACNgIIIAIgAjYCDAwBCyAFQRkgAUEBdmtBACABQR9HG3QhASAAKAIAIQQCQANAIAQiACgCBEF4cSAFRg0BIAFBHXYhBCABQQF0IQEgACAEQQRxakEQaiIGKAIAIgQNAAsgBiACNgIAIAIgADYCGCACIAI2AgwgAiACNgIIDAELIAAoAggiASACNgIMIAAgAjYCCCACQQA2AhggAiAANgIMIAIgATYCCAsgA0EIaiEBDAELAkAgCUUNAAJAIAAoAhwiAUECdEH01wBqIgIoAgAgAEYEQCACIAM2AgAgAw0BQcjVACALQX4gAXdxNgIADAILIAlBEEEUIAkoAhAgAEYbaiADNgIAIANFDQELIAMgCTYCGCAAKAIQIgEEQCADIAE2AhAgASADNgIYCyAAQRRqKAIAIgFFDQAgA0EUaiABNgIAIAEgAzYCGAsCQCAFQQ9NBEAgACAEIAVqIgFBA3I2AgQgACABaiIBIAEoAgRBAXI2AgQMAQsgACAEaiIHIAVBAXI2AgQgACAEQQNyNgIEIAUgB2ogBTYCACAIBEAgCEF4cUHs1QBqIQFB2NUAKAIAIQMCf0EBIAhBA3Z0IgIgBnFFBEBBxNUAIAIgBnI2AgAgAQwBCyABKAIICyICIAM2AgwgASADNgIIIAMgATYCDCADIAI2AggLQdjVACAHNgIAQczVACAFNgIACyAAQQhqIQELIApBEGokACABC0MAIABFBEA/AEEQdA8LAkAgAEH//wNxDQAgAEEASA0AIABBEHZAACIAQX9GBEBBtNkAQTA2AgBBfw8LIABBEHQPCwALC5lCIgBBgAgLDQEAAAAAAAAAAgAAAAMAQZgICwUEAAAABQBBqAgLCQYAAAAHAAAACABB5AgLwjJJbnZhbGlkIGNoYXIgaW4gdXJsIHF1ZXJ5AFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fYm9keQBDb250ZW50LUxlbmd0aCBvdmVyZmxvdwBDaHVuayBzaXplIG92ZXJmbG93AEludmFsaWQgbWV0aG9kIGZvciBIVFRQL3gueCByZXF1ZXN0AEludmFsaWQgbWV0aG9kIGZvciBSVFNQL3gueCByZXF1ZXN0AEV4cGVjdGVkIFNPVVJDRSBtZXRob2QgZm9yIElDRS94LnggcmVxdWVzdABJbnZhbGlkIGNoYXIgaW4gdXJsIGZyYWdtZW50IHN0YXJ0AEV4cGVjdGVkIGRvdABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3N0YXR1cwBJbnZhbGlkIHJlc3BvbnNlIHN0YXR1cwBFeHBlY3RlZCBMRiBhZnRlciBoZWFkZXJzAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMAVXNlciBjYWxsYmFjayBlcnJvcgBgb25fcmVzZXRgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19oZWFkZXJgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3Byb3RvY29sX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fcHJvdG9jb2wARW1wdHkgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyYWN0ZXIgaW4gQ29udGVudC1MZW5ndGgAVHJhbnNmZXItRW5jb2RpbmcgY2FuJ3QgYmUgcHJlc2VudCB3aXRoIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgY2h1bmsgc2l6ZQBFeHBlY3RlZCBMRiBhZnRlciBjaHVuayBzaXplAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBVbmV4cGVjdGVkIHdoaXRlc3BhY2UgYWZ0ZXIgaGVhZGVyIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgaGVhZGVyIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgTEYgYWZ0ZXIgaGVhZGVyIHZhbHVlAEludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYCBoZWFkZXIgdmFsdWUATWlzc2luZyBleHBlY3RlZCBDUiBhZnRlciBjaHVuayBleHRlbnNpb24gdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZSB2YWx1ZQBJbnZhbGlkIHF1b3RlZC1wYWlyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fcHJvdG9jb2xfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUATWlzc2luZyBleHBlY3RlZCBDUiBhZnRlciByZXNwb25zZSBsaW5lAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBuYW1lAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgY2h1bmsgZXh0ZW5zaW9uIG5hbWUASW52YWxpZCBzdGF0dXMgY29kZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABNaXNzaW5nIGV4cGVjdGVkIENSIGFmdGVyIGNodW5rIGRhdGEARXhwZWN0ZWQgTEYgYWZ0ZXIgY2h1bmsgZGF0YQBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AARGF0YSBhZnRlciBgQ29ubmVjdGlvbjogY2xvc2VgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBRVUVSWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAEV4cGVjdGVkIExGIGFmdGVyIENSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX1BST1RPQ09MX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19DT01QTEVURQBIUEVfQ0JfSEVBREVSX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9OQU1FX0NPTVBMRVRFAEhQRV9DQl9NRVNTQUdFX0NPTVBMRVRFAEhQRV9DQl9NRVRIT0RfQ09NUExFVEUASFBFX0NCX0hFQURFUl9GSUVMRF9DT01QTEVURQBERUxFVEUASFBFX0lOVkFMSURfRU9GX1NUQVRFAElOVkFMSURfU1NMX0NFUlRJRklDQVRFAFBBVVNFAE5PX1JFU1BPTlNFAFVOU1VQUE9SVEVEX01FRElBX1RZUEUAR09ORQBOT1RfQUNDRVBUQUJMRQBTRVJWSUNFX1VOQVZBSUxBQkxFAFJBTkdFX05PVF9TQVRJU0ZJQUJMRQBPUklHSU5fSVNfVU5SRUFDSEFCTEUAUkVTUE9OU0VfSVNfU1RBTEUAUFVSR0UATUVSR0UAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRQBSRVFVRVNUX0hFQURFUl9UT09fTEFSR0UAUEFZTE9BRF9UT09fTEFSR0UASU5TVUZGSUNJRU5UX1NUT1JBR0UASFBFX1BBVVNFRF9VUEdSQURFAEhQRV9QQVVTRURfSDJfVVBHUkFERQBTT1VSQ0UAQU5OT1VOQ0UAVFJBQ0UASFBFX1VORVhQRUNURURfU1BBQ0UAREVTQ1JJQkUAVU5TVUJTQ1JJQkUAUkVDT1JEAEhQRV9JTlZBTElEX01FVEhPRABOT1RfRk9VTkQAUFJPUEZJTkQAVU5CSU5EAFJFQklORABVTkFVVEhPUklaRUQATUVUSE9EX05PVF9BTExPV0VEAEhUVFBfVkVSU0lPTl9OT1RfU1VQUE9SVEVEAEFMUkVBRFlfUkVQT1JURUQAQUNDRVBURUQATk9UX0lNUExFTUVOVEVEAExPT1BfREVURUNURUQASFBFX0NSX0VYUEVDVEVEAEhQRV9MRl9FWFBFQ1RFRABDUkVBVEVEAElNX1VTRUQASFBFX1BBVVNFRABUSU1FT1VUX09DQ1VSRUQAUEFZTUVOVF9SRVFVSVJFRABQUkVDT05ESVRJT05fUkVRVUlSRUQAUFJPWFlfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATkVUV09SS19BVVRIRU5USUNBVElPTl9SRVFVSVJFRABMRU5HVEhfUkVRVUlSRUQAU1NMX0NFUlRJRklDQVRFX1JFUVVJUkVEAFVQR1JBREVfUkVRVUlSRUQAUEFHRV9FWFBJUkVEAFBSRUNPTkRJVElPTl9GQUlMRUQARVhQRUNUQVRJT05fRkFJTEVEAFJFVkFMSURBVElPTl9GQUlMRUQAU1NMX0hBTkRTSEFLRV9GQUlMRUQATE9DS0VEAFRSQU5TRk9STUFUSU9OX0FQUExJRUQATk9UX01PRElGSUVEAE5PVF9FWFRFTkRFRABCQU5EV0lEVEhfTElNSVRfRVhDRUVERUQAU0lURV9JU19PVkVSTE9BREVEAEhFQUQARXhwZWN0ZWQgSFRUUC8sIFJUU1AvIG9yIElDRS8A5xUAAK8VAACkEgAAkhoAACYWAACeFAAA2xkAAHkVAAB+EgAA/hQAADYVAAALFgAA2BYAAPMSAABCGAAArBYAABIVAAAUFwAA7xcAAEgUAABxFwAAshoAAGsZAAB+GQAANRQAAIIaAABEFwAA/RYAAB4YAACHFwAAqhkAAJMSAAAHGAAALBcAAMoXAACkFwAA5xUAAOcVAABYFwAAOxgAAKASAAAtHAAAwxEAAEgRAADeEgAAQhMAAKQZAAD9EAAA9xUAAKUVAADvFgAA+BkAAEoWAABWFgAA9RUAAAoaAAAIGgAAARoAAKsVAABCEgAA1xAAAEwRAAAFGQAAVBYAAB4RAADKGQAAyBkAAE4WAAD/GAAAcRQAAPAVAADuFQAAlBkAAPwVAAC/GQAAmxkAAHwUAABDEQAAcBgAAJUUAAAnFAAAGRQAANUSAADUGQAARBYAAPcQAEG5OwsBAQBB0DsL4AEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBBuj0LBAEAAAIAQdE9C14DBAMDAwMDAAADAwADAwADAwMDAwMDAwMDAAUAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAwADAEG6PwsEAQAAAgBB0T8LXgMAAwMDAwMAAAMDAAMDAAMDAwMDAwMDAwMABAAFAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwADAAMAQbDBAAsNbG9zZWVlcC1hbGl2ZQBBycEACwEBAEHgwQAL4AEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBBycMACwEBAEHgwwAL5wEBAQEBAQEBAQEBAQECAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAWNodW5rZWQAQfHFAAteAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQBB0McACyFlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AQYDIAAsgcmFuc2Zlci1lbmNvZGluZ3BncmFkZQ0KDQpTTQ0KDQoAQanIAAsFAQIAAQMAQcDIAAtfBAUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUAQanKAAsFAQIAAQMAQcDKAAtfBAUFBgUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUAQanMAAsEAQAAAQBBwcwAC14CAgACAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAEGpzgALBQECAAEDAEHAzgALXwQFAAAFBQUFBQUFBQUFBQYFBQUFBQUFBQUFBQUABQAHCAUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQAFAAUABQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUAAAAFAEGp0AALBQEBAAEBAEHA0AALAQEAQdrQAAtBAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAQanSAAsFAQEAAQEAQcDSAAsBAQBBytIACwYCAAAAAAIAQeHSAAs6AwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwBBoNQAC50BTk9VTkNFRUNLT1VUTkVDVEVURUNSSUJFTFVTSEVURUFEU0VBUkNIUkdFQ1RJVklUWUxFTkRBUlZFT1RJRllQVElPTlNDSFNFQVlTVEFUQ0hHRVVFUllPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFVFRQQ0VUU1BBRFRQLw==";
    let wasmBuffer;
    Object.defineProperty(module2, "exports", {
      get: () => {
        return wasmBuffer ? wasmBuffer : wasmBuffer = Buffer4.from(wasmBase64, "base64");
      }
    });
  })(llhttp_simdWasm);
  return llhttp_simdWasm.exports;
}
var constants$2;
var hasRequiredConstants$2;
function requireConstants$2() {
  if (hasRequiredConstants$2) return constants$2;
  hasRequiredConstants$2 = 1;
  const corsSafeListedMethods = (
    /** @type {const} */
    ["GET", "HEAD", "POST"]
  );
  const corsSafeListedMethodsSet = new Set(corsSafeListedMethods);
  const nullBodyStatus = (
    /** @type {const} */
    [101, 204, 205, 304]
  );
  const redirectStatus = (
    /** @type {const} */
    [301, 302, 303, 307, 308]
  );
  const redirectStatusSet = new Set(redirectStatus);
  const badPorts = (
    /** @type {const} */
    [
      "1",
      "7",
      "9",
      "11",
      "13",
      "15",
      "17",
      "19",
      "20",
      "21",
      "22",
      "23",
      "25",
      "37",
      "42",
      "43",
      "53",
      "69",
      "77",
      "79",
      "87",
      "95",
      "101",
      "102",
      "103",
      "104",
      "109",
      "110",
      "111",
      "113",
      "115",
      "117",
      "119",
      "123",
      "135",
      "137",
      "139",
      "143",
      "161",
      "179",
      "389",
      "427",
      "465",
      "512",
      "513",
      "514",
      "515",
      "526",
      "530",
      "531",
      "532",
      "540",
      "548",
      "554",
      "556",
      "563",
      "587",
      "601",
      "636",
      "989",
      "990",
      "993",
      "995",
      "1719",
      "1720",
      "1723",
      "2049",
      "3659",
      "4045",
      "4190",
      "5060",
      "5061",
      "6000",
      "6566",
      "6665",
      "6666",
      "6667",
      "6668",
      "6669",
      "6679",
      "6697",
      "10080"
    ]
  );
  const badPortsSet = new Set(badPorts);
  const referrerPolicyTokens = (
    /** @type {const} */
    [
      "no-referrer",
      "no-referrer-when-downgrade",
      "same-origin",
      "origin",
      "strict-origin",
      "origin-when-cross-origin",
      "strict-origin-when-cross-origin",
      "unsafe-url"
    ]
  );
  const referrerPolicy = (
    /** @type {const} */
    [
      "",
      ...referrerPolicyTokens
    ]
  );
  const referrerPolicyTokensSet = new Set(referrerPolicyTokens);
  const requestRedirect = (
    /** @type {const} */
    ["follow", "manual", "error"]
  );
  const safeMethods = (
    /** @type {const} */
    ["GET", "HEAD", "OPTIONS", "TRACE"]
  );
  const safeMethodsSet = new Set(safeMethods);
  const requestMode = (
    /** @type {const} */
    ["navigate", "same-origin", "no-cors", "cors"]
  );
  const requestCredentials = (
    /** @type {const} */
    ["omit", "same-origin", "include"]
  );
  const requestCache = (
    /** @type {const} */
    [
      "default",
      "no-store",
      "reload",
      "no-cache",
      "force-cache",
      "only-if-cached"
    ]
  );
  const requestBodyHeader = (
    /** @type {const} */
    [
      "content-encoding",
      "content-language",
      "content-location",
      "content-type",
      // See https://github.com/nodejs/undici/issues/2021
      // 'Content-Length' is a forbidden header name, which is typically
      // removed in the Headers implementation. However, undici doesn't
      // filter out headers, so we add it here.
      "content-length"
    ]
  );
  const requestDuplex = (
    /** @type {const} */
    [
      "half"
    ]
  );
  const forbiddenMethods = (
    /** @type {const} */
    ["CONNECT", "TRACE", "TRACK"]
  );
  const forbiddenMethodsSet = new Set(forbiddenMethods);
  const subresource = (
    /** @type {const} */
    [
      "audio",
      "audioworklet",
      "font",
      "image",
      "manifest",
      "paintworklet",
      "script",
      "style",
      "track",
      "video",
      "xslt",
      ""
    ]
  );
  const subresourceSet = new Set(subresource);
  constants$2 = {
    subresource,
    forbiddenMethods,
    requestBodyHeader,
    referrerPolicy,
    requestRedirect,
    requestMode,
    requestCredentials,
    requestCache,
    redirectStatus,
    corsSafeListedMethods,
    nullBodyStatus,
    safeMethods,
    badPorts,
    requestDuplex,
    subresourceSet,
    badPortsSet,
    redirectStatusSet,
    corsSafeListedMethodsSet,
    safeMethodsSet,
    forbiddenMethodsSet,
    referrerPolicyTokens: referrerPolicyTokensSet
  };
  return constants$2;
}
var global$2;
var hasRequiredGlobal$1;
function requireGlobal$1() {
  if (hasRequiredGlobal$1) return global$2;
  hasRequiredGlobal$1 = 1;
  const globalOrigin = /* @__PURE__ */ Symbol.for("undici.globalOrigin.1");
  function getGlobalOrigin() {
    return globalThis[globalOrigin];
  }
  function setGlobalOrigin(newOrigin) {
    if (newOrigin === void 0) {
      Object.defineProperty(globalThis, globalOrigin, {
        value: void 0,
        writable: true,
        enumerable: false,
        configurable: false
      });
      return;
    }
    const parsedURL = new URL(newOrigin);
    if (parsedURL.protocol !== "http:" && parsedURL.protocol !== "https:") {
      throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`);
    }
    Object.defineProperty(globalThis, globalOrigin, {
      value: parsedURL,
      writable: true,
      enumerable: false,
      configurable: false
    });
  }
  global$2 = {
    getGlobalOrigin,
    setGlobalOrigin
  };
  return global$2;
}
var encoding;
var hasRequiredEncoding;
function requireEncoding() {
  if (hasRequiredEncoding) return encoding;
  hasRequiredEncoding = 1;
  const textDecoder2 = new TextDecoder();
  function utf8DecodeBytes(buffer) {
    if (buffer.length === 0) {
      return "";
    }
    if (buffer[0] === 239 && buffer[1] === 187 && buffer[2] === 191) {
      buffer = buffer.subarray(3);
    }
    const output = textDecoder2.decode(buffer);
    return output;
  }
  encoding = {
    utf8DecodeBytes
  };
  return encoding;
}
var infra;
var hasRequiredInfra;
function requireInfra() {
  if (hasRequiredInfra) return infra;
  hasRequiredInfra = 1;
  const assert = import_node_assert.default;
  const { utf8DecodeBytes } = requireEncoding();
  function collectASequenceOfCodePoints(condition, input, position) {
    let result = "";
    while (position.position < input.length && condition(input[position.position])) {
      result += input[position.position];
      position.position++;
    }
    return result;
  }
  function collectASequenceOfCodePointsFast(char, input, position) {
    const idx = input.indexOf(char, position.position);
    const start = position.position;
    if (idx === -1) {
      position.position = input.length;
      return input.slice(start);
    }
    position.position = idx;
    return input.slice(start, position.position);
  }
  const ASCII_WHITESPACE_REPLACE_REGEX = /[\u0009\u000A\u000C\u000D\u0020]/g;
  function forgivingBase64(data2) {
    data2 = data2.replace(ASCII_WHITESPACE_REPLACE_REGEX, "");
    let dataLength = data2.length;
    if (dataLength % 4 === 0) {
      if (data2.charCodeAt(dataLength - 1) === 61) {
        --dataLength;
        if (data2.charCodeAt(dataLength - 1) === 61) {
          --dataLength;
        }
      }
    }
    if (dataLength % 4 === 1) {
      return "failure";
    }
    if (/[^+/0-9A-Za-z]/.test(data2.length === dataLength ? data2 : data2.substring(0, dataLength))) {
      return "failure";
    }
    const buffer = Buffer.from(data2, "base64");
    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
  }
  function isASCIIWhitespace(char) {
    return char === 9 || // \t
    char === 10 || // \n
    char === 12 || // \f
    char === 13 || // \r
    char === 32;
  }
  function isomorphicDecode(input) {
    const length = input.length;
    if ((2 << 15) - 1 > length) {
      return String.fromCharCode.apply(null, input);
    }
    let result = "";
    let i4 = 0;
    let addition = (2 << 15) - 1;
    while (i4 < length) {
      if (i4 + addition > length) {
        addition = length - i4;
      }
      result += String.fromCharCode.apply(null, input.subarray(i4, i4 += addition));
    }
    return result;
  }
  const invalidIsomorphicEncodeValueRegex = /[^\x00-\xFF]/;
  function isomorphicEncode(input) {
    assert(!invalidIsomorphicEncodeValueRegex.test(input));
    return input;
  }
  function parseJSONFromBytes(bytes) {
    return JSON.parse(utf8DecodeBytes(bytes));
  }
  function removeASCIIWhitespace(str, leading = true, trailing = true) {
    return removeChars(str, leading, trailing, isASCIIWhitespace);
  }
  function removeChars(str, leading, trailing, predicate) {
    let lead = 0;
    let trail = str.length - 1;
    if (leading) {
      while (lead < str.length && predicate(str.charCodeAt(lead))) lead++;
    }
    if (trailing) {
      while (trail > 0 && predicate(str.charCodeAt(trail))) trail--;
    }
    return lead === 0 && trail === str.length - 1 ? str : str.slice(lead, trail + 1);
  }
  function serializeJavascriptValueToJSONString(value) {
    const result = JSON.stringify(value);
    if (result === void 0) {
      throw new TypeError("Value is not JSON serializable");
    }
    assert(typeof result === "string");
    return result;
  }
  infra = {
    collectASequenceOfCodePoints,
    collectASequenceOfCodePointsFast,
    forgivingBase64,
    isASCIIWhitespace,
    isomorphicDecode,
    isomorphicEncode,
    parseJSONFromBytes,
    removeASCIIWhitespace,
    removeChars,
    serializeJavascriptValueToJSONString
  };
  return infra;
}
var dataUrl;
var hasRequiredDataUrl;
function requireDataUrl() {
  if (hasRequiredDataUrl) return dataUrl;
  hasRequiredDataUrl = 1;
  const assert = import_node_assert.default;
  const { forgivingBase64, collectASequenceOfCodePoints, collectASequenceOfCodePointsFast, isomorphicDecode, removeASCIIWhitespace, removeChars } = requireInfra();
  const encoder = new TextEncoder();
  const HTTP_TOKEN_CODEPOINTS = /^[-!#$%&'*+.^_|~A-Za-z0-9]+$/u;
  const HTTP_WHITESPACE_REGEX = /[\u000A\u000D\u0009\u0020]/u;
  const HTTP_QUOTED_STRING_TOKENS = /^[\u0009\u0020-\u007E\u0080-\u00FF]+$/u;
  function dataURLProcessor(dataURL) {
    assert(dataURL.protocol === "data:");
    let input = URLSerializer(dataURL, true);
    input = input.slice(5);
    const position = { position: 0 };
    let mimeType = collectASequenceOfCodePointsFast(
      ",",
      input,
      position
    );
    const mimeTypeLength = mimeType.length;
    mimeType = removeASCIIWhitespace(mimeType, true, true);
    if (position.position >= input.length) {
      return "failure";
    }
    position.position++;
    const encodedBody = input.slice(mimeTypeLength + 1);
    let body2 = stringPercentDecode(encodedBody);
    if (/;(?:\u0020*)base64$/ui.test(mimeType)) {
      const stringBody = isomorphicDecode(body2);
      body2 = forgivingBase64(stringBody);
      if (body2 === "failure") {
        return "failure";
      }
      mimeType = mimeType.slice(0, -6);
      mimeType = mimeType.replace(/(\u0020+)$/u, "");
      mimeType = mimeType.slice(0, -1);
    }
    if (mimeType.startsWith(";")) {
      mimeType = "text/plain" + mimeType;
    }
    let mimeTypeRecord = parseMIMEType(mimeType);
    if (mimeTypeRecord === "failure") {
      mimeTypeRecord = parseMIMEType("text/plain;charset=US-ASCII");
    }
    return { mimeType: mimeTypeRecord, body: body2 };
  }
  function URLSerializer(url, excludeFragment = false) {
    if (!excludeFragment) {
      return url.href;
    }
    const href = url.href;
    const hashLength = url.hash.length;
    const serialized = hashLength === 0 ? href : href.substring(0, href.length - hashLength);
    if (!hashLength && href.endsWith("#")) {
      return serialized.slice(0, -1);
    }
    return serialized;
  }
  function stringPercentDecode(input) {
    const bytes = encoder.encode(input);
    return percentDecode(bytes);
  }
  function isHexCharByte(byte) {
    return byte >= 48 && byte <= 57 || byte >= 65 && byte <= 70 || byte >= 97 && byte <= 102;
  }
  function hexByteToNumber(byte) {
    return (
      // 0-9
      byte >= 48 && byte <= 57 ? byte - 48 : (byte & 223) - 55
    );
  }
  function percentDecode(input) {
    const length = input.length;
    const output = new Uint8Array(length);
    let j4 = 0;
    let i4 = 0;
    while (i4 < length) {
      const byte = input[i4];
      if (byte !== 37) {
        output[j4++] = byte;
      } else if (byte === 37 && !(isHexCharByte(input[i4 + 1]) && isHexCharByte(input[i4 + 2]))) {
        output[j4++] = 37;
      } else {
        output[j4++] = hexByteToNumber(input[i4 + 1]) << 4 | hexByteToNumber(input[i4 + 2]);
        i4 += 2;
      }
      ++i4;
    }
    return length === j4 ? output : output.subarray(0, j4);
  }
  function parseMIMEType(input) {
    input = removeHTTPWhitespace(input, true, true);
    const position = { position: 0 };
    const type = collectASequenceOfCodePointsFast(
      "/",
      input,
      position
    );
    if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) {
      return "failure";
    }
    if (position.position >= input.length) {
      return "failure";
    }
    position.position++;
    let subtype = collectASequenceOfCodePointsFast(
      ";",
      input,
      position
    );
    subtype = removeHTTPWhitespace(subtype, false, true);
    if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) {
      return "failure";
    }
    const typeLowercase = type.toLowerCase();
    const subtypeLowercase = subtype.toLowerCase();
    const mimeType = {
      type: typeLowercase,
      subtype: subtypeLowercase,
      /** @type {Map<string, string>} */
      parameters: /* @__PURE__ */ new Map(),
      // https://mimesniff.spec.whatwg.org/#mime-type-essence
      essence: `${typeLowercase}/${subtypeLowercase}`
    };
    while (position.position < input.length) {
      position.position++;
      collectASequenceOfCodePoints(
        // https://fetch.spec.whatwg.org/#http-whitespace
        (char) => HTTP_WHITESPACE_REGEX.test(char),
        input,
        position
      );
      let parameterName = collectASequenceOfCodePoints(
        (char) => char !== ";" && char !== "=",
        input,
        position
      );
      parameterName = parameterName.toLowerCase();
      if (position.position < input.length) {
        if (input[position.position] === ";") {
          continue;
        }
        position.position++;
      }
      if (position.position >= input.length) {
        break;
      }
      let parameterValue = null;
      if (input[position.position] === '"') {
        parameterValue = collectAnHTTPQuotedString(input, position, true);
        collectASequenceOfCodePointsFast(
          ";",
          input,
          position
        );
      } else {
        parameterValue = collectASequenceOfCodePointsFast(
          ";",
          input,
          position
        );
        parameterValue = removeHTTPWhitespace(parameterValue, false, true);
        if (parameterValue.length === 0) {
          continue;
        }
      }
      if (parameterName.length !== 0 && HTTP_TOKEN_CODEPOINTS.test(parameterName) && (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) && !mimeType.parameters.has(parameterName)) {
        mimeType.parameters.set(parameterName, parameterValue);
      }
    }
    return mimeType;
  }
  function collectAnHTTPQuotedString(input, position, extractValue = false) {
    const positionStart = position.position;
    let value = "";
    assert(input[position.position] === '"');
    position.position++;
    while (true) {
      value += collectASequenceOfCodePoints(
        (char) => char !== '"' && char !== "\\",
        input,
        position
      );
      if (position.position >= input.length) {
        break;
      }
      const quoteOrBackslash = input[position.position];
      position.position++;
      if (quoteOrBackslash === "\\") {
        if (position.position >= input.length) {
          value += "\\";
          break;
        }
        value += input[position.position];
        position.position++;
      } else {
        assert(quoteOrBackslash === '"');
        break;
      }
    }
    if (extractValue) {
      return value;
    }
    return input.slice(positionStart, position.position);
  }
  function serializeAMimeType(mimeType) {
    assert(mimeType !== "failure");
    const { parameters, essence } = mimeType;
    let serialization = essence;
    for (let [name, value] of parameters.entries()) {
      serialization += ";";
      serialization += name;
      serialization += "=";
      if (!HTTP_TOKEN_CODEPOINTS.test(value)) {
        value = value.replace(/[\\"]/ug, "\\$&");
        value = '"' + value;
        value += '"';
      }
      serialization += value;
    }
    return serialization;
  }
  function isHTTPWhiteSpace(char) {
    return char === 13 || char === 10 || char === 9 || char === 32;
  }
  function removeHTTPWhitespace(str, leading = true, trailing = true) {
    return removeChars(str, leading, trailing, isHTTPWhiteSpace);
  }
  function minimizeSupportedMimeType(mimeType) {
    switch (mimeType.essence) {
      case "application/ecmascript":
      case "application/javascript":
      case "application/x-ecmascript":
      case "application/x-javascript":
      case "text/ecmascript":
      case "text/javascript":
      case "text/javascript1.0":
      case "text/javascript1.1":
      case "text/javascript1.2":
      case "text/javascript1.3":
      case "text/javascript1.4":
      case "text/javascript1.5":
      case "text/jscript":
      case "text/livescript":
      case "text/x-ecmascript":
      case "text/x-javascript":
        return "text/javascript";
      case "application/json":
      case "text/json":
        return "application/json";
      case "image/svg+xml":
        return "image/svg+xml";
      case "text/xml":
      case "application/xml":
        return "application/xml";
    }
    if (mimeType.subtype.endsWith("+json")) {
      return "application/json";
    }
    if (mimeType.subtype.endsWith("+xml")) {
      return "application/xml";
    }
    return "";
  }
  dataUrl = {
    dataURLProcessor,
    URLSerializer,
    stringPercentDecode,
    parseMIMEType,
    collectAnHTTPQuotedString,
    serializeAMimeType,
    removeHTTPWhitespace,
    minimizeSupportedMimeType,
    HTTP_TOKEN_CODEPOINTS
  };
  return dataUrl;
}
var runtimeFeatures = {};
var hasRequiredRuntimeFeatures;
function requireRuntimeFeatures() {
  if (hasRequiredRuntimeFeatures) return runtimeFeatures;
  hasRequiredRuntimeFeatures = 1;
  const lazyLoaders = {
    __proto__: null,
    "node:crypto": () => import_node_crypto2.default,
    "node:sqlite": () => import_node_sqlite.default,
    "node:worker_threads": () => import_node_worker_threads.default,
    "node:zlib": () => import_node_zlib.default
  };
  function detectRuntimeFeatureByNodeModule(moduleName) {
    try {
      lazyLoaders[moduleName]();
      return true;
    } catch (err) {
      if (err.code !== "ERR_UNKNOWN_BUILTIN_MODULE" && err.code !== "ERR_NO_CRYPTO") {
        throw err;
      }
      return false;
    }
  }
  function detectRuntimeFeatureByExportedProperty(moduleName, property) {
    const module2 = lazyLoaders[moduleName]();
    return typeof module2[property] !== "undefined";
  }
  const runtimeFeaturesByExportedProperty = (
    /** @type {const} */
    ["markAsUncloneable", "zstd"]
  );
  const exportedPropertyLookup = {
    markAsUncloneable: ["node:worker_threads", "markAsUncloneable"],
    zstd: ["node:zlib", "createZstdDecompress"]
  };
  const runtimeFeaturesAsNodeModule = (
    /** @type {const} */
    ["crypto", "sqlite"]
  );
  const features = (
    /** @type {const} */
    [
      ...runtimeFeaturesAsNodeModule,
      ...runtimeFeaturesByExportedProperty
    ]
  );
  function detectRuntimeFeature(feature) {
    if (runtimeFeaturesAsNodeModule.includes(
      /** @type {RuntimeFeatureByNodeModule} */
      feature
    )) {
      return detectRuntimeFeatureByNodeModule(`node:${feature}`);
    } else if (runtimeFeaturesByExportedProperty.includes(
      /** @type {RuntimeFeatureByExportedProperty} */
      feature
    )) {
      const [moduleName, property] = exportedPropertyLookup[feature];
      return detectRuntimeFeatureByExportedProperty(moduleName, property);
    }
    throw new TypeError(`unknown feature: ${feature}`);
  }
  class RuntimeFeatures {
    /** @type {Map<Feature, boolean>} */
    #map = /* @__PURE__ */ new Map();
    /**
     * Clears all cached feature detections.
     */
    clear() {
      this.#map.clear();
    }
    /**
     * @param {Feature} feature
     * @returns {boolean}
     */
    has(feature) {
      return this.#map.get(feature) ?? this.#detectRuntimeFeature(feature);
    }
    /**
     * @param {Feature} feature
     * @param {boolean} value
     */
    set(feature, value) {
      if (features.includes(feature) === false) {
        throw new TypeError(`unknown feature: ${feature}`);
      }
      this.#map.set(feature, value);
    }
    /**
     * @param {Feature} feature
     * @returns {boolean}
     */
    #detectRuntimeFeature(feature) {
      const result = detectRuntimeFeature(feature);
      this.#map.set(feature, result);
      return result;
    }
  }
  const instance = new RuntimeFeatures();
  runtimeFeatures.runtimeFeatures = instance;
  runtimeFeatures.default = instance;
  return runtimeFeatures;
}
var webidl_1;
var hasRequiredWebidl;
function requireWebidl() {
  if (hasRequiredWebidl) return webidl_1;
  hasRequiredWebidl = 1;
  const { types, inspect } = import_node_util.default;
  const { runtimeFeatures: runtimeFeatures2 } = requireRuntimeFeatures();
  const UNDEFINED = 1;
  const BOOLEAN = 2;
  const STRING = 3;
  const SYMBOL = 4;
  const NUMBER = 5;
  const BIGINT = 6;
  const NULL = 7;
  const OBJECT = 8;
  const FunctionPrototypeSymbolHasInstance = Function.call.bind(Function.prototype[Symbol.hasInstance]);
  const webidl = {
    converters: {},
    util: {},
    errors: {},
    is: {}
  };
  webidl.errors.exception = function(message) {
    return new TypeError(`${message.header}: ${message.message}`);
  };
  webidl.errors.conversionFailed = function(opts) {
    const plural = opts.types.length === 1 ? "" : " one of";
    const message = `${opts.argument} could not be converted to${plural}: ${opts.types.join(", ")}.`;
    return webidl.errors.exception({
      header: opts.prefix,
      message
    });
  };
  webidl.errors.invalidArgument = function(context) {
    return webidl.errors.exception({
      header: context.prefix,
      message: `"${context.value}" is an invalid ${context.type}.`
    });
  };
  webidl.brandCheck = function(V, I2) {
    if (!FunctionPrototypeSymbolHasInstance(I2, V)) {
      const err = new TypeError("Illegal invocation");
      err.code = "ERR_INVALID_THIS";
      throw err;
    }
  };
  webidl.brandCheckMultiple = function(List) {
    const prototypes = List.map((c4) => webidl.util.MakeTypeAssertion(c4));
    return (V) => {
      if (prototypes.every((typeCheck) => !typeCheck(V))) {
        const err = new TypeError("Illegal invocation");
        err.code = "ERR_INVALID_THIS";
        throw err;
      }
    };
  };
  webidl.argumentLengthCheck = function({ length }, min, ctx) {
    if (length < min) {
      throw webidl.errors.exception({
        message: `${min} argument${min !== 1 ? "s" : ""} required, but${length ? " only" : ""} ${length} found.`,
        header: ctx
      });
    }
  };
  webidl.illegalConstructor = function() {
    throw webidl.errors.exception({
      header: "TypeError",
      message: "Illegal constructor"
    });
  };
  webidl.util.MakeTypeAssertion = function(I2) {
    return (O) => FunctionPrototypeSymbolHasInstance(I2, O);
  };
  webidl.util.Type = function(V) {
    switch (typeof V) {
      case "undefined":
        return UNDEFINED;
      case "boolean":
        return BOOLEAN;
      case "string":
        return STRING;
      case "symbol":
        return SYMBOL;
      case "number":
        return NUMBER;
      case "bigint":
        return BIGINT;
      case "function":
      case "object": {
        if (V === null) {
          return NULL;
        }
        return OBJECT;
      }
    }
  };
  webidl.util.Types = {
    UNDEFINED,
    BOOLEAN,
    STRING,
    SYMBOL,
    NUMBER,
    BIGINT,
    NULL,
    OBJECT
  };
  webidl.util.TypeValueToString = function(o4) {
    switch (webidl.util.Type(o4)) {
      case UNDEFINED:
        return "Undefined";
      case BOOLEAN:
        return "Boolean";
      case STRING:
        return "String";
      case SYMBOL:
        return "Symbol";
      case NUMBER:
        return "Number";
      case BIGINT:
        return "BigInt";
      case NULL:
        return "Null";
      case OBJECT:
        return "Object";
    }
  };
  webidl.util.markAsUncloneable = runtimeFeatures2.has("markAsUncloneable") ? import_node_worker_threads.default.markAsUncloneable : () => {
  };
  webidl.util.ConvertToInt = function(V, bitLength, signedness, flags) {
    let upperBound;
    let lowerBound;
    if (bitLength === 64) {
      upperBound = Math.pow(2, 53) - 1;
      if (signedness === "unsigned") {
        lowerBound = 0;
      } else {
        lowerBound = Math.pow(-2, 53) + 1;
      }
    } else if (signedness === "unsigned") {
      lowerBound = 0;
      upperBound = Math.pow(2, bitLength) - 1;
    } else {
      lowerBound = Math.pow(-2, bitLength) - 1;
      upperBound = Math.pow(2, bitLength - 1) - 1;
    }
    let x4 = Number(V);
    if (x4 === 0) {
      x4 = 0;
    }
    if (webidl.util.HasFlag(flags, webidl.attributes.EnforceRange)) {
      if (Number.isNaN(x4) || x4 === Number.POSITIVE_INFINITY || x4 === Number.NEGATIVE_INFINITY) {
        throw webidl.errors.exception({
          header: "Integer conversion",
          message: `Could not convert ${webidl.util.Stringify(V)} to an integer.`
        });
      }
      x4 = webidl.util.IntegerPart(x4);
      if (x4 < lowerBound || x4 > upperBound) {
        throw webidl.errors.exception({
          header: "Integer conversion",
          message: `Value must be between ${lowerBound}-${upperBound}, got ${x4}.`
        });
      }
      return x4;
    }
    if (!Number.isNaN(x4) && webidl.util.HasFlag(flags, webidl.attributes.Clamp)) {
      x4 = Math.min(Math.max(x4, lowerBound), upperBound);
      if (Math.floor(x4) % 2 === 0) {
        x4 = Math.floor(x4);
      } else {
        x4 = Math.ceil(x4);
      }
      return x4;
    }
    if (Number.isNaN(x4) || x4 === 0 && Object.is(0, x4) || x4 === Number.POSITIVE_INFINITY || x4 === Number.NEGATIVE_INFINITY) {
      return 0;
    }
    x4 = webidl.util.IntegerPart(x4);
    x4 = x4 % Math.pow(2, bitLength);
    if (signedness === "signed" && x4 >= Math.pow(2, bitLength) - 1) {
      return x4 - Math.pow(2, bitLength);
    }
    return x4;
  };
  webidl.util.IntegerPart = function(n4) {
    const r4 = Math.floor(Math.abs(n4));
    if (n4 < 0) {
      return -1 * r4;
    }
    return r4;
  };
  webidl.util.Stringify = function(V) {
    const type = webidl.util.Type(V);
    switch (type) {
      case SYMBOL:
        return `Symbol(${V.description})`;
      case OBJECT:
        return inspect(V);
      case STRING:
        return `"${V}"`;
      case BIGINT:
        return `${V}n`;
      default:
        return `${V}`;
    }
  };
  webidl.util.IsResizableArrayBuffer = function(V) {
    if (types.isArrayBuffer(V)) {
      return V.resizable;
    }
    if (types.isSharedArrayBuffer(V)) {
      return V.growable;
    }
    throw webidl.errors.exception({
      header: "IsResizableArrayBuffer",
      message: `"${webidl.util.Stringify(V)}" is not an array buffer.`
    });
  };
  webidl.util.HasFlag = function(flags, attributes) {
    return typeof flags === "number" && (flags & attributes) === attributes;
  };
  webidl.sequenceConverter = function(converter) {
    return (V, prefix, argument, Iterable) => {
      if (webidl.util.Type(V) !== OBJECT) {
        throw webidl.errors.exception({
          header: prefix,
          message: `${argument} (${webidl.util.Stringify(V)}) is not iterable.`
        });
      }
      const method = typeof Iterable === "function" ? Iterable() : V?.[Symbol.iterator]?.();
      const seq = [];
      let index = 0;
      if (method === void 0 || typeof method.next !== "function") {
        throw webidl.errors.exception({
          header: prefix,
          message: `${argument} is not iterable.`
        });
      }
      while (true) {
        const { done, value } = method.next();
        if (done) {
          break;
        }
        seq.push(converter(value, prefix, `${argument}[${index++}]`));
      }
      return seq;
    };
  };
  webidl.recordConverter = function(keyConverter, valueConverter) {
    return (O, prefix, argument) => {
      if (webidl.util.Type(O) !== OBJECT) {
        throw webidl.errors.exception({
          header: prefix,
          message: `${argument} ("${webidl.util.TypeValueToString(O)}") is not an Object.`
        });
      }
      const result = {};
      if (!types.isProxy(O)) {
        const keys3 = [...Object.getOwnPropertyNames(O), ...Object.getOwnPropertySymbols(O)];
        for (const key of keys3) {
          const keyName = webidl.util.Stringify(key);
          const typedKey = keyConverter(key, prefix, `Key ${keyName} in ${argument}`);
          const typedValue = valueConverter(O[key], prefix, `${argument}[${keyName}]`);
          result[typedKey] = typedValue;
        }
        return result;
      }
      const keys2 = Reflect.ownKeys(O);
      for (const key of keys2) {
        const desc = Reflect.getOwnPropertyDescriptor(O, key);
        if (desc?.enumerable) {
          const typedKey = keyConverter(key, prefix, argument);
          const typedValue = valueConverter(O[key], prefix, argument);
          result[typedKey] = typedValue;
        }
      }
      return result;
    };
  };
  webidl.interfaceConverter = function(TypeCheck, name) {
    return (V, prefix, argument) => {
      if (!TypeCheck(V)) {
        throw webidl.errors.exception({
          header: prefix,
          message: `Expected ${argument} ("${webidl.util.Stringify(V)}") to be an instance of ${name}.`
        });
      }
      return V;
    };
  };
  webidl.dictionaryConverter = function(converters) {
    return (dictionary, prefix, argument) => {
      const dict = {};
      if (dictionary != null && webidl.util.Type(dictionary) !== OBJECT) {
        throw webidl.errors.exception({
          header: prefix,
          message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`
        });
      }
      for (const options of converters) {
        const { key, defaultValue, required, converter } = options;
        if (required === true) {
          if (dictionary == null || !Object.hasOwn(dictionary, key)) {
            throw webidl.errors.exception({
              header: prefix,
              message: `Missing required key "${key}".`
            });
          }
        }
        let value = dictionary?.[key];
        const hasDefault = defaultValue !== void 0;
        if (hasDefault && value === void 0) {
          value = defaultValue();
        }
        if (required || hasDefault || value !== void 0) {
          value = converter(value, prefix, `${argument}.${key}`);
          if (options.allowedValues && !options.allowedValues.includes(value)) {
            throw webidl.errors.exception({
              header: prefix,
              message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(", ")}.`
            });
          }
          dict[key] = value;
        }
      }
      return dict;
    };
  };
  webidl.nullableConverter = function(converter) {
    return (V, prefix, argument) => {
      if (V === null) {
        return V;
      }
      return converter(V, prefix, argument);
    };
  };
  webidl.is.USVString = function(value) {
    return typeof value === "string" && value.isWellFormed();
  };
  webidl.is.ReadableStream = webidl.util.MakeTypeAssertion(ReadableStream);
  webidl.is.Blob = webidl.util.MakeTypeAssertion(Blob);
  webidl.is.URLSearchParams = webidl.util.MakeTypeAssertion(URLSearchParams);
  webidl.is.File = webidl.util.MakeTypeAssertion(File);
  webidl.is.URL = webidl.util.MakeTypeAssertion(URL);
  webidl.is.AbortSignal = webidl.util.MakeTypeAssertion(AbortSignal);
  webidl.is.MessagePort = webidl.util.MakeTypeAssertion(MessagePort);
  webidl.is.BufferSource = function(V) {
    return types.isArrayBuffer(V) || ArrayBuffer.isView(V) && types.isArrayBuffer(V.buffer);
  };
  webidl.converters.DOMString = function(V, prefix, argument, flags) {
    if (V === null && webidl.util.HasFlag(flags, webidl.attributes.LegacyNullToEmptyString)) {
      return "";
    }
    if (typeof V === "symbol") {
      throw webidl.errors.exception({
        header: prefix,
        message: `${argument} is a symbol, which cannot be converted to a DOMString.`
      });
    }
    return String(V);
  };
  webidl.converters.ByteString = function(V, prefix, argument) {
    if (typeof V === "symbol") {
      throw webidl.errors.exception({
        header: prefix,
        message: `${argument} is a symbol, which cannot be converted to a ByteString.`
      });
    }
    const x4 = String(V);
    for (let index = 0; index < x4.length; index++) {
      if (x4.charCodeAt(index) > 255) {
        throw new TypeError(
          `Cannot convert argument to a ByteString because the character at index ${index} has a value of ${x4.charCodeAt(index)} which is greater than 255.`
        );
      }
    }
    return x4;
  };
  webidl.converters.USVString = function(value) {
    if (typeof value === "string") {
      return value.toWellFormed();
    }
    return `${value}`.toWellFormed();
  };
  webidl.converters.boolean = function(V) {
    const x4 = Boolean(V);
    return x4;
  };
  webidl.converters.any = function(V) {
    return V;
  };
  webidl.converters["long long"] = function(V, prefix, argument) {
    const x4 = webidl.util.ConvertToInt(V, 64, "signed", 0, prefix, argument);
    return x4;
  };
  webidl.converters["unsigned long long"] = function(V, prefix, argument) {
    const x4 = webidl.util.ConvertToInt(V, 64, "unsigned", 0, prefix, argument);
    return x4;
  };
  webidl.converters["unsigned long"] = function(V, prefix, argument) {
    const x4 = webidl.util.ConvertToInt(V, 32, "unsigned", 0, prefix, argument);
    return x4;
  };
  webidl.converters["unsigned short"] = function(V, prefix, argument, flags) {
    const x4 = webidl.util.ConvertToInt(V, 16, "unsigned", flags, prefix, argument);
    return x4;
  };
  webidl.converters.ArrayBuffer = function(V, prefix, argument, flags) {
    if (webidl.util.Type(V) !== OBJECT || !types.isArrayBuffer(V)) {
      throw webidl.errors.conversionFailed({
        prefix,
        argument: `${argument} ("${webidl.util.Stringify(V)}")`,
        types: ["ArrayBuffer"]
      });
    }
    if (!webidl.util.HasFlag(flags, webidl.attributes.AllowResizable) && webidl.util.IsResizableArrayBuffer(V)) {
      throw webidl.errors.exception({
        header: prefix,
        message: `${argument} cannot be a resizable ArrayBuffer.`
      });
    }
    return V;
  };
  webidl.converters.SharedArrayBuffer = function(V, prefix, argument, flags) {
    if (webidl.util.Type(V) !== OBJECT || !types.isSharedArrayBuffer(V)) {
      throw webidl.errors.conversionFailed({
        prefix,
        argument: `${argument} ("${webidl.util.Stringify(V)}")`,
        types: ["SharedArrayBuffer"]
      });
    }
    if (!webidl.util.HasFlag(flags, webidl.attributes.AllowResizable) && webidl.util.IsResizableArrayBuffer(V)) {
      throw webidl.errors.exception({
        header: prefix,
        message: `${argument} cannot be a resizable SharedArrayBuffer.`
      });
    }
    return V;
  };
  webidl.converters.TypedArray = function(V, T, prefix, argument, flags) {
    if (webidl.util.Type(V) !== OBJECT || !types.isTypedArray(V) || V.constructor.name !== T.name) {
      throw webidl.errors.conversionFailed({
        prefix,
        argument: `${argument} ("${webidl.util.Stringify(V)}")`,
        types: [T.name]
      });
    }
    if (!webidl.util.HasFlag(flags, webidl.attributes.AllowShared) && types.isSharedArrayBuffer(V.buffer)) {
      throw webidl.errors.exception({
        header: prefix,
        message: `${argument} cannot be a view on a shared array buffer.`
      });
    }
    if (!webidl.util.HasFlag(flags, webidl.attributes.AllowResizable) && webidl.util.IsResizableArrayBuffer(V.buffer)) {
      throw webidl.errors.exception({
        header: prefix,
        message: `${argument} cannot be a view on a resizable array buffer.`
      });
    }
    return V;
  };
  webidl.converters.DataView = function(V, prefix, argument, flags) {
    if (webidl.util.Type(V) !== OBJECT || !types.isDataView(V)) {
      throw webidl.errors.conversionFailed({
        prefix,
        argument: `${argument} ("${webidl.util.Stringify(V)}")`,
        types: ["DataView"]
      });
    }
    if (!webidl.util.HasFlag(flags, webidl.attributes.AllowShared) && types.isSharedArrayBuffer(V.buffer)) {
      throw webidl.errors.exception({
        header: prefix,
        message: `${argument} cannot be a view on a shared array buffer.`
      });
    }
    if (!webidl.util.HasFlag(flags, webidl.attributes.AllowResizable) && webidl.util.IsResizableArrayBuffer(V.buffer)) {
      throw webidl.errors.exception({
        header: prefix,
        message: `${argument} cannot be a view on a resizable array buffer.`
      });
    }
    return V;
  };
  webidl.converters.ArrayBufferView = function(V, prefix, argument, flags) {
    if (webidl.util.Type(V) !== OBJECT || !types.isArrayBufferView(V)) {
      throw webidl.errors.conversionFailed({
        prefix,
        argument: `${argument} ("${webidl.util.Stringify(V)}")`,
        types: ["ArrayBufferView"]
      });
    }
    if (!webidl.util.HasFlag(flags, webidl.attributes.AllowShared) && types.isSharedArrayBuffer(V.buffer)) {
      throw webidl.errors.exception({
        header: prefix,
        message: `${argument} cannot be a view on a shared array buffer.`
      });
    }
    if (!webidl.util.HasFlag(flags, webidl.attributes.AllowResizable) && webidl.util.IsResizableArrayBuffer(V.buffer)) {
      throw webidl.errors.exception({
        header: prefix,
        message: `${argument} cannot be a view on a resizable array buffer.`
      });
    }
    return V;
  };
  webidl.converters.BufferSource = function(V, prefix, argument, flags) {
    if (types.isArrayBuffer(V)) {
      return webidl.converters.ArrayBuffer(V, prefix, argument, flags);
    }
    if (types.isArrayBufferView(V)) {
      flags &= ~webidl.attributes.AllowShared;
      return webidl.converters.ArrayBufferView(V, prefix, argument, flags);
    }
    if (types.isSharedArrayBuffer(V)) {
      throw webidl.errors.exception({
        header: prefix,
        message: `${argument} cannot be a SharedArrayBuffer.`
      });
    }
    throw webidl.errors.conversionFailed({
      prefix,
      argument: `${argument} ("${webidl.util.Stringify(V)}")`,
      types: ["ArrayBuffer", "ArrayBufferView"]
    });
  };
  webidl.converters.AllowSharedBufferSource = function(V, prefix, argument, flags) {
    if (types.isArrayBuffer(V)) {
      return webidl.converters.ArrayBuffer(V, prefix, argument, flags);
    }
    if (types.isSharedArrayBuffer(V)) {
      return webidl.converters.SharedArrayBuffer(V, prefix, argument, flags);
    }
    if (types.isArrayBufferView(V)) {
      flags |= webidl.attributes.AllowShared;
      return webidl.converters.ArrayBufferView(V, prefix, argument, flags);
    }
    throw webidl.errors.conversionFailed({
      prefix,
      argument: `${argument} ("${webidl.util.Stringify(V)}")`,
      types: ["ArrayBuffer", "SharedArrayBuffer", "ArrayBufferView"]
    });
  };
  webidl.converters["sequence<ByteString>"] = webidl.sequenceConverter(
    webidl.converters.ByteString
  );
  webidl.converters["sequence<sequence<ByteString>>"] = webidl.sequenceConverter(
    webidl.converters["sequence<ByteString>"]
  );
  webidl.converters["record<ByteString, ByteString>"] = webidl.recordConverter(
    webidl.converters.ByteString,
    webidl.converters.ByteString
  );
  webidl.converters.Blob = webidl.interfaceConverter(webidl.is.Blob, "Blob");
  webidl.converters.AbortSignal = webidl.interfaceConverter(
    webidl.is.AbortSignal,
    "AbortSignal"
  );
  webidl.converters.EventHandlerNonNull = function(V) {
    if (webidl.util.Type(V) !== OBJECT) {
      return null;
    }
    if (typeof V === "function") {
      return V;
    }
    return () => {
    };
  };
  webidl.attributes = {
    Clamp: 1 << 0,
    EnforceRange: 1 << 1,
    AllowShared: 1 << 2,
    AllowResizable: 1 << 3,
    LegacyNullToEmptyString: 1 << 4
  };
  webidl_1 = {
    webidl
  };
  return webidl_1;
}
var util$4;
var hasRequiredUtil$4;
function requireUtil$4() {
  if (hasRequiredUtil$4) return util$4;
  hasRequiredUtil$4 = 1;
  const { Transform: Transform2 } = import_node_stream.default;
  const zlib2 = import_node_zlib.default;
  const { redirectStatusSet, referrerPolicyTokens, badPortsSet } = requireConstants$2();
  const { getGlobalOrigin } = requireGlobal$1();
  const { collectAnHTTPQuotedString, parseMIMEType } = requireDataUrl();
  const { performance: performance2 } = import_node_perf_hooks.default;
  const { ReadableStreamFrom, isValidHTTPToken, normalizedMethodRecordsBase } = requireUtil$5();
  const assert = import_node_assert.default;
  const { isUint8Array } = import_types3.default;
  const { webidl } = requireWebidl();
  const { isomorphicEncode, collectASequenceOfCodePoints, removeChars } = requireInfra();
  function responseURL(response2) {
    const urlList = response2.urlList;
    const length = urlList.length;
    return length === 0 ? null : urlList[length - 1].toString();
  }
  function responseLocationURL(response2, requestFragment) {
    if (!redirectStatusSet.has(response2.status)) {
      return null;
    }
    let location = response2.headersList.get("location", true);
    if (location !== null && isValidHeaderValue(location)) {
      if (!isValidEncodedURL(location)) {
        location = normalizeBinaryStringToUtf8(location);
      }
      location = new URL(location, responseURL(response2));
    }
    if (location && !location.hash) {
      location.hash = requestFragment;
    }
    return location;
  }
  function isValidEncodedURL(url) {
    for (let i4 = 0; i4 < url.length; ++i4) {
      const code = url.charCodeAt(i4);
      if (code > 126 || // Non-US-ASCII + DEL
      code < 32) {
        return false;
      }
    }
    return true;
  }
  function normalizeBinaryStringToUtf8(value) {
    return Buffer.from(value, "binary").toString("utf8");
  }
  function requestCurrentURL(request2) {
    return request2.urlList[request2.urlList.length - 1];
  }
  function requestBadPort(request2) {
    const url = requestCurrentURL(request2);
    if (urlIsHttpHttpsScheme(url) && badPortsSet.has(url.port)) {
      return "blocked";
    }
    return "allowed";
  }
  function isErrorLike(object) {
    return object instanceof Error || (object?.constructor?.name === "Error" || object?.constructor?.name === "DOMException");
  }
  function isValidReasonPhrase(statusText) {
    for (let i4 = 0; i4 < statusText.length; ++i4) {
      const c4 = statusText.charCodeAt(i4);
      if (!(c4 === 9 || // HTAB
      c4 >= 32 && c4 <= 126 || // SP / VCHAR
      c4 >= 128 && c4 <= 255)) {
        return false;
      }
    }
    return true;
  }
  const isValidHeaderName = isValidHTTPToken;
  function isValidHeaderValue(potentialValue) {
    return (potentialValue[0] === "	" || potentialValue[0] === " " || potentialValue[potentialValue.length - 1] === "	" || potentialValue[potentialValue.length - 1] === " " || potentialValue.includes("\n") || potentialValue.includes("\r") || potentialValue.includes("\0")) === false;
  }
  function parseReferrerPolicy(actualResponse) {
    const policyHeader = (actualResponse.headersList.get("referrer-policy", true) ?? "").split(",");
    let policy = "";
    if (policyHeader.length) {
      for (let i4 = policyHeader.length; i4 !== 0; i4--) {
        const token = policyHeader[i4 - 1].trim();
        if (referrerPolicyTokens.has(token)) {
          policy = token;
          break;
        }
      }
    }
    return policy;
  }
  function setRequestReferrerPolicyOnRedirect(request2, actualResponse) {
    const policy = parseReferrerPolicy(actualResponse);
    if (policy !== "") {
      request2.referrerPolicy = policy;
    }
  }
  function crossOriginResourcePolicyCheck() {
    return "allowed";
  }
  function corsCheck() {
    return "success";
  }
  function TAOCheck() {
    return "success";
  }
  function appendFetchMetadata(httpRequest) {
    let header = null;
    header = httpRequest.mode;
    httpRequest.headersList.set("sec-fetch-mode", header, true);
  }
  function appendRequestOriginHeader(request2) {
    let serializedOrigin = request2.origin;
    if (serializedOrigin === "client" || serializedOrigin === void 0) {
      return;
    }
    if (request2.responseTainting === "cors" || request2.mode === "websocket") {
      request2.headersList.append("origin", serializedOrigin, true);
    } else if (request2.method !== "GET" && request2.method !== "HEAD") {
      switch (request2.referrerPolicy) {
        case "no-referrer":
          serializedOrigin = null;
          break;
        case "no-referrer-when-downgrade":
        case "strict-origin":
        case "strict-origin-when-cross-origin":
          if (request2.origin && urlHasHttpsScheme(request2.origin) && !urlHasHttpsScheme(requestCurrentURL(request2))) {
            serializedOrigin = null;
          }
          break;
        case "same-origin":
          if (!sameOrigin(request2, requestCurrentURL(request2))) {
            serializedOrigin = null;
          }
          break;
      }
      request2.headersList.append("origin", serializedOrigin, true);
    }
  }
  function coarsenTime(timestamp, crossOriginIsolatedCapability) {
    return timestamp;
  }
  function clampAndCoarsenConnectionTimingInfo(connectionTimingInfo, defaultStartTime, crossOriginIsolatedCapability) {
    if (!connectionTimingInfo?.startTime || connectionTimingInfo.startTime < defaultStartTime) {
      return {
        domainLookupStartTime: defaultStartTime,
        domainLookupEndTime: defaultStartTime,
        connectionStartTime: defaultStartTime,
        connectionEndTime: defaultStartTime,
        secureConnectionStartTime: defaultStartTime,
        ALPNNegotiatedProtocol: connectionTimingInfo?.ALPNNegotiatedProtocol
      };
    }
    return {
      domainLookupStartTime: coarsenTime(connectionTimingInfo.domainLookupStartTime),
      domainLookupEndTime: coarsenTime(connectionTimingInfo.domainLookupEndTime),
      connectionStartTime: coarsenTime(connectionTimingInfo.connectionStartTime),
      connectionEndTime: coarsenTime(connectionTimingInfo.connectionEndTime),
      secureConnectionStartTime: coarsenTime(connectionTimingInfo.secureConnectionStartTime),
      ALPNNegotiatedProtocol: connectionTimingInfo.ALPNNegotiatedProtocol
    };
  }
  function coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {
    return coarsenTime(performance2.now());
  }
  function createOpaqueTimingInfo(timingInfo) {
    return {
      startTime: timingInfo.startTime ?? 0,
      redirectStartTime: 0,
      redirectEndTime: 0,
      postRedirectStartTime: timingInfo.startTime ?? 0,
      finalServiceWorkerStartTime: 0,
      finalNetworkResponseStartTime: 0,
      finalNetworkRequestStartTime: 0,
      endTime: 0,
      encodedBodySize: 0,
      decodedBodySize: 0,
      finalConnectionTimingInfo: null
    };
  }
  function makePolicyContainer() {
    return {
      referrerPolicy: "strict-origin-when-cross-origin"
    };
  }
  function clonePolicyContainer(policyContainer) {
    return {
      referrerPolicy: policyContainer.referrerPolicy
    };
  }
  function determineRequestsReferrer(request2) {
    const policy = request2.referrerPolicy;
    assert(policy);
    let referrerSource = null;
    if (request2.referrer === "client") {
      const globalOrigin = getGlobalOrigin();
      if (!globalOrigin || globalOrigin.origin === "null") {
        return "no-referrer";
      }
      referrerSource = new URL(globalOrigin);
    } else if (webidl.is.URL(request2.referrer)) {
      referrerSource = request2.referrer;
    }
    let referrerURL = stripURLForReferrer(referrerSource);
    const referrerOrigin = stripURLForReferrer(referrerSource, true);
    if (referrerURL.toString().length > 4096) {
      referrerURL = referrerOrigin;
    }
    switch (policy) {
      case "no-referrer":
        return "no-referrer";
      case "origin":
        if (referrerOrigin != null) {
          return referrerOrigin;
        }
        return stripURLForReferrer(referrerSource, true);
      case "unsafe-url":
        return referrerURL;
      case "strict-origin": {
        const currentURL = requestCurrentURL(request2);
        if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {
          return "no-referrer";
        }
        return referrerOrigin;
      }
      case "strict-origin-when-cross-origin": {
        const currentURL = requestCurrentURL(request2);
        if (sameOrigin(referrerURL, currentURL)) {
          return referrerURL;
        }
        if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {
          return "no-referrer";
        }
        return referrerOrigin;
      }
      case "same-origin":
        if (sameOrigin(request2, referrerURL)) {
          return referrerURL;
        }
        return "no-referrer";
      case "origin-when-cross-origin":
        if (sameOrigin(request2, referrerURL)) {
          return referrerURL;
        }
        return referrerOrigin;
      case "no-referrer-when-downgrade": {
        const currentURL = requestCurrentURL(request2);
        if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {
          return "no-referrer";
        }
        return referrerURL;
      }
    }
  }
  function stripURLForReferrer(url, originOnly = false) {
    assert(webidl.is.URL(url));
    url = new URL(url);
    if (urlIsLocal(url)) {
      return "no-referrer";
    }
    url.username = "";
    url.password = "";
    url.hash = "";
    if (originOnly === true) {
      url.pathname = "";
      url.search = "";
    }
    return url;
  }
  const isPotentialleTrustworthyIPv4 = RegExp.prototype.test.bind(/^127\.(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)\.){2}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)$/);
  const isPotentiallyTrustworthyIPv6 = RegExp.prototype.test.bind(/^(?:(?:0{1,4}:){7}|(?:0{1,4}:){1,6}:|::)0{0,3}1$/);
  function isOriginIPPotentiallyTrustworthy(origin) {
    if (origin.includes(":")) {
      if (origin[0] === "[" && origin[origin.length - 1] === "]") {
        origin = origin.slice(1, -1);
      }
      return isPotentiallyTrustworthyIPv6(origin);
    }
    return isPotentialleTrustworthyIPv4(origin);
  }
  function isOriginPotentiallyTrustworthy(origin) {
    if (origin == null || origin === "null") {
      return false;
    }
    origin = new URL(origin);
    if (origin.protocol === "https:" || origin.protocol === "wss:") {
      return true;
    }
    if (isOriginIPPotentiallyTrustworthy(origin.hostname)) {
      return true;
    }
    if (origin.hostname === "localhost" || origin.hostname === "localhost.") {
      return true;
    }
    if (origin.hostname.endsWith(".localhost") || origin.hostname.endsWith(".localhost.")) {
      return true;
    }
    if (origin.protocol === "file:") {
      return true;
    }
    return false;
  }
  function isURLPotentiallyTrustworthy(url) {
    if (!webidl.is.URL(url)) {
      return false;
    }
    if (url.href === "about:blank" || url.href === "about:srcdoc") {
      return true;
    }
    if (url.protocol === "data:") return true;
    if (url.protocol === "blob:") return true;
    return isOriginPotentiallyTrustworthy(url.origin);
  }
  function tryUpgradeRequestToAPotentiallyTrustworthyURL(request2) {
  }
  function sameOrigin(A2, B2) {
    if (A2.origin === B2.origin && A2.origin === "null") {
      return true;
    }
    if (A2.protocol === B2.protocol && A2.hostname === B2.hostname && A2.port === B2.port) {
      return true;
    }
    return false;
  }
  function isAborted(fetchParams) {
    return fetchParams.controller.state === "aborted";
  }
  function isCancelled(fetchParams) {
    return fetchParams.controller.state === "aborted" || fetchParams.controller.state === "terminated";
  }
  function normalizeMethod(method) {
    return normalizedMethodRecordsBase[method.toLowerCase()] ?? method;
  }
  const esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
  function createIterator(name, kInternalIterator, keyIndex = 0, valueIndex = 1) {
    class FastIterableIterator {
      /** @type {any} */
      #target;
      /** @type {'key' | 'value' | 'key+value'} */
      #kind;
      /** @type {number} */
      #index;
      /**
       * @see https://webidl.spec.whatwg.org/#dfn-default-iterator-object
       * @param {unknown} target
       * @param {'key' | 'value' | 'key+value'} kind
       */
      constructor(target, kind) {
        this.#target = target;
        this.#kind = kind;
        this.#index = 0;
      }
      next() {
        if (typeof this !== "object" || this === null || !(#target in this)) {
          throw new TypeError(
            `'next' called on an object that does not implement interface ${name} Iterator.`
          );
        }
        const index = this.#index;
        const values = kInternalIterator(this.#target);
        const len = values.length;
        if (index >= len) {
          return {
            value: void 0,
            done: true
          };
        }
        const { [keyIndex]: key, [valueIndex]: value } = values[index];
        this.#index = index + 1;
        let result;
        switch (this.#kind) {
          case "key":
            result = key;
            break;
          case "value":
            result = value;
            break;
          case "key+value":
            result = [key, value];
            break;
        }
        return {
          value: result,
          done: false
        };
      }
    }
    delete FastIterableIterator.prototype.constructor;
    Object.setPrototypeOf(FastIterableIterator.prototype, esIteratorPrototype);
    Object.defineProperties(FastIterableIterator.prototype, {
      [Symbol.toStringTag]: {
        writable: false,
        enumerable: false,
        configurable: true,
        value: `${name} Iterator`
      },
      next: { writable: true, enumerable: true, configurable: true }
    });
    return function(target, kind) {
      return new FastIterableIterator(target, kind);
    };
  }
  function iteratorMixin(name, object, kInternalIterator, keyIndex = 0, valueIndex = 1) {
    const makeIterator = createIterator(name, kInternalIterator, keyIndex, valueIndex);
    const properties = {
      keys: {
        writable: true,
        enumerable: true,
        configurable: true,
        value: function keys2() {
          webidl.brandCheck(this, object);
          return makeIterator(this, "key");
        }
      },
      values: {
        writable: true,
        enumerable: true,
        configurable: true,
        value: function values() {
          webidl.brandCheck(this, object);
          return makeIterator(this, "value");
        }
      },
      entries: {
        writable: true,
        enumerable: true,
        configurable: true,
        value: function entries() {
          webidl.brandCheck(this, object);
          return makeIterator(this, "key+value");
        }
      },
      forEach: {
        writable: true,
        enumerable: true,
        configurable: true,
        value: function forEach(callbackfn, thisArg = globalThis) {
          webidl.brandCheck(this, object);
          webidl.argumentLengthCheck(arguments, 1, `${name}.forEach`);
          if (typeof callbackfn !== "function") {
            throw new TypeError(
              `Failed to execute 'forEach' on '${name}': parameter 1 is not of type 'Function'.`
            );
          }
          for (const { 0: key, 1: value } of makeIterator(this, "key+value")) {
            callbackfn.call(thisArg, value, key, this);
          }
        }
      }
    };
    return Object.defineProperties(object.prototype, {
      ...properties,
      [Symbol.iterator]: {
        writable: true,
        enumerable: false,
        configurable: true,
        value: properties.entries.value
      }
    });
  }
  function fullyReadBody(body2, processBody2, processBodyError) {
    const successSteps = processBody2;
    const errorSteps = processBodyError;
    try {
      const reader = body2.stream.getReader();
      readAllBytes(reader, successSteps, errorSteps);
    } catch (e4) {
      errorSteps(e4);
    }
  }
  function readableStreamClose(controller) {
    try {
      controller.close();
      controller.byobRequest?.respond(0);
    } catch (err) {
      if (!err.message.includes("Controller is already closed") && !err.message.includes("ReadableStream is already closed")) {
        throw err;
      }
    }
  }
  async function readAllBytes(reader, successSteps, failureSteps) {
    try {
      const bytes = [];
      let byteLength = 0;
      do {
        const { done, value: chunk2 } = await reader.read();
        if (done) {
          successSteps(Buffer.concat(bytes, byteLength));
          return;
        }
        if (!isUint8Array(chunk2)) {
          failureSteps(new TypeError("Received non-Uint8Array chunk"));
          return;
        }
        bytes.push(chunk2);
        byteLength += chunk2.length;
      } while (true);
    } catch (e4) {
      failureSteps(e4);
    }
  }
  function urlIsLocal(url) {
    assert("protocol" in url);
    const protocol = url.protocol;
    return protocol === "about:" || protocol === "blob:" || protocol === "data:";
  }
  function urlHasHttpsScheme(url) {
    return typeof url === "string" && url[5] === ":" && url[0] === "h" && url[1] === "t" && url[2] === "t" && url[3] === "p" && url[4] === "s" || url.protocol === "https:";
  }
  function urlIsHttpHttpsScheme(url) {
    assert("protocol" in url);
    const protocol = url.protocol;
    return protocol === "http:" || protocol === "https:";
  }
  function simpleRangeHeaderValue(value, allowWhitespace) {
    const data2 = value;
    if (!data2.startsWith("bytes")) {
      return "failure";
    }
    const position = { position: 5 };
    if (allowWhitespace) {
      collectASequenceOfCodePoints(
        (char) => char === "	" || char === " ",
        data2,
        position
      );
    }
    if (data2.charCodeAt(position.position) !== 61) {
      return "failure";
    }
    position.position++;
    if (allowWhitespace) {
      collectASequenceOfCodePoints(
        (char) => char === "	" || char === " ",
        data2,
        position
      );
    }
    const rangeStart = collectASequenceOfCodePoints(
      (char) => {
        const code = char.charCodeAt(0);
        return code >= 48 && code <= 57;
      },
      data2,
      position
    );
    const rangeStartValue = rangeStart.length ? Number(rangeStart) : null;
    if (allowWhitespace) {
      collectASequenceOfCodePoints(
        (char) => char === "	" || char === " ",
        data2,
        position
      );
    }
    if (data2.charCodeAt(position.position) !== 45) {
      return "failure";
    }
    position.position++;
    if (allowWhitespace) {
      collectASequenceOfCodePoints(
        (char) => char === "	" || char === " ",
        data2,
        position
      );
    }
    const rangeEnd = collectASequenceOfCodePoints(
      (char) => {
        const code = char.charCodeAt(0);
        return code >= 48 && code <= 57;
      },
      data2,
      position
    );
    const rangeEndValue = rangeEnd.length ? Number(rangeEnd) : null;
    if (position.position < data2.length) {
      return "failure";
    }
    if (rangeEndValue === null && rangeStartValue === null) {
      return "failure";
    }
    if (rangeStartValue > rangeEndValue) {
      return "failure";
    }
    return { rangeStartValue, rangeEndValue };
  }
  function buildContentRange(rangeStart, rangeEnd, fullLength) {
    let contentRange = "bytes ";
    contentRange += isomorphicEncode(`${rangeStart}`);
    contentRange += "-";
    contentRange += isomorphicEncode(`${rangeEnd}`);
    contentRange += "/";
    contentRange += isomorphicEncode(`${fullLength}`);
    return contentRange;
  }
  class InflateStream extends Transform2 {
    #zlibOptions;
    /** @param {zlib.ZlibOptions} [zlibOptions] */
    constructor(zlibOptions) {
      super();
      this.#zlibOptions = zlibOptions;
    }
    _transform(chunk2, encoding2, callback) {
      if (!this._inflateStream) {
        if (chunk2.length === 0) {
          callback();
          return;
        }
        this._inflateStream = (chunk2[0] & 15) === 8 ? zlib2.createInflate(this.#zlibOptions) : zlib2.createInflateRaw(this.#zlibOptions);
        this._inflateStream.on("data", this.push.bind(this));
        this._inflateStream.on("end", () => this.push(null));
        this._inflateStream.on("error", (err) => this.destroy(err));
      }
      this._inflateStream.write(chunk2, encoding2, callback);
    }
    _final(callback) {
      if (this._inflateStream) {
        this._inflateStream.end();
        this._inflateStream = null;
      }
      callback();
    }
  }
  function createInflate(zlibOptions) {
    return new InflateStream(zlibOptions);
  }
  function extractMimeType(headers2) {
    let charset = null;
    let essence = null;
    let mimeType = null;
    const values = getDecodeSplit("content-type", headers2);
    if (values === null) {
      return "failure";
    }
    for (const value of values) {
      const temporaryMimeType = parseMIMEType(value);
      if (temporaryMimeType === "failure" || temporaryMimeType.essence === "*/*") {
        continue;
      }
      mimeType = temporaryMimeType;
      if (mimeType.essence !== essence) {
        charset = null;
        if (mimeType.parameters.has("charset")) {
          charset = mimeType.parameters.get("charset");
        }
        essence = mimeType.essence;
      } else if (!mimeType.parameters.has("charset") && charset !== null) {
        mimeType.parameters.set("charset", charset);
      }
    }
    if (mimeType == null) {
      return "failure";
    }
    return mimeType;
  }
  function gettingDecodingSplitting(value) {
    const input = value;
    const position = { position: 0 };
    const values = [];
    let temporaryValue = "";
    while (position.position < input.length) {
      temporaryValue += collectASequenceOfCodePoints(
        (char) => char !== '"' && char !== ",",
        input,
        position
      );
      if (position.position < input.length) {
        if (input.charCodeAt(position.position) === 34) {
          temporaryValue += collectAnHTTPQuotedString(
            input,
            position
          );
          if (position.position < input.length) {
            continue;
          }
        } else {
          assert(input.charCodeAt(position.position) === 44);
          position.position++;
        }
      }
      temporaryValue = removeChars(temporaryValue, true, true, (char) => char === 9 || char === 32);
      values.push(temporaryValue);
      temporaryValue = "";
    }
    return values;
  }
  function getDecodeSplit(name, list2) {
    const value = list2.get(name, true);
    if (value === null) {
      return null;
    }
    return gettingDecodingSplitting(value);
  }
  class EnvironmentSettingsObjectBase {
    get baseUrl() {
      return getGlobalOrigin();
    }
    get origin() {
      return this.baseUrl?.origin;
    }
    policyContainer = makePolicyContainer();
  }
  class EnvironmentSettingsObject {
    settingsObject = new EnvironmentSettingsObjectBase();
  }
  const environmentSettingsObject = new EnvironmentSettingsObject();
  util$4 = {
    isAborted,
    isCancelled,
    isValidEncodedURL,
    ReadableStreamFrom,
    tryUpgradeRequestToAPotentiallyTrustworthyURL,
    clampAndCoarsenConnectionTimingInfo,
    coarsenedSharedCurrentTime,
    determineRequestsReferrer,
    makePolicyContainer,
    clonePolicyContainer,
    appendFetchMetadata,
    appendRequestOriginHeader,
    TAOCheck,
    corsCheck,
    crossOriginResourcePolicyCheck,
    createOpaqueTimingInfo,
    setRequestReferrerPolicyOnRedirect,
    isValidHTTPToken,
    requestBadPort,
    requestCurrentURL,
    responseURL,
    responseLocationURL,
    isURLPotentiallyTrustworthy,
    isValidReasonPhrase,
    sameOrigin,
    normalizeMethod,
    iteratorMixin,
    createIterator,
    isValidHeaderName,
    isValidHeaderValue,
    isErrorLike,
    fullyReadBody,
    readableStreamClose,
    urlIsLocal,
    urlHasHttpsScheme,
    urlIsHttpHttpsScheme,
    readAllBytes,
    simpleRangeHeaderValue,
    buildContentRange,
    createInflate,
    extractMimeType,
    getDecodeSplit,
    environmentSettingsObject,
    isOriginIPPotentiallyTrustworthy
  };
  return util$4;
}
var formdata;
var hasRequiredFormdata;
function requireFormdata() {
  if (hasRequiredFormdata) return formdata;
  hasRequiredFormdata = 1;
  const { iteratorMixin } = requireUtil$4();
  const { kEnumerableProperty } = requireUtil$5();
  const { webidl } = requireWebidl();
  const nodeUtil2 = import_node_util.default;
  class FormData2 {
    #state = [];
    constructor(form = void 0) {
      webidl.util.markAsUncloneable(this);
      if (form !== void 0) {
        throw webidl.errors.conversionFailed({
          prefix: "FormData constructor",
          argument: "Argument 1",
          types: ["undefined"]
        });
      }
    }
    append(name, value, filename = void 0) {
      webidl.brandCheck(this, FormData2);
      const prefix = "FormData.append";
      webidl.argumentLengthCheck(arguments, 2, prefix);
      name = webidl.converters.USVString(name);
      if (arguments.length === 3 || webidl.is.Blob(value)) {
        value = webidl.converters.Blob(value, prefix, "value");
        if (filename !== void 0) {
          filename = webidl.converters.USVString(filename);
        }
      } else {
        value = webidl.converters.USVString(value);
      }
      const entry = makeEntry(name, value, filename);
      this.#state.push(entry);
    }
    delete(name) {
      webidl.brandCheck(this, FormData2);
      const prefix = "FormData.delete";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      name = webidl.converters.USVString(name);
      this.#state = this.#state.filter((entry) => entry.name !== name);
    }
    get(name) {
      webidl.brandCheck(this, FormData2);
      const prefix = "FormData.get";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      name = webidl.converters.USVString(name);
      const idx = this.#state.findIndex((entry) => entry.name === name);
      if (idx === -1) {
        return null;
      }
      return this.#state[idx].value;
    }
    getAll(name) {
      webidl.brandCheck(this, FormData2);
      const prefix = "FormData.getAll";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      name = webidl.converters.USVString(name);
      return this.#state.filter((entry) => entry.name === name).map((entry) => entry.value);
    }
    has(name) {
      webidl.brandCheck(this, FormData2);
      const prefix = "FormData.has";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      name = webidl.converters.USVString(name);
      return this.#state.findIndex((entry) => entry.name === name) !== -1;
    }
    set(name, value, filename = void 0) {
      webidl.brandCheck(this, FormData2);
      const prefix = "FormData.set";
      webidl.argumentLengthCheck(arguments, 2, prefix);
      name = webidl.converters.USVString(name);
      if (arguments.length === 3 || webidl.is.Blob(value)) {
        value = webidl.converters.Blob(value, prefix, "value");
        if (filename !== void 0) {
          filename = webidl.converters.USVString(filename);
        }
      } else {
        value = webidl.converters.USVString(value);
      }
      const entry = makeEntry(name, value, filename);
      const idx = this.#state.findIndex((entry2) => entry2.name === name);
      if (idx !== -1) {
        this.#state = [
          ...this.#state.slice(0, idx),
          entry,
          ...this.#state.slice(idx + 1).filter((entry2) => entry2.name !== name)
        ];
      } else {
        this.#state.push(entry);
      }
    }
    [nodeUtil2.inspect.custom](depth, options) {
      const state2 = this.#state.reduce((a4, b4) => {
        if (a4[b4.name]) {
          if (Array.isArray(a4[b4.name])) {
            a4[b4.name].push(b4.value);
          } else {
            a4[b4.name] = [a4[b4.name], b4.value];
          }
        } else {
          a4[b4.name] = b4.value;
        }
        return a4;
      }, { __proto__: null });
      options.depth ??= depth;
      options.colors ??= true;
      const output = nodeUtil2.formatWithOptions(options, state2);
      return `FormData ${output.slice(output.indexOf("]") + 2)}`;
    }
    /**
     * @param {FormData} formData
     */
    static getFormDataState(formData) {
      return formData.#state;
    }
    /**
     * @param {FormData} formData
     * @param {any[]} newState
     */
    static setFormDataState(formData, newState) {
      formData.#state = newState;
    }
  }
  const { getFormDataState, setFormDataState } = FormData2;
  Reflect.deleteProperty(FormData2, "getFormDataState");
  Reflect.deleteProperty(FormData2, "setFormDataState");
  iteratorMixin("FormData", FormData2, getFormDataState, "name", "value");
  Object.defineProperties(FormData2.prototype, {
    append: kEnumerableProperty,
    delete: kEnumerableProperty,
    get: kEnumerableProperty,
    getAll: kEnumerableProperty,
    has: kEnumerableProperty,
    set: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "FormData",
      configurable: true
    }
  });
  function makeEntry(name, value, filename) {
    if (typeof value === "string") ;
    else {
      if (!webidl.is.File(value)) {
        value = new File([value], "blob", { type: value.type });
      }
      if (filename !== void 0) {
        const options = {
          type: value.type,
          lastModified: value.lastModified
        };
        value = new File([value], filename, options);
      }
    }
    return { name, value };
  }
  webidl.is.FormData = webidl.util.MakeTypeAssertion(FormData2);
  formdata = { FormData: FormData2, makeEntry, setFormDataState };
  return formdata;
}
var formdataParser;
var hasRequiredFormdataParser;
function requireFormdataParser() {
  if (hasRequiredFormdataParser) return formdataParser;
  hasRequiredFormdataParser = 1;
  const { bufferToLowerCasedHeaderName } = requireUtil$5();
  const { HTTP_TOKEN_CODEPOINTS } = requireDataUrl();
  const { makeEntry } = requireFormdata();
  const { webidl } = requireWebidl();
  const assert = import_node_assert.default;
  const { isomorphicDecode } = requireInfra();
  const { utf8DecodeBytes } = requireEncoding();
  const dd = Buffer.from("--");
  const decoder = new TextDecoder();
  function isAsciiString(chars) {
    for (let i4 = 0; i4 < chars.length; ++i4) {
      if ((chars.charCodeAt(i4) & -128) !== 0) {
        return false;
      }
    }
    return true;
  }
  function validateBoundary(boundary) {
    const length = boundary.length;
    if (length < 27 || length > 70) {
      return false;
    }
    for (let i4 = 0; i4 < length; ++i4) {
      const cp = boundary.charCodeAt(i4);
      if (!(cp >= 48 && cp <= 57 || cp >= 65 && cp <= 90 || cp >= 97 && cp <= 122 || cp === 39 || cp === 45 || cp === 95)) {
        return false;
      }
    }
    return true;
  }
  function multipartFormDataParser(input, mimeType) {
    assert(mimeType !== "failure" && mimeType.essence === "multipart/form-data");
    const boundaryString = mimeType.parameters.get("boundary");
    if (boundaryString === void 0) {
      throw parsingError("missing boundary in content-type header");
    }
    const boundary = Buffer.from(`--${boundaryString}`, "utf8");
    const entryList = [];
    const position = { position: 0 };
    const firstBoundaryIndex = input.indexOf(boundary);
    if (firstBoundaryIndex === -1) {
      throw parsingError("no boundary found in multipart body");
    }
    position.position = firstBoundaryIndex;
    while (true) {
      if (input.subarray(position.position, position.position + boundary.length).equals(boundary)) {
        position.position += boundary.length;
      } else {
        throw parsingError("expected a value starting with -- and the boundary");
      }
      if (bufferStartsWith(input, dd, position)) {
        return entryList;
      }
      if (input[position.position] !== 13 || input[position.position + 1] !== 10) {
        throw parsingError("expected CRLF");
      }
      position.position += 2;
      const result = parseMultipartFormDataHeaders(input, position);
      let { name, filename, contentType, encoding: encoding2 } = result;
      position.position += 2;
      let body2;
      {
        const boundaryIndex = input.indexOf(boundary.subarray(2), position.position);
        if (boundaryIndex === -1) {
          throw parsingError("expected boundary after body");
        }
        body2 = input.subarray(position.position, boundaryIndex - 4);
        position.position += body2.length;
        if (encoding2 === "base64") {
          body2 = Buffer.from(body2.toString(), "base64");
        }
      }
      if (input[position.position] !== 13 || input[position.position + 1] !== 10) {
        throw parsingError("expected CRLF");
      } else {
        position.position += 2;
      }
      let value;
      if (filename !== null) {
        contentType ??= "text/plain";
        if (!isAsciiString(contentType)) {
          contentType = "";
        }
        value = new File([body2], filename, { type: contentType });
      } else {
        value = utf8DecodeBytes(Buffer.from(body2));
      }
      assert(webidl.is.USVString(name));
      assert(typeof value === "string" && webidl.is.USVString(value) || webidl.is.File(value));
      entryList.push(makeEntry(name, value, filename));
    }
  }
  function parseContentDispositionAttribute(input, position) {
    if (input[position.position] === 59) {
      position.position++;
    }
    collectASequenceOfBytes(
      (char) => char === 32 || char === 9,
      input,
      position
    );
    const attributeName = collectASequenceOfBytes(
      (char) => isToken(char) && char !== 61 && char !== 42,
      // not = or *
      input,
      position
    );
    if (attributeName.length === 0) {
      return null;
    }
    const attrNameStr = attributeName.toString("ascii").toLowerCase();
    const isExtended = input[position.position] === 42;
    if (isExtended) {
      position.position++;
    }
    if (input[position.position] !== 61) {
      return null;
    }
    position.position++;
    collectASequenceOfBytes(
      (char) => char === 32 || char === 9,
      input,
      position
    );
    let value;
    if (isExtended) {
      const headerValue = collectASequenceOfBytes(
        (char) => char !== 32 && char !== 13 && char !== 10 && char !== 59,
        // not space, CRLF, or ;
        input,
        position
      );
      if (headerValue[0] !== 117 && headerValue[0] !== 85 || // u or U
      headerValue[1] !== 116 && headerValue[1] !== 84 || // t or T
      headerValue[2] !== 102 && headerValue[2] !== 70 || // f or F
      headerValue[3] !== 45 || // -
      headerValue[4] !== 56) {
        throw parsingError("unknown encoding, expected utf-8''");
      }
      value = decodeURIComponent(decoder.decode(headerValue.subarray(7)));
    } else if (input[position.position] === 34) {
      position.position++;
      const quotedValue = collectASequenceOfBytes(
        (char) => char !== 10 && char !== 13 && char !== 34,
        // not LF, CR, or "
        input,
        position
      );
      if (input[position.position] !== 34) {
        throw parsingError("Closing quote not found");
      }
      position.position++;
      value = decoder.decode(quotedValue).replace(/%0A/ig, "\n").replace(/%0D/ig, "\r").replace(/%22/g, '"');
    } else {
      const tokenValue = collectASequenceOfBytes(
        (char) => isToken(char) && char !== 59,
        // not ;
        input,
        position
      );
      value = decoder.decode(tokenValue);
    }
    return { name: attrNameStr, value };
  }
  function parseMultipartFormDataHeaders(input, position) {
    let name = null;
    let filename = null;
    let contentType = null;
    let encoding2 = null;
    while (true) {
      if (input[position.position] === 13 && input[position.position + 1] === 10) {
        if (name === null) {
          throw parsingError("header name is null");
        }
        return { name, filename, contentType, encoding: encoding2 };
      }
      let headerName = collectASequenceOfBytes(
        (char) => char !== 10 && char !== 13 && char !== 58,
        input,
        position
      );
      headerName = removeChars(headerName, true, true, (char) => char === 9 || char === 32);
      if (!HTTP_TOKEN_CODEPOINTS.test(headerName.toString())) {
        throw parsingError("header name does not match the field-name token production");
      }
      if (input[position.position] !== 58) {
        throw parsingError("expected :");
      }
      position.position++;
      collectASequenceOfBytes(
        (char) => char === 32 || char === 9,
        input,
        position
      );
      switch (bufferToLowerCasedHeaderName(headerName)) {
        case "content-disposition": {
          name = filename = null;
          const dispositionType = collectASequenceOfBytes(
            (char) => isToken(char),
            input,
            position
          );
          if (dispositionType.toString("ascii").toLowerCase() !== "form-data") {
            throw parsingError("expected form-data for content-disposition header");
          }
          while (position.position < input.length && input[position.position] !== 13 && input[position.position + 1] !== 10) {
            const attribute = parseContentDispositionAttribute(input, position);
            if (!attribute) {
              break;
            }
            if (attribute.name === "name") {
              name = attribute.value;
            } else if (attribute.name === "filename") {
              filename = attribute.value;
            }
          }
          if (name === null) {
            throw parsingError("name attribute is required in content-disposition header");
          }
          break;
        }
        case "content-type": {
          let headerValue = collectASequenceOfBytes(
            (char) => char !== 10 && char !== 13,
            input,
            position
          );
          headerValue = removeChars(headerValue, false, true, (char) => char === 9 || char === 32);
          contentType = isomorphicDecode(headerValue);
          break;
        }
        case "content-transfer-encoding": {
          let headerValue = collectASequenceOfBytes(
            (char) => char !== 10 && char !== 13,
            input,
            position
          );
          headerValue = removeChars(headerValue, false, true, (char) => char === 9 || char === 32);
          encoding2 = isomorphicDecode(headerValue);
          break;
        }
        default: {
          collectASequenceOfBytes(
            (char) => char !== 10 && char !== 13,
            input,
            position
          );
        }
      }
      if (input[position.position] !== 13 && input[position.position + 1] !== 10) {
        throw parsingError("expected CRLF");
      } else {
        position.position += 2;
      }
    }
  }
  function collectASequenceOfBytes(condition, input, position) {
    let start = position.position;
    while (start < input.length && condition(input[start])) {
      ++start;
    }
    return input.subarray(position.position, position.position = start);
  }
  function removeChars(buf, leading, trailing, predicate) {
    let lead = 0;
    let trail = buf.length - 1;
    if (leading) {
      while (lead < buf.length && predicate(buf[lead])) lead++;
    }
    {
      while (trail > 0 && predicate(buf[trail])) trail--;
    }
    return lead === 0 && trail === buf.length - 1 ? buf : buf.subarray(lead, trail + 1);
  }
  function bufferStartsWith(buffer, start, position) {
    if (buffer.length < start.length) {
      return false;
    }
    for (let i4 = 0; i4 < start.length; i4++) {
      if (start[i4] !== buffer[position.position + i4]) {
        return false;
      }
    }
    return true;
  }
  function parsingError(cause) {
    return new TypeError("Failed to parse body as FormData.", { cause: new TypeError(cause) });
  }
  function isCTL(char) {
    return char <= 31 || char === 127;
  }
  function isTSpecial(char) {
    return char === 40 || // (
    char === 41 || // )
    char === 60 || // <
    char === 62 || // >
    char === 64 || // @
    char === 44 || // ,
    char === 59 || // ;
    char === 58 || // :
    char === 92 || // \
    char === 34 || // "
    char === 47 || // /
    char === 91 || // [
    char === 93 || // ]
    char === 63 || // ?
    char === 61;
  }
  function isToken(char) {
    return char <= 127 && // ascii
    char !== 32 && // space
    char !== 9 && !isCTL(char) && !isTSpecial(char);
  }
  formdataParser = {
    multipartFormDataParser,
    validateBoundary
  };
  return formdataParser;
}
var promise;
var hasRequiredPromise;
function requirePromise() {
  if (hasRequiredPromise) return promise;
  hasRequiredPromise = 1;
  function createDeferredPromise() {
    let res;
    let rej;
    const promise2 = new Promise((resolve, reject) => {
      res = resolve;
      rej = reject;
    });
    return { promise: promise2, resolve: res, reject: rej };
  }
  promise = {
    createDeferredPromise
  };
  return promise;
}
var body;
var hasRequiredBody;
function requireBody() {
  if (hasRequiredBody) return body;
  hasRequiredBody = 1;
  const util2 = requireUtil$5();
  const {
    ReadableStreamFrom,
    readableStreamClose,
    fullyReadBody,
    extractMimeType
  } = requireUtil$4();
  const { FormData: FormData2, setFormDataState } = requireFormdata();
  const { webidl } = requireWebidl();
  const assert = import_node_assert.default;
  const { isErrored, isDisturbed } = import_node_stream.default;
  const { isArrayBuffer } = import_types3.default;
  const { serializeAMimeType } = requireDataUrl();
  const { multipartFormDataParser } = requireFormdataParser();
  const { createDeferredPromise } = requirePromise();
  const { parseJSONFromBytes } = requireInfra();
  const { utf8DecodeBytes } = requireEncoding();
  const { runtimeFeatures: runtimeFeatures2 } = requireRuntimeFeatures();
  const random2 = runtimeFeatures2.has("crypto") ? import_node_crypto2.default.randomInt : (max) => Math.floor(Math.random() * max);
  const textEncoder2 = new TextEncoder();
  function noop2() {
  }
  const streamRegistry = new FinalizationRegistry((weakRef) => {
    const stream = weakRef.deref();
    if (stream && !stream.locked && !isDisturbed(stream) && !isErrored(stream)) {
      stream.cancel("Response object has been garbage collected").catch(noop2);
    }
  });
  function extractBody(object, keepalive = false) {
    let stream = null;
    if (webidl.is.ReadableStream(object)) {
      stream = object;
    } else if (webidl.is.Blob(object)) {
      stream = object.stream();
    } else {
      stream = new ReadableStream({
        pull(controller) {
          const buffer = typeof source === "string" ? textEncoder2.encode(source) : source;
          if (buffer.byteLength) {
            controller.enqueue(buffer);
          }
          queueMicrotask(() => readableStreamClose(controller));
        },
        start() {
        },
        type: "bytes"
      });
    }
    assert(webidl.is.ReadableStream(stream));
    let action = null;
    let source = null;
    let length = null;
    let type = null;
    if (typeof object === "string") {
      source = object;
      type = "text/plain;charset=UTF-8";
    } else if (webidl.is.URLSearchParams(object)) {
      source = object.toString();
      type = "application/x-www-form-urlencoded;charset=UTF-8";
    } else if (webidl.is.BufferSource(object)) {
      source = isArrayBuffer(object) ? new Uint8Array(object.slice()) : new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));
    } else if (webidl.is.FormData(object)) {
      const boundary = `----formdata-undici-0${`${random2(1e11)}`.padStart(11, "0")}`;
      const prefix = `--${boundary}\r
Content-Disposition: form-data`;
      const formdataEscape = (str) => str.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
      const normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, "\r\n");
      const blobParts = [];
      const rn = new Uint8Array([13, 10]);
      length = 0;
      let hasUnknownSizeValue = false;
      for (const [name, value] of object) {
        if (typeof value === "string") {
          const chunk3 = textEncoder2.encode(prefix + `; name="${formdataEscape(normalizeLinefeeds(name))}"\r
\r
${normalizeLinefeeds(value)}\r
`);
          blobParts.push(chunk3);
          length += chunk3.byteLength;
        } else {
          const chunk3 = textEncoder2.encode(`${prefix}; name="${formdataEscape(normalizeLinefeeds(name))}"` + (value.name ? `; filename="${formdataEscape(value.name)}"` : "") + `\r
Content-Type: ${value.type || "application/octet-stream"}\r
\r
`);
          blobParts.push(chunk3, value, rn);
          if (typeof value.size === "number") {
            length += chunk3.byteLength + value.size + rn.byteLength;
          } else {
            hasUnknownSizeValue = true;
          }
        }
      }
      const chunk2 = textEncoder2.encode(`--${boundary}--\r
`);
      blobParts.push(chunk2);
      length += chunk2.byteLength;
      if (hasUnknownSizeValue) {
        length = null;
      }
      source = object;
      action = async function* () {
        for (const part of blobParts) {
          if (part.stream) {
            yield* part.stream();
          } else {
            yield part;
          }
        }
      };
      type = `multipart/form-data; boundary=${boundary}`;
    } else if (webidl.is.Blob(object)) {
      source = object;
      length = object.size;
      if (object.type) {
        type = object.type;
      }
    } else if (typeof object[Symbol.asyncIterator] === "function") {
      if (keepalive) {
        throw new TypeError("keepalive");
      }
      if (util2.isDisturbed(object) || object.locked) {
        throw new TypeError(
          "Response body object should not be disturbed or locked"
        );
      }
      stream = webidl.is.ReadableStream(object) ? object : ReadableStreamFrom(object);
    }
    if (typeof source === "string" || util2.isBuffer(source)) {
      length = Buffer.byteLength(source);
    }
    if (action != null) {
      let iterator;
      stream = new ReadableStream({
        start() {
          iterator = action(object)[Symbol.asyncIterator]();
        },
        pull(controller) {
          return iterator.next().then(({ value, done }) => {
            if (done) {
              queueMicrotask(() => {
                controller.close();
                controller.byobRequest?.respond(0);
              });
            } else {
              if (!isErrored(stream)) {
                const buffer = new Uint8Array(value);
                if (buffer.byteLength) {
                  controller.enqueue(buffer);
                }
              }
            }
            return controller.desiredSize > 0;
          });
        },
        cancel(reason) {
          return iterator.return();
        },
        type: "bytes"
      });
    }
    const body2 = { stream, source, length };
    return [body2, type];
  }
  function safelyExtractBody(object, keepalive = false) {
    if (webidl.is.ReadableStream(object)) {
      assert(!util2.isDisturbed(object), "The body has already been consumed.");
      assert(!object.locked, "The stream is locked.");
    }
    return extractBody(object, keepalive);
  }
  function cloneBody(body2) {
    const { 0: out1, 1: out2 } = body2.stream.tee();
    body2.stream = out1;
    return {
      stream: out2,
      length: body2.length,
      source: body2.source
    };
  }
  function bodyMixinMethods(instance, getInternalState) {
    const methods = {
      blob() {
        return consumeBody(this, (bytes) => {
          let mimeType = bodyMimeType(getInternalState(this));
          if (mimeType === null) {
            mimeType = "";
          } else if (mimeType) {
            mimeType = serializeAMimeType(mimeType);
          }
          return new Blob([bytes], { type: mimeType });
        }, instance, getInternalState);
      },
      arrayBuffer() {
        return consumeBody(this, (bytes) => {
          return new Uint8Array(bytes).buffer;
        }, instance, getInternalState);
      },
      text() {
        return consumeBody(this, utf8DecodeBytes, instance, getInternalState);
      },
      json() {
        return consumeBody(this, parseJSONFromBytes, instance, getInternalState);
      },
      formData() {
        return consumeBody(this, (value) => {
          const mimeType = bodyMimeType(getInternalState(this));
          if (mimeType !== null) {
            switch (mimeType.essence) {
              case "multipart/form-data": {
                const parsed = multipartFormDataParser(value, mimeType);
                const fd = new FormData2();
                setFormDataState(fd, parsed);
                return fd;
              }
              case "application/x-www-form-urlencoded": {
                const entries = new URLSearchParams(value.toString());
                const fd = new FormData2();
                for (const [name, value2] of entries) {
                  fd.append(name, value2);
                }
                return fd;
              }
            }
          }
          throw new TypeError(
            'Content-Type was not one of "multipart/form-data" or "application/x-www-form-urlencoded".'
          );
        }, instance, getInternalState);
      },
      bytes() {
        return consumeBody(this, (bytes) => {
          return new Uint8Array(bytes);
        }, instance, getInternalState);
      }
    };
    return methods;
  }
  function mixinBody(prototype, getInternalState) {
    Object.assign(prototype.prototype, bodyMixinMethods(prototype, getInternalState));
  }
  function consumeBody(object, convertBytesToJSValue, instance, getInternalState) {
    try {
      webidl.brandCheck(object, instance);
    } catch (e4) {
      return Promise.reject(e4);
    }
    const state2 = getInternalState(object);
    if (bodyUnusable(state2)) {
      return Promise.reject(new TypeError("Body is unusable: Body has already been read"));
    }
    if (state2.aborted) {
      return Promise.reject(new DOMException("The operation was aborted.", "AbortError"));
    }
    const promise2 = createDeferredPromise();
    const errorSteps = promise2.reject;
    const successSteps = (data2) => {
      try {
        promise2.resolve(convertBytesToJSValue(data2));
      } catch (e4) {
        errorSteps(e4);
      }
    };
    if (state2.body == null) {
      successSteps(Buffer.allocUnsafe(0));
      return promise2.promise;
    }
    fullyReadBody(state2.body, successSteps, errorSteps);
    return promise2.promise;
  }
  function bodyUnusable(object) {
    const body2 = object.body;
    return body2 != null && (body2.stream.locked || util2.isDisturbed(body2.stream));
  }
  function bodyMimeType(requestOrResponse) {
    const headers2 = requestOrResponse.headersList;
    const mimeType = extractMimeType(headers2);
    if (mimeType === "failure") {
      return null;
    }
    return mimeType;
  }
  body = {
    extractBody,
    safelyExtractBody,
    cloneBody,
    mixinBody,
    streamRegistry,
    bodyUnusable
  };
  return body;
}
var clientH1;
var hasRequiredClientH1;
function requireClientH1() {
  if (hasRequiredClientH1) return clientH1;
  hasRequiredClientH1 = 1;
  const assert = import_node_assert.default;
  const util2 = requireUtil$5();
  const { channels } = requireDiagnostics();
  const timers2 = requireTimers();
  const {
    RequestContentLengthMismatchError,
    ResponseContentLengthMismatchError,
    RequestAbortedError,
    HeadersTimeoutError,
    HeadersOverflowError,
    SocketError,
    InformationalError,
    BodyTimeoutError,
    HTTPParserError,
    ResponseExceededMaxSizeError
  } = requireErrors();
  const {
    kUrl,
    kReset,
    kClient,
    kParser,
    kBlocking,
    kRunning,
    kPending,
    kSize,
    kWriting,
    kQueue,
    kNoRef,
    kKeepAliveDefaultTimeout,
    kHostHeader,
    kPendingIdx,
    kRunningIdx,
    kError,
    kPipelining,
    kSocket,
    kKeepAliveTimeoutValue,
    kMaxHeadersSize,
    kKeepAliveMaxTimeout,
    kKeepAliveTimeoutThreshold,
    kHeadersTimeout,
    kBodyTimeout,
    kStrictContentLength,
    kMaxRequests,
    kCounter,
    kMaxResponseSize,
    kOnError,
    kResume,
    kHTTPContext,
    kClosed
  } = requireSymbols();
  const constants2 = requireConstants$3();
  const EMPTY_BUF = Buffer.alloc(0);
  const FastBuffer = Buffer[Symbol.species];
  const removeAllListeners = util2.removeAllListeners;
  let extractBody;
  function lazyllhttp() {
    const llhttpWasmData = process.env.JEST_WORKER_ID ? requireLlhttpWasm() : void 0;
    let mod;
    let useWasmSIMD = process.arch !== "ppc64";
    if (process.env.UNDICI_NO_WASM_SIMD === "1") {
      useWasmSIMD = true;
    } else if (process.env.UNDICI_NO_WASM_SIMD === "0") {
      useWasmSIMD = false;
    }
    if (useWasmSIMD) {
      try {
        mod = new WebAssembly.Module(requireLlhttp_simdWasm());
      } catch {
      }
    }
    if (!mod) {
      mod = new WebAssembly.Module(llhttpWasmData || requireLlhttpWasm());
    }
    return new WebAssembly.Instance(mod, {
      env: {
        /**
         * @param {number} p
         * @param {number} at
         * @param {number} len
         * @returns {number}
         */
        wasm_on_url: (p4, at, len) => {
          return 0;
        },
        /**
         * @param {number} p
         * @param {number} at
         * @param {number} len
         * @returns {number}
         */
        wasm_on_status: (p4, at, len) => {
          assert(currentParser.ptr === p4);
          const start = at - currentBufferPtr + currentBufferRef.byteOffset;
          return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len));
        },
        /**
         * @param {number} p
         * @returns {number}
         */
        wasm_on_message_begin: (p4) => {
          assert(currentParser.ptr === p4);
          return currentParser.onMessageBegin();
        },
        /**
         * @param {number} p
         * @param {number} at
         * @param {number} len
         * @returns {number}
         */
        wasm_on_header_field: (p4, at, len) => {
          assert(currentParser.ptr === p4);
          const start = at - currentBufferPtr + currentBufferRef.byteOffset;
          return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len));
        },
        /**
         * @param {number} p
         * @param {number} at
         * @param {number} len
         * @returns {number}
         */
        wasm_on_header_value: (p4, at, len) => {
          assert(currentParser.ptr === p4);
          const start = at - currentBufferPtr + currentBufferRef.byteOffset;
          return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len));
        },
        /**
         * @param {number} p
         * @param {number} statusCode
         * @param {0|1} upgrade
         * @param {0|1} shouldKeepAlive
         * @returns {number}
         */
        wasm_on_headers_complete: (p4, statusCode, upgrade, shouldKeepAlive) => {
          assert(currentParser.ptr === p4);
          return currentParser.onHeadersComplete(statusCode, upgrade === 1, shouldKeepAlive === 1);
        },
        /**
         * @param {number} p
         * @param {number} at
         * @param {number} len
         * @returns {number}
         */
        wasm_on_body: (p4, at, len) => {
          assert(currentParser.ptr === p4);
          const start = at - currentBufferPtr + currentBufferRef.byteOffset;
          return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len));
        },
        /**
         * @param {number} p
         * @returns {number}
         */
        wasm_on_message_complete: (p4) => {
          assert(currentParser.ptr === p4);
          return currentParser.onMessageComplete();
        }
      }
    });
  }
  let llhttpInstance = null;
  let currentParser = null;
  let currentBufferRef = null;
  let currentBufferSize = 0;
  let currentBufferPtr = null;
  const USE_NATIVE_TIMER = 0;
  const USE_FAST_TIMER = 1;
  const TIMEOUT_HEADERS = 2 | USE_FAST_TIMER;
  const TIMEOUT_BODY = 4 | USE_FAST_TIMER;
  const TIMEOUT_KEEP_ALIVE = 8 | USE_NATIVE_TIMER;
  class Parser {
    /**
       * @param {import('./client.js')} client
       * @param {import('net').Socket} socket
       * @param {*} llhttp
       */
    constructor(client2, socket, { exports: exports$1 }) {
      this.llhttp = exports$1;
      this.ptr = this.llhttp.llhttp_alloc(constants2.TYPE.RESPONSE);
      this.client = client2;
      this.socket = socket;
      this.timeout = null;
      this.timeoutValue = null;
      this.timeoutType = null;
      this.statusCode = 0;
      this.statusText = "";
      this.upgrade = false;
      this.headers = [];
      this.headersSize = 0;
      this.headersMaxSize = client2[kMaxHeadersSize];
      this.shouldKeepAlive = false;
      this.paused = false;
      this.resume = this.resume.bind(this);
      this.bytesRead = 0;
      this.keepAlive = "";
      this.contentLength = "";
      this.connection = "";
      this.maxResponseSize = client2[kMaxResponseSize];
    }
    setTimeout(delay, type) {
      if (delay !== this.timeoutValue || type & USE_FAST_TIMER ^ this.timeoutType & USE_FAST_TIMER) {
        if (this.timeout) {
          timers2.clearTimeout(this.timeout);
          this.timeout = null;
        }
        if (delay) {
          if (type & USE_FAST_TIMER) {
            this.timeout = timers2.setFastTimeout(onParserTimeout, delay, new WeakRef(this));
          } else {
            this.timeout = setTimeout(onParserTimeout, delay, new WeakRef(this));
            this.timeout?.unref();
          }
        }
        this.timeoutValue = delay;
      } else if (this.timeout) {
        if (this.timeout.refresh) {
          this.timeout.refresh();
        }
      }
      this.timeoutType = type;
    }
    resume() {
      if (this.socket.destroyed || !this.paused) {
        return;
      }
      assert(this.ptr != null);
      assert(currentParser === null);
      this.llhttp.llhttp_resume(this.ptr);
      assert(this.timeoutType === TIMEOUT_BODY);
      if (this.timeout) {
        if (this.timeout.refresh) {
          this.timeout.refresh();
        }
      }
      this.paused = false;
      this.execute(this.socket.read() || EMPTY_BUF);
      this.readMore();
    }
    readMore() {
      while (!this.paused && this.ptr) {
        const chunk2 = this.socket.read();
        if (chunk2 === null) {
          break;
        }
        this.execute(chunk2);
      }
    }
    /**
     * @param {Buffer} chunk
     */
    execute(chunk2) {
      assert(currentParser === null);
      assert(this.ptr != null);
      assert(!this.paused);
      const { socket, llhttp } = this;
      if (chunk2.length > currentBufferSize) {
        if (currentBufferPtr) {
          llhttp.free(currentBufferPtr);
        }
        currentBufferSize = Math.ceil(chunk2.length / 4096) * 4096;
        currentBufferPtr = llhttp.malloc(currentBufferSize);
      }
      new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(chunk2);
      try {
        let ret;
        try {
          currentBufferRef = chunk2;
          currentParser = this;
          ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, chunk2.length);
        } finally {
          currentParser = null;
          currentBufferRef = null;
        }
        if (ret !== constants2.ERROR.OK) {
          const data2 = chunk2.subarray(llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr);
          if (ret === constants2.ERROR.PAUSED_UPGRADE) {
            this.onUpgrade(data2);
          } else if (ret === constants2.ERROR.PAUSED) {
            this.paused = true;
            socket.unshift(data2);
          } else {
            const ptr = llhttp.llhttp_get_error_reason(this.ptr);
            let message = "";
            if (ptr) {
              const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);
              message = "Response does not match the HTTP/1.1 protocol (" + Buffer.from(llhttp.memory.buffer, ptr, len).toString() + ")";
            }
            throw new HTTPParserError(message, constants2.ERROR[ret], data2);
          }
        }
      } catch (err) {
        util2.destroy(socket, err);
      }
    }
    destroy() {
      assert(currentParser === null);
      assert(this.ptr != null);
      this.llhttp.llhttp_free(this.ptr);
      this.ptr = null;
      this.timeout && timers2.clearTimeout(this.timeout);
      this.timeout = null;
      this.timeoutValue = null;
      this.timeoutType = null;
      this.paused = false;
    }
    /**
     * @param {Buffer} buf
     * @returns {0}
     */
    onStatus(buf) {
      this.statusText = buf.toString();
      return 0;
    }
    /**
     * @returns {0|-1}
     */
    onMessageBegin() {
      const { socket, client: client2 } = this;
      if (socket.destroyed) {
        return -1;
      }
      const request2 = client2[kQueue][client2[kRunningIdx]];
      if (!request2) {
        return -1;
      }
      request2.onResponseStarted();
      return 0;
    }
    /**
     * @param {Buffer} buf
     * @returns {number}
     */
    onHeaderField(buf) {
      const len = this.headers.length;
      if ((len & 1) === 0) {
        this.headers.push(buf);
      } else {
        this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
      }
      this.trackHeader(buf.length);
      return 0;
    }
    /**
     * @param {Buffer} buf
     * @returns {number}
     */
    onHeaderValue(buf) {
      let len = this.headers.length;
      if ((len & 1) === 1) {
        this.headers.push(buf);
        len += 1;
      } else {
        this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
      }
      const key = this.headers[len - 2];
      if (key.length === 10) {
        const headerName = util2.bufferToLowerCasedHeaderName(key);
        if (headerName === "keep-alive") {
          this.keepAlive += buf.toString();
        } else if (headerName === "connection") {
          this.connection += buf.toString();
        }
      } else if (key.length === 14 && util2.bufferToLowerCasedHeaderName(key) === "content-length") {
        this.contentLength += buf.toString();
      }
      this.trackHeader(buf.length);
      return 0;
    }
    /**
     * @param {number} len
     */
    trackHeader(len) {
      this.headersSize += len;
      if (this.headersSize >= this.headersMaxSize) {
        util2.destroy(this.socket, new HeadersOverflowError());
      }
    }
    /**
     * @param {Buffer} head
     */
    onUpgrade(head) {
      const { upgrade, client: client2, socket, headers: headers2, statusCode } = this;
      assert(upgrade);
      assert(client2[kSocket] === socket);
      assert(!socket.destroyed);
      assert(!this.paused);
      assert((headers2.length & 1) === 0);
      const request2 = client2[kQueue][client2[kRunningIdx]];
      assert(request2);
      assert(request2.upgrade || request2.method === "CONNECT");
      this.statusCode = 0;
      this.statusText = "";
      this.shouldKeepAlive = false;
      this.headers = [];
      this.headersSize = 0;
      socket.unshift(head);
      socket[kParser].destroy();
      socket[kParser] = null;
      socket[kClient] = null;
      socket[kError] = null;
      removeAllListeners(socket);
      client2[kSocket] = null;
      client2[kHTTPContext] = null;
      client2[kQueue][client2[kRunningIdx]++] = null;
      client2.emit("disconnect", client2[kUrl], [client2], new InformationalError("upgrade"));
      try {
        request2.onUpgrade(statusCode, headers2, socket);
      } catch (err) {
        util2.destroy(socket, err);
      }
      client2[kResume]();
    }
    /**
     * @param {number} statusCode
     * @param {boolean} upgrade
     * @param {boolean} shouldKeepAlive
     * @returns {number}
     */
    onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {
      const { client: client2, socket, headers: headers2, statusText } = this;
      if (socket.destroyed) {
        return -1;
      }
      const request2 = client2[kQueue][client2[kRunningIdx]];
      if (!request2) {
        return -1;
      }
      assert(!this.upgrade);
      assert(this.statusCode < 200);
      if (statusCode === 100) {
        util2.destroy(socket, new SocketError("bad response", util2.getSocketInfo(socket)));
        return -1;
      }
      if (upgrade && !request2.upgrade) {
        util2.destroy(socket, new SocketError("bad upgrade", util2.getSocketInfo(socket)));
        return -1;
      }
      assert(this.timeoutType === TIMEOUT_HEADERS);
      this.statusCode = statusCode;
      this.shouldKeepAlive = shouldKeepAlive || // Override llhttp value which does not allow keepAlive for HEAD.
      request2.method === "HEAD" && !socket[kReset] && this.connection.toLowerCase() === "keep-alive";
      if (this.statusCode >= 200) {
        const bodyTimeout = request2.bodyTimeout != null ? request2.bodyTimeout : client2[kBodyTimeout];
        this.setTimeout(bodyTimeout, TIMEOUT_BODY);
      } else if (this.timeout) {
        if (this.timeout.refresh) {
          this.timeout.refresh();
        }
      }
      if (request2.method === "CONNECT") {
        assert(client2[kRunning] === 1);
        this.upgrade = true;
        return 2;
      }
      if (upgrade) {
        assert(client2[kRunning] === 1);
        this.upgrade = true;
        return 2;
      }
      assert((this.headers.length & 1) === 0);
      this.headers = [];
      this.headersSize = 0;
      if (this.shouldKeepAlive && client2[kPipelining]) {
        const keepAliveTimeout = this.keepAlive ? util2.parseKeepAliveTimeout(this.keepAlive) : null;
        if (keepAliveTimeout != null) {
          const timeout = Math.min(
            keepAliveTimeout - client2[kKeepAliveTimeoutThreshold],
            client2[kKeepAliveMaxTimeout]
          );
          if (timeout <= 0) {
            socket[kReset] = true;
          } else {
            client2[kKeepAliveTimeoutValue] = timeout;
          }
        } else {
          client2[kKeepAliveTimeoutValue] = client2[kKeepAliveDefaultTimeout];
        }
      } else {
        socket[kReset] = true;
      }
      const pause = request2.onHeaders(statusCode, headers2, this.resume, statusText) === false;
      if (request2.aborted) {
        return -1;
      }
      if (request2.method === "HEAD") {
        return 1;
      }
      if (statusCode < 200) {
        return 1;
      }
      if (socket[kBlocking]) {
        socket[kBlocking] = false;
        client2[kResume]();
      }
      return pause ? constants2.ERROR.PAUSED : 0;
    }
    /**
     * @param {Buffer} buf
     * @returns {number}
     */
    onBody(buf) {
      const { client: client2, socket, statusCode, maxResponseSize } = this;
      if (socket.destroyed) {
        return -1;
      }
      const request2 = client2[kQueue][client2[kRunningIdx]];
      assert(request2);
      assert(this.timeoutType === TIMEOUT_BODY);
      if (this.timeout) {
        if (this.timeout.refresh) {
          this.timeout.refresh();
        }
      }
      assert(statusCode >= 200);
      if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {
        util2.destroy(socket, new ResponseExceededMaxSizeError());
        return -1;
      }
      this.bytesRead += buf.length;
      if (request2.onData(buf) === false) {
        return constants2.ERROR.PAUSED;
      }
      return 0;
    }
    /**
     * @returns {number}
     */
    onMessageComplete() {
      const { client: client2, socket, statusCode, upgrade, headers: headers2, contentLength, bytesRead, shouldKeepAlive } = this;
      if (socket.destroyed && (!statusCode || shouldKeepAlive)) {
        return -1;
      }
      if (upgrade) {
        return 0;
      }
      assert(statusCode >= 100);
      assert((this.headers.length & 1) === 0);
      const request2 = client2[kQueue][client2[kRunningIdx]];
      assert(request2);
      this.statusCode = 0;
      this.statusText = "";
      this.bytesRead = 0;
      this.contentLength = "";
      this.keepAlive = "";
      this.connection = "";
      this.headers = [];
      this.headersSize = 0;
      if (statusCode < 200) {
        return 0;
      }
      if (request2.method !== "HEAD" && contentLength && bytesRead !== parseInt(contentLength, 10)) {
        util2.destroy(socket, new ResponseContentLengthMismatchError());
        return -1;
      }
      request2.onComplete(headers2);
      client2[kQueue][client2[kRunningIdx]++] = null;
      if (socket[kWriting]) {
        assert(client2[kRunning] === 0);
        util2.destroy(socket, new InformationalError("reset"));
        return constants2.ERROR.PAUSED;
      } else if (!shouldKeepAlive) {
        util2.destroy(socket, new InformationalError("reset"));
        return constants2.ERROR.PAUSED;
      } else if (socket[kReset] && client2[kRunning] === 0) {
        util2.destroy(socket, new InformationalError("reset"));
        return constants2.ERROR.PAUSED;
      } else if (client2[kPipelining] == null || client2[kPipelining] === 1) {
        setImmediate(client2[kResume]);
      } else {
        client2[kResume]();
      }
      return 0;
    }
  }
  function onParserTimeout(parser) {
    const { socket, timeoutType, client: client2, paused } = parser.deref();
    if (timeoutType === TIMEOUT_HEADERS) {
      if (!socket[kWriting] || socket.writableNeedDrain || client2[kRunning] > 1) {
        assert(!paused, "cannot be paused while waiting for headers");
        util2.destroy(socket, new HeadersTimeoutError());
      }
    } else if (timeoutType === TIMEOUT_BODY) {
      if (!paused) {
        util2.destroy(socket, new BodyTimeoutError());
      }
    } else if (timeoutType === TIMEOUT_KEEP_ALIVE) {
      assert(client2[kRunning] === 0 && client2[kKeepAliveTimeoutValue]);
      util2.destroy(socket, new InformationalError("socket idle timeout"));
    }
  }
  function connectH1(client2, socket) {
    client2[kSocket] = socket;
    if (!llhttpInstance) {
      llhttpInstance = lazyllhttp();
    }
    if (socket.errored) {
      throw socket.errored;
    }
    if (socket.destroyed) {
      throw new SocketError("destroyed");
    }
    socket[kNoRef] = false;
    socket[kWriting] = false;
    socket[kReset] = false;
    socket[kBlocking] = false;
    socket[kParser] = new Parser(client2, socket, llhttpInstance);
    util2.addListener(socket, "error", onHttpSocketError);
    util2.addListener(socket, "readable", onHttpSocketReadable);
    util2.addListener(socket, "end", onHttpSocketEnd);
    util2.addListener(socket, "close", onHttpSocketClose);
    socket[kClosed] = false;
    socket.on("close", onSocketClose);
    return {
      version: "h1",
      defaultPipelining: 1,
      write(request2) {
        return writeH1(client2, request2);
      },
      resume() {
        resumeH1(client2);
      },
      /**
       * @param {Error|undefined} err
       * @param {() => void} callback
       */
      destroy(err, callback) {
        if (socket[kClosed]) {
          queueMicrotask(callback);
        } else {
          socket.on("close", callback);
          socket.destroy(err);
        }
      },
      /**
       * @returns {boolean}
       */
      get destroyed() {
        return socket.destroyed;
      },
      /**
       * @param {import('../core/request.js')} request
       * @returns {boolean}
       */
      busy(request2) {
        if (socket[kWriting] || socket[kReset] || socket[kBlocking]) {
          return true;
        }
        if (request2) {
          if (client2[kRunning] > 0 && !request2.idempotent) {
            return true;
          }
          if (client2[kRunning] > 0 && (request2.upgrade || request2.method === "CONNECT")) {
            return true;
          }
          if (client2[kRunning] > 0 && util2.bodyLength(request2.body) !== 0 && (util2.isStream(request2.body) || util2.isAsyncIterable(request2.body) || util2.isFormDataLike(request2.body))) {
            return true;
          }
        }
        return false;
      }
    };
  }
  function onHttpSocketError(err) {
    assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
    const parser = this[kParser];
    if (err.code === "ECONNRESET" && parser.statusCode && !parser.shouldKeepAlive) {
      parser.onMessageComplete();
      return;
    }
    this[kError] = err;
    this[kClient][kOnError](err);
  }
  function onHttpSocketReadable() {
    this[kParser]?.readMore();
  }
  function onHttpSocketEnd() {
    const parser = this[kParser];
    if (parser.statusCode && !parser.shouldKeepAlive) {
      parser.onMessageComplete();
      return;
    }
    util2.destroy(this, new SocketError("other side closed", util2.getSocketInfo(this)));
  }
  function onHttpSocketClose() {
    const parser = this[kParser];
    if (parser) {
      if (!this[kError] && parser.statusCode && !parser.shouldKeepAlive) {
        parser.onMessageComplete();
      }
      this[kParser].destroy();
      this[kParser] = null;
    }
    const err = this[kError] || new SocketError("closed", util2.getSocketInfo(this));
    const client2 = this[kClient];
    client2[kSocket] = null;
    client2[kHTTPContext] = null;
    if (client2.destroyed) {
      assert(client2[kPending] === 0);
      const requests = client2[kQueue].splice(client2[kRunningIdx]);
      for (let i4 = 0; i4 < requests.length; i4++) {
        const request2 = requests[i4];
        util2.errorRequest(client2, request2, err);
      }
    } else if (client2[kRunning] > 0 && err.code !== "UND_ERR_INFO") {
      const request2 = client2[kQueue][client2[kRunningIdx]];
      client2[kQueue][client2[kRunningIdx]++] = null;
      util2.errorRequest(client2, request2, err);
    }
    client2[kPendingIdx] = client2[kRunningIdx];
    assert(client2[kRunning] === 0);
    client2.emit("disconnect", client2[kUrl], [client2], err);
    client2[kResume]();
  }
  function onSocketClose() {
    this[kClosed] = true;
  }
  function resumeH1(client2) {
    const socket = client2[kSocket];
    if (socket && !socket.destroyed) {
      if (client2[kSize] === 0) {
        if (!socket[kNoRef] && socket.unref) {
          socket.unref();
          socket[kNoRef] = true;
        }
      } else if (socket[kNoRef] && socket.ref) {
        socket.ref();
        socket[kNoRef] = false;
      }
      if (client2[kSize] === 0) {
        if (socket[kParser].timeoutType !== TIMEOUT_KEEP_ALIVE) {
          socket[kParser].setTimeout(client2[kKeepAliveTimeoutValue], TIMEOUT_KEEP_ALIVE);
        }
      } else if (client2[kRunning] > 0 && socket[kParser].statusCode < 200) {
        if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {
          const request2 = client2[kQueue][client2[kRunningIdx]];
          const headersTimeout = request2.headersTimeout != null ? request2.headersTimeout : client2[kHeadersTimeout];
          socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);
        }
      }
    }
  }
  function shouldSendContentLength(method) {
    return method !== "GET" && method !== "HEAD" && method !== "OPTIONS" && method !== "TRACE" && method !== "CONNECT";
  }
  function writeH1(client2, request2) {
    const { method, path: path3, host, upgrade, blocking, reset } = request2;
    let { body: body2, headers: headers2, contentLength } = request2;
    const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH" || method === "QUERY" || method === "PROPFIND" || method === "PROPPATCH";
    if (util2.isFormDataLike(body2)) {
      if (!extractBody) {
        extractBody = requireBody().extractBody;
      }
      const [bodyStream, contentType] = extractBody(body2);
      if (request2.contentType == null) {
        headers2.push("content-type", contentType);
      }
      body2 = bodyStream.stream;
      contentLength = bodyStream.length;
    } else if (util2.isBlobLike(body2) && request2.contentType == null && body2.type) {
      headers2.push("content-type", body2.type);
    }
    if (body2 && typeof body2.read === "function") {
      body2.read(0);
    }
    const bodyLength = util2.bodyLength(body2);
    contentLength = bodyLength ?? contentLength;
    if (contentLength === null) {
      contentLength = request2.contentLength;
    }
    if (contentLength === 0 && !expectsPayload) {
      contentLength = null;
    }
    if (shouldSendContentLength(method) && contentLength > 0 && request2.contentLength !== null && request2.contentLength !== contentLength) {
      if (client2[kStrictContentLength]) {
        util2.errorRequest(client2, request2, new RequestContentLengthMismatchError());
        return false;
      }
      process.emitWarning(new RequestContentLengthMismatchError());
    }
    const socket = client2[kSocket];
    const abort = (err) => {
      if (request2.aborted || request2.completed) {
        return;
      }
      util2.errorRequest(client2, request2, err || new RequestAbortedError());
      util2.destroy(body2);
      util2.destroy(socket, new InformationalError("aborted"));
    };
    try {
      request2.onConnect(abort);
    } catch (err) {
      util2.errorRequest(client2, request2, err);
    }
    if (request2.aborted) {
      return false;
    }
    if (method === "HEAD") {
      socket[kReset] = true;
    }
    if (upgrade || method === "CONNECT") {
      socket[kReset] = true;
    }
    if (reset != null) {
      socket[kReset] = reset;
    }
    if (client2[kMaxRequests] && socket[kCounter]++ >= client2[kMaxRequests]) {
      socket[kReset] = true;
    }
    if (blocking) {
      socket[kBlocking] = true;
    }
    let header = `${method} ${path3} HTTP/1.1\r
`;
    if (typeof host === "string") {
      header += `host: ${host}\r
`;
    } else {
      header += client2[kHostHeader];
    }
    if (upgrade) {
      header += `connection: upgrade\r
upgrade: ${upgrade}\r
`;
    } else if (client2[kPipelining] && !socket[kReset]) {
      header += "connection: keep-alive\r\n";
    } else {
      header += "connection: close\r\n";
    }
    if (Array.isArray(headers2)) {
      for (let n4 = 0; n4 < headers2.length; n4 += 2) {
        const key = headers2[n4 + 0];
        const val = headers2[n4 + 1];
        if (Array.isArray(val)) {
          for (let i4 = 0; i4 < val.length; i4++) {
            header += `${key}: ${val[i4]}\r
`;
          }
        } else {
          header += `${key}: ${val}\r
`;
        }
      }
    }
    if (channels.sendHeaders.hasSubscribers) {
      channels.sendHeaders.publish({ request: request2, headers: header, socket });
    }
    if (!body2 || bodyLength === 0) {
      writeBuffer(abort, null, client2, request2, socket, contentLength, header, expectsPayload);
    } else if (util2.isBuffer(body2)) {
      writeBuffer(abort, body2, client2, request2, socket, contentLength, header, expectsPayload);
    } else if (util2.isBlobLike(body2)) {
      if (typeof body2.stream === "function") {
        writeIterable(abort, body2.stream(), client2, request2, socket, contentLength, header, expectsPayload);
      } else {
        writeBlob(abort, body2, client2, request2, socket, contentLength, header, expectsPayload);
      }
    } else if (util2.isStream(body2)) {
      writeStream(abort, body2, client2, request2, socket, contentLength, header, expectsPayload);
    } else if (util2.isIterable(body2)) {
      writeIterable(abort, body2, client2, request2, socket, contentLength, header, expectsPayload);
    } else {
      assert(false);
    }
    return true;
  }
  function writeStream(abort, body2, client2, request2, socket, contentLength, header, expectsPayload) {
    assert(contentLength !== 0 || client2[kRunning] === 0, "stream body cannot be pipelined");
    let finished = false;
    const writer = new AsyncWriter({ abort, socket, request: request2, contentLength, client: client2, expectsPayload, header });
    const onData = function(chunk2) {
      if (finished) {
        return;
      }
      try {
        if (!writer.write(chunk2) && this.pause) {
          this.pause();
        }
      } catch (err) {
        util2.destroy(this, err);
      }
    };
    const onDrain = function() {
      if (finished) {
        return;
      }
      if (body2.resume) {
        body2.resume();
      }
    };
    const onClose = function() {
      queueMicrotask(() => {
        body2.removeListener("error", onFinished);
      });
      if (!finished) {
        const err = new RequestAbortedError();
        queueMicrotask(() => onFinished(err));
      }
    };
    const onFinished = function(err) {
      if (finished) {
        return;
      }
      finished = true;
      assert(socket.destroyed || socket[kWriting] && client2[kRunning] <= 1);
      socket.off("drain", onDrain).off("error", onFinished);
      body2.removeListener("data", onData).removeListener("end", onFinished).removeListener("close", onClose);
      if (!err) {
        try {
          writer.end();
        } catch (er) {
          err = er;
        }
      }
      writer.destroy(err);
      if (err && (err.code !== "UND_ERR_INFO" || err.message !== "reset")) {
        util2.destroy(body2, err);
      } else {
        util2.destroy(body2);
      }
    };
    body2.on("data", onData).on("end", onFinished).on("error", onFinished).on("close", onClose);
    if (body2.resume) {
      body2.resume();
    }
    socket.on("drain", onDrain).on("error", onFinished);
    if (body2.errorEmitted ?? body2.errored) {
      setImmediate(onFinished, body2.errored);
    } else if (body2.endEmitted ?? body2.readableEnded) {
      setImmediate(onFinished, null);
    }
    if (body2.closeEmitted ?? body2.closed) {
      setImmediate(onClose);
    }
  }
  function writeBuffer(abort, body2, client2, request2, socket, contentLength, header, expectsPayload) {
    try {
      if (!body2) {
        if (contentLength === 0) {
          socket.write(`${header}content-length: 0\r
\r
`, "latin1");
        } else {
          assert(contentLength === null, "no body must not have content length");
          socket.write(`${header}\r
`, "latin1");
        }
      } else if (util2.isBuffer(body2)) {
        assert(contentLength === body2.byteLength, "buffer body must have content length");
        socket.cork();
        socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
        socket.write(body2);
        socket.uncork();
        request2.onBodySent(body2);
        if (!expectsPayload && request2.reset !== false) {
          socket[kReset] = true;
        }
      }
      request2.onRequestSent();
      client2[kResume]();
    } catch (err) {
      abort(err);
    }
  }
  async function writeBlob(abort, body2, client2, request2, socket, contentLength, header, expectsPayload) {
    assert(contentLength === body2.size, "blob body must have content length");
    try {
      if (contentLength != null && contentLength !== body2.size) {
        throw new RequestContentLengthMismatchError();
      }
      const buffer = Buffer.from(await body2.arrayBuffer());
      socket.cork();
      socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
      socket.write(buffer);
      socket.uncork();
      request2.onBodySent(buffer);
      request2.onRequestSent();
      if (!expectsPayload && request2.reset !== false) {
        socket[kReset] = true;
      }
      client2[kResume]();
    } catch (err) {
      abort(err);
    }
  }
  async function writeIterable(abort, body2, client2, request2, socket, contentLength, header, expectsPayload) {
    assert(contentLength !== 0 || client2[kRunning] === 0, "iterator body cannot be pipelined");
    let callback = null;
    function onDrain() {
      if (callback) {
        const cb = callback;
        callback = null;
        cb();
      }
    }
    const waitForDrain = () => new Promise((resolve, reject) => {
      assert(callback === null);
      if (socket[kError]) {
        reject(socket[kError]);
      } else {
        callback = resolve;
      }
    });
    socket.on("close", onDrain).on("drain", onDrain);
    const writer = new AsyncWriter({ abort, socket, request: request2, contentLength, client: client2, expectsPayload, header });
    try {
      for await (const chunk2 of body2) {
        if (socket[kError]) {
          throw socket[kError];
        }
        if (!writer.write(chunk2)) {
          await waitForDrain();
        }
      }
      writer.end();
    } catch (err) {
      writer.destroy(err);
    } finally {
      socket.off("close", onDrain).off("drain", onDrain);
    }
  }
  class AsyncWriter {
    /**
     *
     * @param {object} arg
     * @param {AbortCallback} arg.abort
     * @param {import('net').Socket} arg.socket
     * @param {import('../core/request.js')} arg.request
     * @param {number} arg.contentLength
     * @param {import('./client.js')} arg.client
     * @param {boolean} arg.expectsPayload
     * @param {string} arg.header
     */
    constructor({ abort, socket, request: request2, contentLength, client: client2, expectsPayload, header }) {
      this.socket = socket;
      this.request = request2;
      this.contentLength = contentLength;
      this.client = client2;
      this.bytesWritten = 0;
      this.expectsPayload = expectsPayload;
      this.header = header;
      this.abort = abort;
      socket[kWriting] = true;
    }
    /**
     * @param {Buffer} chunk
     * @returns
     */
    write(chunk2) {
      const { socket, request: request2, contentLength, client: client2, bytesWritten, expectsPayload, header } = this;
      if (socket[kError]) {
        throw socket[kError];
      }
      if (socket.destroyed) {
        return false;
      }
      const len = Buffer.byteLength(chunk2);
      if (!len) {
        return true;
      }
      if (contentLength !== null && bytesWritten + len > contentLength) {
        if (client2[kStrictContentLength]) {
          throw new RequestContentLengthMismatchError();
        }
        process.emitWarning(new RequestContentLengthMismatchError());
      }
      socket.cork();
      if (bytesWritten === 0) {
        if (!expectsPayload && request2.reset !== false) {
          socket[kReset] = true;
        }
        if (contentLength === null) {
          socket.write(`${header}transfer-encoding: chunked\r
`, "latin1");
        } else {
          socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
        }
      }
      if (contentLength === null) {
        socket.write(`\r
${len.toString(16)}\r
`, "latin1");
      }
      this.bytesWritten += len;
      const ret = socket.write(chunk2);
      socket.uncork();
      request2.onBodySent(chunk2);
      if (!ret) {
        if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
          if (socket[kParser].timeout.refresh) {
            socket[kParser].timeout.refresh();
          }
        }
      }
      return ret;
    }
    /**
     * @returns {void}
     */
    end() {
      const { socket, contentLength, client: client2, bytesWritten, expectsPayload, header, request: request2 } = this;
      request2.onRequestSent();
      socket[kWriting] = false;
      if (socket[kError]) {
        throw socket[kError];
      }
      if (socket.destroyed) {
        return;
      }
      if (bytesWritten === 0) {
        if (expectsPayload) {
          socket.write(`${header}content-length: 0\r
\r
`, "latin1");
        } else {
          socket.write(`${header}\r
`, "latin1");
        }
      } else if (contentLength === null) {
        socket.write("\r\n0\r\n\r\n", "latin1");
      }
      if (contentLength !== null && bytesWritten !== contentLength) {
        if (client2[kStrictContentLength]) {
          throw new RequestContentLengthMismatchError();
        } else {
          process.emitWarning(new RequestContentLengthMismatchError());
        }
      }
      if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
        if (socket[kParser].timeout.refresh) {
          socket[kParser].timeout.refresh();
        }
      }
      client2[kResume]();
    }
    /**
     * @param {Error} [err]
     * @returns {void}
     */
    destroy(err) {
      const { socket, client: client2, abort } = this;
      socket[kWriting] = false;
      if (err) {
        assert(client2[kRunning] <= 1, "pipeline should only contain this request");
        abort(err);
      }
    }
  }
  clientH1 = connectH1;
  return clientH1;
}
var clientH2;
var hasRequiredClientH2;
function requireClientH2() {
  if (hasRequiredClientH2) return clientH2;
  hasRequiredClientH2 = 1;
  const assert = import_node_assert.default;
  const { pipeline } = import_node_stream.default;
  const util2 = requireUtil$5();
  const {
    RequestContentLengthMismatchError,
    RequestAbortedError,
    SocketError,
    InformationalError,
    InvalidArgumentError
  } = requireErrors();
  const {
    kUrl,
    kReset,
    kClient,
    kRunning,
    kPending,
    kQueue,
    kPendingIdx,
    kRunningIdx,
    kError,
    kSocket,
    kStrictContentLength,
    kOnError,
    kMaxConcurrentStreams,
    kHTTP2Session,
    kResume,
    kSize,
    kHTTPContext,
    kClosed,
    kBodyTimeout,
    kEnableConnectProtocol,
    kRemoteSettings,
    kHTTP2Stream
  } = requireSymbols();
  const { channels } = requireDiagnostics();
  const kOpenStreams = /* @__PURE__ */ Symbol("open streams");
  let extractBody;
  let http2;
  try {
    http2 = require("node:http2");
  } catch {
    http2 = { constants: {} };
  }
  const {
    constants: {
      HTTP2_HEADER_AUTHORITY,
      HTTP2_HEADER_METHOD,
      HTTP2_HEADER_PATH,
      HTTP2_HEADER_SCHEME,
      HTTP2_HEADER_CONTENT_LENGTH,
      HTTP2_HEADER_EXPECT,
      HTTP2_HEADER_STATUS,
      HTTP2_HEADER_PROTOCOL,
      NGHTTP2_REFUSED_STREAM,
      NGHTTP2_CANCEL
    }
  } = http2;
  function parseH2Headers(headers2) {
    const result = [];
    for (const [name, value] of Object.entries(headers2)) {
      if (Array.isArray(value)) {
        for (const subvalue of value) {
          result.push(Buffer.from(name), Buffer.from(subvalue));
        }
      } else {
        result.push(Buffer.from(name), Buffer.from(value));
      }
    }
    return result;
  }
  function connectH2(client2, socket) {
    client2[kSocket] = socket;
    const session = http2.connect(client2[kUrl], {
      createConnection: () => socket,
      peerMaxConcurrentStreams: client2[kMaxConcurrentStreams],
      settings: {
        // TODO(metcoder95): add support for PUSH
        enablePush: false
      }
    });
    session[kOpenStreams] = 0;
    session[kClient] = client2;
    session[kSocket] = socket;
    session[kHTTP2Session] = null;
    session[kEnableConnectProtocol] = false;
    session[kRemoteSettings] = false;
    util2.addListener(session, "error", onHttp2SessionError);
    util2.addListener(session, "frameError", onHttp2FrameError);
    util2.addListener(session, "end", onHttp2SessionEnd);
    util2.addListener(session, "goaway", onHttp2SessionGoAway);
    util2.addListener(session, "close", onHttp2SessionClose);
    util2.addListener(session, "remoteSettings", onHttp2RemoteSettings);
    session.unref();
    client2[kHTTP2Session] = session;
    socket[kHTTP2Session] = session;
    util2.addListener(socket, "error", onHttp2SocketError);
    util2.addListener(socket, "end", onHttp2SocketEnd);
    util2.addListener(socket, "close", onHttp2SocketClose);
    socket[kClosed] = false;
    socket.on("close", onSocketClose);
    return {
      version: "h2",
      defaultPipelining: Infinity,
      /**
       * @param {import('../core/request.js')} request
       * @returns {boolean}
      */
      write(request2) {
        return writeH2(client2, request2);
      },
      /**
       * @returns {void}
       */
      resume() {
        resumeH2(client2);
      },
      /**
       * @param {Error | null} err
       * @param {() => void} callback
       */
      destroy(err, callback) {
        if (socket[kClosed]) {
          queueMicrotask(callback);
        } else {
          socket.destroy(err).on("close", callback);
        }
      },
      /**
       * @type {boolean}
       */
      get destroyed() {
        return socket.destroyed;
      },
      /**
       * @param {import('../core/request.js')} request
       * @returns {boolean}
      */
      busy(request2) {
        if (request2 != null) {
          if (client2[kRunning] > 0) {
            if (request2.idempotent === false) return true;
            if ((request2.upgrade === "websocket" || request2.method === "CONNECT") && session[kRemoteSettings] === false) return true;
            if (util2.bodyLength(request2.body) !== 0 && (util2.isStream(request2.body) || util2.isAsyncIterable(request2.body) || util2.isFormDataLike(request2.body))) return true;
          } else {
            return (request2.upgrade === "websocket" || request2.method === "CONNECT") && session[kRemoteSettings] === false;
          }
        }
        return false;
      }
    };
  }
  function resumeH2(client2) {
    const socket = client2[kSocket];
    if (socket?.destroyed === false) {
      if (client2[kSize] === 0 || client2[kMaxConcurrentStreams] === 0) {
        socket.unref();
        client2[kHTTP2Session].unref();
      } else {
        socket.ref();
        client2[kHTTP2Session].ref();
      }
    }
  }
  function onHttp2RemoteSettings(settings) {
    this[kClient][kMaxConcurrentStreams] = settings.maxConcurrentStreams ?? this[kClient][kMaxConcurrentStreams];
    if (this[kRemoteSettings] === true && this[kEnableConnectProtocol] === true && settings.enableConnectProtocol === false) {
      const err = new InformationalError("HTTP/2: Server disabled extended CONNECT protocol against RFC-8441");
      this[kSocket][kError] = err;
      this[kClient][kOnError](err);
      return;
    }
    this[kEnableConnectProtocol] = settings.enableConnectProtocol ?? this[kEnableConnectProtocol];
    this[kRemoteSettings] = true;
    this[kClient][kResume]();
  }
  function onHttp2SessionError(err) {
    assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
    this[kSocket][kError] = err;
    this[kClient][kOnError](err);
  }
  function onHttp2FrameError(type, code, id2) {
    if (id2 === 0) {
      const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
      this[kSocket][kError] = err;
      this[kClient][kOnError](err);
    }
  }
  function onHttp2SessionEnd() {
    const err = new SocketError("other side closed", util2.getSocketInfo(this[kSocket]));
    this.destroy(err);
    util2.destroy(this[kSocket], err);
  }
  function onHttp2SessionGoAway(errorCode) {
    const err = this[kError] || new SocketError(`HTTP/2: "GOAWAY" frame received with code ${errorCode}`, util2.getSocketInfo(this[kSocket]));
    const client2 = this[kClient];
    client2[kSocket] = null;
    client2[kHTTPContext] = null;
    this.close();
    this[kHTTP2Session] = null;
    util2.destroy(this[kSocket], err);
    if (client2[kRunningIdx] < client2[kQueue].length) {
      const request2 = client2[kQueue][client2[kRunningIdx]];
      client2[kQueue][client2[kRunningIdx]++] = null;
      util2.errorRequest(client2, request2, err);
      client2[kPendingIdx] = client2[kRunningIdx];
    }
    assert(client2[kRunning] === 0);
    client2.emit("disconnect", client2[kUrl], [client2], err);
    client2.emit("connectionError", client2[kUrl], [client2], err);
    client2[kResume]();
  }
  function onHttp2SessionClose() {
    const { [kClient]: client2 } = this;
    const { [kSocket]: socket } = client2;
    const err = this[kSocket][kError] || this[kError] || new SocketError("closed", util2.getSocketInfo(socket));
    client2[kSocket] = null;
    client2[kHTTPContext] = null;
    if (client2.destroyed) {
      assert(client2[kPending] === 0);
      const requests = client2[kQueue].splice(client2[kRunningIdx]);
      for (let i4 = 0; i4 < requests.length; i4++) {
        const request2 = requests[i4];
        util2.errorRequest(client2, request2, err);
      }
    }
  }
  function onHttp2SocketClose() {
    const err = this[kError] || new SocketError("closed", util2.getSocketInfo(this));
    const client2 = this[kHTTP2Session][kClient];
    client2[kSocket] = null;
    client2[kHTTPContext] = null;
    if (this[kHTTP2Session] !== null) {
      this[kHTTP2Session].destroy(err);
    }
    client2[kPendingIdx] = client2[kRunningIdx];
    assert(client2[kRunning] === 0);
    client2.emit("disconnect", client2[kUrl], [client2], err);
    client2[kResume]();
  }
  function onHttp2SocketError(err) {
    assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
    this[kError] = err;
    this[kClient][kOnError](err);
  }
  function onHttp2SocketEnd() {
    util2.destroy(this, new SocketError("other side closed", util2.getSocketInfo(this)));
  }
  function onSocketClose() {
    this[kClosed] = true;
  }
  function shouldSendContentLength(method) {
    return method !== "GET" && method !== "HEAD" && method !== "OPTIONS" && method !== "TRACE" && method !== "CONNECT";
  }
  function writeH2(client2, request2) {
    const requestTimeout = request2.bodyTimeout ?? client2[kBodyTimeout];
    const session = client2[kHTTP2Session];
    const { method, path: path3, host, upgrade, expectContinue, signal, protocol, headers: reqHeaders } = request2;
    let { body: body2 } = request2;
    if (upgrade != null && upgrade !== "websocket") {
      util2.errorRequest(client2, request2, new InvalidArgumentError(`Custom upgrade "${upgrade}" not supported over HTTP/2`));
      return false;
    }
    const headers2 = {};
    for (let n4 = 0; n4 < reqHeaders.length; n4 += 2) {
      const key = reqHeaders[n4 + 0];
      const val = reqHeaders[n4 + 1];
      if (key === "cookie") {
        if (headers2[key] != null) {
          headers2[key] = Array.isArray(headers2[key]) ? (headers2[key].push(val), headers2[key]) : [headers2[key], val];
        } else {
          headers2[key] = val;
        }
        continue;
      }
      if (Array.isArray(val)) {
        for (let i4 = 0; i4 < val.length; i4++) {
          if (headers2[key]) {
            headers2[key] += `, ${val[i4]}`;
          } else {
            headers2[key] = val[i4];
          }
        }
      } else if (headers2[key]) {
        headers2[key] += `, ${val}`;
      } else {
        headers2[key] = val;
      }
    }
    let stream = null;
    const { hostname, port } = client2[kUrl];
    headers2[HTTP2_HEADER_AUTHORITY] = host || `${hostname}${port ? `:${port}` : ""}`;
    headers2[HTTP2_HEADER_METHOD] = method;
    const abort = (err) => {
      if (request2.aborted || request2.completed) {
        return;
      }
      err = err || new RequestAbortedError();
      util2.errorRequest(client2, request2, err);
      if (stream != null) {
        stream.removeAllListeners("data");
        stream.close();
        client2[kOnError](err);
        client2[kResume]();
      }
      util2.destroy(body2, err);
    };
    try {
      request2.onConnect(abort);
    } catch (err) {
      util2.errorRequest(client2, request2, err);
    }
    if (request2.aborted) {
      return false;
    }
    if (upgrade || method === "CONNECT") {
      session.ref();
      if (upgrade === "websocket") {
        if (session[kEnableConnectProtocol] === false) {
          util2.errorRequest(client2, request2, new InformationalError("HTTP/2: Extended CONNECT protocol not supported by server"));
          session.unref();
          return false;
        }
        headers2[HTTP2_HEADER_METHOD] = "CONNECT";
        headers2[HTTP2_HEADER_PROTOCOL] = "websocket";
        headers2[HTTP2_HEADER_PATH] = path3;
        if (protocol === "ws:" || protocol === "wss:") {
          headers2[HTTP2_HEADER_SCHEME] = protocol === "ws:" ? "http" : "https";
        } else {
          headers2[HTTP2_HEADER_SCHEME] = protocol === "http:" ? "http" : "https";
        }
        stream = session.request(headers2, { endStream: false, signal });
        stream[kHTTP2Stream] = true;
        stream.once("response", (headers3, _flags) => {
          const { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers3;
          request2.onUpgrade(statusCode, parseH2Headers(realHeaders), stream);
          ++session[kOpenStreams];
          client2[kQueue][client2[kRunningIdx]++] = null;
        });
        stream.on("error", () => {
          if (stream.rstCode === NGHTTP2_REFUSED_STREAM || stream.rstCode === NGHTTP2_CANCEL) {
            abort(new InformationalError(`HTTP/2: "stream error" received - code ${stream.rstCode}`));
          }
        });
        stream.once("close", () => {
          session[kOpenStreams] -= 1;
          if (session[kOpenStreams] === 0) session.unref();
        });
        stream.setTimeout(requestTimeout);
        return true;
      }
      stream = session.request(headers2, { endStream: false, signal });
      stream[kHTTP2Stream] = true;
      stream.on("response", (headers3) => {
        const { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers3;
        request2.onUpgrade(statusCode, parseH2Headers(realHeaders), stream);
        ++session[kOpenStreams];
        client2[kQueue][client2[kRunningIdx]++] = null;
      });
      stream.once("close", () => {
        session[kOpenStreams] -= 1;
        if (session[kOpenStreams] === 0) session.unref();
      });
      stream.setTimeout(requestTimeout);
      return true;
    }
    headers2[HTTP2_HEADER_PATH] = path3;
    headers2[HTTP2_HEADER_SCHEME] = protocol === "http:" ? "http" : "https";
    const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
    if (body2 && typeof body2.read === "function") {
      body2.read(0);
    }
    let contentLength = util2.bodyLength(body2);
    if (util2.isFormDataLike(body2)) {
      extractBody ??= requireBody().extractBody;
      const [bodyStream, contentType] = extractBody(body2);
      headers2["content-type"] = contentType;
      body2 = bodyStream.stream;
      contentLength = bodyStream.length;
    }
    if (contentLength == null) {
      contentLength = request2.contentLength;
    }
    if (!expectsPayload) {
      contentLength = null;
    }
    if (shouldSendContentLength(method) && contentLength > 0 && request2.contentLength != null && request2.contentLength !== contentLength) {
      if (client2[kStrictContentLength]) {
        util2.errorRequest(client2, request2, new RequestContentLengthMismatchError());
        return false;
      }
      process.emitWarning(new RequestContentLengthMismatchError());
    }
    if (contentLength != null) {
      assert(body2 || contentLength === 0, "no body must not have content length");
      headers2[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`;
    }
    session.ref();
    if (channels.sendHeaders.hasSubscribers) {
      let header = "";
      for (const key in headers2) {
        header += `${key}: ${headers2[key]}\r
`;
      }
      channels.sendHeaders.publish({ request: request2, headers: header, socket: session[kSocket] });
    }
    const shouldEndStream = method === "GET" || method === "HEAD" || body2 === null;
    if (expectContinue) {
      headers2[HTTP2_HEADER_EXPECT] = "100-continue";
      stream = session.request(headers2, { endStream: shouldEndStream, signal });
      stream[kHTTP2Stream] = true;
      stream.once("continue", writeBodyH2);
    } else {
      stream = session.request(headers2, {
        endStream: shouldEndStream,
        signal
      });
      stream[kHTTP2Stream] = true;
      writeBodyH2();
    }
    ++session[kOpenStreams];
    stream.setTimeout(requestTimeout);
    stream.once("response", (headers3) => {
      const { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers3;
      request2.onResponseStarted();
      if (request2.aborted) {
        stream.removeAllListeners("data");
        return;
      }
      if (request2.onHeaders(Number(statusCode), parseH2Headers(realHeaders), stream.resume.bind(stream), "") === false) {
        stream.pause();
      }
    });
    stream.on("data", (chunk2) => {
      if (request2.onData(chunk2) === false) {
        stream.pause();
      }
    });
    stream.once("end", (err) => {
      stream.removeAllListeners("data");
      if (stream.state?.state == null || stream.state.state < 6) {
        if (!request2.aborted && !request2.completed) {
          request2.onComplete({});
        }
        client2[kQueue][client2[kRunningIdx]++] = null;
        client2[kResume]();
      } else {
        --session[kOpenStreams];
        if (session[kOpenStreams] === 0) {
          session.unref();
        }
        abort(err ?? new InformationalError("HTTP/2: stream half-closed (remote)"));
        client2[kQueue][client2[kRunningIdx]++] = null;
        client2[kPendingIdx] = client2[kRunningIdx];
        client2[kResume]();
      }
    });
    stream.once("close", () => {
      stream.removeAllListeners("data");
      session[kOpenStreams] -= 1;
      if (session[kOpenStreams] === 0) {
        session.unref();
      }
    });
    stream.once("error", function(err) {
      stream.removeAllListeners("data");
      abort(err);
    });
    stream.once("frameError", (type, code) => {
      stream.removeAllListeners("data");
      abort(new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`));
    });
    stream.on("aborted", () => {
      stream.removeAllListeners("data");
    });
    stream.on("timeout", () => {
      const err = new InformationalError(`HTTP/2: "stream timeout after ${requestTimeout}"`);
      stream.removeAllListeners("data");
      session[kOpenStreams] -= 1;
      if (session[kOpenStreams] === 0) {
        session.unref();
      }
      abort(err);
    });
    stream.once("trailers", (trailers) => {
      if (request2.aborted || request2.completed) {
        return;
      }
      request2.onComplete(trailers);
    });
    return true;
    function writeBodyH2() {
      if (!body2 || contentLength === 0) {
        writeBuffer(
          abort,
          stream,
          null,
          client2,
          request2,
          client2[kSocket],
          contentLength,
          expectsPayload
        );
      } else if (util2.isBuffer(body2)) {
        writeBuffer(
          abort,
          stream,
          body2,
          client2,
          request2,
          client2[kSocket],
          contentLength,
          expectsPayload
        );
      } else if (util2.isBlobLike(body2)) {
        if (typeof body2.stream === "function") {
          writeIterable(
            abort,
            stream,
            body2.stream(),
            client2,
            request2,
            client2[kSocket],
            contentLength,
            expectsPayload
          );
        } else {
          writeBlob(
            abort,
            stream,
            body2,
            client2,
            request2,
            client2[kSocket],
            contentLength,
            expectsPayload
          );
        }
      } else if (util2.isStream(body2)) {
        writeStream(
          abort,
          client2[kSocket],
          expectsPayload,
          stream,
          body2,
          client2,
          request2,
          contentLength
        );
      } else if (util2.isIterable(body2)) {
        writeIterable(
          abort,
          stream,
          body2,
          client2,
          request2,
          client2[kSocket],
          contentLength,
          expectsPayload
        );
      } else {
        assert(false);
      }
    }
  }
  function writeBuffer(abort, h2stream, body2, client2, request2, socket, contentLength, expectsPayload) {
    try {
      if (body2 != null && util2.isBuffer(body2)) {
        assert(contentLength === body2.byteLength, "buffer body must have content length");
        h2stream.cork();
        h2stream.write(body2);
        h2stream.uncork();
        h2stream.end();
        request2.onBodySent(body2);
      }
      if (!expectsPayload) {
        socket[kReset] = true;
      }
      request2.onRequestSent();
      client2[kResume]();
    } catch (error2) {
      abort(error2);
    }
  }
  function writeStream(abort, socket, expectsPayload, h2stream, body2, client2, request2, contentLength) {
    assert(contentLength !== 0 || client2[kRunning] === 0, "stream body cannot be pipelined");
    const pipe = pipeline(
      body2,
      h2stream,
      (err) => {
        if (err) {
          util2.destroy(pipe, err);
          abort(err);
        } else {
          util2.removeAllListeners(pipe);
          request2.onRequestSent();
          if (!expectsPayload) {
            socket[kReset] = true;
          }
          client2[kResume]();
        }
      }
    );
    util2.addListener(pipe, "data", onPipeData);
    function onPipeData(chunk2) {
      request2.onBodySent(chunk2);
    }
  }
  async function writeBlob(abort, h2stream, body2, client2, request2, socket, contentLength, expectsPayload) {
    assert(contentLength === body2.size, "blob body must have content length");
    try {
      if (contentLength != null && contentLength !== body2.size) {
        throw new RequestContentLengthMismatchError();
      }
      const buffer = Buffer.from(await body2.arrayBuffer());
      h2stream.cork();
      h2stream.write(buffer);
      h2stream.uncork();
      h2stream.end();
      request2.onBodySent(buffer);
      request2.onRequestSent();
      if (!expectsPayload) {
        socket[kReset] = true;
      }
      client2[kResume]();
    } catch (err) {
      abort(err);
    }
  }
  async function writeIterable(abort, h2stream, body2, client2, request2, socket, contentLength, expectsPayload) {
    assert(contentLength !== 0 || client2[kRunning] === 0, "iterator body cannot be pipelined");
    let callback = null;
    function onDrain() {
      if (callback) {
        const cb = callback;
        callback = null;
        cb();
      }
    }
    const waitForDrain = () => new Promise((resolve, reject) => {
      assert(callback === null);
      if (socket[kError]) {
        reject(socket[kError]);
      } else {
        callback = resolve;
      }
    });
    h2stream.on("close", onDrain).on("drain", onDrain);
    try {
      for await (const chunk2 of body2) {
        if (socket[kError]) {
          throw socket[kError];
        }
        const res = h2stream.write(chunk2);
        request2.onBodySent(chunk2);
        if (!res) {
          await waitForDrain();
        }
      }
      h2stream.end();
      request2.onRequestSent();
      if (!expectsPayload) {
        socket[kReset] = true;
      }
      client2[kResume]();
    } catch (err) {
      abort(err);
    } finally {
      h2stream.off("close", onDrain).off("drain", onDrain);
    }
  }
  clientH2 = connectH2;
  return clientH2;
}
var client;
var hasRequiredClient;
function requireClient() {
  if (hasRequiredClient) return client;
  hasRequiredClient = 1;
  const assert = import_node_assert.default;
  const net$1 = import_node_net.default;
  const http = import_node_http.default;
  const util2 = requireUtil$5();
  const { ClientStats } = requireStats();
  const { channels } = requireDiagnostics();
  const Request2 = requireRequest$1();
  const DispatcherBase = requireDispatcherBase();
  const {
    InvalidArgumentError,
    InformationalError,
    ClientDestroyedError
  } = requireErrors();
  const buildConnector = requireConnect();
  const {
    kUrl,
    kServerName,
    kClient,
    kBusy,
    kConnect,
    kResuming,
    kRunning,
    kPending,
    kSize,
    kQueue,
    kConnected,
    kConnecting,
    kNeedDrain,
    kKeepAliveDefaultTimeout,
    kHostHeader,
    kPendingIdx,
    kRunningIdx,
    kError,
    kPipelining,
    kKeepAliveTimeoutValue,
    kMaxHeadersSize,
    kKeepAliveMaxTimeout,
    kKeepAliveTimeoutThreshold,
    kHeadersTimeout,
    kBodyTimeout,
    kStrictContentLength,
    kConnector,
    kMaxRequests,
    kCounter,
    kClose,
    kDestroy,
    kDispatch,
    kLocalAddress,
    kMaxResponseSize,
    kOnError,
    kHTTPContext,
    kMaxConcurrentStreams,
    kResume
  } = requireSymbols();
  const connectH1 = requireClientH1();
  const connectH2 = requireClientH2();
  const kClosedResolve = /* @__PURE__ */ Symbol("kClosedResolve");
  const getDefaultNodeMaxHeaderSize = http && http.maxHeaderSize && Number.isInteger(http.maxHeaderSize) && http.maxHeaderSize > 0 ? () => http.maxHeaderSize : () => {
    throw new InvalidArgumentError("http module not available or http.maxHeaderSize invalid");
  };
  const noop2 = () => {
  };
  function getPipelining(client2) {
    return client2[kPipelining] ?? client2[kHTTPContext]?.defaultPipelining ?? 1;
  }
  class Client2 extends DispatcherBase {
    /**
     *
     * @param {string|URL} url
     * @param {import('../../types/client.js').Client.Options} options
     */
    constructor(url, {
      maxHeaderSize,
      headersTimeout,
      socketTimeout,
      requestTimeout,
      connectTimeout,
      bodyTimeout,
      idleTimeout,
      keepAlive,
      keepAliveTimeout,
      maxKeepAliveTimeout,
      keepAliveMaxTimeout,
      keepAliveTimeoutThreshold,
      socketPath,
      pipelining,
      tls,
      strictContentLength,
      maxCachedSessions,
      connect: connect3,
      maxRequestsPerClient,
      localAddress,
      maxResponseSize,
      autoSelectFamily,
      autoSelectFamilyAttemptTimeout,
      // h2
      maxConcurrentStreams,
      allowH2,
      useH2c
    } = {}) {
      if (keepAlive !== void 0) {
        throw new InvalidArgumentError("unsupported keepAlive, use pipelining=0 instead");
      }
      if (socketTimeout !== void 0) {
        throw new InvalidArgumentError("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
      }
      if (requestTimeout !== void 0) {
        throw new InvalidArgumentError("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
      }
      if (idleTimeout !== void 0) {
        throw new InvalidArgumentError("unsupported idleTimeout, use keepAliveTimeout instead");
      }
      if (maxKeepAliveTimeout !== void 0) {
        throw new InvalidArgumentError("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
      }
      if (maxHeaderSize != null) {
        if (!Number.isInteger(maxHeaderSize) || maxHeaderSize < 1) {
          throw new InvalidArgumentError("invalid maxHeaderSize");
        }
      } else {
        maxHeaderSize = getDefaultNodeMaxHeaderSize();
      }
      if (socketPath != null && typeof socketPath !== "string") {
        throw new InvalidArgumentError("invalid socketPath");
      }
      if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {
        throw new InvalidArgumentError("invalid connectTimeout");
      }
      if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {
        throw new InvalidArgumentError("invalid keepAliveTimeout");
      }
      if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {
        throw new InvalidArgumentError("invalid keepAliveMaxTimeout");
      }
      if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {
        throw new InvalidArgumentError("invalid keepAliveTimeoutThreshold");
      }
      if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {
        throw new InvalidArgumentError("headersTimeout must be a positive integer or zero");
      }
      if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {
        throw new InvalidArgumentError("bodyTimeout must be a positive integer or zero");
      }
      if (connect3 != null && typeof connect3 !== "function" && typeof connect3 !== "object") {
        throw new InvalidArgumentError("connect must be a function or an object");
      }
      if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {
        throw new InvalidArgumentError("maxRequestsPerClient must be a positive number");
      }
      if (localAddress != null && (typeof localAddress !== "string" || net$1.isIP(localAddress) === 0)) {
        throw new InvalidArgumentError("localAddress must be valid string IP address");
      }
      if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {
        throw new InvalidArgumentError("maxResponseSize must be a positive number");
      }
      if (autoSelectFamilyAttemptTimeout != null && (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)) {
        throw new InvalidArgumentError("autoSelectFamilyAttemptTimeout must be a positive number");
      }
      if (allowH2 != null && typeof allowH2 !== "boolean") {
        throw new InvalidArgumentError("allowH2 must be a valid boolean value");
      }
      if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== "number" || maxConcurrentStreams < 1)) {
        throw new InvalidArgumentError("maxConcurrentStreams must be a positive integer, greater than 0");
      }
      if (useH2c != null && typeof useH2c !== "boolean") {
        throw new InvalidArgumentError("useH2c must be a valid boolean value");
      }
      super();
      if (typeof connect3 !== "function") {
        connect3 = buildConnector({
          ...tls,
          maxCachedSessions,
          allowH2,
          useH2c,
          socketPath,
          timeout: connectTimeout,
          ...typeof autoSelectFamily === "boolean" ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : void 0,
          ...connect3
        });
      }
      this[kUrl] = util2.parseOrigin(url);
      this[kConnector] = connect3;
      this[kPipelining] = pipelining != null ? pipelining : 1;
      this[kMaxHeadersSize] = maxHeaderSize;
      this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;
      this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 6e5 : keepAliveMaxTimeout;
      this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 2e3 : keepAliveTimeoutThreshold;
      this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];
      this[kServerName] = null;
      this[kLocalAddress] = localAddress != null ? localAddress : null;
      this[kResuming] = 0;
      this[kNeedDrain] = 0;
      this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}\r
`;
      this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 3e5;
      this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 3e5;
      this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;
      this[kMaxRequests] = maxRequestsPerClient;
      this[kClosedResolve] = null;
      this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1;
      this[kMaxConcurrentStreams] = maxConcurrentStreams != null ? maxConcurrentStreams : 100;
      this[kHTTPContext] = null;
      this[kQueue] = [];
      this[kRunningIdx] = 0;
      this[kPendingIdx] = 0;
      this[kResume] = (sync) => resume(this, sync);
      this[kOnError] = (err) => onError(this, err);
    }
    get pipelining() {
      return this[kPipelining];
    }
    set pipelining(value) {
      this[kPipelining] = value;
      this[kResume](true);
    }
    get stats() {
      return new ClientStats(this);
    }
    get [kPending]() {
      return this[kQueue].length - this[kPendingIdx];
    }
    get [kRunning]() {
      return this[kPendingIdx] - this[kRunningIdx];
    }
    get [kSize]() {
      return this[kQueue].length - this[kRunningIdx];
    }
    get [kConnected]() {
      return !!this[kHTTPContext] && !this[kConnecting] && !this[kHTTPContext].destroyed;
    }
    get [kBusy]() {
      return Boolean(
        this[kHTTPContext]?.busy(null) || this[kSize] >= (getPipelining(this) || 1) || this[kPending] > 0
      );
    }
    [kConnect](cb) {
      connect2(this);
      this.once("connect", cb);
    }
    [kDispatch](opts, handler) {
      const request2 = new Request2(this[kUrl].origin, opts, handler);
      this[kQueue].push(request2);
      if (this[kResuming]) ;
      else if (util2.bodyLength(request2.body) == null && util2.isIterable(request2.body)) {
        this[kResuming] = 1;
        queueMicrotask(() => resume(this));
      } else {
        this[kResume](true);
      }
      if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {
        this[kNeedDrain] = 2;
      }
      return this[kNeedDrain] < 2;
    }
    [kClose]() {
      return new Promise((resolve) => {
        if (this[kSize]) {
          this[kClosedResolve] = resolve;
        } else {
          resolve(null);
        }
      });
    }
    [kDestroy](err) {
      return new Promise((resolve) => {
        const requests = this[kQueue].splice(this[kPendingIdx]);
        for (let i4 = 0; i4 < requests.length; i4++) {
          const request2 = requests[i4];
          util2.errorRequest(this, request2, err);
        }
        const callback = () => {
          if (this[kClosedResolve]) {
            this[kClosedResolve]();
            this[kClosedResolve] = null;
          }
          resolve(null);
        };
        if (this[kHTTPContext]) {
          this[kHTTPContext].destroy(err, callback);
          this[kHTTPContext] = null;
        } else {
          queueMicrotask(callback);
        }
        this[kResume]();
      });
    }
  }
  function onError(client2, err) {
    if (client2[kRunning] === 0 && err.code !== "UND_ERR_INFO" && err.code !== "UND_ERR_SOCKET") {
      assert(client2[kPendingIdx] === client2[kRunningIdx]);
      const requests = client2[kQueue].splice(client2[kRunningIdx]);
      for (let i4 = 0; i4 < requests.length; i4++) {
        const request2 = requests[i4];
        util2.errorRequest(client2, request2, err);
      }
      assert(client2[kSize] === 0);
    }
  }
  function connect2(client2) {
    assert(!client2[kConnecting]);
    assert(!client2[kHTTPContext]);
    let { host, hostname, protocol, port } = client2[kUrl];
    if (hostname[0] === "[") {
      const idx = hostname.indexOf("]");
      assert(idx !== -1);
      const ip = hostname.substring(1, idx);
      assert(net$1.isIPv6(ip));
      hostname = ip;
    }
    client2[kConnecting] = true;
    if (channels.beforeConnect.hasSubscribers) {
      channels.beforeConnect.publish({
        connectParams: {
          host,
          hostname,
          protocol,
          port,
          version: client2[kHTTPContext]?.version,
          servername: client2[kServerName],
          localAddress: client2[kLocalAddress]
        },
        connector: client2[kConnector]
      });
    }
    client2[kConnector]({
      host,
      hostname,
      protocol,
      port,
      servername: client2[kServerName],
      localAddress: client2[kLocalAddress]
    }, (err, socket) => {
      if (err) {
        handleConnectError(client2, err, { host, hostname, protocol, port });
        client2[kResume]();
        return;
      }
      if (client2.destroyed) {
        util2.destroy(socket.on("error", noop2), new ClientDestroyedError());
        client2[kResume]();
        return;
      }
      assert(socket);
      try {
        client2[kHTTPContext] = socket.alpnProtocol === "h2" ? connectH2(client2, socket) : connectH1(client2, socket);
      } catch (err2) {
        socket.destroy().on("error", noop2);
        handleConnectError(client2, err2, { host, hostname, protocol, port });
        client2[kResume]();
        return;
      }
      client2[kConnecting] = false;
      socket[kCounter] = 0;
      socket[kMaxRequests] = client2[kMaxRequests];
      socket[kClient] = client2;
      socket[kError] = null;
      if (channels.connected.hasSubscribers) {
        channels.connected.publish({
          connectParams: {
            host,
            hostname,
            protocol,
            port,
            version: client2[kHTTPContext]?.version,
            servername: client2[kServerName],
            localAddress: client2[kLocalAddress]
          },
          connector: client2[kConnector],
          socket
        });
      }
      client2.emit("connect", client2[kUrl], [client2]);
      client2[kResume]();
    });
  }
  function handleConnectError(client2, err, { host, hostname, protocol, port }) {
    if (client2.destroyed) {
      return;
    }
    client2[kConnecting] = false;
    if (channels.connectError.hasSubscribers) {
      channels.connectError.publish({
        connectParams: {
          host,
          hostname,
          protocol,
          port,
          version: client2[kHTTPContext]?.version,
          servername: client2[kServerName],
          localAddress: client2[kLocalAddress]
        },
        connector: client2[kConnector],
        error: err
      });
    }
    if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
      assert(client2[kRunning] === 0);
      while (client2[kPending] > 0 && client2[kQueue][client2[kPendingIdx]].servername === client2[kServerName]) {
        const request2 = client2[kQueue][client2[kPendingIdx]++];
        util2.errorRequest(client2, request2, err);
      }
    } else {
      onError(client2, err);
    }
    client2.emit("connectionError", client2[kUrl], [client2], err);
  }
  function emitDrain(client2) {
    client2[kNeedDrain] = 0;
    client2.emit("drain", client2[kUrl], [client2]);
  }
  function resume(client2, sync) {
    if (client2[kResuming] === 2) {
      return;
    }
    client2[kResuming] = 2;
    _resume(client2, sync);
    client2[kResuming] = 0;
    if (client2[kRunningIdx] > 256) {
      client2[kQueue].splice(0, client2[kRunningIdx]);
      client2[kPendingIdx] -= client2[kRunningIdx];
      client2[kRunningIdx] = 0;
    }
  }
  function _resume(client2, sync) {
    while (true) {
      if (client2.destroyed) {
        assert(client2[kPending] === 0);
        return;
      }
      if (client2[kClosedResolve] && !client2[kSize]) {
        client2[kClosedResolve]();
        client2[kClosedResolve] = null;
        return;
      }
      if (client2[kHTTPContext]) {
        client2[kHTTPContext].resume();
      }
      if (client2[kBusy]) {
        client2[kNeedDrain] = 2;
      } else if (client2[kNeedDrain] === 2) {
        if (sync) {
          client2[kNeedDrain] = 1;
          queueMicrotask(() => emitDrain(client2));
        } else {
          emitDrain(client2);
        }
        continue;
      }
      if (client2[kPending] === 0) {
        return;
      }
      if (client2[kRunning] >= (getPipelining(client2) || 1)) {
        return;
      }
      const request2 = client2[kQueue][client2[kPendingIdx]];
      if (client2[kUrl].protocol === "https:" && client2[kServerName] !== request2.servername) {
        if (client2[kRunning] > 0) {
          return;
        }
        client2[kServerName] = request2.servername;
        client2[kHTTPContext]?.destroy(new InformationalError("servername changed"), () => {
          client2[kHTTPContext] = null;
          resume(client2);
        });
      }
      if (client2[kConnecting]) {
        return;
      }
      if (!client2[kHTTPContext]) {
        connect2(client2);
        return;
      }
      if (client2[kHTTPContext].destroyed) {
        return;
      }
      if (client2[kHTTPContext].busy(request2)) {
        return;
      }
      if (!request2.aborted && client2[kHTTPContext].write(request2)) {
        client2[kPendingIdx]++;
      } else {
        client2[kQueue].splice(client2[kPendingIdx], 1);
      }
    }
  }
  client = Client2;
  return client;
}
var fixedQueue;
var hasRequiredFixedQueue;
function requireFixedQueue() {
  if (hasRequiredFixedQueue) return fixedQueue;
  hasRequiredFixedQueue = 1;
  const kSize = 2048;
  const kMask = kSize - 1;
  class FixedCircularBuffer {
    /** @type {number} */
    bottom = 0;
    /** @type {number} */
    top = 0;
    /** @type {Array<T|undefined>} */
    list = new Array(kSize).fill(void 0);
    /** @type {T|null} */
    next = null;
    /** @returns {boolean} */
    isEmpty() {
      return this.top === this.bottom;
    }
    /** @returns {boolean} */
    isFull() {
      return (this.top + 1 & kMask) === this.bottom;
    }
    /**
     * @param {T} data
     * @returns {void}
     */
    push(data2) {
      this.list[this.top] = data2;
      this.top = this.top + 1 & kMask;
    }
    /** @returns {T|null} */
    shift() {
      const nextItem = this.list[this.bottom];
      if (nextItem === void 0) {
        return null;
      }
      this.list[this.bottom] = void 0;
      this.bottom = this.bottom + 1 & kMask;
      return nextItem;
    }
  }
  fixedQueue = class FixedQueue {
    constructor() {
      this.head = this.tail = new FixedCircularBuffer();
    }
    /** @returns {boolean} */
    isEmpty() {
      return this.head.isEmpty();
    }
    /** @param {T} data */
    push(data2) {
      if (this.head.isFull()) {
        this.head = this.head.next = new FixedCircularBuffer();
      }
      this.head.push(data2);
    }
    /** @returns {T|null} */
    shift() {
      const tail = this.tail;
      const next = tail.shift();
      if (tail.isEmpty() && tail.next !== null) {
        this.tail = tail.next;
        tail.next = null;
      }
      return next;
    }
  };
  return fixedQueue;
}
var poolBase;
var hasRequiredPoolBase;
function requirePoolBase() {
  if (hasRequiredPoolBase) return poolBase;
  hasRequiredPoolBase = 1;
  const { PoolStats } = requireStats();
  const DispatcherBase = requireDispatcherBase();
  const FixedQueue = requireFixedQueue();
  const { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = requireSymbols();
  const kClients = /* @__PURE__ */ Symbol("clients");
  const kNeedDrain = /* @__PURE__ */ Symbol("needDrain");
  const kQueue = /* @__PURE__ */ Symbol("queue");
  const kClosedResolve = /* @__PURE__ */ Symbol("closed resolve");
  const kOnDrain = /* @__PURE__ */ Symbol("onDrain");
  const kOnConnect = /* @__PURE__ */ Symbol("onConnect");
  const kOnDisconnect = /* @__PURE__ */ Symbol("onDisconnect");
  const kOnConnectionError = /* @__PURE__ */ Symbol("onConnectionError");
  const kGetDispatcher = /* @__PURE__ */ Symbol("get dispatcher");
  const kAddClient = /* @__PURE__ */ Symbol("add client");
  const kRemoveClient = /* @__PURE__ */ Symbol("remove client");
  class PoolBase extends DispatcherBase {
    [kQueue] = new FixedQueue();
    [kQueued] = 0;
    [kClients] = [];
    [kNeedDrain] = false;
    [kOnDrain](client2, origin, targets) {
      const queue = this[kQueue];
      let needDrain = false;
      while (!needDrain) {
        const item = queue.shift();
        if (!item) {
          break;
        }
        this[kQueued]--;
        needDrain = !client2.dispatch(item.opts, item.handler);
      }
      client2[kNeedDrain] = needDrain;
      if (!needDrain && this[kNeedDrain]) {
        this[kNeedDrain] = false;
        this.emit("drain", origin, [this, ...targets]);
      }
      if (this[kClosedResolve] && queue.isEmpty()) {
        const closeAll = new Array(this[kClients].length);
        for (let i4 = 0; i4 < this[kClients].length; i4++) {
          closeAll[i4] = this[kClients][i4].close();
        }
        return Promise.all(closeAll).then(this[kClosedResolve]);
      }
    }
    [kOnConnect] = (origin, targets) => {
      this.emit("connect", origin, [this, ...targets]);
    };
    [kOnDisconnect] = (origin, targets, err) => {
      this.emit("disconnect", origin, [this, ...targets], err);
    };
    [kOnConnectionError] = (origin, targets, err) => {
      this.emit("connectionError", origin, [this, ...targets], err);
    };
    get [kBusy]() {
      return this[kNeedDrain];
    }
    get [kConnected]() {
      let ret = 0;
      for (const { [kConnected]: connected } of this[kClients]) {
        ret += connected;
      }
      return ret;
    }
    get [kFree]() {
      let ret = 0;
      for (const { [kConnected]: connected, [kNeedDrain]: needDrain } of this[kClients]) {
        ret += connected && !needDrain;
      }
      return ret;
    }
    get [kPending]() {
      let ret = this[kQueued];
      for (const { [kPending]: pending } of this[kClients]) {
        ret += pending;
      }
      return ret;
    }
    get [kRunning]() {
      let ret = 0;
      for (const { [kRunning]: running } of this[kClients]) {
        ret += running;
      }
      return ret;
    }
    get [kSize]() {
      let ret = this[kQueued];
      for (const { [kSize]: size } of this[kClients]) {
        ret += size;
      }
      return ret;
    }
    get stats() {
      return new PoolStats(this);
    }
    [kClose]() {
      if (this[kQueue].isEmpty()) {
        const closeAll = new Array(this[kClients].length);
        for (let i4 = 0; i4 < this[kClients].length; i4++) {
          closeAll[i4] = this[kClients][i4].close();
        }
        return Promise.all(closeAll);
      } else {
        return new Promise((resolve) => {
          this[kClosedResolve] = resolve;
        });
      }
    }
    [kDestroy](err) {
      while (true) {
        const item = this[kQueue].shift();
        if (!item) {
          break;
        }
        item.handler.onError(err);
      }
      const destroyAll = new Array(this[kClients].length);
      for (let i4 = 0; i4 < this[kClients].length; i4++) {
        destroyAll[i4] = this[kClients][i4].destroy(err);
      }
      return Promise.all(destroyAll);
    }
    [kDispatch](opts, handler) {
      const dispatcher2 = this[kGetDispatcher]();
      if (!dispatcher2) {
        this[kNeedDrain] = true;
        this[kQueue].push({ opts, handler });
        this[kQueued]++;
      } else if (!dispatcher2.dispatch(opts, handler)) {
        dispatcher2[kNeedDrain] = true;
        this[kNeedDrain] = !this[kGetDispatcher]();
      }
      return !this[kNeedDrain];
    }
    [kAddClient](client2) {
      client2.on("drain", this[kOnDrain].bind(this, client2)).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
      this[kClients].push(client2);
      if (this[kNeedDrain]) {
        queueMicrotask(() => {
          if (this[kNeedDrain]) {
            this[kOnDrain](client2, client2[kUrl], [client2, this]);
          }
        });
      }
      return this;
    }
    [kRemoveClient](client2) {
      client2.close(() => {
        const idx = this[kClients].indexOf(client2);
        if (idx !== -1) {
          this[kClients].splice(idx, 1);
        }
      });
      this[kNeedDrain] = this[kClients].some((dispatcher2) => !dispatcher2[kNeedDrain] && dispatcher2.closed !== true && dispatcher2.destroyed !== true);
    }
  }
  poolBase = {
    PoolBase,
    kClients,
    kNeedDrain,
    kAddClient,
    kRemoveClient,
    kGetDispatcher
  };
  return poolBase;
}
var pool$1;
var hasRequiredPool;
function requirePool() {
  if (hasRequiredPool) return pool$1;
  hasRequiredPool = 1;
  const {
    PoolBase,
    kClients,
    kNeedDrain,
    kAddClient,
    kGetDispatcher,
    kRemoveClient
  } = requirePoolBase();
  const Client2 = requireClient();
  const {
    InvalidArgumentError
  } = requireErrors();
  const util2 = requireUtil$5();
  const { kUrl } = requireSymbols();
  const buildConnector = requireConnect();
  const kOptions = /* @__PURE__ */ Symbol("options");
  const kConnections = /* @__PURE__ */ Symbol("connections");
  const kFactory = /* @__PURE__ */ Symbol("factory");
  function defaultFactory(origin, opts) {
    return new Client2(origin, opts);
  }
  class Pool extends PoolBase {
    constructor(origin, {
      connections,
      factory = defaultFactory,
      connect: connect2,
      connectTimeout,
      tls,
      maxCachedSessions,
      socketPath,
      autoSelectFamily,
      autoSelectFamilyAttemptTimeout,
      allowH2,
      clientTtl,
      ...options
    } = {}) {
      if (connections != null && (!Number.isFinite(connections) || connections < 0)) {
        throw new InvalidArgumentError("invalid connections");
      }
      if (typeof factory !== "function") {
        throw new InvalidArgumentError("factory must be a function.");
      }
      if (connect2 != null && typeof connect2 !== "function" && typeof connect2 !== "object") {
        throw new InvalidArgumentError("connect must be a function or an object");
      }
      if (typeof connect2 !== "function") {
        connect2 = buildConnector({
          ...tls,
          maxCachedSessions,
          allowH2,
          socketPath,
          timeout: connectTimeout,
          ...typeof autoSelectFamily === "boolean" ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : void 0,
          ...connect2
        });
      }
      super();
      this[kConnections] = connections || null;
      this[kUrl] = util2.parseOrigin(origin);
      this[kOptions] = { ...util2.deepClone(options), connect: connect2, allowH2, clientTtl };
      this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : void 0;
      this[kFactory] = factory;
      this.on("connect", (origin2, targets) => {
        if (clientTtl != null && clientTtl > 0) {
          for (const target of targets) {
            Object.assign(target, { ttl: Date.now() });
          }
        }
      });
      this.on("connectionError", (origin2, targets, error2) => {
        for (const target of targets) {
          const idx = this[kClients].indexOf(target);
          if (idx !== -1) {
            this[kClients].splice(idx, 1);
          }
        }
      });
    }
    [kGetDispatcher]() {
      const clientTtlOption = this[kOptions].clientTtl;
      for (const client2 of this[kClients]) {
        if (clientTtlOption != null && clientTtlOption > 0 && client2.ttl && Date.now() - client2.ttl > clientTtlOption) {
          this[kRemoveClient](client2);
        } else if (!client2[kNeedDrain]) {
          return client2;
        }
      }
      if (!this[kConnections] || this[kClients].length < this[kConnections]) {
        const dispatcher2 = this[kFactory](this[kUrl], this[kOptions]);
        this[kAddClient](dispatcher2);
        return dispatcher2;
      }
    }
  }
  pool$1 = Pool;
  return pool$1;
}
var balancedPool;
var hasRequiredBalancedPool;
function requireBalancedPool() {
  if (hasRequiredBalancedPool) return balancedPool;
  hasRequiredBalancedPool = 1;
  const {
    BalancedPoolMissingUpstreamError,
    InvalidArgumentError
  } = requireErrors();
  const {
    PoolBase,
    kClients,
    kNeedDrain,
    kAddClient,
    kRemoveClient,
    kGetDispatcher
  } = requirePoolBase();
  const Pool = requirePool();
  const { kUrl } = requireSymbols();
  const { parseOrigin } = requireUtil$5();
  const kFactory = /* @__PURE__ */ Symbol("factory");
  const kOptions = /* @__PURE__ */ Symbol("options");
  const kGreatestCommonDivisor = /* @__PURE__ */ Symbol("kGreatestCommonDivisor");
  const kCurrentWeight = /* @__PURE__ */ Symbol("kCurrentWeight");
  const kIndex = /* @__PURE__ */ Symbol("kIndex");
  const kWeight = /* @__PURE__ */ Symbol("kWeight");
  const kMaxWeightPerServer = /* @__PURE__ */ Symbol("kMaxWeightPerServer");
  const kErrorPenalty = /* @__PURE__ */ Symbol("kErrorPenalty");
  function getGreatestCommonDivisor(a4, b4) {
    if (a4 === 0) return b4;
    while (b4 !== 0) {
      const t4 = b4;
      b4 = a4 % b4;
      a4 = t4;
    }
    return a4;
  }
  function defaultFactory(origin, opts) {
    return new Pool(origin, opts);
  }
  class BalancedPool extends PoolBase {
    constructor(upstreams = [], { factory = defaultFactory, ...opts } = {}) {
      if (typeof factory !== "function") {
        throw new InvalidArgumentError("factory must be a function.");
      }
      super();
      this[kOptions] = opts;
      this[kIndex] = -1;
      this[kCurrentWeight] = 0;
      this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100;
      this[kErrorPenalty] = this[kOptions].errorPenalty || 15;
      if (!Array.isArray(upstreams)) {
        upstreams = [upstreams];
      }
      this[kFactory] = factory;
      for (const upstream of upstreams) {
        this.addUpstream(upstream);
      }
      this._updateBalancedPoolStats();
    }
    addUpstream(upstream) {
      const upstreamOrigin = parseOrigin(upstream).origin;
      if (this[kClients].find((pool4) => pool4[kUrl].origin === upstreamOrigin && pool4.closed !== true && pool4.destroyed !== true)) {
        return this;
      }
      const pool3 = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]));
      this[kAddClient](pool3);
      pool3.on("connect", () => {
        pool3[kWeight] = Math.min(this[kMaxWeightPerServer], pool3[kWeight] + this[kErrorPenalty]);
      });
      pool3.on("connectionError", () => {
        pool3[kWeight] = Math.max(1, pool3[kWeight] - this[kErrorPenalty]);
        this._updateBalancedPoolStats();
      });
      pool3.on("disconnect", (...args) => {
        const err = args[2];
        if (err && err.code === "UND_ERR_SOCKET") {
          pool3[kWeight] = Math.max(1, pool3[kWeight] - this[kErrorPenalty]);
          this._updateBalancedPoolStats();
        }
      });
      for (const client2 of this[kClients]) {
        client2[kWeight] = this[kMaxWeightPerServer];
      }
      this._updateBalancedPoolStats();
      return this;
    }
    _updateBalancedPoolStats() {
      let result = 0;
      for (let i4 = 0; i4 < this[kClients].length; i4++) {
        result = getGreatestCommonDivisor(this[kClients][i4][kWeight], result);
      }
      this[kGreatestCommonDivisor] = result;
    }
    removeUpstream(upstream) {
      const upstreamOrigin = parseOrigin(upstream).origin;
      const pool3 = this[kClients].find((pool4) => pool4[kUrl].origin === upstreamOrigin && pool4.closed !== true && pool4.destroyed !== true);
      if (pool3) {
        this[kRemoveClient](pool3);
      }
      return this;
    }
    getUpstream(upstream) {
      const upstreamOrigin = parseOrigin(upstream).origin;
      return this[kClients].find((pool3) => pool3[kUrl].origin === upstreamOrigin && pool3.closed !== true && pool3.destroyed !== true);
    }
    get upstreams() {
      return this[kClients].filter((dispatcher2) => dispatcher2.closed !== true && dispatcher2.destroyed !== true).map((p4) => p4[kUrl].origin);
    }
    [kGetDispatcher]() {
      if (this[kClients].length === 0) {
        throw new BalancedPoolMissingUpstreamError();
      }
      const dispatcher2 = this[kClients].find((dispatcher3) => !dispatcher3[kNeedDrain] && dispatcher3.closed !== true && dispatcher3.destroyed !== true);
      if (!dispatcher2) {
        return;
      }
      const allClientsBusy = this[kClients].map((pool3) => pool3[kNeedDrain]).reduce((a4, b4) => a4 && b4, true);
      if (allClientsBusy) {
        return;
      }
      let counter = 0;
      let maxWeightIndex = this[kClients].findIndex((pool3) => !pool3[kNeedDrain]);
      while (counter++ < this[kClients].length) {
        this[kIndex] = (this[kIndex] + 1) % this[kClients].length;
        const pool3 = this[kClients][this[kIndex]];
        if (pool3[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool3[kNeedDrain]) {
          maxWeightIndex = this[kIndex];
        }
        if (this[kIndex] === 0) {
          this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor];
          if (this[kCurrentWeight] <= 0) {
            this[kCurrentWeight] = this[kMaxWeightPerServer];
          }
        }
        if (pool3[kWeight] >= this[kCurrentWeight] && !pool3[kNeedDrain]) {
          return pool3;
        }
      }
      this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight];
      this[kIndex] = maxWeightIndex;
      return this[kClients][maxWeightIndex];
    }
  }
  balancedPool = BalancedPool;
  return balancedPool;
}
var roundRobinPool;
var hasRequiredRoundRobinPool;
function requireRoundRobinPool() {
  if (hasRequiredRoundRobinPool) return roundRobinPool;
  hasRequiredRoundRobinPool = 1;
  const {
    PoolBase,
    kClients,
    kNeedDrain,
    kAddClient,
    kGetDispatcher,
    kRemoveClient
  } = requirePoolBase();
  const Client2 = requireClient();
  const {
    InvalidArgumentError
  } = requireErrors();
  const util2 = requireUtil$5();
  const { kUrl } = requireSymbols();
  const buildConnector = requireConnect();
  const kOptions = /* @__PURE__ */ Symbol("options");
  const kConnections = /* @__PURE__ */ Symbol("connections");
  const kFactory = /* @__PURE__ */ Symbol("factory");
  const kIndex = /* @__PURE__ */ Symbol("index");
  function defaultFactory(origin, opts) {
    return new Client2(origin, opts);
  }
  class RoundRobinPool extends PoolBase {
    constructor(origin, {
      connections,
      factory = defaultFactory,
      connect: connect2,
      connectTimeout,
      tls,
      maxCachedSessions,
      socketPath,
      autoSelectFamily,
      autoSelectFamilyAttemptTimeout,
      allowH2,
      clientTtl,
      ...options
    } = {}) {
      if (connections != null && (!Number.isFinite(connections) || connections < 0)) {
        throw new InvalidArgumentError("invalid connections");
      }
      if (typeof factory !== "function") {
        throw new InvalidArgumentError("factory must be a function.");
      }
      if (connect2 != null && typeof connect2 !== "function" && typeof connect2 !== "object") {
        throw new InvalidArgumentError("connect must be a function or an object");
      }
      if (typeof connect2 !== "function") {
        connect2 = buildConnector({
          ...tls,
          maxCachedSessions,
          allowH2,
          socketPath,
          timeout: connectTimeout,
          ...typeof autoSelectFamily === "boolean" ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : void 0,
          ...connect2
        });
      }
      super();
      this[kConnections] = connections || null;
      this[kUrl] = util2.parseOrigin(origin);
      this[kOptions] = { ...util2.deepClone(options), connect: connect2, allowH2, clientTtl };
      this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : void 0;
      this[kFactory] = factory;
      this[kIndex] = -1;
      this.on("connect", (origin2, targets) => {
        if (clientTtl != null && clientTtl > 0) {
          for (const target of targets) {
            Object.assign(target, { ttl: Date.now() });
          }
        }
      });
      this.on("connectionError", (origin2, targets, error2) => {
        for (const target of targets) {
          const idx = this[kClients].indexOf(target);
          if (idx !== -1) {
            this[kClients].splice(idx, 1);
          }
        }
      });
    }
    [kGetDispatcher]() {
      const clientTtlOption = this[kOptions].clientTtl;
      const clientsLength = this[kClients].length;
      if (clientsLength === 0) {
        const dispatcher2 = this[kFactory](this[kUrl], this[kOptions]);
        this[kAddClient](dispatcher2);
        return dispatcher2;
      }
      let checked = 0;
      while (checked < clientsLength) {
        this[kIndex] = (this[kIndex] + 1) % clientsLength;
        const client2 = this[kClients][this[kIndex]];
        if (clientTtlOption != null && clientTtlOption > 0 && client2.ttl && Date.now() - client2.ttl > clientTtlOption) {
          this[kRemoveClient](client2);
          checked++;
          continue;
        }
        if (!client2[kNeedDrain]) {
          return client2;
        }
        checked++;
      }
      if (!this[kConnections] || clientsLength < this[kConnections]) {
        const dispatcher2 = this[kFactory](this[kUrl], this[kOptions]);
        this[kAddClient](dispatcher2);
        return dispatcher2;
      }
    }
  }
  roundRobinPool = RoundRobinPool;
  return roundRobinPool;
}
var agent;
var hasRequiredAgent;
function requireAgent() {
  if (hasRequiredAgent) return agent;
  hasRequiredAgent = 1;
  const { InvalidArgumentError, MaxOriginsReachedError } = requireErrors();
  const { kClients, kRunning, kClose, kDestroy, kDispatch, kUrl } = requireSymbols();
  const DispatcherBase = requireDispatcherBase();
  const Pool = requirePool();
  const Client2 = requireClient();
  const util2 = requireUtil$5();
  const kOnConnect = /* @__PURE__ */ Symbol("onConnect");
  const kOnDisconnect = /* @__PURE__ */ Symbol("onDisconnect");
  const kOnConnectionError = /* @__PURE__ */ Symbol("onConnectionError");
  const kOnDrain = /* @__PURE__ */ Symbol("onDrain");
  const kFactory = /* @__PURE__ */ Symbol("factory");
  const kOptions = /* @__PURE__ */ Symbol("options");
  const kOrigins = /* @__PURE__ */ Symbol("origins");
  function defaultFactory(origin, opts) {
    return opts && opts.connections === 1 ? new Client2(origin, opts) : new Pool(origin, opts);
  }
  class Agent extends DispatcherBase {
    constructor({ factory = defaultFactory, maxOrigins = Infinity, connect: connect2, ...options } = {}) {
      if (typeof factory !== "function") {
        throw new InvalidArgumentError("factory must be a function.");
      }
      if (connect2 != null && typeof connect2 !== "function" && typeof connect2 !== "object") {
        throw new InvalidArgumentError("connect must be a function or an object");
      }
      if (typeof maxOrigins !== "number" || Number.isNaN(maxOrigins) || maxOrigins <= 0) {
        throw new InvalidArgumentError("maxOrigins must be a number greater than 0");
      }
      super();
      if (connect2 && typeof connect2 !== "function") {
        connect2 = { ...connect2 };
      }
      this[kOptions] = { ...util2.deepClone(options), maxOrigins, connect: connect2 };
      this[kFactory] = factory;
      this[kClients] = /* @__PURE__ */ new Map();
      this[kOrigins] = /* @__PURE__ */ new Set();
      this[kOnDrain] = (origin, targets) => {
        this.emit("drain", origin, [this, ...targets]);
      };
      this[kOnConnect] = (origin, targets) => {
        this.emit("connect", origin, [this, ...targets]);
      };
      this[kOnDisconnect] = (origin, targets, err) => {
        this.emit("disconnect", origin, [this, ...targets], err);
      };
      this[kOnConnectionError] = (origin, targets, err) => {
        this.emit("connectionError", origin, [this, ...targets], err);
      };
    }
    get [kRunning]() {
      let ret = 0;
      for (const { dispatcher: dispatcher2 } of this[kClients].values()) {
        ret += dispatcher2[kRunning];
      }
      return ret;
    }
    [kDispatch](opts, handler) {
      let key;
      if (opts.origin && (typeof opts.origin === "string" || opts.origin instanceof URL)) {
        key = String(opts.origin);
      } else {
        throw new InvalidArgumentError("opts.origin must be a non-empty string or URL.");
      }
      if (this[kOrigins].size >= this[kOptions].maxOrigins && !this[kOrigins].has(key)) {
        throw new MaxOriginsReachedError();
      }
      const result = this[kClients].get(key);
      let dispatcher2 = result && result.dispatcher;
      if (!dispatcher2) {
        const closeClientIfUnused = (connected) => {
          const result2 = this[kClients].get(key);
          if (result2) {
            if (connected) result2.count -= 1;
            if (result2.count <= 0) {
              this[kClients].delete(key);
              result2.dispatcher.close();
            }
            this[kOrigins].delete(key);
          }
        };
        dispatcher2 = this[kFactory](opts.origin, this[kOptions]).on("drain", this[kOnDrain]).on("connect", (origin, targets) => {
          const result2 = this[kClients].get(key);
          if (result2) {
            result2.count += 1;
          }
          this[kOnConnect](origin, targets);
        }).on("disconnect", (origin, targets, err) => {
          closeClientIfUnused(true);
          this[kOnDisconnect](origin, targets, err);
        }).on("connectionError", (origin, targets, err) => {
          closeClientIfUnused(false);
          this[kOnConnectionError](origin, targets, err);
        });
        this[kClients].set(key, { count: 0, dispatcher: dispatcher2 });
        this[kOrigins].add(key);
      }
      return dispatcher2.dispatch(opts, handler);
    }
    [kClose]() {
      const closePromises = [];
      for (const { dispatcher: dispatcher2 } of this[kClients].values()) {
        closePromises.push(dispatcher2.close());
      }
      this[kClients].clear();
      return Promise.all(closePromises);
    }
    [kDestroy](err) {
      const destroyPromises = [];
      for (const { dispatcher: dispatcher2 } of this[kClients].values()) {
        destroyPromises.push(dispatcher2.destroy(err));
      }
      this[kClients].clear();
      return Promise.all(destroyPromises);
    }
    get stats() {
      const allClientStats = {};
      for (const { dispatcher: dispatcher2 } of this[kClients].values()) {
        if (dispatcher2.stats) {
          allClientStats[dispatcher2[kUrl].origin] = dispatcher2.stats;
        }
      }
      return allClientStats;
    }
  }
  agent = Agent;
  return agent;
}
var proxyAgent;
var hasRequiredProxyAgent;
function requireProxyAgent() {
  if (hasRequiredProxyAgent) return proxyAgent;
  hasRequiredProxyAgent = 1;
  const { kProxy, kClose, kDestroy, kDispatch } = requireSymbols();
  const Agent = requireAgent();
  const Pool = requirePool();
  const DispatcherBase = requireDispatcherBase();
  const { InvalidArgumentError, RequestAbortedError, SecureProxyConnectionError } = requireErrors();
  const buildConnector = requireConnect();
  const Client2 = requireClient();
  const { channels } = requireDiagnostics();
  const kAgent = /* @__PURE__ */ Symbol("proxy agent");
  const kClient = /* @__PURE__ */ Symbol("proxy client");
  const kProxyHeaders = /* @__PURE__ */ Symbol("proxy headers");
  const kRequestTls = /* @__PURE__ */ Symbol("request tls settings");
  const kProxyTls = /* @__PURE__ */ Symbol("proxy tls settings");
  const kConnectEndpoint = /* @__PURE__ */ Symbol("connect endpoint function");
  const kTunnelProxy = /* @__PURE__ */ Symbol("tunnel proxy");
  function defaultProtocolPort(protocol) {
    return protocol === "https:" ? 443 : 80;
  }
  function defaultFactory(origin, opts) {
    return new Pool(origin, opts);
  }
  const noop2 = () => {
  };
  function defaultAgentFactory(origin, opts) {
    if (opts.connections === 1) {
      return new Client2(origin, opts);
    }
    return new Pool(origin, opts);
  }
  class Http1ProxyWrapper extends DispatcherBase {
    #client;
    constructor(proxyUrl, { headers: headers2 = {}, connect: connect2, factory }) {
      if (!proxyUrl) {
        throw new InvalidArgumentError("Proxy URL is mandatory");
      }
      super();
      this[kProxyHeaders] = headers2;
      if (factory) {
        this.#client = factory(proxyUrl, { connect: connect2 });
      } else {
        this.#client = new Client2(proxyUrl, { connect: connect2 });
      }
    }
    [kDispatch](opts, handler) {
      const onHeaders = handler.onHeaders;
      handler.onHeaders = function(statusCode, data2, resume) {
        if (statusCode === 407) {
          if (typeof handler.onError === "function") {
            handler.onError(new InvalidArgumentError("Proxy Authentication Required (407)"));
          }
          return;
        }
        if (onHeaders) onHeaders.call(this, statusCode, data2, resume);
      };
      const {
        origin,
        path: path3 = "/",
        headers: headers2 = {}
      } = opts;
      opts.path = origin + path3;
      if (!("host" in headers2) && !("Host" in headers2)) {
        const { host } = new URL(origin);
        headers2.host = host;
      }
      opts.headers = { ...this[kProxyHeaders], ...headers2 };
      return this.#client[kDispatch](opts, handler);
    }
    [kClose]() {
      return this.#client.close();
    }
    [kDestroy](err) {
      return this.#client.destroy(err);
    }
  }
  class ProxyAgent extends DispatcherBase {
    constructor(opts) {
      if (!opts || typeof opts === "object" && !(opts instanceof URL) && !opts.uri) {
        throw new InvalidArgumentError("Proxy uri is mandatory");
      }
      const { clientFactory = defaultFactory } = opts;
      if (typeof clientFactory !== "function") {
        throw new InvalidArgumentError("Proxy opts.clientFactory must be a function.");
      }
      const { proxyTunnel = true } = opts;
      super();
      const url = this.#getUrl(opts);
      const { href, origin, port, protocol, username, password, hostname: proxyHostname } = url;
      this[kProxy] = { uri: href, protocol };
      this[kRequestTls] = opts.requestTls;
      this[kProxyTls] = opts.proxyTls;
      this[kProxyHeaders] = opts.headers || {};
      this[kTunnelProxy] = proxyTunnel;
      if (opts.auth && opts.token) {
        throw new InvalidArgumentError("opts.auth cannot be used in combination with opts.token");
      } else if (opts.auth) {
        this[kProxyHeaders]["proxy-authorization"] = `Basic ${opts.auth}`;
      } else if (opts.token) {
        this[kProxyHeaders]["proxy-authorization"] = opts.token;
      } else if (username && password) {
        this[kProxyHeaders]["proxy-authorization"] = `Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString("base64")}`;
      }
      const connect2 = buildConnector({ ...opts.proxyTls });
      this[kConnectEndpoint] = buildConnector({ ...opts.requestTls });
      const agentFactory = opts.factory || defaultAgentFactory;
      const factory = (origin2, options) => {
        const { protocol: protocol2 } = new URL(origin2);
        if (!this[kTunnelProxy] && protocol2 === "http:" && this[kProxy].protocol === "http:") {
          return new Http1ProxyWrapper(this[kProxy].uri, {
            headers: this[kProxyHeaders],
            connect: connect2,
            factory: agentFactory
          });
        }
        return agentFactory(origin2, options);
      };
      this[kClient] = clientFactory(url, { connect: connect2 });
      this[kAgent] = new Agent({
        ...opts,
        factory,
        connect: async (opts2, callback) => {
          let requestedPath = opts2.host;
          if (!opts2.port) {
            requestedPath += `:${defaultProtocolPort(opts2.protocol)}`;
          }
          try {
            const connectParams = {
              origin,
              port,
              path: requestedPath,
              signal: opts2.signal,
              headers: {
                ...this[kProxyHeaders],
                host: opts2.host,
                ...opts2.connections == null || opts2.connections > 0 ? { "proxy-connection": "keep-alive" } : {}
              },
              servername: this[kProxyTls]?.servername || proxyHostname
            };
            const { socket, statusCode } = await this[kClient].connect(connectParams);
            if (statusCode !== 200) {
              socket.on("error", noop2).destroy();
              callback(new RequestAbortedError(`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`));
              return;
            }
            if (channels.proxyConnected.hasSubscribers) {
              channels.proxyConnected.publish({
                socket,
                connectParams
              });
            }
            if (opts2.protocol !== "https:") {
              callback(null, socket);
              return;
            }
            let servername;
            if (this[kRequestTls]) {
              servername = this[kRequestTls].servername;
            } else {
              servername = opts2.servername;
            }
            this[kConnectEndpoint]({ ...opts2, servername, httpSocket: socket }, callback);
          } catch (err) {
            if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
              callback(new SecureProxyConnectionError(err));
            } else {
              callback(err);
            }
          }
        }
      });
    }
    dispatch(opts, handler) {
      const headers2 = buildHeaders(opts.headers);
      throwIfProxyAuthIsSent(headers2);
      if (headers2 && !("host" in headers2) && !("Host" in headers2)) {
        const { host } = new URL(opts.origin);
        headers2.host = host;
      }
      return this[kAgent].dispatch(
        {
          ...opts,
          headers: headers2
        },
        handler
      );
    }
    /**
     * @param {import('../../types/proxy-agent').ProxyAgent.Options | string | URL} opts
     * @returns {URL}
     */
    #getUrl(opts) {
      if (typeof opts === "string") {
        return new URL(opts);
      } else if (opts instanceof URL) {
        return opts;
      } else {
        return new URL(opts.uri);
      }
    }
    [kClose]() {
      return Promise.all([
        this[kAgent].close(),
        this[kClient].close()
      ]);
    }
    [kDestroy]() {
      return Promise.all([
        this[kAgent].destroy(),
        this[kClient].destroy()
      ]);
    }
  }
  function buildHeaders(headers2) {
    if (Array.isArray(headers2)) {
      const headersPair = {};
      for (let i4 = 0; i4 < headers2.length; i4 += 2) {
        headersPair[headers2[i4]] = headers2[i4 + 1];
      }
      return headersPair;
    }
    return headers2;
  }
  function throwIfProxyAuthIsSent(headers2) {
    const existProxyAuth = headers2 && Object.keys(headers2).find((key) => key.toLowerCase() === "proxy-authorization");
    if (existProxyAuth) {
      throw new InvalidArgumentError("Proxy-Authorization should be sent in ProxyAgent constructor");
    }
  }
  proxyAgent = ProxyAgent;
  return proxyAgent;
}
var envHttpProxyAgent;
var hasRequiredEnvHttpProxyAgent;
function requireEnvHttpProxyAgent() {
  if (hasRequiredEnvHttpProxyAgent) return envHttpProxyAgent;
  hasRequiredEnvHttpProxyAgent = 1;
  const DispatcherBase = requireDispatcherBase();
  const { kClose, kDestroy, kClosed, kDestroyed, kDispatch, kNoProxyAgent, kHttpProxyAgent, kHttpsProxyAgent } = requireSymbols();
  const ProxyAgent = requireProxyAgent();
  const Agent = requireAgent();
  const DEFAULT_PORTS = {
    "http:": 80,
    "https:": 443
  };
  class EnvHttpProxyAgent extends DispatcherBase {
    #noProxyValue = null;
    #noProxyEntries = null;
    #opts = null;
    constructor(opts = {}) {
      super();
      this.#opts = opts;
      const { httpProxy, httpsProxy, noProxy, ...agentOpts } = opts;
      this[kNoProxyAgent] = new Agent(agentOpts);
      const HTTP_PROXY = httpProxy ?? process.env.http_proxy ?? process.env.HTTP_PROXY;
      if (HTTP_PROXY) {
        this[kHttpProxyAgent] = new ProxyAgent({ ...agentOpts, uri: HTTP_PROXY });
      } else {
        this[kHttpProxyAgent] = this[kNoProxyAgent];
      }
      const HTTPS_PROXY = httpsProxy ?? process.env.https_proxy ?? process.env.HTTPS_PROXY;
      if (HTTPS_PROXY) {
        this[kHttpsProxyAgent] = new ProxyAgent({ ...agentOpts, uri: HTTPS_PROXY });
      } else {
        this[kHttpsProxyAgent] = this[kHttpProxyAgent];
      }
      this.#parseNoProxy();
    }
    [kDispatch](opts, handler) {
      const url = new URL(opts.origin);
      const agent2 = this.#getProxyAgentForUrl(url);
      return agent2.dispatch(opts, handler);
    }
    [kClose]() {
      return Promise.all([
        this[kNoProxyAgent].close(),
        !this[kHttpProxyAgent][kClosed] && this[kHttpProxyAgent].close(),
        !this[kHttpsProxyAgent][kClosed] && this[kHttpsProxyAgent].close()
      ]);
    }
    [kDestroy](err) {
      return Promise.all([
        this[kNoProxyAgent].destroy(err),
        !this[kHttpProxyAgent][kDestroyed] && this[kHttpProxyAgent].destroy(err),
        !this[kHttpsProxyAgent][kDestroyed] && this[kHttpsProxyAgent].destroy(err)
      ]);
    }
    #getProxyAgentForUrl(url) {
      let { protocol, host: hostname, port } = url;
      hostname = hostname.replace(/:\d*$/, "").toLowerCase();
      port = Number.parseInt(port, 10) || DEFAULT_PORTS[protocol] || 0;
      if (!this.#shouldProxy(hostname, port)) {
        return this[kNoProxyAgent];
      }
      if (protocol === "https:") {
        return this[kHttpsProxyAgent];
      }
      return this[kHttpProxyAgent];
    }
    #shouldProxy(hostname, port) {
      if (this.#noProxyChanged) {
        this.#parseNoProxy();
      }
      if (this.#noProxyEntries.length === 0) {
        return true;
      }
      if (this.#noProxyValue === "*") {
        return false;
      }
      for (let i4 = 0; i4 < this.#noProxyEntries.length; i4++) {
        const entry = this.#noProxyEntries[i4];
        if (entry.port && entry.port !== port) {
          continue;
        }
        if (!/^[.*]/.test(entry.hostname)) {
          if (hostname === entry.hostname) {
            return false;
          }
        } else {
          if (hostname.endsWith(entry.hostname.replace(/^\*/, ""))) {
            return false;
          }
        }
      }
      return true;
    }
    #parseNoProxy() {
      const noProxyValue = this.#opts.noProxy ?? this.#noProxyEnv;
      const noProxySplit = noProxyValue.split(/[,\s]/);
      const noProxyEntries = [];
      for (let i4 = 0; i4 < noProxySplit.length; i4++) {
        const entry = noProxySplit[i4];
        if (!entry) {
          continue;
        }
        const parsed = entry.match(/^(.+):(\d+)$/);
        noProxyEntries.push({
          hostname: (parsed ? parsed[1] : entry).toLowerCase(),
          port: parsed ? Number.parseInt(parsed[2], 10) : 0
        });
      }
      this.#noProxyValue = noProxyValue;
      this.#noProxyEntries = noProxyEntries;
    }
    get #noProxyChanged() {
      if (this.#opts.noProxy !== void 0) {
        return false;
      }
      return this.#noProxyValue !== this.#noProxyEnv;
    }
    get #noProxyEnv() {
      return process.env.no_proxy ?? process.env.NO_PROXY ?? "";
    }
  }
  envHttpProxyAgent = EnvHttpProxyAgent;
  return envHttpProxyAgent;
}
var retryHandler;
var hasRequiredRetryHandler;
function requireRetryHandler() {
  if (hasRequiredRetryHandler) return retryHandler;
  hasRequiredRetryHandler = 1;
  const assert = import_node_assert.default;
  const { kRetryHandlerDefaultRetry } = requireSymbols();
  const { RequestRetryError } = requireErrors();
  const WrapHandler = requireWrapHandler();
  const {
    isDisturbed,
    parseRangeHeader,
    wrapRequestBody
  } = requireUtil$5();
  function calculateRetryAfterHeader(retryAfter) {
    const retryTime = new Date(retryAfter).getTime();
    return isNaN(retryTime) ? 0 : retryTime - Date.now();
  }
  class RetryHandler {
    constructor(opts, { dispatch, handler }) {
      const { retryOptions, ...dispatchOpts } = opts;
      const {
        // Retry scoped
        retry: retryFn,
        maxRetries,
        maxTimeout,
        minTimeout,
        timeoutFactor,
        // Response scoped
        methods,
        errorCodes,
        retryAfter,
        statusCodes,
        throwOnError
      } = retryOptions ?? {};
      this.error = null;
      this.dispatch = dispatch;
      this.handler = WrapHandler.wrap(handler);
      this.opts = { ...dispatchOpts, body: wrapRequestBody(opts.body) };
      this.retryOpts = {
        throwOnError: throwOnError ?? true,
        retry: retryFn ?? RetryHandler[kRetryHandlerDefaultRetry],
        retryAfter: retryAfter ?? true,
        maxTimeout: maxTimeout ?? 30 * 1e3,
        // 30s,
        minTimeout: minTimeout ?? 500,
        // .5s
        timeoutFactor: timeoutFactor ?? 2,
        maxRetries: maxRetries ?? 5,
        // What errors we should retry
        methods: methods ?? ["GET", "HEAD", "OPTIONS", "PUT", "DELETE", "TRACE"],
        // Indicates which errors to retry
        statusCodes: statusCodes ?? [500, 502, 503, 504, 429],
        // List of errors to retry
        errorCodes: errorCodes ?? [
          "ECONNRESET",
          "ECONNREFUSED",
          "ENOTFOUND",
          "ENETDOWN",
          "ENETUNREACH",
          "EHOSTDOWN",
          "EHOSTUNREACH",
          "EPIPE",
          "UND_ERR_SOCKET"
        ]
      };
      this.retryCount = 0;
      this.retryCountCheckpoint = 0;
      this.headersSent = false;
      this.start = 0;
      this.end = null;
      this.etag = null;
    }
    onResponseStartWithRetry(controller, statusCode, headers2, statusMessage, err) {
      if (this.retryOpts.throwOnError) {
        if (this.retryOpts.statusCodes.includes(statusCode) === false) {
          this.headersSent = true;
          this.handler.onResponseStart?.(controller, statusCode, headers2, statusMessage);
        } else {
          this.error = err;
        }
        return;
      }
      if (isDisturbed(this.opts.body)) {
        this.headersSent = true;
        this.handler.onResponseStart?.(controller, statusCode, headers2, statusMessage);
        return;
      }
      function shouldRetry(passedErr) {
        if (passedErr) {
          this.headersSent = true;
          this.handler.onResponseStart?.(controller, statusCode, headers2, statusMessage);
          controller.resume();
          return;
        }
        this.error = err;
        controller.resume();
      }
      controller.pause();
      this.retryOpts.retry(
        err,
        {
          state: { counter: this.retryCount },
          opts: { retryOptions: this.retryOpts, ...this.opts }
        },
        shouldRetry.bind(this)
      );
    }
    onRequestStart(controller, context) {
      if (!this.headersSent) {
        this.handler.onRequestStart?.(controller, context);
      }
    }
    onRequestUpgrade(controller, statusCode, headers2, socket) {
      this.handler.onRequestUpgrade?.(controller, statusCode, headers2, socket);
    }
    static [kRetryHandlerDefaultRetry](err, { state: state2, opts }, cb) {
      const { statusCode, code, headers: headers2 } = err;
      const { method, retryOptions } = opts;
      const {
        maxRetries,
        minTimeout,
        maxTimeout,
        timeoutFactor,
        statusCodes,
        errorCodes,
        methods
      } = retryOptions;
      const { counter } = state2;
      if (code && code !== "UND_ERR_REQ_RETRY" && !errorCodes.includes(code)) {
        cb(err);
        return;
      }
      if (Array.isArray(methods) && !methods.includes(method)) {
        cb(err);
        return;
      }
      if (statusCode != null && Array.isArray(statusCodes) && !statusCodes.includes(statusCode)) {
        cb(err);
        return;
      }
      if (counter > maxRetries) {
        cb(err);
        return;
      }
      let retryAfterHeader = headers2?.["retry-after"];
      if (retryAfterHeader) {
        retryAfterHeader = Number(retryAfterHeader);
        retryAfterHeader = Number.isNaN(retryAfterHeader) ? calculateRetryAfterHeader(headers2["retry-after"]) : retryAfterHeader * 1e3;
      }
      const retryTimeout = retryAfterHeader > 0 ? Math.min(retryAfterHeader, maxTimeout) : Math.min(minTimeout * timeoutFactor ** (counter - 1), maxTimeout);
      setTimeout(() => cb(null), retryTimeout);
    }
    onResponseStart(controller, statusCode, headers2, statusMessage) {
      this.error = null;
      this.retryCount += 1;
      if (statusCode >= 300) {
        const err = new RequestRetryError("Request failed", statusCode, {
          headers: headers2,
          data: {
            count: this.retryCount
          }
        });
        this.onResponseStartWithRetry(controller, statusCode, headers2, statusMessage, err);
        return;
      }
      if (this.headersSent) {
        if (statusCode !== 206 && (this.start > 0 || statusCode !== 200)) {
          throw new RequestRetryError("server does not support the range header and the payload was partially consumed", statusCode, {
            headers: headers2,
            data: { count: this.retryCount }
          });
        }
        const contentRange = parseRangeHeader(headers2["content-range"]);
        if (!contentRange) {
          throw new RequestRetryError("Content-Range mismatch", statusCode, {
            headers: headers2,
            data: { count: this.retryCount }
          });
        }
        if (this.etag != null && this.etag !== headers2.etag) {
          throw new RequestRetryError("ETag mismatch", statusCode, {
            headers: headers2,
            data: { count: this.retryCount }
          });
        }
        const { start, size, end = size ? size - 1 : null } = contentRange;
        assert(this.start === start, "content-range mismatch");
        assert(this.end == null || this.end === end, "content-range mismatch");
        return;
      }
      if (this.end == null) {
        if (statusCode === 206) {
          const range2 = parseRangeHeader(headers2["content-range"]);
          if (range2 == null) {
            this.headersSent = true;
            this.handler.onResponseStart?.(
              controller,
              statusCode,
              headers2,
              statusMessage
            );
            return;
          }
          const { start, size, end = size ? size - 1 : null } = range2;
          assert(
            start != null && Number.isFinite(start),
            "content-range mismatch"
          );
          assert(end != null && Number.isFinite(end), "invalid content-length");
          this.start = start;
          this.end = end;
        }
        if (this.end == null) {
          const contentLength = headers2["content-length"];
          this.end = contentLength != null ? Number(contentLength) - 1 : null;
        }
        assert(Number.isFinite(this.start));
        assert(
          this.end == null || Number.isFinite(this.end),
          "invalid content-length"
        );
        this.resume = true;
        this.etag = headers2.etag != null ? headers2.etag : null;
        if (this.etag != null && this.etag[0] === "W" && this.etag[1] === "/") {
          this.etag = null;
        }
        this.headersSent = true;
        this.handler.onResponseStart?.(
          controller,
          statusCode,
          headers2,
          statusMessage
        );
      } else {
        throw new RequestRetryError("Request failed", statusCode, {
          headers: headers2,
          data: { count: this.retryCount }
        });
      }
    }
    onResponseData(controller, chunk2) {
      if (this.error) {
        return;
      }
      this.start += chunk2.length;
      this.handler.onResponseData?.(controller, chunk2);
    }
    onResponseEnd(controller, trailers) {
      if (this.error && this.retryOpts.throwOnError) {
        throw this.error;
      }
      if (!this.error) {
        this.retryCount = 0;
        return this.handler.onResponseEnd?.(controller, trailers);
      }
      this.retry(controller);
    }
    retry(controller) {
      if (this.start !== 0) {
        const headers2 = { range: `bytes=${this.start}-${this.end ?? ""}` };
        if (this.etag != null) {
          headers2["if-match"] = this.etag;
        }
        this.opts = {
          ...this.opts,
          headers: {
            ...this.opts.headers,
            ...headers2
          }
        };
      }
      try {
        this.retryCountCheckpoint = this.retryCount;
        this.dispatch(this.opts, this);
      } catch (err) {
        this.handler.onResponseError?.(controller, err);
      }
    }
    onResponseError(controller, err) {
      if (controller?.aborted || isDisturbed(this.opts.body)) {
        this.handler.onResponseError?.(controller, err);
        return;
      }
      function shouldRetry(returnedErr) {
        if (!returnedErr) {
          this.retry(controller);
          return;
        }
        this.handler?.onResponseError?.(controller, returnedErr);
      }
      if (this.retryCount - this.retryCountCheckpoint > 0) {
        this.retryCount = this.retryCountCheckpoint + (this.retryCount - this.retryCountCheckpoint);
      } else {
        this.retryCount += 1;
      }
      this.retryOpts.retry(
        err,
        {
          state: { counter: this.retryCount },
          opts: { retryOptions: this.retryOpts, ...this.opts }
        },
        shouldRetry.bind(this)
      );
    }
  }
  retryHandler = RetryHandler;
  return retryHandler;
}
var retryAgent;
var hasRequiredRetryAgent;
function requireRetryAgent() {
  if (hasRequiredRetryAgent) return retryAgent;
  hasRequiredRetryAgent = 1;
  const Dispatcher = requireDispatcher();
  const RetryHandler = requireRetryHandler();
  class RetryAgent extends Dispatcher {
    #agent = null;
    #options = null;
    constructor(agent2, options = {}) {
      super(options);
      this.#agent = agent2;
      this.#options = options;
    }
    dispatch(opts, handler) {
      const retry2 = new RetryHandler({
        ...opts,
        retryOptions: this.#options
      }, {
        dispatch: this.#agent.dispatch.bind(this.#agent),
        handler
      });
      return this.#agent.dispatch(opts, retry2);
    }
    close() {
      return this.#agent.close();
    }
    destroy() {
      return this.#agent.destroy();
    }
  }
  retryAgent = RetryAgent;
  return retryAgent;
}
var h2cClient;
var hasRequiredH2cClient;
function requireH2cClient() {
  if (hasRequiredH2cClient) return h2cClient;
  hasRequiredH2cClient = 1;
  const { InvalidArgumentError } = requireErrors();
  const Client2 = requireClient();
  class H2CClient extends Client2 {
    constructor(origin, clientOpts) {
      if (typeof origin === "string") {
        origin = new URL(origin);
      }
      if (origin.protocol !== "http:") {
        throw new InvalidArgumentError(
          "h2c-client: Only h2c protocol is supported"
        );
      }
      const { connect: connect2, maxConcurrentStreams, pipelining, ...opts } = clientOpts ?? {};
      let defaultMaxConcurrentStreams = 100;
      let defaultPipelining = 100;
      if (maxConcurrentStreams != null && Number.isInteger(maxConcurrentStreams) && maxConcurrentStreams > 0) {
        defaultMaxConcurrentStreams = maxConcurrentStreams;
      }
      if (pipelining != null && Number.isInteger(pipelining) && pipelining > 0) {
        defaultPipelining = pipelining;
      }
      if (defaultPipelining > defaultMaxConcurrentStreams) {
        throw new InvalidArgumentError(
          "h2c-client: pipelining cannot be greater than maxConcurrentStreams"
        );
      }
      super(origin, {
        ...opts,
        maxConcurrentStreams: defaultMaxConcurrentStreams,
        pipelining: defaultPipelining,
        allowH2: true,
        useH2c: true
      });
    }
  }
  h2cClient = H2CClient;
  return h2cClient;
}
var api = {};
var apiRequest = { exports: {} };
var readable;
var hasRequiredReadable;
function requireReadable() {
  if (hasRequiredReadable) return readable;
  hasRequiredReadable = 1;
  const assert = import_node_assert.default;
  const { Readable: Readable2 } = import_node_stream.default;
  const { RequestAbortedError, NotSupportedError, InvalidArgumentError, AbortError } = requireErrors();
  const util2 = requireUtil$5();
  const { ReadableStreamFrom } = requireUtil$5();
  const kConsume = /* @__PURE__ */ Symbol("kConsume");
  const kReading = /* @__PURE__ */ Symbol("kReading");
  const kBody = /* @__PURE__ */ Symbol("kBody");
  const kAbort = /* @__PURE__ */ Symbol("kAbort");
  const kContentType = /* @__PURE__ */ Symbol("kContentType");
  const kContentLength = /* @__PURE__ */ Symbol("kContentLength");
  const kUsed = /* @__PURE__ */ Symbol("kUsed");
  const kBytesRead = /* @__PURE__ */ Symbol("kBytesRead");
  const noop2 = () => {
  };
  class BodyReadable extends Readable2 {
    /**
     * @param {object} opts
     * @param {(this: Readable, size: number) => void} opts.resume
     * @param {() => (void | null)} opts.abort
     * @param {string} [opts.contentType = '']
     * @param {number} [opts.contentLength]
     * @param {number} [opts.highWaterMark = 64 * 1024]
     */
    constructor({
      resume,
      abort,
      contentType = "",
      contentLength,
      highWaterMark = 64 * 1024
      // Same as nodejs fs streams.
    }) {
      super({
        autoDestroy: true,
        read: resume,
        highWaterMark
      });
      this._readableState.dataEmitted = false;
      this[kAbort] = abort;
      this[kConsume] = null;
      this[kBytesRead] = 0;
      this[kBody] = null;
      this[kUsed] = false;
      this[kContentType] = contentType;
      this[kContentLength] = Number.isFinite(contentLength) ? contentLength : null;
      this[kReading] = false;
    }
    /**
     * @param {Error|null} err
     * @param {(error:(Error|null)) => void} callback
     * @returns {void}
     */
    _destroy(err, callback) {
      if (!err && !this._readableState.endEmitted) {
        err = new RequestAbortedError();
      }
      if (err) {
        this[kAbort]();
      }
      if (!this[kUsed]) {
        setImmediate(callback, err);
      } else {
        callback(err);
      }
    }
    /**
     * @param {string|symbol} event
     * @param {(...args: any[]) => void} listener
     * @returns {this}
     */
    on(event, listener) {
      if (event === "data" || event === "readable") {
        this[kReading] = true;
        this[kUsed] = true;
      }
      return super.on(event, listener);
    }
    /**
     * @param {string|symbol} event
     * @param {(...args: any[]) => void} listener
     * @returns {this}
     */
    addListener(event, listener) {
      return this.on(event, listener);
    }
    /**
     * @param {string|symbol} event
     * @param {(...args: any[]) => void} listener
     * @returns {this}
     */
    off(event, listener) {
      const ret = super.off(event, listener);
      if (event === "data" || event === "readable") {
        this[kReading] = this.listenerCount("data") > 0 || this.listenerCount("readable") > 0;
      }
      return ret;
    }
    /**
     * @param {string|symbol} event
     * @param {(...args: any[]) => void} listener
     * @returns {this}
     */
    removeListener(event, listener) {
      return this.off(event, listener);
    }
    /**
     * @param {Buffer|null} chunk
     * @returns {boolean}
     */
    push(chunk2) {
      if (chunk2) {
        this[kBytesRead] += chunk2.length;
        if (this[kConsume]) {
          consumePush(this[kConsume], chunk2);
          return this[kReading] ? super.push(chunk2) : true;
        }
      }
      return super.push(chunk2);
    }
    /**
     * Consumes and returns the body as a string.
     *
     * @see https://fetch.spec.whatwg.org/#dom-body-text
     * @returns {Promise<string>}
     */
    text() {
      return consume(this, "text");
    }
    /**
     * Consumes and returns the body as a JavaScript Object.
     *
     * @see https://fetch.spec.whatwg.org/#dom-body-json
     * @returns {Promise<unknown>}
     */
    json() {
      return consume(this, "json");
    }
    /**
     * Consumes and returns the body as a Blob
     *
     * @see https://fetch.spec.whatwg.org/#dom-body-blob
     * @returns {Promise<Blob>}
     */
    blob() {
      return consume(this, "blob");
    }
    /**
     * Consumes and returns the body as an Uint8Array.
     *
     * @see https://fetch.spec.whatwg.org/#dom-body-bytes
     * @returns {Promise<Uint8Array>}
     */
    bytes() {
      return consume(this, "bytes");
    }
    /**
     * Consumes and returns the body as an ArrayBuffer.
     *
     * @see https://fetch.spec.whatwg.org/#dom-body-arraybuffer
     * @returns {Promise<ArrayBuffer>}
     */
    arrayBuffer() {
      return consume(this, "arrayBuffer");
    }
    /**
     * Not implemented
     *
     * @see https://fetch.spec.whatwg.org/#dom-body-formdata
     * @throws {NotSupportedError}
     */
    async formData() {
      throw new NotSupportedError();
    }
    /**
     * Returns true if the body is not null and the body has been consumed.
     * Otherwise, returns false.
     *
     * @see https://fetch.spec.whatwg.org/#dom-body-bodyused
     * @readonly
     * @returns {boolean}
     */
    get bodyUsed() {
      return util2.isDisturbed(this);
    }
    /**
     * @see https://fetch.spec.whatwg.org/#dom-body-body
     * @readonly
     * @returns {ReadableStream}
     */
    get body() {
      if (!this[kBody]) {
        this[kBody] = ReadableStreamFrom(this);
        if (this[kConsume]) {
          this[kBody].getReader();
          assert(this[kBody].locked);
        }
      }
      return this[kBody];
    }
    /**
     * Dumps the response body by reading `limit` number of bytes.
     * @param {object} opts
     * @param {number} [opts.limit = 131072] Number of bytes to read.
     * @param {AbortSignal} [opts.signal] An AbortSignal to cancel the dump.
     * @returns {Promise<null>}
     */
    dump(opts) {
      const signal = opts?.signal;
      if (signal != null && (typeof signal !== "object" || !("aborted" in signal))) {
        return Promise.reject(new InvalidArgumentError("signal must be an AbortSignal"));
      }
      const limit = opts?.limit && Number.isFinite(opts.limit) ? opts.limit : 128 * 1024;
      if (signal?.aborted) {
        return Promise.reject(signal.reason ?? new AbortError());
      }
      if (this._readableState.closeEmitted) {
        return Promise.resolve(null);
      }
      return new Promise((resolve, reject) => {
        if (this[kContentLength] && this[kContentLength] > limit || this[kBytesRead] > limit) {
          this.destroy(new AbortError());
        }
        if (signal) {
          const onAbort = () => {
            this.destroy(signal.reason ?? new AbortError());
          };
          signal.addEventListener("abort", onAbort);
          this.on("close", function() {
            signal.removeEventListener("abort", onAbort);
            if (signal.aborted) {
              reject(signal.reason ?? new AbortError());
            } else {
              resolve(null);
            }
          });
        } else {
          this.on("close", resolve);
        }
        this.on("error", noop2).on("data", () => {
          if (this[kBytesRead] > limit) {
            this.destroy();
          }
        }).resume();
      });
    }
    /**
     * @param {BufferEncoding} encoding
     * @returns {this}
     */
    setEncoding(encoding2) {
      if (Buffer.isEncoding(encoding2)) {
        this._readableState.encoding = encoding2;
      }
      return this;
    }
  }
  function isLocked(bodyReadable) {
    return bodyReadable[kBody]?.locked === true || bodyReadable[kConsume] !== null;
  }
  function isUnusable(bodyReadable) {
    return util2.isDisturbed(bodyReadable) || isLocked(bodyReadable);
  }
  function consume(stream, type) {
    assert(!stream[kConsume]);
    return new Promise((resolve, reject) => {
      if (isUnusable(stream)) {
        const rState = stream._readableState;
        if (rState.destroyed && rState.closeEmitted === false) {
          stream.on("error", reject).on("close", () => {
            reject(new TypeError("unusable"));
          });
        } else {
          reject(rState.errored ?? new TypeError("unusable"));
        }
      } else {
        queueMicrotask(() => {
          stream[kConsume] = {
            type,
            stream,
            resolve,
            reject,
            length: 0,
            body: []
          };
          stream.on("error", function(err) {
            consumeFinish(this[kConsume], err);
          }).on("close", function() {
            if (this[kConsume].body !== null) {
              consumeFinish(this[kConsume], new RequestAbortedError());
            }
          });
          consumeStart(stream[kConsume]);
        });
      }
    });
  }
  function consumeStart(consume2) {
    if (consume2.body === null) {
      return;
    }
    const { _readableState: state2 } = consume2.stream;
    if (state2.bufferIndex) {
      const start = state2.bufferIndex;
      const end = state2.buffer.length;
      for (let n4 = start; n4 < end; n4++) {
        consumePush(consume2, state2.buffer[n4]);
      }
    } else {
      for (const chunk2 of state2.buffer) {
        consumePush(consume2, chunk2);
      }
    }
    if (state2.endEmitted) {
      consumeEnd(this[kConsume], this._readableState.encoding);
    } else {
      consume2.stream.on("end", function() {
        consumeEnd(this[kConsume], this._readableState.encoding);
      });
    }
    consume2.stream.resume();
    while (consume2.stream.read() != null) {
    }
  }
  function chunksDecode(chunks, length, encoding2) {
    if (chunks.length === 0 || length === 0) {
      return "";
    }
    const buffer = chunks.length === 1 ? chunks[0] : Buffer.concat(chunks, length);
    const bufferLength = buffer.length;
    const start = bufferLength > 2 && buffer[0] === 239 && buffer[1] === 187 && buffer[2] === 191 ? 3 : 0;
    if (!encoding2 || encoding2 === "utf8" || encoding2 === "utf-8") {
      return buffer.utf8Slice(start, bufferLength);
    } else {
      return buffer.subarray(start, bufferLength).toString(encoding2);
    }
  }
  function chunksConcat(chunks, length) {
    if (chunks.length === 0 || length === 0) {
      return new Uint8Array(0);
    }
    if (chunks.length === 1) {
      return new Uint8Array(chunks[0]);
    }
    const buffer = new Uint8Array(Buffer.allocUnsafeSlow(length).buffer);
    let offset = 0;
    for (let i4 = 0; i4 < chunks.length; ++i4) {
      const chunk2 = chunks[i4];
      buffer.set(chunk2, offset);
      offset += chunk2.length;
    }
    return buffer;
  }
  function consumeEnd(consume2, encoding2) {
    const { type, body: body2, resolve, stream, length } = consume2;
    try {
      if (type === "text") {
        resolve(chunksDecode(body2, length, encoding2));
      } else if (type === "json") {
        resolve(JSON.parse(chunksDecode(body2, length, encoding2)));
      } else if (type === "arrayBuffer") {
        resolve(chunksConcat(body2, length).buffer);
      } else if (type === "blob") {
        resolve(new Blob(body2, { type: stream[kContentType] }));
      } else if (type === "bytes") {
        resolve(chunksConcat(body2, length));
      }
      consumeFinish(consume2);
    } catch (err) {
      stream.destroy(err);
    }
  }
  function consumePush(consume2, chunk2) {
    consume2.length += chunk2.length;
    consume2.body.push(chunk2);
  }
  function consumeFinish(consume2, err) {
    if (consume2.body === null) {
      return;
    }
    if (err) {
      consume2.reject(err);
    } else {
      consume2.resolve();
    }
    consume2.type = null;
    consume2.stream = null;
    consume2.resolve = null;
    consume2.reject = null;
    consume2.length = 0;
    consume2.body = null;
  }
  readable = {
    Readable: BodyReadable,
    chunksDecode
  };
  return readable;
}
var hasRequiredApiRequest;
function requireApiRequest() {
  if (hasRequiredApiRequest) return apiRequest.exports;
  hasRequiredApiRequest = 1;
  const assert = import_node_assert.default;
  const { AsyncResource } = import_node_async_hooks.default;
  const { Readable: Readable2 } = requireReadable();
  const { InvalidArgumentError, RequestAbortedError } = requireErrors();
  const util2 = requireUtil$5();
  function noop2() {
  }
  class RequestHandler4 extends AsyncResource {
    constructor(opts, callback) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      const { signal, method, opaque, body: body2, onInfo, responseHeaders, highWaterMark } = opts;
      try {
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (highWaterMark && (typeof highWaterMark !== "number" || highWaterMark < 0)) {
          throw new InvalidArgumentError("invalid highWaterMark");
        }
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        if (method === "CONNECT") {
          throw new InvalidArgumentError("invalid method");
        }
        if (onInfo && typeof onInfo !== "function") {
          throw new InvalidArgumentError("invalid onInfo callback");
        }
        super("UNDICI_REQUEST");
      } catch (err) {
        if (util2.isStream(body2)) {
          util2.destroy(body2.on("error", noop2), err);
        }
        throw err;
      }
      this.method = method;
      this.responseHeaders = responseHeaders || null;
      this.opaque = opaque || null;
      this.callback = callback;
      this.res = null;
      this.abort = null;
      this.body = body2;
      this.trailers = {};
      this.context = null;
      this.onInfo = onInfo || null;
      this.highWaterMark = highWaterMark;
      this.reason = null;
      this.removeAbortListener = null;
      if (signal?.aborted) {
        this.reason = signal.reason ?? new RequestAbortedError();
      } else if (signal) {
        this.removeAbortListener = util2.addAbortListener(signal, () => {
          this.reason = signal.reason ?? new RequestAbortedError();
          if (this.res) {
            util2.destroy(this.res.on("error", noop2), this.reason);
          } else if (this.abort) {
            this.abort(this.reason);
          }
        });
      }
    }
    onConnect(abort, context) {
      if (this.reason) {
        abort(this.reason);
        return;
      }
      assert(this.callback);
      this.abort = abort;
      this.context = context;
    }
    onHeaders(statusCode, rawHeaders, resume, statusMessage) {
      const { callback, opaque, abort, context, responseHeaders, highWaterMark } = this;
      const headers2 = responseHeaders === "raw" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);
      if (statusCode < 200) {
        if (this.onInfo) {
          this.onInfo({ statusCode, headers: headers2 });
        }
        return;
      }
      const parsedHeaders = responseHeaders === "raw" ? util2.parseHeaders(rawHeaders) : headers2;
      const contentType = parsedHeaders["content-type"];
      const contentLength = parsedHeaders["content-length"];
      const res = new Readable2({
        resume,
        abort,
        contentType,
        contentLength: this.method !== "HEAD" && contentLength ? Number(contentLength) : null,
        highWaterMark
      });
      if (this.removeAbortListener) {
        res.on("close", this.removeAbortListener);
        this.removeAbortListener = null;
      }
      this.callback = null;
      this.res = res;
      if (callback !== null) {
        try {
          this.runInAsyncScope(callback, null, null, {
            statusCode,
            headers: headers2,
            trailers: this.trailers,
            opaque,
            body: res,
            context
          });
        } catch (err) {
          this.res = null;
          util2.destroy(res.on("error", noop2), err);
          queueMicrotask(() => {
            throw err;
          });
        }
      }
    }
    onData(chunk2) {
      return this.res.push(chunk2);
    }
    onComplete(trailers) {
      util2.parseHeaders(trailers, this.trailers);
      this.res.push(null);
    }
    onError(err) {
      const { res, callback, body: body2, opaque } = this;
      if (callback) {
        this.callback = null;
        queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, { opaque });
        });
      }
      if (res) {
        this.res = null;
        queueMicrotask(() => {
          util2.destroy(res.on("error", noop2), err);
        });
      }
      if (body2) {
        this.body = null;
        if (util2.isStream(body2)) {
          body2.on("error", noop2);
          util2.destroy(body2, err);
        }
      }
      if (this.removeAbortListener) {
        this.removeAbortListener();
        this.removeAbortListener = null;
      }
    }
  }
  function request2(opts, callback) {
    if (callback === void 0) {
      return new Promise((resolve, reject) => {
        request2.call(this, opts, (err, data2) => {
          return err ? reject(err) : resolve(data2);
        });
      });
    }
    try {
      const handler = new RequestHandler4(opts, callback);
      this.dispatch(opts, handler);
    } catch (err) {
      if (typeof callback !== "function") {
        throw err;
      }
      const opaque = opts?.opaque;
      queueMicrotask(() => callback(err, { opaque }));
    }
  }
  apiRequest.exports = request2;
  apiRequest.exports.RequestHandler = RequestHandler4;
  return apiRequest.exports;
}
var abortSignal;
var hasRequiredAbortSignal;
function requireAbortSignal() {
  if (hasRequiredAbortSignal) return abortSignal;
  hasRequiredAbortSignal = 1;
  const { addAbortListener } = requireUtil$5();
  const { RequestAbortedError } = requireErrors();
  const kListener = /* @__PURE__ */ Symbol("kListener");
  const kSignal = /* @__PURE__ */ Symbol("kSignal");
  function abort(self2) {
    if (self2.abort) {
      self2.abort(self2[kSignal]?.reason);
    } else {
      self2.reason = self2[kSignal]?.reason ?? new RequestAbortedError();
    }
    removeSignal(self2);
  }
  function addSignal(self2, signal) {
    self2.reason = null;
    self2[kSignal] = null;
    self2[kListener] = null;
    if (!signal) {
      return;
    }
    if (signal.aborted) {
      abort(self2);
      return;
    }
    self2[kSignal] = signal;
    self2[kListener] = () => {
      abort(self2);
    };
    addAbortListener(self2[kSignal], self2[kListener]);
  }
  function removeSignal(self2) {
    if (!self2[kSignal]) {
      return;
    }
    if ("removeEventListener" in self2[kSignal]) {
      self2[kSignal].removeEventListener("abort", self2[kListener]);
    } else {
      self2[kSignal].removeListener("abort", self2[kListener]);
    }
    self2[kSignal] = null;
    self2[kListener] = null;
  }
  abortSignal = {
    addSignal,
    removeSignal
  };
  return abortSignal;
}
var apiStream;
var hasRequiredApiStream;
function requireApiStream() {
  if (hasRequiredApiStream) return apiStream;
  hasRequiredApiStream = 1;
  const assert = import_node_assert.default;
  const { finished } = import_node_stream.default;
  const { AsyncResource } = import_node_async_hooks.default;
  const { InvalidArgumentError, InvalidReturnValueError } = requireErrors();
  const util2 = requireUtil$5();
  const { addSignal, removeSignal } = requireAbortSignal();
  function noop2() {
  }
  class StreamHandler extends AsyncResource {
    constructor(opts, factory, callback) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      const { signal, method, opaque, body: body2, onInfo, responseHeaders } = opts;
      try {
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("invalid factory");
        }
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        if (method === "CONNECT") {
          throw new InvalidArgumentError("invalid method");
        }
        if (onInfo && typeof onInfo !== "function") {
          throw new InvalidArgumentError("invalid onInfo callback");
        }
        super("UNDICI_STREAM");
      } catch (err) {
        if (util2.isStream(body2)) {
          util2.destroy(body2.on("error", noop2), err);
        }
        throw err;
      }
      this.responseHeaders = responseHeaders || null;
      this.opaque = opaque || null;
      this.factory = factory;
      this.callback = callback;
      this.res = null;
      this.abort = null;
      this.context = null;
      this.trailers = null;
      this.body = body2;
      this.onInfo = onInfo || null;
      if (util2.isStream(body2)) {
        body2.on("error", (err) => {
          this.onError(err);
        });
      }
      addSignal(this, signal);
    }
    onConnect(abort, context) {
      if (this.reason) {
        abort(this.reason);
        return;
      }
      assert(this.callback);
      this.abort = abort;
      this.context = context;
    }
    onHeaders(statusCode, rawHeaders, resume, statusMessage) {
      const { factory, opaque, context, responseHeaders } = this;
      const headers2 = responseHeaders === "raw" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);
      if (statusCode < 200) {
        if (this.onInfo) {
          this.onInfo({ statusCode, headers: headers2 });
        }
        return;
      }
      this.factory = null;
      if (factory === null) {
        return;
      }
      const res = this.runInAsyncScope(factory, null, {
        statusCode,
        headers: headers2,
        opaque,
        context
      });
      if (!res || typeof res.write !== "function" || typeof res.end !== "function" || typeof res.on !== "function") {
        throw new InvalidReturnValueError("expected Writable");
      }
      finished(res, { readable: false }, (err) => {
        const { callback, res: res2, opaque: opaque2, trailers, abort } = this;
        this.res = null;
        if (err || !res2?.readable) {
          util2.destroy(res2, err);
        }
        this.callback = null;
        this.runInAsyncScope(callback, null, err || null, { opaque: opaque2, trailers });
        if (err) {
          abort();
        }
      });
      res.on("drain", resume);
      this.res = res;
      const needDrain = res.writableNeedDrain !== void 0 ? res.writableNeedDrain : res._writableState?.needDrain;
      return needDrain !== true;
    }
    onData(chunk2) {
      const { res } = this;
      return res ? res.write(chunk2) : true;
    }
    onComplete(trailers) {
      const { res } = this;
      removeSignal(this);
      if (!res) {
        return;
      }
      this.trailers = util2.parseHeaders(trailers);
      res.end();
    }
    onError(err) {
      const { res, callback, opaque, body: body2 } = this;
      removeSignal(this);
      this.factory = null;
      if (res) {
        this.res = null;
        util2.destroy(res, err);
      } else if (callback) {
        this.callback = null;
        queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, { opaque });
        });
      }
      if (body2) {
        this.body = null;
        util2.destroy(body2, err);
      }
    }
  }
  function stream(opts, factory, callback) {
    if (callback === void 0) {
      return new Promise((resolve, reject) => {
        stream.call(this, opts, factory, (err, data2) => {
          return err ? reject(err) : resolve(data2);
        });
      });
    }
    try {
      const handler = new StreamHandler(opts, factory, callback);
      this.dispatch(opts, handler);
    } catch (err) {
      if (typeof callback !== "function") {
        throw err;
      }
      const opaque = opts?.opaque;
      queueMicrotask(() => callback(err, { opaque }));
    }
  }
  apiStream = stream;
  return apiStream;
}
var apiPipeline;
var hasRequiredApiPipeline;
function requireApiPipeline() {
  if (hasRequiredApiPipeline) return apiPipeline;
  hasRequiredApiPipeline = 1;
  const {
    Readable: Readable2,
    Duplex,
    PassThrough
  } = import_node_stream.default;
  const assert = import_node_assert.default;
  const { AsyncResource } = import_node_async_hooks.default;
  const {
    InvalidArgumentError,
    InvalidReturnValueError,
    RequestAbortedError
  } = requireErrors();
  const util2 = requireUtil$5();
  const { addSignal, removeSignal } = requireAbortSignal();
  function noop2() {
  }
  const kResume = /* @__PURE__ */ Symbol("resume");
  class PipelineRequest extends Readable2 {
    constructor() {
      super({ autoDestroy: true });
      this[kResume] = null;
    }
    _read() {
      const { [kResume]: resume } = this;
      if (resume) {
        this[kResume] = null;
        resume();
      }
    }
    _destroy(err, callback) {
      this._read();
      callback(err);
    }
  }
  class PipelineResponse extends Readable2 {
    constructor(resume) {
      super({ autoDestroy: true });
      this[kResume] = resume;
    }
    _read() {
      this[kResume]();
    }
    _destroy(err, callback) {
      if (!err && !this._readableState.endEmitted) {
        err = new RequestAbortedError();
      }
      callback(err);
    }
  }
  class PipelineHandler extends AsyncResource {
    constructor(opts, handler) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      if (typeof handler !== "function") {
        throw new InvalidArgumentError("invalid handler");
      }
      const { signal, method, opaque, onInfo, responseHeaders } = opts;
      if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
        throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
      }
      if (method === "CONNECT") {
        throw new InvalidArgumentError("invalid method");
      }
      if (onInfo && typeof onInfo !== "function") {
        throw new InvalidArgumentError("invalid onInfo callback");
      }
      super("UNDICI_PIPELINE");
      this.opaque = opaque || null;
      this.responseHeaders = responseHeaders || null;
      this.handler = handler;
      this.abort = null;
      this.context = null;
      this.onInfo = onInfo || null;
      this.req = new PipelineRequest().on("error", noop2);
      this.ret = new Duplex({
        readableObjectMode: opts.objectMode,
        autoDestroy: true,
        read: () => {
          const { body: body2 } = this;
          if (body2?.resume) {
            body2.resume();
          }
        },
        write: (chunk2, encoding2, callback) => {
          const { req } = this;
          if (req.push(chunk2, encoding2) || req._readableState.destroyed) {
            callback();
          } else {
            req[kResume] = callback;
          }
        },
        destroy: (err, callback) => {
          const { body: body2, req, res, ret, abort } = this;
          if (!err && !ret._readableState.endEmitted) {
            err = new RequestAbortedError();
          }
          if (abort && err) {
            abort();
          }
          util2.destroy(body2, err);
          util2.destroy(req, err);
          util2.destroy(res, err);
          removeSignal(this);
          callback(err);
        }
      }).on("prefinish", () => {
        const { req } = this;
        req.push(null);
      });
      this.res = null;
      addSignal(this, signal);
    }
    onConnect(abort, context) {
      const { res } = this;
      if (this.reason) {
        abort(this.reason);
        return;
      }
      assert(!res, "pipeline cannot be retried");
      this.abort = abort;
      this.context = context;
    }
    onHeaders(statusCode, rawHeaders, resume) {
      const { opaque, handler, context } = this;
      if (statusCode < 200) {
        if (this.onInfo) {
          const headers2 = this.responseHeaders === "raw" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);
          this.onInfo({ statusCode, headers: headers2 });
        }
        return;
      }
      this.res = new PipelineResponse(resume);
      let body2;
      try {
        this.handler = null;
        const headers2 = this.responseHeaders === "raw" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);
        body2 = this.runInAsyncScope(handler, null, {
          statusCode,
          headers: headers2,
          opaque,
          body: this.res,
          context
        });
      } catch (err) {
        this.res.on("error", noop2);
        throw err;
      }
      if (!body2 || typeof body2.on !== "function") {
        throw new InvalidReturnValueError("expected Readable");
      }
      body2.on("data", (chunk2) => {
        const { ret, body: body3 } = this;
        if (!ret.push(chunk2) && body3.pause) {
          body3.pause();
        }
      }).on("error", (err) => {
        const { ret } = this;
        util2.destroy(ret, err);
      }).on("end", () => {
        const { ret } = this;
        ret.push(null);
      }).on("close", () => {
        const { ret } = this;
        if (!ret._readableState.ended) {
          util2.destroy(ret, new RequestAbortedError());
        }
      });
      this.body = body2;
    }
    onData(chunk2) {
      const { res } = this;
      return res.push(chunk2);
    }
    onComplete(trailers) {
      const { res } = this;
      res.push(null);
    }
    onError(err) {
      const { ret } = this;
      this.handler = null;
      util2.destroy(ret, err);
    }
  }
  function pipeline(opts, handler) {
    try {
      const pipelineHandler = new PipelineHandler(opts, handler);
      this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler);
      return pipelineHandler.ret;
    } catch (err) {
      return new PassThrough().destroy(err);
    }
  }
  apiPipeline = pipeline;
  return apiPipeline;
}
var apiUpgrade;
var hasRequiredApiUpgrade;
function requireApiUpgrade() {
  if (hasRequiredApiUpgrade) return apiUpgrade;
  hasRequiredApiUpgrade = 1;
  const { InvalidArgumentError, SocketError } = requireErrors();
  const { AsyncResource } = import_node_async_hooks.default;
  const assert = import_node_assert.default;
  const util2 = requireUtil$5();
  const { kHTTP2Stream } = requireSymbols();
  const { addSignal, removeSignal } = requireAbortSignal();
  class UpgradeHandler extends AsyncResource {
    constructor(opts, callback) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      if (typeof callback !== "function") {
        throw new InvalidArgumentError("invalid callback");
      }
      const { signal, opaque, responseHeaders } = opts;
      if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
        throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
      }
      super("UNDICI_UPGRADE");
      this.responseHeaders = responseHeaders || null;
      this.opaque = opaque || null;
      this.callback = callback;
      this.abort = null;
      this.context = null;
      addSignal(this, signal);
    }
    onConnect(abort, context) {
      if (this.reason) {
        abort(this.reason);
        return;
      }
      assert(this.callback);
      this.abort = abort;
      this.context = null;
    }
    onHeaders() {
      throw new SocketError("bad upgrade", null);
    }
    onUpgrade(statusCode, rawHeaders, socket) {
      assert(socket[kHTTP2Stream] === true ? statusCode === 200 : statusCode === 101);
      const { callback, opaque, context } = this;
      removeSignal(this);
      this.callback = null;
      const headers2 = this.responseHeaders === "raw" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);
      this.runInAsyncScope(callback, null, null, {
        headers: headers2,
        socket,
        opaque,
        context
      });
    }
    onError(err) {
      const { callback, opaque } = this;
      removeSignal(this);
      if (callback) {
        this.callback = null;
        queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, { opaque });
        });
      }
    }
  }
  function upgrade(opts, callback) {
    if (callback === void 0) {
      return new Promise((resolve, reject) => {
        upgrade.call(this, opts, (err, data2) => {
          return err ? reject(err) : resolve(data2);
        });
      });
    }
    try {
      const upgradeHandler = new UpgradeHandler(opts, callback);
      const upgradeOpts = {
        ...opts,
        method: opts.method || "GET",
        upgrade: opts.protocol || "Websocket"
      };
      this.dispatch(upgradeOpts, upgradeHandler);
    } catch (err) {
      if (typeof callback !== "function") {
        throw err;
      }
      const opaque = opts?.opaque;
      queueMicrotask(() => callback(err, { opaque }));
    }
  }
  apiUpgrade = upgrade;
  return apiUpgrade;
}
var apiConnect;
var hasRequiredApiConnect;
function requireApiConnect() {
  if (hasRequiredApiConnect) return apiConnect;
  hasRequiredApiConnect = 1;
  const assert = import_node_assert.default;
  const { AsyncResource } = import_node_async_hooks.default;
  const { InvalidArgumentError, SocketError } = requireErrors();
  const util2 = requireUtil$5();
  const { addSignal, removeSignal } = requireAbortSignal();
  class ConnectHandler extends AsyncResource {
    constructor(opts, callback) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      if (typeof callback !== "function") {
        throw new InvalidArgumentError("invalid callback");
      }
      const { signal, opaque, responseHeaders } = opts;
      if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
        throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
      }
      super("UNDICI_CONNECT");
      this.opaque = opaque || null;
      this.responseHeaders = responseHeaders || null;
      this.callback = callback;
      this.abort = null;
      addSignal(this, signal);
    }
    onConnect(abort, context) {
      if (this.reason) {
        abort(this.reason);
        return;
      }
      assert(this.callback);
      this.abort = abort;
      this.context = context;
    }
    onHeaders() {
      throw new SocketError("bad connect", null);
    }
    onUpgrade(statusCode, rawHeaders, socket) {
      const { callback, opaque, context } = this;
      removeSignal(this);
      this.callback = null;
      let headers2 = rawHeaders;
      if (headers2 != null) {
        headers2 = this.responseHeaders === "raw" ? util2.parseRawHeaders(rawHeaders) : util2.parseHeaders(rawHeaders);
      }
      this.runInAsyncScope(callback, null, null, {
        statusCode,
        headers: headers2,
        socket,
        opaque,
        context
      });
    }
    onError(err) {
      const { callback, opaque } = this;
      removeSignal(this);
      if (callback) {
        this.callback = null;
        queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, { opaque });
        });
      }
    }
  }
  function connect2(opts, callback) {
    if (callback === void 0) {
      return new Promise((resolve, reject) => {
        connect2.call(this, opts, (err, data2) => {
          return err ? reject(err) : resolve(data2);
        });
      });
    }
    try {
      const connectHandler = new ConnectHandler(opts, callback);
      const connectOptions = { ...opts, method: "CONNECT" };
      this.dispatch(connectOptions, connectHandler);
    } catch (err) {
      if (typeof callback !== "function") {
        throw err;
      }
      const opaque = opts?.opaque;
      queueMicrotask(() => callback(err, { opaque }));
    }
  }
  apiConnect = connect2;
  return apiConnect;
}
var hasRequiredApi;
function requireApi() {
  if (hasRequiredApi) return api;
  hasRequiredApi = 1;
  api.request = requireApiRequest();
  api.stream = requireApiStream();
  api.pipeline = requireApiPipeline();
  api.upgrade = requireApiUpgrade();
  api.connect = requireApiConnect();
  return api;
}
var mockErrors;
var hasRequiredMockErrors;
function requireMockErrors() {
  if (hasRequiredMockErrors) return mockErrors;
  hasRequiredMockErrors = 1;
  const { UndiciError } = requireErrors();
  const kMockNotMatchedError = /* @__PURE__ */ Symbol.for("undici.error.UND_MOCK_ERR_MOCK_NOT_MATCHED");
  class MockNotMatchedError extends UndiciError {
    constructor(message) {
      super(message);
      this.name = "MockNotMatchedError";
      this.message = message || "The request does not match any registered mock dispatches";
      this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED";
    }
    static [Symbol.hasInstance](instance) {
      return instance && instance[kMockNotMatchedError] === true;
    }
    get [kMockNotMatchedError]() {
      return true;
    }
  }
  mockErrors = {
    MockNotMatchedError
  };
  return mockErrors;
}
var mockSymbols;
var hasRequiredMockSymbols;
function requireMockSymbols() {
  if (hasRequiredMockSymbols) return mockSymbols;
  hasRequiredMockSymbols = 1;
  mockSymbols = {
    kAgent: /* @__PURE__ */ Symbol("agent"),
    kOptions: /* @__PURE__ */ Symbol("options"),
    kFactory: /* @__PURE__ */ Symbol("factory"),
    kDispatches: /* @__PURE__ */ Symbol("dispatches"),
    kDispatchKey: /* @__PURE__ */ Symbol("dispatch key"),
    kDefaultHeaders: /* @__PURE__ */ Symbol("default headers"),
    kDefaultTrailers: /* @__PURE__ */ Symbol("default trailers"),
    kContentLength: /* @__PURE__ */ Symbol("content length"),
    kMockAgent: /* @__PURE__ */ Symbol("mock agent"),
    kMockAgentSet: /* @__PURE__ */ Symbol("mock agent set"),
    kMockAgentGet: /* @__PURE__ */ Symbol("mock agent get"),
    kMockDispatch: /* @__PURE__ */ Symbol("mock dispatch"),
    kClose: /* @__PURE__ */ Symbol("close"),
    kOriginalClose: /* @__PURE__ */ Symbol("original agent close"),
    kOriginalDispatch: /* @__PURE__ */ Symbol("original dispatch"),
    kOrigin: /* @__PURE__ */ Symbol("origin"),
    kIsMockActive: /* @__PURE__ */ Symbol("is mock active"),
    kNetConnect: /* @__PURE__ */ Symbol("net connect"),
    kGetNetConnect: /* @__PURE__ */ Symbol("get net connect"),
    kConnected: /* @__PURE__ */ Symbol("connected"),
    kIgnoreTrailingSlash: /* @__PURE__ */ Symbol("ignore trailing slash"),
    kMockAgentMockCallHistoryInstance: /* @__PURE__ */ Symbol("mock agent mock call history name"),
    kMockAgentRegisterCallHistory: /* @__PURE__ */ Symbol("mock agent register mock call history"),
    kMockAgentAddCallHistoryLog: /* @__PURE__ */ Symbol("mock agent add call history log"),
    kMockAgentIsCallHistoryEnabled: /* @__PURE__ */ Symbol("mock agent is call history enabled"),
    kMockAgentAcceptsNonStandardSearchParameters: /* @__PURE__ */ Symbol("mock agent accepts non standard search parameters"),
    kMockCallHistoryAddLog: /* @__PURE__ */ Symbol("mock call history add log")
  };
  return mockSymbols;
}
var mockUtils;
var hasRequiredMockUtils;
function requireMockUtils() {
  if (hasRequiredMockUtils) return mockUtils;
  hasRequiredMockUtils = 1;
  const { MockNotMatchedError } = requireMockErrors();
  const {
    kDispatches,
    kMockAgent,
    kOriginalDispatch,
    kOrigin,
    kGetNetConnect
  } = requireMockSymbols();
  const { serializePathWithQuery } = requireUtil$5();
  const { STATUS_CODES } = import_node_http.default;
  const {
    types: {
      isPromise
    }
  } = import_node_util.default;
  const { InvalidArgumentError } = requireErrors();
  function matchValue(match, value) {
    if (typeof match === "string") {
      return match === value;
    }
    if (match instanceof RegExp) {
      return match.test(value);
    }
    if (typeof match === "function") {
      return match(value) === true;
    }
    return false;
  }
  function lowerCaseEntries(headers2) {
    return Object.fromEntries(
      Object.entries(headers2).map(([headerName, headerValue]) => {
        return [headerName.toLocaleLowerCase(), headerValue];
      })
    );
  }
  function getHeaderByName(headers2, key) {
    if (Array.isArray(headers2)) {
      for (let i4 = 0; i4 < headers2.length; i4 += 2) {
        if (headers2[i4].toLocaleLowerCase() === key.toLocaleLowerCase()) {
          return headers2[i4 + 1];
        }
      }
      return void 0;
    } else if (typeof headers2.get === "function") {
      return headers2.get(key);
    } else {
      return lowerCaseEntries(headers2)[key.toLocaleLowerCase()];
    }
  }
  function buildHeadersFromArray(headers2) {
    const clone = headers2.slice();
    const entries = [];
    for (let index = 0; index < clone.length; index += 2) {
      entries.push([clone[index], clone[index + 1]]);
    }
    return Object.fromEntries(entries);
  }
  function matchHeaders(mockDispatch2, headers2) {
    if (typeof mockDispatch2.headers === "function") {
      if (Array.isArray(headers2)) {
        headers2 = buildHeadersFromArray(headers2);
      }
      return mockDispatch2.headers(headers2 ? lowerCaseEntries(headers2) : {});
    }
    if (typeof mockDispatch2.headers === "undefined") {
      return true;
    }
    if (typeof headers2 !== "object" || typeof mockDispatch2.headers !== "object") {
      return false;
    }
    for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch2.headers)) {
      const headerValue = getHeaderByName(headers2, matchHeaderName);
      if (!matchValue(matchHeaderValue, headerValue)) {
        return false;
      }
    }
    return true;
  }
  function normalizeSearchParams(query) {
    if (typeof query !== "string") {
      return query;
    }
    const originalQp = new URLSearchParams(query);
    const normalizedQp = new URLSearchParams();
    for (let [key, value] of originalQp.entries()) {
      key = key.replace("[]", "");
      const valueRepresentsString = /^(['"]).*\1$/.test(value);
      if (valueRepresentsString) {
        normalizedQp.append(key, value);
        continue;
      }
      if (value.includes(",")) {
        const values = value.split(",");
        for (const v4 of values) {
          normalizedQp.append(key, v4);
        }
        continue;
      }
      normalizedQp.append(key, value);
    }
    return normalizedQp;
  }
  function safeUrl(path3) {
    if (typeof path3 !== "string") {
      return path3;
    }
    const pathSegments = path3.split("?", 3);
    if (pathSegments.length !== 2) {
      return path3;
    }
    const qp = new URLSearchParams(pathSegments.pop());
    qp.sort();
    return [...pathSegments, qp.toString()].join("?");
  }
  function matchKey(mockDispatch2, { path: path3, method, body: body2, headers: headers2 }) {
    const pathMatch = matchValue(mockDispatch2.path, path3);
    const methodMatch = matchValue(mockDispatch2.method, method);
    const bodyMatch = typeof mockDispatch2.body !== "undefined" ? matchValue(mockDispatch2.body, body2) : true;
    const headersMatch = matchHeaders(mockDispatch2, headers2);
    return pathMatch && methodMatch && bodyMatch && headersMatch;
  }
  function getResponseData(data2) {
    if (Buffer.isBuffer(data2)) {
      return data2;
    } else if (data2 instanceof Uint8Array) {
      return data2;
    } else if (data2 instanceof ArrayBuffer) {
      return data2;
    } else if (typeof data2 === "object") {
      return JSON.stringify(data2);
    } else if (data2) {
      return data2.toString();
    } else {
      return "";
    }
  }
  function getMockDispatch(mockDispatches, key) {
    const basePath = key.query ? serializePathWithQuery(key.path, key.query) : key.path;
    const resolvedPath2 = typeof basePath === "string" ? safeUrl(basePath) : basePath;
    const resolvedPathWithoutTrailingSlash = removeTrailingSlash(resolvedPath2);
    let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path: path3, ignoreTrailingSlash }) => {
      return ignoreTrailingSlash ? matchValue(removeTrailingSlash(safeUrl(path3)), resolvedPathWithoutTrailingSlash) : matchValue(safeUrl(path3), resolvedPath2);
    });
    if (matchedMockDispatches.length === 0) {
      throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath2}'`);
    }
    matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method));
    if (matchedMockDispatches.length === 0) {
      throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}' on path '${resolvedPath2}'`);
    }
    matchedMockDispatches = matchedMockDispatches.filter(({ body: body2 }) => typeof body2 !== "undefined" ? matchValue(body2, key.body) : true);
    if (matchedMockDispatches.length === 0) {
      throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}' on path '${resolvedPath2}'`);
    }
    matchedMockDispatches = matchedMockDispatches.filter((mockDispatch2) => matchHeaders(mockDispatch2, key.headers));
    if (matchedMockDispatches.length === 0) {
      const headers2 = typeof key.headers === "object" ? JSON.stringify(key.headers) : key.headers;
      throw new MockNotMatchedError(`Mock dispatch not matched for headers '${headers2}' on path '${resolvedPath2}'`);
    }
    return matchedMockDispatches[0];
  }
  function addMockDispatch(mockDispatches, key, data2, opts) {
    const baseData = { timesInvoked: 0, times: 1, persist: false, consumed: false, ...opts };
    const replyData = typeof data2 === "function" ? { callback: data2 } : { ...data2 };
    const newMockDispatch = { ...baseData, ...key, pending: true, data: { error: null, ...replyData } };
    mockDispatches.push(newMockDispatch);
    return newMockDispatch;
  }
  function deleteMockDispatch(mockDispatches, key) {
    const index = mockDispatches.findIndex((dispatch) => {
      if (!dispatch.consumed) {
        return false;
      }
      return matchKey(dispatch, key);
    });
    if (index !== -1) {
      mockDispatches.splice(index, 1);
    }
  }
  function removeTrailingSlash(path3) {
    while (path3.endsWith("/")) {
      path3 = path3.slice(0, -1);
    }
    if (path3.length === 0) {
      path3 = "/";
    }
    return path3;
  }
  function buildKey(opts) {
    const { path: path3, method, body: body2, headers: headers2, query } = opts;
    return {
      path: path3,
      method,
      body: body2,
      headers: headers2,
      query
    };
  }
  function generateKeyValues(data2) {
    const keys2 = Object.keys(data2);
    const result = [];
    for (let i4 = 0; i4 < keys2.length; ++i4) {
      const key = keys2[i4];
      const value = data2[key];
      const name = Buffer.from(`${key}`);
      if (Array.isArray(value)) {
        for (let j4 = 0; j4 < value.length; ++j4) {
          result.push(name, Buffer.from(`${value[j4]}`));
        }
      } else {
        result.push(name, Buffer.from(`${value}`));
      }
    }
    return result;
  }
  function getStatusText(statusCode) {
    return STATUS_CODES[statusCode] || "unknown";
  }
  async function getResponse(body2) {
    const buffers = [];
    for await (const data2 of body2) {
      buffers.push(data2);
    }
    return Buffer.concat(buffers).toString("utf8");
  }
  function mockDispatch(opts, handler) {
    const key = buildKey(opts);
    const mockDispatch2 = getMockDispatch(this[kDispatches], key);
    mockDispatch2.timesInvoked++;
    if (mockDispatch2.data.callback) {
      mockDispatch2.data = { ...mockDispatch2.data, ...mockDispatch2.data.callback(opts) };
    }
    const { data: { statusCode, data: data2, headers: headers2, trailers, error: error2 }, delay, persist } = mockDispatch2;
    const { timesInvoked, times } = mockDispatch2;
    mockDispatch2.consumed = !persist && timesInvoked >= times;
    mockDispatch2.pending = timesInvoked < times;
    if (error2 !== null) {
      deleteMockDispatch(this[kDispatches], key);
      handler.onError(error2);
      return true;
    }
    if (typeof delay === "number" && delay > 0) {
      setTimeout(() => {
        handleReply(this[kDispatches]);
      }, delay);
    } else {
      handleReply(this[kDispatches]);
    }
    function handleReply(mockDispatches, _data4 = data2) {
      const optsHeaders = Array.isArray(opts.headers) ? buildHeadersFromArray(opts.headers) : opts.headers;
      const body2 = typeof _data4 === "function" ? _data4({ ...opts, headers: optsHeaders }) : _data4;
      if (isPromise(body2)) {
        return body2.then((newData) => handleReply(mockDispatches, newData));
      }
      const responseData = getResponseData(body2);
      const responseHeaders = generateKeyValues(headers2);
      const responseTrailers = generateKeyValues(trailers);
      handler.onConnect?.((err) => handler.onError(err), null);
      handler.onHeaders?.(statusCode, responseHeaders, resume, getStatusText(statusCode));
      handler.onData?.(Buffer.from(responseData));
      handler.onComplete?.(responseTrailers);
      deleteMockDispatch(mockDispatches, key);
    }
    function resume() {
    }
    return true;
  }
  function buildMockDispatch() {
    const agent2 = this[kMockAgent];
    const origin = this[kOrigin];
    const originalDispatch = this[kOriginalDispatch];
    return function dispatch(opts, handler) {
      if (agent2.isMockActive) {
        try {
          mockDispatch.call(this, opts, handler);
        } catch (error2) {
          if (error2.code === "UND_MOCK_ERR_MOCK_NOT_MATCHED") {
            const netConnect = agent2[kGetNetConnect]();
            if (netConnect === false) {
              throw new MockNotMatchedError(`${error2.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);
            }
            if (checkNetConnect(netConnect, origin)) {
              originalDispatch.call(this, opts, handler);
            } else {
              throw new MockNotMatchedError(`${error2.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);
            }
          } else {
            throw error2;
          }
        }
      } else {
        originalDispatch.call(this, opts, handler);
      }
    };
  }
  function checkNetConnect(netConnect, origin) {
    const url = new URL(origin);
    if (netConnect === true) {
      return true;
    } else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url.host))) {
      return true;
    }
    return false;
  }
  function buildAndValidateMockOptions(opts) {
    const { agent: agent2, ...mockOptions } = opts;
    if ("enableCallHistory" in mockOptions && typeof mockOptions.enableCallHistory !== "boolean") {
      throw new InvalidArgumentError("options.enableCallHistory must to be a boolean");
    }
    if ("acceptNonStandardSearchParameters" in mockOptions && typeof mockOptions.acceptNonStandardSearchParameters !== "boolean") {
      throw new InvalidArgumentError("options.acceptNonStandardSearchParameters must to be a boolean");
    }
    if ("ignoreTrailingSlash" in mockOptions && typeof mockOptions.ignoreTrailingSlash !== "boolean") {
      throw new InvalidArgumentError("options.ignoreTrailingSlash must to be a boolean");
    }
    return mockOptions;
  }
  mockUtils = {
    getResponseData,
    getMockDispatch,
    addMockDispatch,
    deleteMockDispatch,
    buildKey,
    generateKeyValues,
    matchValue,
    getResponse,
    getStatusText,
    mockDispatch,
    buildMockDispatch,
    checkNetConnect,
    buildAndValidateMockOptions,
    getHeaderByName,
    buildHeadersFromArray,
    normalizeSearchParams
  };
  return mockUtils;
}
var mockInterceptor = {};
var hasRequiredMockInterceptor;
function requireMockInterceptor() {
  if (hasRequiredMockInterceptor) return mockInterceptor;
  hasRequiredMockInterceptor = 1;
  const { getResponseData, buildKey, addMockDispatch } = requireMockUtils();
  const {
    kDispatches,
    kDispatchKey,
    kDefaultHeaders,
    kDefaultTrailers,
    kContentLength,
    kMockDispatch,
    kIgnoreTrailingSlash
  } = requireMockSymbols();
  const { InvalidArgumentError } = requireErrors();
  const { serializePathWithQuery } = requireUtil$5();
  class MockScope {
    constructor(mockDispatch) {
      this[kMockDispatch] = mockDispatch;
    }
    /**
     * Delay a reply by a set amount in ms.
     */
    delay(waitInMs) {
      if (typeof waitInMs !== "number" || !Number.isInteger(waitInMs) || waitInMs <= 0) {
        throw new InvalidArgumentError("waitInMs must be a valid integer > 0");
      }
      this[kMockDispatch].delay = waitInMs;
      return this;
    }
    /**
     * For a defined reply, never mark as consumed.
     */
    persist() {
      this[kMockDispatch].persist = true;
      return this;
    }
    /**
     * Allow one to define a reply for a set amount of matching requests.
     */
    times(repeatTimes) {
      if (typeof repeatTimes !== "number" || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {
        throw new InvalidArgumentError("repeatTimes must be a valid integer > 0");
      }
      this[kMockDispatch].times = repeatTimes;
      return this;
    }
  }
  class MockInterceptor {
    constructor(opts, mockDispatches) {
      if (typeof opts !== "object") {
        throw new InvalidArgumentError("opts must be an object");
      }
      if (typeof opts.path === "undefined") {
        throw new InvalidArgumentError("opts.path must be defined");
      }
      if (typeof opts.method === "undefined") {
        opts.method = "GET";
      }
      if (typeof opts.path === "string") {
        if (opts.query) {
          opts.path = serializePathWithQuery(opts.path, opts.query);
        } else {
          const parsedURL = new URL(opts.path, "data://");
          opts.path = parsedURL.pathname + parsedURL.search;
        }
      }
      if (typeof opts.method === "string") {
        opts.method = opts.method.toUpperCase();
      }
      this[kDispatchKey] = buildKey(opts);
      this[kDispatches] = mockDispatches;
      this[kIgnoreTrailingSlash] = opts.ignoreTrailingSlash ?? false;
      this[kDefaultHeaders] = {};
      this[kDefaultTrailers] = {};
      this[kContentLength] = false;
    }
    createMockScopeDispatchData({ statusCode, data: data2, responseOptions }) {
      const responseData = getResponseData(data2);
      const contentLength = this[kContentLength] ? { "content-length": responseData.length } : {};
      const headers2 = { ...this[kDefaultHeaders], ...contentLength, ...responseOptions.headers };
      const trailers = { ...this[kDefaultTrailers], ...responseOptions.trailers };
      return { statusCode, data: data2, headers: headers2, trailers };
    }
    validateReplyParameters(replyParameters) {
      if (typeof replyParameters.statusCode === "undefined") {
        throw new InvalidArgumentError("statusCode must be defined");
      }
      if (typeof replyParameters.responseOptions !== "object" || replyParameters.responseOptions === null) {
        throw new InvalidArgumentError("responseOptions must be an object");
      }
    }
    /**
     * Mock an undici request with a defined reply.
     */
    reply(replyOptionsCallbackOrStatusCode) {
      if (typeof replyOptionsCallbackOrStatusCode === "function") {
        const wrappedDefaultsCallback = (opts) => {
          const resolvedData = replyOptionsCallbackOrStatusCode(opts);
          if (typeof resolvedData !== "object" || resolvedData === null) {
            throw new InvalidArgumentError("reply options callback must return an object");
          }
          const replyParameters2 = { data: "", responseOptions: {}, ...resolvedData };
          this.validateReplyParameters(replyParameters2);
          return {
            ...this.createMockScopeDispatchData(replyParameters2)
          };
        };
        const newMockDispatch2 = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback, { ignoreTrailingSlash: this[kIgnoreTrailingSlash] });
        return new MockScope(newMockDispatch2);
      }
      const replyParameters = {
        statusCode: replyOptionsCallbackOrStatusCode,
        data: arguments[1] === void 0 ? "" : arguments[1],
        responseOptions: arguments[2] === void 0 ? {} : arguments[2]
      };
      this.validateReplyParameters(replyParameters);
      const dispatchData = this.createMockScopeDispatchData(replyParameters);
      const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData, { ignoreTrailingSlash: this[kIgnoreTrailingSlash] });
      return new MockScope(newMockDispatch);
    }
    /**
     * Mock an undici request with a defined error.
     */
    replyWithError(error2) {
      if (typeof error2 === "undefined") {
        throw new InvalidArgumentError("error must be defined");
      }
      const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], { error: error2 }, { ignoreTrailingSlash: this[kIgnoreTrailingSlash] });
      return new MockScope(newMockDispatch);
    }
    /**
     * Set default reply headers on the interceptor for subsequent replies
     */
    defaultReplyHeaders(headers2) {
      if (typeof headers2 === "undefined") {
        throw new InvalidArgumentError("headers must be defined");
      }
      this[kDefaultHeaders] = headers2;
      return this;
    }
    /**
     * Set default reply trailers on the interceptor for subsequent replies
     */
    defaultReplyTrailers(trailers) {
      if (typeof trailers === "undefined") {
        throw new InvalidArgumentError("trailers must be defined");
      }
      this[kDefaultTrailers] = trailers;
      return this;
    }
    /**
     * Set reply content length header for replies on the interceptor
     */
    replyContentLength() {
      this[kContentLength] = true;
      return this;
    }
  }
  mockInterceptor.MockInterceptor = MockInterceptor;
  mockInterceptor.MockScope = MockScope;
  return mockInterceptor;
}
var mockClient;
var hasRequiredMockClient;
function requireMockClient() {
  if (hasRequiredMockClient) return mockClient;
  hasRequiredMockClient = 1;
  const { promisify: promisify2 } = import_node_util.default;
  const Client2 = requireClient();
  const { buildMockDispatch } = requireMockUtils();
  const {
    kDispatches,
    kMockAgent,
    kClose,
    kOriginalClose,
    kOrigin,
    kOriginalDispatch,
    kConnected,
    kIgnoreTrailingSlash
  } = requireMockSymbols();
  const { MockInterceptor } = requireMockInterceptor();
  const Symbols = requireSymbols();
  const { InvalidArgumentError } = requireErrors();
  class MockClient extends Client2 {
    constructor(origin, opts) {
      if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
        throw new InvalidArgumentError("Argument opts.agent must implement Agent");
      }
      super(origin, opts);
      this[kMockAgent] = opts.agent;
      this[kOrigin] = origin;
      this[kIgnoreTrailingSlash] = opts.ignoreTrailingSlash ?? false;
      this[kDispatches] = [];
      this[kConnected] = 1;
      this[kOriginalDispatch] = this.dispatch;
      this[kOriginalClose] = this.close.bind(this);
      this.dispatch = buildMockDispatch.call(this);
      this.close = this[kClose];
    }
    get [Symbols.kConnected]() {
      return this[kConnected];
    }
    /**
     * Sets up the base interceptor for mocking replies from undici.
     */
    intercept(opts) {
      return new MockInterceptor(
        opts && { ignoreTrailingSlash: this[kIgnoreTrailingSlash], ...opts },
        this[kDispatches]
      );
    }
    cleanMocks() {
      this[kDispatches] = [];
    }
    async [kClose]() {
      await promisify2(this[kOriginalClose])();
      this[kConnected] = 0;
      this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
    }
  }
  mockClient = MockClient;
  return mockClient;
}
var mockCallHistory = {};
var hasRequiredMockCallHistory;
function requireMockCallHistory() {
  if (hasRequiredMockCallHistory) return mockCallHistory;
  hasRequiredMockCallHistory = 1;
  const { kMockCallHistoryAddLog } = requireMockSymbols();
  const { InvalidArgumentError } = requireErrors();
  function handleFilterCallsWithOptions(criteria, options, handler, store) {
    switch (options.operator) {
      case "OR":
        store.push(...handler(criteria));
        return store;
      case "AND":
        return handler.call({ logs: store }, criteria);
      default:
        throw new InvalidArgumentError("options.operator must to be a case insensitive string equal to 'OR' or 'AND'");
    }
  }
  function buildAndValidateFilterCallsOptions(options = {}) {
    const finalOptions = {};
    if ("operator" in options) {
      if (typeof options.operator !== "string" || options.operator.toUpperCase() !== "OR" && options.operator.toUpperCase() !== "AND") {
        throw new InvalidArgumentError("options.operator must to be a case insensitive string equal to 'OR' or 'AND'");
      }
      return {
        ...finalOptions,
        operator: options.operator.toUpperCase()
      };
    }
    return finalOptions;
  }
  function makeFilterCalls(parameterName) {
    return (parameterValue) => {
      if (typeof parameterValue === "string" || parameterValue == null) {
        return this.logs.filter((log) => {
          return log[parameterName] === parameterValue;
        });
      }
      if (parameterValue instanceof RegExp) {
        return this.logs.filter((log) => {
          return parameterValue.test(log[parameterName]);
        });
      }
      throw new InvalidArgumentError(`${parameterName} parameter should be one of string, regexp, undefined or null`);
    };
  }
  function computeUrlWithMaybeSearchParameters(requestInit) {
    try {
      const url = new URL(requestInit.path, requestInit.origin);
      if (url.search.length !== 0) {
        return url;
      }
      url.search = new URLSearchParams(requestInit.query).toString();
      return url;
    } catch (error2) {
      throw new InvalidArgumentError("An error occurred when computing MockCallHistoryLog.url", { cause: error2 });
    }
  }
  class MockCallHistoryLog {
    constructor(requestInit = {}) {
      this.body = requestInit.body;
      this.headers = requestInit.headers;
      this.method = requestInit.method;
      const url = computeUrlWithMaybeSearchParameters(requestInit);
      this.fullUrl = url.toString();
      this.origin = url.origin;
      this.path = url.pathname;
      this.searchParams = Object.fromEntries(url.searchParams);
      this.protocol = url.protocol;
      this.host = url.host;
      this.port = url.port;
      this.hash = url.hash;
    }
    toMap() {
      return /* @__PURE__ */ new Map(
        [
          ["protocol", this.protocol],
          ["host", this.host],
          ["port", this.port],
          ["origin", this.origin],
          ["path", this.path],
          ["hash", this.hash],
          ["searchParams", this.searchParams],
          ["fullUrl", this.fullUrl],
          ["method", this.method],
          ["body", this.body],
          ["headers", this.headers]
        ]
      );
    }
    toString() {
      const options = { betweenKeyValueSeparator: "->", betweenPairSeparator: "|" };
      let result = "";
      this.toMap().forEach((value, key) => {
        if (typeof value === "string" || value === void 0 || value === null) {
          result = `${result}${key}${options.betweenKeyValueSeparator}${value}${options.betweenPairSeparator}`;
        }
        if (typeof value === "object" && value !== null || Array.isArray(value)) {
          result = `${result}${key}${options.betweenKeyValueSeparator}${JSON.stringify(value)}${options.betweenPairSeparator}`;
        }
      });
      return result.slice(0, -1);
    }
  }
  class MockCallHistory {
    logs = [];
    calls() {
      return this.logs;
    }
    firstCall() {
      return this.logs.at(0);
    }
    lastCall() {
      return this.logs.at(-1);
    }
    nthCall(number) {
      if (typeof number !== "number") {
        throw new InvalidArgumentError("nthCall must be called with a number");
      }
      if (!Number.isInteger(number)) {
        throw new InvalidArgumentError("nthCall must be called with an integer");
      }
      if (Math.sign(number) !== 1) {
        throw new InvalidArgumentError("nthCall must be called with a positive value. use firstCall or lastCall instead");
      }
      return this.logs.at(number - 1);
    }
    filterCalls(criteria, options) {
      if (this.logs.length === 0) {
        return this.logs;
      }
      if (typeof criteria === "function") {
        return this.logs.filter(criteria);
      }
      if (criteria instanceof RegExp) {
        return this.logs.filter((log) => {
          return criteria.test(log.toString());
        });
      }
      if (typeof criteria === "object" && criteria !== null) {
        if (Object.keys(criteria).length === 0) {
          return this.logs;
        }
        const finalOptions = { operator: "OR", ...buildAndValidateFilterCallsOptions(options) };
        let maybeDuplicatedLogsFiltered = [];
        if ("protocol" in criteria) {
          maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.protocol, finalOptions, this.filterCallsByProtocol, maybeDuplicatedLogsFiltered);
        }
        if ("host" in criteria) {
          maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.host, finalOptions, this.filterCallsByHost, maybeDuplicatedLogsFiltered);
        }
        if ("port" in criteria) {
          maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.port, finalOptions, this.filterCallsByPort, maybeDuplicatedLogsFiltered);
        }
        if ("origin" in criteria) {
          maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.origin, finalOptions, this.filterCallsByOrigin, maybeDuplicatedLogsFiltered);
        }
        if ("path" in criteria) {
          maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.path, finalOptions, this.filterCallsByPath, maybeDuplicatedLogsFiltered);
        }
        if ("hash" in criteria) {
          maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.hash, finalOptions, this.filterCallsByHash, maybeDuplicatedLogsFiltered);
        }
        if ("fullUrl" in criteria) {
          maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.fullUrl, finalOptions, this.filterCallsByFullUrl, maybeDuplicatedLogsFiltered);
        }
        if ("method" in criteria) {
          maybeDuplicatedLogsFiltered = handleFilterCallsWithOptions(criteria.method, finalOptions, this.filterCallsByMethod, maybeDuplicatedLogsFiltered);
        }
        const uniqLogsFiltered = [...new Set(maybeDuplicatedLogsFiltered)];
        return uniqLogsFiltered;
      }
      throw new InvalidArgumentError("criteria parameter should be one of function, regexp, or object");
    }
    filterCallsByProtocol = makeFilterCalls.call(this, "protocol");
    filterCallsByHost = makeFilterCalls.call(this, "host");
    filterCallsByPort = makeFilterCalls.call(this, "port");
    filterCallsByOrigin = makeFilterCalls.call(this, "origin");
    filterCallsByPath = makeFilterCalls.call(this, "path");
    filterCallsByHash = makeFilterCalls.call(this, "hash");
    filterCallsByFullUrl = makeFilterCalls.call(this, "fullUrl");
    filterCallsByMethod = makeFilterCalls.call(this, "method");
    clear() {
      this.logs = [];
    }
    [kMockCallHistoryAddLog](requestInit) {
      const log = new MockCallHistoryLog(requestInit);
      this.logs.push(log);
      return log;
    }
    *[Symbol.iterator]() {
      for (const log of this.calls()) {
        yield log;
      }
    }
  }
  mockCallHistory.MockCallHistory = MockCallHistory;
  mockCallHistory.MockCallHistoryLog = MockCallHistoryLog;
  return mockCallHistory;
}
var mockPool;
var hasRequiredMockPool;
function requireMockPool() {
  if (hasRequiredMockPool) return mockPool;
  hasRequiredMockPool = 1;
  const { promisify: promisify2 } = import_node_util.default;
  const Pool = requirePool();
  const { buildMockDispatch } = requireMockUtils();
  const {
    kDispatches,
    kMockAgent,
    kClose,
    kOriginalClose,
    kOrigin,
    kOriginalDispatch,
    kConnected,
    kIgnoreTrailingSlash
  } = requireMockSymbols();
  const { MockInterceptor } = requireMockInterceptor();
  const Symbols = requireSymbols();
  const { InvalidArgumentError } = requireErrors();
  class MockPool extends Pool {
    constructor(origin, opts) {
      if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
        throw new InvalidArgumentError("Argument opts.agent must implement Agent");
      }
      super(origin, opts);
      this[kMockAgent] = opts.agent;
      this[kOrigin] = origin;
      this[kIgnoreTrailingSlash] = opts.ignoreTrailingSlash ?? false;
      this[kDispatches] = [];
      this[kConnected] = 1;
      this[kOriginalDispatch] = this.dispatch;
      this[kOriginalClose] = this.close.bind(this);
      this.dispatch = buildMockDispatch.call(this);
      this.close = this[kClose];
    }
    get [Symbols.kConnected]() {
      return this[kConnected];
    }
    /**
     * Sets up the base interceptor for mocking replies from undici.
     */
    intercept(opts) {
      return new MockInterceptor(
        opts && { ignoreTrailingSlash: this[kIgnoreTrailingSlash], ...opts },
        this[kDispatches]
      );
    }
    cleanMocks() {
      this[kDispatches] = [];
    }
    async [kClose]() {
      await promisify2(this[kOriginalClose])();
      this[kConnected] = 0;
      this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
    }
  }
  mockPool = MockPool;
  return mockPool;
}
var pendingInterceptorsFormatter;
var hasRequiredPendingInterceptorsFormatter;
function requirePendingInterceptorsFormatter() {
  if (hasRequiredPendingInterceptorsFormatter) return pendingInterceptorsFormatter;
  hasRequiredPendingInterceptorsFormatter = 1;
  const { Transform: Transform2 } = import_node_stream.default;
  const { Console } = import_node_console.default;
  const PERSISTENT = process.versions.icu ? "\u2705" : "Y ";
  const NOT_PERSISTENT = process.versions.icu ? "\u274C" : "N ";
  pendingInterceptorsFormatter = class PendingInterceptorsFormatter {
    constructor({ disableColors } = {}) {
      this.transform = new Transform2({
        transform(chunk2, _enc, cb) {
          cb(null, chunk2);
        }
      });
      this.logger = new Console({
        stdout: this.transform,
        inspectOptions: {
          colors: !disableColors && !process.env.CI
        }
      });
    }
    format(pendingInterceptors) {
      const withPrettyHeaders = pendingInterceptors.map(
        ({ method, path: path3, data: { statusCode }, persist, times, timesInvoked, origin }) => ({
          Method: method,
          Origin: origin,
          Path: path3,
          "Status code": statusCode,
          Persistent: persist ? PERSISTENT : NOT_PERSISTENT,
          Invocations: timesInvoked,
          Remaining: persist ? Infinity : times - timesInvoked
        })
      );
      this.logger.table(withPrettyHeaders);
      return this.transform.read().toString();
    }
  };
  return pendingInterceptorsFormatter;
}
var mockAgent;
var hasRequiredMockAgent;
function requireMockAgent() {
  if (hasRequiredMockAgent) return mockAgent;
  hasRequiredMockAgent = 1;
  const { kClients } = requireSymbols();
  const Agent = requireAgent();
  const {
    kAgent,
    kMockAgentSet,
    kMockAgentGet,
    kDispatches,
    kIsMockActive,
    kNetConnect,
    kGetNetConnect,
    kOptions,
    kFactory,
    kMockAgentRegisterCallHistory,
    kMockAgentIsCallHistoryEnabled,
    kMockAgentAddCallHistoryLog,
    kMockAgentMockCallHistoryInstance,
    kMockAgentAcceptsNonStandardSearchParameters,
    kMockCallHistoryAddLog,
    kIgnoreTrailingSlash
  } = requireMockSymbols();
  const MockClient = requireMockClient();
  const MockPool = requireMockPool();
  const { matchValue, normalizeSearchParams, buildAndValidateMockOptions } = requireMockUtils();
  const { InvalidArgumentError, UndiciError } = requireErrors();
  const Dispatcher = requireDispatcher();
  const PendingInterceptorsFormatter = requirePendingInterceptorsFormatter();
  const { MockCallHistory } = requireMockCallHistory();
  class MockAgent extends Dispatcher {
    constructor(opts = {}) {
      super(opts);
      const mockOptions = buildAndValidateMockOptions(opts);
      this[kNetConnect] = true;
      this[kIsMockActive] = true;
      this[kMockAgentIsCallHistoryEnabled] = mockOptions.enableCallHistory ?? false;
      this[kMockAgentAcceptsNonStandardSearchParameters] = mockOptions.acceptNonStandardSearchParameters ?? false;
      this[kIgnoreTrailingSlash] = mockOptions.ignoreTrailingSlash ?? false;
      if (opts?.agent && typeof opts.agent.dispatch !== "function") {
        throw new InvalidArgumentError("Argument opts.agent must implement Agent");
      }
      const agent2 = opts?.agent ? opts.agent : new Agent(opts);
      this[kAgent] = agent2;
      this[kClients] = agent2[kClients];
      this[kOptions] = mockOptions;
      if (this[kMockAgentIsCallHistoryEnabled]) {
        this[kMockAgentRegisterCallHistory]();
      }
    }
    get(origin) {
      const originKey = this[kIgnoreTrailingSlash] ? origin.replace(/\/$/, "") : origin;
      let dispatcher2 = this[kMockAgentGet](originKey);
      if (!dispatcher2) {
        dispatcher2 = this[kFactory](originKey);
        this[kMockAgentSet](originKey, dispatcher2);
      }
      return dispatcher2;
    }
    dispatch(opts, handler) {
      this.get(opts.origin);
      this[kMockAgentAddCallHistoryLog](opts);
      const acceptNonStandardSearchParameters = this[kMockAgentAcceptsNonStandardSearchParameters];
      const dispatchOpts = { ...opts };
      if (acceptNonStandardSearchParameters && dispatchOpts.path) {
        const [path3, searchParams] = dispatchOpts.path.split("?");
        const normalizedSearchParams = normalizeSearchParams(searchParams, acceptNonStandardSearchParameters);
        dispatchOpts.path = `${path3}?${normalizedSearchParams}`;
      }
      return this[kAgent].dispatch(dispatchOpts, handler);
    }
    async close() {
      this.clearCallHistory();
      await this[kAgent].close();
      this[kClients].clear();
    }
    deactivate() {
      this[kIsMockActive] = false;
    }
    activate() {
      this[kIsMockActive] = true;
    }
    enableNetConnect(matcher) {
      if (typeof matcher === "string" || typeof matcher === "function" || matcher instanceof RegExp) {
        if (Array.isArray(this[kNetConnect])) {
          this[kNetConnect].push(matcher);
        } else {
          this[kNetConnect] = [matcher];
        }
      } else if (typeof matcher === "undefined") {
        this[kNetConnect] = true;
      } else {
        throw new InvalidArgumentError("Unsupported matcher. Must be one of String|Function|RegExp.");
      }
    }
    disableNetConnect() {
      this[kNetConnect] = false;
    }
    enableCallHistory() {
      this[kMockAgentIsCallHistoryEnabled] = true;
      return this;
    }
    disableCallHistory() {
      this[kMockAgentIsCallHistoryEnabled] = false;
      return this;
    }
    getCallHistory() {
      return this[kMockAgentMockCallHistoryInstance];
    }
    clearCallHistory() {
      if (this[kMockAgentMockCallHistoryInstance] !== void 0) {
        this[kMockAgentMockCallHistoryInstance].clear();
      }
    }
    // This is required to bypass issues caused by using global symbols - see:
    // https://github.com/nodejs/undici/issues/1447
    get isMockActive() {
      return this[kIsMockActive];
    }
    [kMockAgentRegisterCallHistory]() {
      if (this[kMockAgentMockCallHistoryInstance] === void 0) {
        this[kMockAgentMockCallHistoryInstance] = new MockCallHistory();
      }
    }
    [kMockAgentAddCallHistoryLog](opts) {
      if (this[kMockAgentIsCallHistoryEnabled]) {
        this[kMockAgentRegisterCallHistory]();
        this[kMockAgentMockCallHistoryInstance][kMockCallHistoryAddLog](opts);
      }
    }
    [kMockAgentSet](origin, dispatcher2) {
      this[kClients].set(origin, { count: 0, dispatcher: dispatcher2 });
    }
    [kFactory](origin) {
      const mockOptions = Object.assign({ agent: this }, this[kOptions]);
      return this[kOptions] && this[kOptions].connections === 1 ? new MockClient(origin, mockOptions) : new MockPool(origin, mockOptions);
    }
    [kMockAgentGet](origin) {
      const result = this[kClients].get(origin);
      if (result?.dispatcher) {
        return result.dispatcher;
      }
      if (typeof origin !== "string") {
        const dispatcher2 = this[kFactory]("http://localhost:9999");
        this[kMockAgentSet](origin, dispatcher2);
        return dispatcher2;
      }
      for (const [keyMatcher, result2] of Array.from(this[kClients])) {
        if (result2 && typeof keyMatcher !== "string" && matchValue(keyMatcher, origin)) {
          const dispatcher2 = this[kFactory](origin);
          this[kMockAgentSet](origin, dispatcher2);
          dispatcher2[kDispatches] = result2.dispatcher[kDispatches];
          return dispatcher2;
        }
      }
    }
    [kGetNetConnect]() {
      return this[kNetConnect];
    }
    pendingInterceptors() {
      const mockAgentClients = this[kClients];
      return Array.from(mockAgentClients.entries()).flatMap(([origin, result]) => result.dispatcher[kDispatches].map((dispatch) => ({ ...dispatch, origin }))).filter(({ pending }) => pending);
    }
    assertNoPendingInterceptors({ pendingInterceptorsFormatter: pendingInterceptorsFormatter2 = new PendingInterceptorsFormatter() } = {}) {
      const pending = this.pendingInterceptors();
      if (pending.length === 0) {
        return;
      }
      throw new UndiciError(
        pending.length === 1 ? `1 interceptor is pending:

${pendingInterceptorsFormatter2.format(pending)}`.trim() : `${pending.length} interceptors are pending:

${pendingInterceptorsFormatter2.format(pending)}`.trim()
      );
    }
  }
  mockAgent = MockAgent;
  return mockAgent;
}
var snapshotUtils;
var hasRequiredSnapshotUtils;
function requireSnapshotUtils() {
  if (hasRequiredSnapshotUtils) return snapshotUtils;
  hasRequiredSnapshotUtils = 1;
  const { InvalidArgumentError } = requireErrors();
  const { runtimeFeatures: runtimeFeatures2 } = requireRuntimeFeatures();
  function createHeaderFilters(matchOptions = {}) {
    const { ignoreHeaders = [], excludeHeaders = [], matchHeaders = [], caseSensitive = false } = matchOptions;
    return {
      ignore: new Set(ignoreHeaders.map((header) => caseSensitive ? header : header.toLowerCase())),
      exclude: new Set(excludeHeaders.map((header) => caseSensitive ? header : header.toLowerCase())),
      match: new Set(matchHeaders.map((header) => caseSensitive ? header : header.toLowerCase()))
    };
  }
  const crypto5 = runtimeFeatures2.has("crypto") ? import_node_crypto2.default : null;
  const hashId = crypto5?.hash ? (value) => crypto5.hash("sha256", value, "base64url") : (value) => Buffer.from(value).toString("base64url");
  function isUndiciHeaders(headers2) {
    return Array.isArray(headers2) && (headers2.length & 1) === 0;
  }
  function isUrlExcludedFactory(excludePatterns = []) {
    if (excludePatterns.length === 0) {
      return () => false;
    }
    return function isUrlExcluded(url) {
      let urlLowerCased;
      for (const pattern of excludePatterns) {
        if (typeof pattern === "string") {
          if (!urlLowerCased) {
            urlLowerCased = url.toLowerCase();
          }
          if (urlLowerCased.includes(pattern.toLowerCase())) {
            return true;
          }
        } else if (pattern instanceof RegExp) {
          if (pattern.test(url)) {
            return true;
          }
        }
      }
      return false;
    };
  }
  function normalizeHeaders(headers2) {
    const normalizedHeaders = {};
    if (!headers2) return normalizedHeaders;
    if (isUndiciHeaders(headers2)) {
      for (let i4 = 0; i4 < headers2.length; i4 += 2) {
        const key = headers2[i4];
        const value = headers2[i4 + 1];
        if (key && value !== void 0) {
          const keyStr = Buffer.isBuffer(key) ? key.toString() : key;
          const valueStr = Buffer.isBuffer(value) ? value.toString() : value;
          normalizedHeaders[keyStr.toLowerCase()] = valueStr;
        }
      }
      return normalizedHeaders;
    }
    if (headers2 && typeof headers2 === "object") {
      for (const [key, value] of Object.entries(headers2)) {
        if (key && typeof key === "string") {
          normalizedHeaders[key.toLowerCase()] = Array.isArray(value) ? value.join(", ") : String(value);
        }
      }
    }
    return normalizedHeaders;
  }
  const validSnapshotModes = (
    /** @type {const} */
    ["record", "playback", "update"]
  );
  function validateSnapshotMode(mode) {
    if (!validSnapshotModes.includes(mode)) {
      throw new InvalidArgumentError(`Invalid snapshot mode: ${mode}. Must be one of: ${validSnapshotModes.join(", ")}`);
    }
  }
  snapshotUtils = {
    createHeaderFilters,
    hashId,
    isUndiciHeaders,
    normalizeHeaders,
    isUrlExcludedFactory,
    validateSnapshotMode
  };
  return snapshotUtils;
}
var snapshotRecorder;
var hasRequiredSnapshotRecorder;
function requireSnapshotRecorder() {
  if (hasRequiredSnapshotRecorder) return snapshotRecorder;
  hasRequiredSnapshotRecorder = 1;
  const { writeFile: writeFile2, readFile: readFile2, mkdir: mkdir2 } = import_promises.default;
  const { dirname: dirname2, resolve } = import_node_path.default;
  const { setTimeout: setTimeout2, clearTimeout: clearTimeout2 } = import_node_timers.default;
  const { InvalidArgumentError, UndiciError } = requireErrors();
  const { hashId, isUrlExcludedFactory, normalizeHeaders, createHeaderFilters } = requireSnapshotUtils();
  function formatRequestKey(opts, headerFilters, matchOptions = {}) {
    const url = new URL(opts.path, opts.origin);
    const normalized = opts._normalizedHeaders || normalizeHeaders(opts.headers);
    if (!opts._normalizedHeaders) {
      opts._normalizedHeaders = normalized;
    }
    return {
      method: opts.method || "GET",
      url: matchOptions.matchQuery !== false ? url.toString() : `${url.origin}${url.pathname}`,
      headers: filterHeadersForMatching(normalized, headerFilters, matchOptions),
      body: matchOptions.matchBody !== false && opts.body ? String(opts.body) : ""
    };
  }
  function filterHeadersForMatching(headers2, headerFilters, matchOptions = {}) {
    if (!headers2 || typeof headers2 !== "object") return {};
    const {
      caseSensitive = false
    } = matchOptions;
    const filtered = {};
    const { ignore, exclude, match } = headerFilters;
    for (const [key, value] of Object.entries(headers2)) {
      const headerKey = caseSensitive ? key : key.toLowerCase();
      if (exclude.has(headerKey)) continue;
      if (ignore.has(headerKey)) continue;
      if (match.size !== 0) {
        if (!match.has(headerKey)) continue;
      }
      filtered[headerKey] = value;
    }
    return filtered;
  }
  function filterHeadersForStorage(headers2, headerFilters, matchOptions = {}) {
    if (!headers2 || typeof headers2 !== "object") return {};
    const {
      caseSensitive = false
    } = matchOptions;
    const filtered = {};
    const { exclude: excludeSet } = headerFilters;
    for (const [key, value] of Object.entries(headers2)) {
      const headerKey = caseSensitive ? key : key.toLowerCase();
      if (excludeSet.has(headerKey)) continue;
      filtered[headerKey] = value;
    }
    return filtered;
  }
  function createRequestHash(formattedRequest) {
    const parts = [
      formattedRequest.method,
      formattedRequest.url
    ];
    if (formattedRequest.headers && typeof formattedRequest.headers === "object") {
      const headerKeys = Object.keys(formattedRequest.headers).sort();
      for (const key of headerKeys) {
        const values = Array.isArray(formattedRequest.headers[key]) ? formattedRequest.headers[key] : [formattedRequest.headers[key]];
        parts.push(key);
        for (const value of values.sort()) {
          parts.push(String(value));
        }
      }
    }
    parts.push(formattedRequest.body);
    const content = parts.join("|");
    return hashId(content);
  }
  class SnapshotRecorder {
    /** @type {NodeJS.Timeout | null} */
    #flushTimeout;
    /** @type {import('./snapshot-utils').IsUrlExcluded} */
    #isUrlExcluded;
    /** @type {Map<string, SnapshotEntry>} */
    #snapshots = /* @__PURE__ */ new Map();
    /** @type {string|undefined} */
    #snapshotPath;
    /** @type {number} */
    #maxSnapshots = Infinity;
    /** @type {boolean} */
    #autoFlush = false;
    /** @type {import('./snapshot-utils').HeaderFilters} */
    #headerFilters;
    /**
     * Creates a new SnapshotRecorder instance
     * @param {SnapshotRecorderOptions&SnapshotRecorderMatchOptions} [options={}] - Configuration options for the recorder
     */
    constructor(options = {}) {
      this.#snapshotPath = options.snapshotPath;
      this.#maxSnapshots = options.maxSnapshots || Infinity;
      this.#autoFlush = options.autoFlush || false;
      this.flushInterval = options.flushInterval || 3e4;
      this._flushTimer = null;
      this.matchOptions = {
        matchHeaders: options.matchHeaders || [],
        // empty means match all headers
        ignoreHeaders: options.ignoreHeaders || [],
        excludeHeaders: options.excludeHeaders || [],
        matchBody: options.matchBody !== false,
        // default: true
        matchQuery: options.matchQuery !== false,
        // default: true
        caseSensitive: options.caseSensitive || false
      };
      this.#headerFilters = createHeaderFilters(this.matchOptions);
      this.shouldRecord = options.shouldRecord || (() => true);
      this.shouldPlayback = options.shouldPlayback || (() => true);
      this.#isUrlExcluded = isUrlExcludedFactory(options.excludeUrls);
      if (this.#autoFlush && this.#snapshotPath) {
        this.#startAutoFlush();
      }
    }
    /**
     * Records a request-response interaction
     * @param {SnapshotRequestOptions} requestOpts - Request options
     * @param {SnapshotEntryResponse} response - Response data to record
     * @return {Promise<void>} - Resolves when the recording is complete
     */
    async record(requestOpts, response2) {
      if (!this.shouldRecord(requestOpts)) {
        return;
      }
      if (this.isUrlExcluded(requestOpts)) {
        return;
      }
      const request2 = formatRequestKey(requestOpts, this.#headerFilters, this.matchOptions);
      const hash = createRequestHash(request2);
      const normalizedHeaders = normalizeHeaders(response2.headers);
      const responseData = {
        statusCode: response2.statusCode,
        headers: filterHeadersForStorage(normalizedHeaders, this.#headerFilters, this.matchOptions),
        body: Buffer.isBuffer(response2.body) ? response2.body.toString("base64") : Buffer.from(String(response2.body || "")).toString("base64"),
        trailers: response2.trailers
      };
      if (this.#snapshots.size >= this.#maxSnapshots && !this.#snapshots.has(hash)) {
        const oldestKey = this.#snapshots.keys().next().value;
        this.#snapshots.delete(oldestKey);
      }
      const existingSnapshot = this.#snapshots.get(hash);
      if (existingSnapshot && existingSnapshot.responses) {
        existingSnapshot.responses.push(responseData);
        existingSnapshot.timestamp = (/* @__PURE__ */ new Date()).toISOString();
      } else {
        this.#snapshots.set(hash, {
          request: request2,
          responses: [responseData],
          // Always store as array for consistency
          callCount: 0,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        });
      }
      if (this.#autoFlush && this.#snapshotPath) {
        this.#scheduleFlush();
      }
    }
    /**
     * Checks if a URL should be excluded from recording/playback
     * @param {SnapshotRequestOptions} requestOpts - Request options to check
     * @returns {boolean} - True if URL is excluded
     */
    isUrlExcluded(requestOpts) {
      const url = new URL(requestOpts.path, requestOpts.origin).toString();
      return this.#isUrlExcluded(url);
    }
    /**
     * Finds a matching snapshot for the given request
     * Returns the appropriate response based on call count for sequential responses
     *
     * @param {SnapshotRequestOptions} requestOpts - Request options to match
     * @returns {SnapshotEntry&Record<'response', SnapshotEntryResponse>|undefined} - Matching snapshot response or undefined if not found
     */
    findSnapshot(requestOpts) {
      if (!this.shouldPlayback(requestOpts)) {
        return void 0;
      }
      if (this.isUrlExcluded(requestOpts)) {
        return void 0;
      }
      const request2 = formatRequestKey(requestOpts, this.#headerFilters, this.matchOptions);
      const hash = createRequestHash(request2);
      const snapshot = this.#snapshots.get(hash);
      if (!snapshot) return void 0;
      const currentCallCount = snapshot.callCount || 0;
      const responseIndex = Math.min(currentCallCount, snapshot.responses.length - 1);
      snapshot.callCount = currentCallCount + 1;
      return {
        ...snapshot,
        response: snapshot.responses[responseIndex]
      };
    }
    /**
     * Loads snapshots from file
     * @param {string} [filePath] - Optional file path to load snapshots from
     * @return {Promise<void>} - Resolves when snapshots are loaded
     */
    async loadSnapshots(filePath) {
      const path3 = filePath || this.#snapshotPath;
      if (!path3) {
        throw new InvalidArgumentError("Snapshot path is required");
      }
      try {
        const data2 = await readFile2(resolve(path3), "utf8");
        const parsed = JSON.parse(data2);
        if (Array.isArray(parsed)) {
          this.#snapshots.clear();
          for (const { hash, snapshot } of parsed) {
            this.#snapshots.set(hash, snapshot);
          }
        } else {
          this.#snapshots = new Map(Object.entries(parsed));
        }
      } catch (error2) {
        if (error2.code === "ENOENT") {
          this.#snapshots.clear();
        } else {
          throw new UndiciError(`Failed to load snapshots from ${path3}`, { cause: error2 });
        }
      }
    }
    /**
     * Saves snapshots to file
     *
     * @param {string} [filePath] - Optional file path to save snapshots
     * @returns {Promise<void>} - Resolves when snapshots are saved
     */
    async saveSnapshots(filePath) {
      const path3 = filePath || this.#snapshotPath;
      if (!path3) {
        throw new InvalidArgumentError("Snapshot path is required");
      }
      const resolvedPath2 = resolve(path3);
      await mkdir2(dirname2(resolvedPath2), { recursive: true });
      const data2 = Array.from(this.#snapshots.entries()).map(([hash, snapshot]) => ({
        hash,
        snapshot
      }));
      await writeFile2(resolvedPath2, JSON.stringify(data2, null, 2), { flush: true });
    }
    /**
     * Clears all recorded snapshots
     * @returns {void}
     */
    clear() {
      this.#snapshots.clear();
    }
    /**
     * Gets all recorded snapshots
     * @return {Array<SnapshotEntry>} - Array of all recorded snapshots
     */
    getSnapshots() {
      return Array.from(this.#snapshots.values());
    }
    /**
     * Gets snapshot count
     * @return {number} - Number of recorded snapshots
     */
    size() {
      return this.#snapshots.size;
    }
    /**
     * Resets call counts for all snapshots (useful for test cleanup)
     * @returns {void}
     */
    resetCallCounts() {
      for (const snapshot of this.#snapshots.values()) {
        snapshot.callCount = 0;
      }
    }
    /**
     * Deletes a specific snapshot by request options
     * @param {SnapshotRequestOptions} requestOpts - Request options to match
     * @returns {boolean} - True if snapshot was deleted, false if not found
     */
    deleteSnapshot(requestOpts) {
      const request2 = formatRequestKey(requestOpts, this.#headerFilters, this.matchOptions);
      const hash = createRequestHash(request2);
      return this.#snapshots.delete(hash);
    }
    /**
     * Gets information about a specific snapshot
     * @param {SnapshotRequestOptions} requestOpts - Request options to match
     * @returns {SnapshotInfo|null} - Snapshot information or null if not found
     */
    getSnapshotInfo(requestOpts) {
      const request2 = formatRequestKey(requestOpts, this.#headerFilters, this.matchOptions);
      const hash = createRequestHash(request2);
      const snapshot = this.#snapshots.get(hash);
      if (!snapshot) return null;
      return {
        hash,
        request: snapshot.request,
        responseCount: snapshot.responses ? snapshot.responses.length : snapshot.response ? 1 : 0,
        // .response for legacy snapshots
        callCount: snapshot.callCount || 0,
        timestamp: snapshot.timestamp
      };
    }
    /**
     * Replaces all snapshots with new data (full replacement)
     * @param {Array<{hash: string; snapshot: SnapshotEntry}>|Record<string, SnapshotEntry>} snapshotData - New snapshot data to replace existing ones
     * @returns {void}
     */
    replaceSnapshots(snapshotData) {
      this.#snapshots.clear();
      if (Array.isArray(snapshotData)) {
        for (const { hash, snapshot } of snapshotData) {
          this.#snapshots.set(hash, snapshot);
        }
      } else if (snapshotData && typeof snapshotData === "object") {
        this.#snapshots = new Map(Object.entries(snapshotData));
      }
    }
    /**
     * Starts the auto-flush timer
     * @returns {void}
     */
    #startAutoFlush() {
      return this.#scheduleFlush();
    }
    /**
     * Stops the auto-flush timer
     * @returns {void}
     */
    #stopAutoFlush() {
      if (this.#flushTimeout) {
        clearTimeout2(this.#flushTimeout);
        this.saveSnapshots().catch(() => {
        });
        this.#flushTimeout = null;
      }
    }
    /**
     * Schedules a flush (debounced to avoid excessive writes)
     */
    #scheduleFlush() {
      this.#flushTimeout = setTimeout2(() => {
        this.saveSnapshots().catch(() => {
        });
        if (this.#autoFlush) {
          this.#flushTimeout?.refresh();
        } else {
          this.#flushTimeout = null;
        }
      }, 1e3);
    }
    /**
     * Cleanup method to stop timers
     * @returns {void}
     */
    destroy() {
      this.#stopAutoFlush();
      if (this.#flushTimeout) {
        clearTimeout2(this.#flushTimeout);
        this.#flushTimeout = null;
      }
    }
    /**
     * Async close method that saves all recordings and performs cleanup
     * @returns {Promise<void>}
     */
    async close() {
      if (this.#snapshotPath && this.#snapshots.size !== 0) {
        await this.saveSnapshots();
      }
      this.destroy();
    }
  }
  snapshotRecorder = { SnapshotRecorder, formatRequestKey, createRequestHash, filterHeadersForMatching, filterHeadersForStorage, createHeaderFilters };
  return snapshotRecorder;
}
var snapshotAgent;
var hasRequiredSnapshotAgent;
function requireSnapshotAgent() {
  if (hasRequiredSnapshotAgent) return snapshotAgent;
  hasRequiredSnapshotAgent = 1;
  const Agent = requireAgent();
  const MockAgent = requireMockAgent();
  const { SnapshotRecorder } = requireSnapshotRecorder();
  const WrapHandler = requireWrapHandler();
  const { InvalidArgumentError, UndiciError } = requireErrors();
  const { validateSnapshotMode } = requireSnapshotUtils();
  const kSnapshotRecorder = /* @__PURE__ */ Symbol("kSnapshotRecorder");
  const kSnapshotMode = /* @__PURE__ */ Symbol("kSnapshotMode");
  const kSnapshotPath = /* @__PURE__ */ Symbol("kSnapshotPath");
  const kSnapshotLoaded = /* @__PURE__ */ Symbol("kSnapshotLoaded");
  const kRealAgent = /* @__PURE__ */ Symbol("kRealAgent");
  let warningEmitted = false;
  class SnapshotAgent extends MockAgent {
    constructor(opts = {}) {
      if (!warningEmitted) {
        process.emitWarning(
          "SnapshotAgent is experimental and subject to change",
          "ExperimentalWarning"
        );
        warningEmitted = true;
      }
      const {
        mode = "record",
        snapshotPath = null,
        ...mockAgentOpts
      } = opts;
      super(mockAgentOpts);
      validateSnapshotMode(mode);
      if ((mode === "playback" || mode === "update") && !snapshotPath) {
        throw new InvalidArgumentError(`snapshotPath is required when mode is '${mode}'`);
      }
      this[kSnapshotMode] = mode;
      this[kSnapshotPath] = snapshotPath;
      this[kSnapshotRecorder] = new SnapshotRecorder({
        snapshotPath: this[kSnapshotPath],
        mode: this[kSnapshotMode],
        maxSnapshots: opts.maxSnapshots,
        autoFlush: opts.autoFlush,
        flushInterval: opts.flushInterval,
        matchHeaders: opts.matchHeaders,
        ignoreHeaders: opts.ignoreHeaders,
        excludeHeaders: opts.excludeHeaders,
        matchBody: opts.matchBody,
        matchQuery: opts.matchQuery,
        caseSensitive: opts.caseSensitive,
        shouldRecord: opts.shouldRecord,
        shouldPlayback: opts.shouldPlayback,
        excludeUrls: opts.excludeUrls
      });
      this[kSnapshotLoaded] = false;
      if (this[kSnapshotMode] === "record" || this[kSnapshotMode] === "update" || this[kSnapshotMode] === "playback" && opts.excludeUrls && opts.excludeUrls.length > 0) {
        this[kRealAgent] = new Agent(opts);
      }
      if ((this[kSnapshotMode] === "playback" || this[kSnapshotMode] === "update") && this[kSnapshotPath]) {
        this.loadSnapshots().catch(() => {
        });
      }
    }
    dispatch(opts, handler) {
      handler = WrapHandler.wrap(handler);
      const mode = this[kSnapshotMode];
      if (this[kSnapshotRecorder].isUrlExcluded(opts)) {
        return this[kRealAgent].dispatch(opts, handler);
      }
      if (mode === "playback" || mode === "update") {
        if (!this[kSnapshotLoaded]) {
          return this.#asyncDispatch(opts, handler);
        }
        const snapshot = this[kSnapshotRecorder].findSnapshot(opts);
        if (snapshot) {
          return this.#replaySnapshot(snapshot, handler);
        } else if (mode === "update") {
          return this.#recordAndReplay(opts, handler);
        } else {
          const error2 = new UndiciError(`No snapshot found for ${opts.method || "GET"} ${opts.path}`);
          if (handler.onError) {
            handler.onError(error2);
            return;
          }
          throw error2;
        }
      } else if (mode === "record") {
        return this.#recordAndReplay(opts, handler);
      }
    }
    /**
     * Async version of dispatch for when we need to load snapshots first
     */
    async #asyncDispatch(opts, handler) {
      await this.loadSnapshots();
      return this.dispatch(opts, handler);
    }
    /**
     * Records a real request and replays the response
     */
    #recordAndReplay(opts, handler) {
      const responseData = {
        statusCode: null,
        headers: {},
        trailers: {},
        body: []
      };
      const self2 = this;
      const recordingHandler = {
        onRequestStart(controller, context) {
          return handler.onRequestStart(controller, { ...context, history: this.history });
        },
        onRequestUpgrade(controller, statusCode, headers2, socket) {
          return handler.onRequestUpgrade(controller, statusCode, headers2, socket);
        },
        onResponseStart(controller, statusCode, headers2, statusMessage) {
          responseData.statusCode = statusCode;
          responseData.headers = headers2;
          return handler.onResponseStart(controller, statusCode, headers2, statusMessage);
        },
        onResponseData(controller, chunk2) {
          responseData.body.push(chunk2);
          return handler.onResponseData(controller, chunk2);
        },
        onResponseEnd(controller, trailers) {
          responseData.trailers = trailers;
          const responseBody = Buffer.concat(responseData.body);
          self2[kSnapshotRecorder].record(opts, {
            statusCode: responseData.statusCode,
            headers: responseData.headers,
            body: responseBody,
            trailers: responseData.trailers
          }).then(() => handler.onResponseEnd(controller, trailers)).catch((error2) => handler.onResponseError(controller, error2));
        }
      };
      const agent2 = this[kRealAgent];
      return agent2.dispatch(opts, recordingHandler);
    }
    /**
     * Replays a recorded response
     *
     * @param {Object} snapshot - The recorded snapshot to replay.
     * @param {Object} handler - The handler to call with the response data.
     * @returns {void}
     */
    #replaySnapshot(snapshot, handler) {
      try {
        const { response: response2 } = snapshot;
        const controller = {
          pause() {
          },
          resume() {
          },
          abort(reason) {
            this.aborted = true;
            this.reason = reason;
          },
          aborted: false,
          paused: false
        };
        handler.onRequestStart(controller);
        handler.onResponseStart(controller, response2.statusCode, response2.headers);
        const body2 = Buffer.from(response2.body, "base64");
        handler.onResponseData(controller, body2);
        handler.onResponseEnd(controller, response2.trailers);
      } catch (error2) {
        handler.onError?.(error2);
      }
    }
    /**
     * Loads snapshots from file
     *
     * @param {string} [filePath] - Optional file path to load snapshots from.
     * @returns {Promise<void>} - Resolves when snapshots are loaded.
     */
    async loadSnapshots(filePath) {
      await this[kSnapshotRecorder].loadSnapshots(filePath || this[kSnapshotPath]);
      this[kSnapshotLoaded] = true;
      if (this[kSnapshotMode] === "playback") {
        this.#setupMockInterceptors();
      }
    }
    /**
     * Saves snapshots to file
     *
     * @param {string} [filePath] - Optional file path to save snapshots to.
     * @returns {Promise<void>} - Resolves when snapshots are saved.
     */
    async saveSnapshots(filePath) {
      return this[kSnapshotRecorder].saveSnapshots(filePath || this[kSnapshotPath]);
    }
    /**
     * Sets up MockAgent interceptors based on recorded snapshots.
     *
     * This method creates MockAgent interceptors for each recorded snapshot,
     * allowing the SnapshotAgent to fall back to MockAgent's standard intercept
     * mechanism in playback mode. Each interceptor is configured to persist
     * (remain active for multiple requests) and responds with the recorded
     * response data.
     *
     * Called automatically when loading snapshots in playback mode.
     *
     * @returns {void}
     */
    #setupMockInterceptors() {
      for (const snapshot of this[kSnapshotRecorder].getSnapshots()) {
        const { request: request2, responses, response: response2 } = snapshot;
        const url = new URL(request2.url);
        const mockPool2 = this.get(url.origin);
        const responseData = responses ? responses[0] : response2;
        if (!responseData) continue;
        mockPool2.intercept({
          path: url.pathname + url.search,
          method: request2.method,
          headers: request2.headers,
          body: request2.body
        }).reply(responseData.statusCode, responseData.body, {
          headers: responseData.headers,
          trailers: responseData.trailers
        }).persist();
      }
    }
    /**
     * Gets the snapshot recorder
     * @return {SnapshotRecorder} - The snapshot recorder instance
     */
    getRecorder() {
      return this[kSnapshotRecorder];
    }
    /**
     * Gets the current mode
     * @return {import('./snapshot-utils').SnapshotMode} - The current snapshot mode
     */
    getMode() {
      return this[kSnapshotMode];
    }
    /**
     * Clears all snapshots
     * @returns {void}
     */
    clearSnapshots() {
      this[kSnapshotRecorder].clear();
    }
    /**
     * Resets call counts for all snapshots (useful for test cleanup)
     * @returns {void}
     */
    resetCallCounts() {
      this[kSnapshotRecorder].resetCallCounts();
    }
    /**
     * Deletes a specific snapshot by request options
     * @param {import('./snapshot-recorder').SnapshotRequestOptions} requestOpts - Request options to identify the snapshot
     * @return {Promise<boolean>} - Returns true if the snapshot was deleted, false if not found
     */
    deleteSnapshot(requestOpts) {
      return this[kSnapshotRecorder].deleteSnapshot(requestOpts);
    }
    /**
     * Gets information about a specific snapshot
     * @returns {import('./snapshot-recorder').SnapshotInfo|null} - Snapshot information or null if not found
     */
    getSnapshotInfo(requestOpts) {
      return this[kSnapshotRecorder].getSnapshotInfo(requestOpts);
    }
    /**
     * Replaces all snapshots with new data (full replacement)
     * @param {Array<{hash: string; snapshot: import('./snapshot-recorder').SnapshotEntryshotEntry}>|Record<string, import('./snapshot-recorder').SnapshotEntry>} snapshotData - New snapshot data to replace existing snapshots
     * @returns {void}
     */
    replaceSnapshots(snapshotData) {
      this[kSnapshotRecorder].replaceSnapshots(snapshotData);
    }
    /**
     * Closes the agent, saving snapshots and cleaning up resources.
     *
     * @returns {Promise<void>}
     */
    async close() {
      await this[kSnapshotRecorder].close();
      await this[kRealAgent]?.close();
      await super.close();
    }
  }
  snapshotAgent = SnapshotAgent;
  return snapshotAgent;
}
var global$1;
var hasRequiredGlobal;
function requireGlobal() {
  if (hasRequiredGlobal) return global$1;
  hasRequiredGlobal = 1;
  const globalDispatcher = /* @__PURE__ */ Symbol.for("undici.globalDispatcher.1");
  const { InvalidArgumentError } = requireErrors();
  const Agent = requireAgent();
  if (getGlobalDispatcher() === void 0) {
    setGlobalDispatcher(new Agent());
  }
  function setGlobalDispatcher(agent2) {
    if (!agent2 || typeof agent2.dispatch !== "function") {
      throw new InvalidArgumentError("Argument agent must implement Agent");
    }
    Object.defineProperty(globalThis, globalDispatcher, {
      value: agent2,
      writable: true,
      enumerable: false,
      configurable: false
    });
  }
  function getGlobalDispatcher() {
    return globalThis[globalDispatcher];
  }
  const installedExports = (
    /** @type {const} */
    [
      "fetch",
      "Headers",
      "Response",
      "Request",
      "FormData",
      "WebSocket",
      "CloseEvent",
      "ErrorEvent",
      "MessageEvent",
      "EventSource"
    ]
  );
  global$1 = {
    setGlobalDispatcher,
    getGlobalDispatcher,
    installedExports
  };
  return global$1;
}
var decoratorHandler;
var hasRequiredDecoratorHandler;
function requireDecoratorHandler() {
  if (hasRequiredDecoratorHandler) return decoratorHandler;
  hasRequiredDecoratorHandler = 1;
  const assert = import_node_assert.default;
  const WrapHandler = requireWrapHandler();
  decoratorHandler = class DecoratorHandler {
    #handler;
    #onCompleteCalled = false;
    #onErrorCalled = false;
    #onResponseStartCalled = false;
    constructor(handler) {
      if (typeof handler !== "object" || handler === null) {
        throw new TypeError("handler must be an object");
      }
      this.#handler = WrapHandler.wrap(handler);
    }
    onRequestStart(...args) {
      this.#handler.onRequestStart?.(...args);
    }
    onRequestUpgrade(...args) {
      assert(!this.#onCompleteCalled);
      assert(!this.#onErrorCalled);
      return this.#handler.onRequestUpgrade?.(...args);
    }
    onResponseStart(...args) {
      assert(!this.#onCompleteCalled);
      assert(!this.#onErrorCalled);
      assert(!this.#onResponseStartCalled);
      this.#onResponseStartCalled = true;
      return this.#handler.onResponseStart?.(...args);
    }
    onResponseData(...args) {
      assert(!this.#onCompleteCalled);
      assert(!this.#onErrorCalled);
      return this.#handler.onResponseData?.(...args);
    }
    onResponseEnd(...args) {
      assert(!this.#onCompleteCalled);
      assert(!this.#onErrorCalled);
      this.#onCompleteCalled = true;
      return this.#handler.onResponseEnd?.(...args);
    }
    onResponseError(...args) {
      this.#onErrorCalled = true;
      return this.#handler.onResponseError?.(...args);
    }
    /**
     * @deprecated
     */
    onBodySent() {
    }
  };
  return decoratorHandler;
}
var redirectHandler;
var hasRequiredRedirectHandler;
function requireRedirectHandler() {
  if (hasRequiredRedirectHandler) return redirectHandler;
  hasRequiredRedirectHandler = 1;
  const util2 = requireUtil$5();
  const { kBodyUsed } = requireSymbols();
  const assert = import_node_assert.default;
  const { InvalidArgumentError } = requireErrors();
  const EE = import_node_events.default;
  const redirectableStatusCodes = [300, 301, 302, 303, 307, 308];
  const kBody = /* @__PURE__ */ Symbol("body");
  const noop2 = () => {
  };
  class BodyAsyncIterable {
    constructor(body2) {
      this[kBody] = body2;
      this[kBodyUsed] = false;
    }
    async *[Symbol.asyncIterator]() {
      assert(!this[kBodyUsed], "disturbed");
      this[kBodyUsed] = true;
      yield* this[kBody];
    }
  }
  class RedirectHandler {
    static buildDispatch(dispatcher2, maxRedirections) {
      if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
        throw new InvalidArgumentError("maxRedirections must be a positive number");
      }
      const dispatch = dispatcher2.dispatch.bind(dispatcher2);
      return (opts, originalHandler) => dispatch(opts, new RedirectHandler(dispatch, maxRedirections, opts, originalHandler));
    }
    constructor(dispatch, maxRedirections, opts, handler) {
      if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
        throw new InvalidArgumentError("maxRedirections must be a positive number");
      }
      this.dispatch = dispatch;
      this.location = null;
      const { maxRedirections: _, ...cleanOpts } = opts;
      this.opts = cleanOpts;
      this.maxRedirections = maxRedirections;
      this.handler = handler;
      this.history = [];
      if (util2.isStream(this.opts.body)) {
        if (util2.bodyLength(this.opts.body) === 0) {
          this.opts.body.on("data", function() {
            assert(false);
          });
        }
        if (typeof this.opts.body.readableDidRead !== "boolean") {
          this.opts.body[kBodyUsed] = false;
          EE.prototype.on.call(this.opts.body, "data", function() {
            this[kBodyUsed] = true;
          });
        }
      } else if (this.opts.body && typeof this.opts.body.pipeTo === "function") {
        this.opts.body = new BodyAsyncIterable(this.opts.body);
      } else if (this.opts.body && typeof this.opts.body !== "string" && !ArrayBuffer.isView(this.opts.body) && util2.isIterable(this.opts.body) && !util2.isFormDataLike(this.opts.body)) {
        this.opts.body = new BodyAsyncIterable(this.opts.body);
      }
    }
    onRequestStart(controller, context) {
      this.handler.onRequestStart?.(controller, { ...context, history: this.history });
    }
    onRequestUpgrade(controller, statusCode, headers2, socket) {
      this.handler.onRequestUpgrade?.(controller, statusCode, headers2, socket);
    }
    onResponseStart(controller, statusCode, headers2, statusMessage) {
      if (this.opts.throwOnMaxRedirect && this.history.length >= this.maxRedirections) {
        throw new Error("max redirects");
      }
      if ((statusCode === 301 || statusCode === 302) && this.opts.method === "POST") {
        this.opts.method = "GET";
        if (util2.isStream(this.opts.body)) {
          util2.destroy(this.opts.body.on("error", noop2));
        }
        this.opts.body = null;
      }
      if (statusCode === 303 && this.opts.method !== "HEAD") {
        this.opts.method = "GET";
        if (util2.isStream(this.opts.body)) {
          util2.destroy(this.opts.body.on("error", noop2));
        }
        this.opts.body = null;
      }
      this.location = this.history.length >= this.maxRedirections || util2.isDisturbed(this.opts.body) || redirectableStatusCodes.indexOf(statusCode) === -1 ? null : headers2.location;
      if (this.opts.origin) {
        this.history.push(new URL(this.opts.path, this.opts.origin));
      }
      if (!this.location) {
        this.handler.onResponseStart?.(controller, statusCode, headers2, statusMessage);
        return;
      }
      const { origin, pathname, search } = util2.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)));
      const path3 = search ? `${pathname}${search}` : pathname;
      const redirectUrlString = `${origin}${path3}`;
      for (const historyUrl of this.history) {
        if (historyUrl.toString() === redirectUrlString) {
          throw new InvalidArgumentError(`Redirect loop detected. Cannot redirect to ${origin}. This typically happens when using a Client or Pool with cross-origin redirects. Use an Agent for cross-origin redirects.`);
        }
      }
      this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin);
      this.opts.path = path3;
      this.opts.origin = origin;
      this.opts.query = null;
    }
    onResponseData(controller, chunk2) {
      if (this.location) ;
      else {
        this.handler.onResponseData?.(controller, chunk2);
      }
    }
    onResponseEnd(controller, trailers) {
      if (this.location) {
        this.dispatch(this.opts, this);
      } else {
        this.handler.onResponseEnd(controller, trailers);
      }
    }
    onResponseError(controller, error2) {
      this.handler.onResponseError?.(controller, error2);
    }
  }
  function shouldRemoveHeader(header, removeContent, unknownOrigin) {
    if (header.length === 4) {
      return util2.headerNameToString(header) === "host";
    }
    if (removeContent && util2.headerNameToString(header).startsWith("content-")) {
      return true;
    }
    if (unknownOrigin && (header.length === 13 || header.length === 6 || header.length === 19)) {
      const name = util2.headerNameToString(header);
      return name === "authorization" || name === "cookie" || name === "proxy-authorization";
    }
    return false;
  }
  function cleanRequestHeaders(headers2, removeContent, unknownOrigin) {
    const ret = [];
    if (Array.isArray(headers2)) {
      for (let i4 = 0; i4 < headers2.length; i4 += 2) {
        if (!shouldRemoveHeader(headers2[i4], removeContent, unknownOrigin)) {
          ret.push(headers2[i4], headers2[i4 + 1]);
        }
      }
    } else if (headers2 && typeof headers2 === "object") {
      const entries = typeof headers2[Symbol.iterator] === "function" ? headers2 : Object.entries(headers2);
      for (const [key, value] of entries) {
        if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {
          ret.push(key, value);
        }
      }
    } else {
      assert(headers2 == null, "headers must be an object or an array");
    }
    return ret;
  }
  redirectHandler = RedirectHandler;
  return redirectHandler;
}
var redirect;
var hasRequiredRedirect;
function requireRedirect() {
  if (hasRequiredRedirect) return redirect;
  hasRequiredRedirect = 1;
  const RedirectHandler = requireRedirectHandler();
  function createRedirectInterceptor({ maxRedirections: defaultMaxRedirections } = {}) {
    return (dispatch) => {
      return function Intercept(opts, handler) {
        const { maxRedirections = defaultMaxRedirections, ...rest } = opts;
        if (maxRedirections == null || maxRedirections === 0) {
          return dispatch(opts, handler);
        }
        const dispatchOpts = { ...rest };
        const redirectHandler2 = new RedirectHandler(dispatch, maxRedirections, dispatchOpts, handler);
        return dispatch(dispatchOpts, redirectHandler2);
      };
    };
  }
  redirect = createRedirectInterceptor;
  return redirect;
}
var responseError;
var hasRequiredResponseError;
function requireResponseError() {
  if (hasRequiredResponseError) return responseError;
  hasRequiredResponseError = 1;
  const DecoratorHandler = requireDecoratorHandler();
  const { ResponseError } = requireErrors();
  class ResponseErrorHandler extends DecoratorHandler {
    #statusCode;
    #contentType;
    #decoder;
    #headers;
    #body;
    constructor(_opts, { handler }) {
      super(handler);
    }
    #checkContentType(contentType) {
      return (this.#contentType ?? "").indexOf(contentType) === 0;
    }
    onRequestStart(controller, context) {
      this.#statusCode = 0;
      this.#contentType = null;
      this.#decoder = null;
      this.#headers = null;
      this.#body = "";
      return super.onRequestStart(controller, context);
    }
    onResponseStart(controller, statusCode, headers2, statusMessage) {
      this.#statusCode = statusCode;
      this.#headers = headers2;
      this.#contentType = headers2["content-type"];
      if (this.#statusCode < 400) {
        return super.onResponseStart(controller, statusCode, headers2, statusMessage);
      }
      if (this.#checkContentType("application/json") || this.#checkContentType("text/plain")) {
        this.#decoder = new TextDecoder("utf-8");
      }
    }
    onResponseData(controller, chunk2) {
      if (this.#statusCode < 400) {
        return super.onResponseData(controller, chunk2);
      }
      this.#body += this.#decoder?.decode(chunk2, { stream: true }) ?? "";
    }
    onResponseEnd(controller, trailers) {
      if (this.#statusCode >= 400) {
        this.#body += this.#decoder?.decode(void 0, { stream: false }) ?? "";
        if (this.#checkContentType("application/json")) {
          try {
            this.#body = JSON.parse(this.#body);
          } catch {
          }
        }
        let err;
        const stackTraceLimit = Error.stackTraceLimit;
        Error.stackTraceLimit = 0;
        try {
          err = new ResponseError("Response Error", this.#statusCode, {
            body: this.#body,
            headers: this.#headers
          });
        } finally {
          Error.stackTraceLimit = stackTraceLimit;
        }
        super.onResponseError(controller, err);
      } else {
        super.onResponseEnd(controller, trailers);
      }
    }
    onResponseError(controller, err) {
      super.onResponseError(controller, err);
    }
  }
  responseError = () => {
    return (dispatch) => {
      return function Intercept(opts, handler) {
        return dispatch(opts, new ResponseErrorHandler(opts, { handler }));
      };
    };
  };
  return responseError;
}
var retry;
var hasRequiredRetry;
function requireRetry() {
  if (hasRequiredRetry) return retry;
  hasRequiredRetry = 1;
  const RetryHandler = requireRetryHandler();
  retry = (globalOpts) => {
    return (dispatch) => {
      return function retryInterceptor(opts, handler) {
        return dispatch(
          opts,
          new RetryHandler(
            { ...opts, retryOptions: { ...globalOpts, ...opts.retryOptions } },
            {
              handler,
              dispatch
            }
          )
        );
      };
    };
  };
  return retry;
}
var dump;
var hasRequiredDump;
function requireDump() {
  if (hasRequiredDump) return dump;
  hasRequiredDump = 1;
  const { InvalidArgumentError, RequestAbortedError } = requireErrors();
  const DecoratorHandler = requireDecoratorHandler();
  class DumpHandler extends DecoratorHandler {
    #maxSize = 1024 * 1024;
    #dumped = false;
    #size = 0;
    #controller = null;
    aborted = false;
    reason = false;
    constructor({ maxSize, signal }, handler) {
      if (maxSize != null && (!Number.isFinite(maxSize) || maxSize < 1)) {
        throw new InvalidArgumentError("maxSize must be a number greater than 0");
      }
      super(handler);
      this.#maxSize = maxSize ?? this.#maxSize;
    }
    #abort(reason) {
      this.aborted = true;
      this.reason = reason;
    }
    onRequestStart(controller, context) {
      controller.abort = this.#abort.bind(this);
      this.#controller = controller;
      return super.onRequestStart(controller, context);
    }
    onResponseStart(controller, statusCode, headers2, statusMessage) {
      const contentLength = headers2["content-length"];
      if (contentLength != null && contentLength > this.#maxSize) {
        throw new RequestAbortedError(
          `Response size (${contentLength}) larger than maxSize (${this.#maxSize})`
        );
      }
      if (this.aborted === true) {
        return true;
      }
      return super.onResponseStart(controller, statusCode, headers2, statusMessage);
    }
    onResponseError(controller, err) {
      if (this.#dumped) {
        return;
      }
      err = this.#controller?.reason ?? err;
      super.onResponseError(controller, err);
    }
    onResponseData(controller, chunk2) {
      this.#size = this.#size + chunk2.length;
      if (this.#size >= this.#maxSize) {
        this.#dumped = true;
        if (this.aborted === true) {
          super.onResponseError(controller, this.reason);
        } else {
          super.onResponseEnd(controller, {});
        }
      }
      return true;
    }
    onResponseEnd(controller, trailers) {
      if (this.#dumped) {
        return;
      }
      if (this.#controller.aborted === true) {
        super.onResponseError(controller, this.reason);
        return;
      }
      super.onResponseEnd(controller, trailers);
    }
  }
  function createDumpInterceptor({ maxSize: defaultMaxSize } = {
    maxSize: 1024 * 1024
  }) {
    return (dispatch) => {
      return function Intercept(opts, handler) {
        const { dumpMaxSize = defaultMaxSize } = opts;
        const dumpHandler = new DumpHandler({ maxSize: dumpMaxSize, signal: opts.signal }, handler);
        return dispatch(opts, dumpHandler);
      };
    };
  }
  dump = createDumpInterceptor;
  return dump;
}
var dns;
var hasRequiredDns;
function requireDns() {
  if (hasRequiredDns) return dns;
  hasRequiredDns = 1;
  const { isIP } = import_node_net.default;
  const { lookup: lookup2 } = import_node_dns.default;
  const DecoratorHandler = requireDecoratorHandler();
  const { InvalidArgumentError, InformationalError } = requireErrors();
  const maxInt = Math.pow(2, 31) - 1;
  class DNSStorage {
    #maxItems = 0;
    #records = /* @__PURE__ */ new Map();
    constructor(opts) {
      this.#maxItems = opts.maxItems;
    }
    get size() {
      return this.#records.size;
    }
    get(hostname) {
      return this.#records.get(hostname) ?? null;
    }
    set(hostname, records) {
      this.#records.set(hostname, records);
    }
    delete(hostname) {
      this.#records.delete(hostname);
    }
    // Delegate to storage decide can we do more lookups or not
    full() {
      return this.size >= this.#maxItems;
    }
  }
  class DNSInstance {
    #maxTTL = 0;
    #maxItems = 0;
    dualStack = true;
    affinity = null;
    lookup = null;
    pick = null;
    storage = null;
    constructor(opts) {
      this.#maxTTL = opts.maxTTL;
      this.#maxItems = opts.maxItems;
      this.dualStack = opts.dualStack;
      this.affinity = opts.affinity;
      this.lookup = opts.lookup ?? this.#defaultLookup;
      this.pick = opts.pick ?? this.#defaultPick;
      this.storage = opts.storage ?? new DNSStorage(opts);
    }
    runLookup(origin, opts, cb) {
      const ips = this.storage.get(origin.hostname);
      if (ips == null && this.storage.full()) {
        cb(null, origin);
        return;
      }
      const newOpts = {
        affinity: this.affinity,
        dualStack: this.dualStack,
        lookup: this.lookup,
        pick: this.pick,
        ...opts.dns,
        maxTTL: this.#maxTTL,
        maxItems: this.#maxItems
      };
      if (ips == null) {
        this.lookup(origin, newOpts, (err, addresses) => {
          if (err || addresses == null || addresses.length === 0) {
            cb(err ?? new InformationalError("No DNS entries found"));
            return;
          }
          this.setRecords(origin, addresses);
          const records = this.storage.get(origin.hostname);
          const ip = this.pick(
            origin,
            records,
            newOpts.affinity
          );
          let port;
          if (typeof ip.port === "number") {
            port = `:${ip.port}`;
          } else if (origin.port !== "") {
            port = `:${origin.port}`;
          } else {
            port = "";
          }
          cb(
            null,
            new URL(`${origin.protocol}//${ip.family === 6 ? `[${ip.address}]` : ip.address}${port}`)
          );
        });
      } else {
        const ip = this.pick(
          origin,
          ips,
          newOpts.affinity
        );
        if (ip == null) {
          this.storage.delete(origin.hostname);
          this.runLookup(origin, opts, cb);
          return;
        }
        let port;
        if (typeof ip.port === "number") {
          port = `:${ip.port}`;
        } else if (origin.port !== "") {
          port = `:${origin.port}`;
        } else {
          port = "";
        }
        cb(
          null,
          new URL(`${origin.protocol}//${ip.family === 6 ? `[${ip.address}]` : ip.address}${port}`)
        );
      }
    }
    #defaultLookup(origin, opts, cb) {
      lookup2(
        origin.hostname,
        {
          all: true,
          family: this.dualStack === false ? this.affinity : 0,
          order: "ipv4first"
        },
        (err, addresses) => {
          if (err) {
            return cb(err);
          }
          const results = /* @__PURE__ */ new Map();
          for (const addr of addresses) {
            results.set(`${addr.address}:${addr.family}`, addr);
          }
          cb(null, results.values());
        }
      );
    }
    #defaultPick(origin, hostnameRecords, affinity) {
      let ip = null;
      const { records, offset } = hostnameRecords;
      let family;
      if (this.dualStack) {
        if (affinity == null) {
          if (offset == null || offset === maxInt) {
            hostnameRecords.offset = 0;
            affinity = 4;
          } else {
            hostnameRecords.offset++;
            affinity = (hostnameRecords.offset & 1) === 1 ? 6 : 4;
          }
        }
        if (records[affinity] != null && records[affinity].ips.length > 0) {
          family = records[affinity];
        } else {
          family = records[affinity === 4 ? 6 : 4];
        }
      } else {
        family = records[affinity];
      }
      if (family == null || family.ips.length === 0) {
        return ip;
      }
      if (family.offset == null || family.offset === maxInt) {
        family.offset = 0;
      } else {
        family.offset++;
      }
      const position = family.offset % family.ips.length;
      ip = family.ips[position] ?? null;
      if (ip == null) {
        return ip;
      }
      if (Date.now() - ip.timestamp > ip.ttl) {
        family.ips.splice(position, 1);
        return this.pick(origin, hostnameRecords, affinity);
      }
      return ip;
    }
    pickFamily(origin, ipFamily) {
      const records = this.storage.get(origin.hostname)?.records;
      if (!records) {
        return null;
      }
      const family = records[ipFamily];
      if (!family) {
        return null;
      }
      if (family.offset == null || family.offset === maxInt) {
        family.offset = 0;
      } else {
        family.offset++;
      }
      const position = family.offset % family.ips.length;
      const ip = family.ips[position] ?? null;
      if (ip == null) {
        return ip;
      }
      if (Date.now() - ip.timestamp > ip.ttl) {
        family.ips.splice(position, 1);
      }
      return ip;
    }
    setRecords(origin, addresses) {
      const timestamp = Date.now();
      const records = { records: { 4: null, 6: null } };
      let minTTL = this.#maxTTL;
      for (const record of addresses) {
        record.timestamp = timestamp;
        if (typeof record.ttl === "number") {
          record.ttl = Math.min(record.ttl, this.#maxTTL);
          minTTL = Math.min(minTTL, record.ttl);
        } else {
          record.ttl = this.#maxTTL;
        }
        const familyRecords = records.records[record.family] ?? { ips: [] };
        familyRecords.ips.push(record);
        records.records[record.family] = familyRecords;
      }
      this.storage.set(origin.hostname, records, { ttl: minTTL });
    }
    deleteRecords(origin) {
      this.storage.delete(origin.hostname);
    }
    getHandler(meta, opts) {
      return new DNSDispatchHandler(this, meta, opts);
    }
  }
  class DNSDispatchHandler extends DecoratorHandler {
    #state = null;
    #opts = null;
    #dispatch = null;
    #origin = null;
    #controller = null;
    #newOrigin = null;
    #firstTry = true;
    constructor(state2, { origin, handler, dispatch, newOrigin }, opts) {
      super(handler);
      this.#origin = origin;
      this.#newOrigin = newOrigin;
      this.#opts = { ...opts };
      this.#state = state2;
      this.#dispatch = dispatch;
    }
    onResponseError(controller, err) {
      switch (err.code) {
        case "ETIMEDOUT":
        case "ECONNREFUSED": {
          if (this.#state.dualStack) {
            if (!this.#firstTry) {
              super.onResponseError(controller, err);
              return;
            }
            this.#firstTry = false;
            const otherFamily = this.#newOrigin.hostname[0] === "[" ? 4 : 6;
            const ip = this.#state.pickFamily(this.#origin, otherFamily);
            if (ip == null) {
              super.onResponseError(controller, err);
              return;
            }
            let port;
            if (typeof ip.port === "number") {
              port = `:${ip.port}`;
            } else if (this.#origin.port !== "") {
              port = `:${this.#origin.port}`;
            } else {
              port = "";
            }
            const dispatchOpts = {
              ...this.#opts,
              origin: `${this.#origin.protocol}//${ip.family === 6 ? `[${ip.address}]` : ip.address}${port}`
            };
            this.#dispatch(dispatchOpts, this);
            return;
          }
          super.onResponseError(controller, err);
          break;
        }
        case "ENOTFOUND":
          this.#state.deleteRecords(this.#origin);
          super.onResponseError(controller, err);
          break;
        default:
          super.onResponseError(controller, err);
          break;
      }
    }
  }
  dns = (interceptorOpts) => {
    if (interceptorOpts?.maxTTL != null && (typeof interceptorOpts?.maxTTL !== "number" || interceptorOpts?.maxTTL < 0)) {
      throw new InvalidArgumentError("Invalid maxTTL. Must be a positive number");
    }
    if (interceptorOpts?.maxItems != null && (typeof interceptorOpts?.maxItems !== "number" || interceptorOpts?.maxItems < 1)) {
      throw new InvalidArgumentError(
        "Invalid maxItems. Must be a positive number and greater than zero"
      );
    }
    if (interceptorOpts?.affinity != null && interceptorOpts?.affinity !== 4 && interceptorOpts?.affinity !== 6) {
      throw new InvalidArgumentError("Invalid affinity. Must be either 4 or 6");
    }
    if (interceptorOpts?.dualStack != null && typeof interceptorOpts?.dualStack !== "boolean") {
      throw new InvalidArgumentError("Invalid dualStack. Must be a boolean");
    }
    if (interceptorOpts?.lookup != null && typeof interceptorOpts?.lookup !== "function") {
      throw new InvalidArgumentError("Invalid lookup. Must be a function");
    }
    if (interceptorOpts?.pick != null && typeof interceptorOpts?.pick !== "function") {
      throw new InvalidArgumentError("Invalid pick. Must be a function");
    }
    if (interceptorOpts?.storage != null && (typeof interceptorOpts?.storage?.get !== "function" || typeof interceptorOpts?.storage?.set !== "function" || typeof interceptorOpts?.storage?.full !== "function" || typeof interceptorOpts?.storage?.delete !== "function")) {
      throw new InvalidArgumentError("Invalid storage. Must be a object with methods: { get, set, full, delete }");
    }
    const dualStack = interceptorOpts?.dualStack ?? true;
    let affinity;
    if (dualStack) {
      affinity = interceptorOpts?.affinity ?? null;
    } else {
      affinity = interceptorOpts?.affinity ?? 4;
    }
    const opts = {
      maxTTL: interceptorOpts?.maxTTL ?? 1e4,
      // Expressed in ms
      lookup: interceptorOpts?.lookup ?? null,
      pick: interceptorOpts?.pick ?? null,
      dualStack,
      affinity,
      maxItems: interceptorOpts?.maxItems ?? Infinity,
      storage: interceptorOpts?.storage
    };
    const instance = new DNSInstance(opts);
    return (dispatch) => {
      return function dnsInterceptor(origDispatchOpts, handler) {
        const origin = origDispatchOpts.origin.constructor === URL ? origDispatchOpts.origin : new URL(origDispatchOpts.origin);
        if (isIP(origin.hostname) !== 0) {
          return dispatch(origDispatchOpts, handler);
        }
        instance.runLookup(origin, origDispatchOpts, (err, newOrigin) => {
          if (err) {
            return handler.onResponseError(null, err);
          }
          const dispatchOpts = {
            ...origDispatchOpts,
            servername: origin.hostname,
            // For SNI on TLS
            origin: newOrigin.origin,
            headers: {
              host: origin.host,
              ...origDispatchOpts.headers
            }
          };
          dispatch(
            dispatchOpts,
            instance.getHandler(
              { origin, dispatch, handler, newOrigin },
              origDispatchOpts
            )
          );
        });
        return true;
      };
    };
  };
  return dns;
}
var cache$2;
var hasRequiredCache$2;
function requireCache$2() {
  if (hasRequiredCache$2) return cache$2;
  hasRequiredCache$2 = 1;
  const {
    safeHTTPMethods,
    pathHasQueryOrFragment
  } = requireUtil$5();
  const { serializePathWithQuery } = requireUtil$5();
  function makeCacheKey(opts) {
    if (!opts.origin) {
      throw new Error("opts.origin is undefined");
    }
    let fullPath = opts.path || "/";
    if (opts.query && !pathHasQueryOrFragment(opts.path)) {
      fullPath = serializePathWithQuery(fullPath, opts.query);
    }
    return {
      origin: opts.origin.toString(),
      method: opts.method,
      path: fullPath,
      headers: opts.headers
    };
  }
  function normalizeHeaders(opts) {
    let headers2;
    if (opts.headers == null) {
      headers2 = {};
    } else if (typeof opts.headers[Symbol.iterator] === "function") {
      headers2 = {};
      for (const x4 of opts.headers) {
        if (!Array.isArray(x4)) {
          throw new Error("opts.headers is not a valid header map");
        }
        const [key, val] = x4;
        if (typeof key !== "string" || typeof val !== "string") {
          throw new Error("opts.headers is not a valid header map");
        }
        headers2[key.toLowerCase()] = val;
      }
    } else if (typeof opts.headers === "object") {
      headers2 = {};
      for (const key of Object.keys(opts.headers)) {
        headers2[key.toLowerCase()] = opts.headers[key];
      }
    } else {
      throw new Error("opts.headers is not an object");
    }
    return headers2;
  }
  function assertCacheKey(key) {
    if (typeof key !== "object") {
      throw new TypeError(`expected key to be object, got ${typeof key}`);
    }
    for (const property of ["origin", "method", "path"]) {
      if (typeof key[property] !== "string") {
        throw new TypeError(`expected key.${property} to be string, got ${typeof key[property]}`);
      }
    }
    if (key.headers !== void 0 && typeof key.headers !== "object") {
      throw new TypeError(`expected headers to be object, got ${typeof key}`);
    }
  }
  function assertCacheValue(value) {
    if (typeof value !== "object") {
      throw new TypeError(`expected value to be object, got ${typeof value}`);
    }
    for (const property of ["statusCode", "cachedAt", "staleAt", "deleteAt"]) {
      if (typeof value[property] !== "number") {
        throw new TypeError(`expected value.${property} to be number, got ${typeof value[property]}`);
      }
    }
    if (typeof value.statusMessage !== "string") {
      throw new TypeError(`expected value.statusMessage to be string, got ${typeof value.statusMessage}`);
    }
    if (value.headers != null && typeof value.headers !== "object") {
      throw new TypeError(`expected value.rawHeaders to be object, got ${typeof value.headers}`);
    }
    if (value.vary !== void 0 && typeof value.vary !== "object") {
      throw new TypeError(`expected value.vary to be object, got ${typeof value.vary}`);
    }
    if (value.etag !== void 0 && typeof value.etag !== "string") {
      throw new TypeError(`expected value.etag to be string, got ${typeof value.etag}`);
    }
  }
  function parseCacheControlHeader(header) {
    const output = {};
    let directives;
    if (Array.isArray(header)) {
      directives = [];
      for (const directive of header) {
        directives.push(...directive.split(","));
      }
    } else {
      directives = header.split(",");
    }
    for (let i4 = 0; i4 < directives.length; i4++) {
      const directive = directives[i4].toLowerCase();
      const keyValueDelimiter = directive.indexOf("=");
      let key;
      let value;
      if (keyValueDelimiter !== -1) {
        key = directive.substring(0, keyValueDelimiter).trimStart();
        value = directive.substring(keyValueDelimiter + 1);
      } else {
        key = directive.trim();
      }
      switch (key) {
        case "min-fresh":
        case "max-stale":
        case "max-age":
        case "s-maxage":
        case "stale-while-revalidate":
        case "stale-if-error": {
          if (value === void 0 || value[0] === " ") {
            continue;
          }
          if (value.length >= 2 && value[0] === '"' && value[value.length - 1] === '"') {
            value = value.substring(1, value.length - 1);
          }
          const parsedValue = parseInt(value, 10);
          if (parsedValue !== parsedValue) {
            continue;
          }
          if (key === "max-age" && key in output && output[key] >= parsedValue) {
            continue;
          }
          output[key] = parsedValue;
          break;
        }
        case "private":
        case "no-cache": {
          if (value) {
            if (value[0] === '"') {
              const headers2 = [value.substring(1)];
              let foundEndingQuote = value[value.length - 1] === '"';
              if (!foundEndingQuote) {
                for (let j4 = i4 + 1; j4 < directives.length; j4++) {
                  const nextPart = directives[j4];
                  const nextPartLength = nextPart.length;
                  headers2.push(nextPart.trim());
                  if (nextPartLength !== 0 && nextPart[nextPartLength - 1] === '"') {
                    foundEndingQuote = true;
                    break;
                  }
                }
              }
              if (foundEndingQuote) {
                let lastHeader = headers2[headers2.length - 1];
                if (lastHeader[lastHeader.length - 1] === '"') {
                  lastHeader = lastHeader.substring(0, lastHeader.length - 1);
                  headers2[headers2.length - 1] = lastHeader;
                }
                if (key in output) {
                  output[key] = output[key].concat(headers2);
                } else {
                  output[key] = headers2;
                }
              }
            } else {
              if (key in output) {
                output[key] = output[key].concat(value);
              } else {
                output[key] = [value];
              }
            }
            break;
          }
        }
        // eslint-disable-next-line no-fallthrough
        case "public":
        case "no-store":
        case "must-revalidate":
        case "proxy-revalidate":
        case "immutable":
        case "no-transform":
        case "must-understand":
        case "only-if-cached":
          if (value) {
            continue;
          }
          output[key] = true;
          break;
        default:
          continue;
      }
    }
    return output;
  }
  function parseVaryHeader(varyHeader, headers2) {
    if (typeof varyHeader === "string" && varyHeader.includes("*")) {
      return headers2;
    }
    const output = (
      /** @type {Record<string, string | string[] | null>} */
      {}
    );
    const varyingHeaders = typeof varyHeader === "string" ? varyHeader.split(",") : varyHeader;
    for (const header of varyingHeaders) {
      const trimmedHeader = header.trim().toLowerCase();
      output[trimmedHeader] = headers2[trimmedHeader] ?? null;
    }
    return output;
  }
  function isEtagUsable(etag) {
    if (etag.length <= 2) {
      return false;
    }
    if (etag[0] === '"' && etag[etag.length - 1] === '"') {
      return !(etag[1] === '"' || etag.startsWith('"W/'));
    }
    if (etag.startsWith('W/"') && etag[etag.length - 1] === '"') {
      return etag.length !== 4;
    }
    return false;
  }
  function assertCacheStore(store, name = "CacheStore") {
    if (typeof store !== "object" || store === null) {
      throw new TypeError(`expected type of ${name} to be a CacheStore, got ${store === null ? "null" : typeof store}`);
    }
    for (const fn of ["get", "createWriteStream", "delete"]) {
      if (typeof store[fn] !== "function") {
        throw new TypeError(`${name} needs to have a \`${fn}()\` function`);
      }
    }
  }
  function assertCacheMethods(methods, name = "CacheMethods") {
    if (!Array.isArray(methods)) {
      throw new TypeError(`expected type of ${name} needs to be an array, got ${methods === null ? "null" : typeof methods}`);
    }
    if (methods.length === 0) {
      throw new TypeError(`${name} needs to have at least one method`);
    }
    for (const method of methods) {
      if (!safeHTTPMethods.includes(method)) {
        throw new TypeError(`element of ${name}-array needs to be one of following values: ${safeHTTPMethods.join(", ")}, got ${method}`);
      }
    }
  }
  function makeDeduplicationKey(cacheKey, excludeHeaders) {
    let key = `${cacheKey.origin}:${cacheKey.method}:${cacheKey.path}`;
    if (cacheKey.headers) {
      const sortedHeaders = Object.keys(cacheKey.headers).sort();
      for (const header of sortedHeaders) {
        if (excludeHeaders?.has(header.toLowerCase())) {
          continue;
        }
        const value = cacheKey.headers[header];
        key += `:${header}=${Array.isArray(value) ? value.join(",") : value}`;
      }
    }
    return key;
  }
  cache$2 = {
    makeCacheKey,
    normalizeHeaders,
    assertCacheKey,
    assertCacheValue,
    parseCacheControlHeader,
    parseVaryHeader,
    isEtagUsable,
    assertCacheMethods,
    assertCacheStore,
    makeDeduplicationKey
  };
  return cache$2;
}
var date2;
var hasRequiredDate;
function requireDate() {
  if (hasRequiredDate) return date2;
  hasRequiredDate = 1;
  function parseHttpDate(date3) {
    switch (date3[3]) {
      case ",":
        return parseImfDate(date3);
      case " ":
        return parseAscTimeDate(date3);
      default:
        return parseRfc850Date(date3);
    }
  }
  function parseImfDate(date3) {
    if (date3.length !== 29 || date3[4] !== " " || date3[7] !== " " || date3[11] !== " " || date3[16] !== " " || date3[19] !== ":" || date3[22] !== ":" || date3[25] !== " " || date3[26] !== "G" || date3[27] !== "M" || date3[28] !== "T") {
      return void 0;
    }
    let weekday = -1;
    if (date3[0] === "S" && date3[1] === "u" && date3[2] === "n") {
      weekday = 0;
    } else if (date3[0] === "M" && date3[1] === "o" && date3[2] === "n") {
      weekday = 1;
    } else if (date3[0] === "T" && date3[1] === "u" && date3[2] === "e") {
      weekday = 2;
    } else if (date3[0] === "W" && date3[1] === "e" && date3[2] === "d") {
      weekday = 3;
    } else if (date3[0] === "T" && date3[1] === "h" && date3[2] === "u") {
      weekday = 4;
    } else if (date3[0] === "F" && date3[1] === "r" && date3[2] === "i") {
      weekday = 5;
    } else if (date3[0] === "S" && date3[1] === "a" && date3[2] === "t") {
      weekday = 6;
    } else {
      return void 0;
    }
    let day = 0;
    if (date3[5] === "0") {
      const code = date3.charCodeAt(6);
      if (code < 49 || code > 57) {
        return void 0;
      }
      day = code - 48;
    } else {
      const code1 = date3.charCodeAt(5);
      if (code1 < 49 || code1 > 51) {
        return void 0;
      }
      const code2 = date3.charCodeAt(6);
      if (code2 < 48 || code2 > 57) {
        return void 0;
      }
      day = (code1 - 48) * 10 + (code2 - 48);
    }
    let monthIdx = -1;
    if (date3[8] === "J" && date3[9] === "a" && date3[10] === "n") {
      monthIdx = 0;
    } else if (date3[8] === "F" && date3[9] === "e" && date3[10] === "b") {
      monthIdx = 1;
    } else if (date3[8] === "M" && date3[9] === "a") {
      if (date3[10] === "r") {
        monthIdx = 2;
      } else if (date3[10] === "y") {
        monthIdx = 4;
      } else {
        return void 0;
      }
    } else if (date3[8] === "J") {
      if (date3[9] === "a" && date3[10] === "n") {
        monthIdx = 0;
      } else if (date3[9] === "u") {
        if (date3[10] === "n") {
          monthIdx = 5;
        } else if (date3[10] === "l") {
          monthIdx = 6;
        } else {
          return void 0;
        }
      } else {
        return void 0;
      }
    } else if (date3[8] === "A") {
      if (date3[9] === "p" && date3[10] === "r") {
        monthIdx = 3;
      } else if (date3[9] === "u" && date3[10] === "g") {
        monthIdx = 7;
      } else {
        return void 0;
      }
    } else if (date3[8] === "S" && date3[9] === "e" && date3[10] === "p") {
      monthIdx = 8;
    } else if (date3[8] === "O" && date3[9] === "c" && date3[10] === "t") {
      monthIdx = 9;
    } else if (date3[8] === "N" && date3[9] === "o" && date3[10] === "v") {
      monthIdx = 10;
    } else if (date3[8] === "D" && date3[9] === "e" && date3[10] === "c") {
      monthIdx = 11;
    } else {
      return void 0;
    }
    const yearDigit1 = date3.charCodeAt(12);
    if (yearDigit1 < 48 || yearDigit1 > 57) {
      return void 0;
    }
    const yearDigit2 = date3.charCodeAt(13);
    if (yearDigit2 < 48 || yearDigit2 > 57) {
      return void 0;
    }
    const yearDigit3 = date3.charCodeAt(14);
    if (yearDigit3 < 48 || yearDigit3 > 57) {
      return void 0;
    }
    const yearDigit4 = date3.charCodeAt(15);
    if (yearDigit4 < 48 || yearDigit4 > 57) {
      return void 0;
    }
    const year2 = (yearDigit1 - 48) * 1e3 + (yearDigit2 - 48) * 100 + (yearDigit3 - 48) * 10 + (yearDigit4 - 48);
    let hour = 0;
    if (date3[17] === "0") {
      const code = date3.charCodeAt(18);
      if (code < 48 || code > 57) {
        return void 0;
      }
      hour = code - 48;
    } else {
      const code1 = date3.charCodeAt(17);
      if (code1 < 48 || code1 > 50) {
        return void 0;
      }
      const code2 = date3.charCodeAt(18);
      if (code2 < 48 || code2 > 57) {
        return void 0;
      }
      if (code1 === 50 && code2 > 51) {
        return void 0;
      }
      hour = (code1 - 48) * 10 + (code2 - 48);
    }
    let minute = 0;
    if (date3[20] === "0") {
      const code = date3.charCodeAt(21);
      if (code < 48 || code > 57) {
        return void 0;
      }
      minute = code - 48;
    } else {
      const code1 = date3.charCodeAt(20);
      if (code1 < 48 || code1 > 53) {
        return void 0;
      }
      const code2 = date3.charCodeAt(21);
      if (code2 < 48 || code2 > 57) {
        return void 0;
      }
      minute = (code1 - 48) * 10 + (code2 - 48);
    }
    let second = 0;
    if (date3[23] === "0") {
      const code = date3.charCodeAt(24);
      if (code < 48 || code > 57) {
        return void 0;
      }
      second = code - 48;
    } else {
      const code1 = date3.charCodeAt(23);
      if (code1 < 48 || code1 > 53) {
        return void 0;
      }
      const code2 = date3.charCodeAt(24);
      if (code2 < 48 || code2 > 57) {
        return void 0;
      }
      second = (code1 - 48) * 10 + (code2 - 48);
    }
    const result = new Date(Date.UTC(year2, monthIdx, day, hour, minute, second));
    return result.getUTCDay() === weekday ? result : void 0;
  }
  function parseAscTimeDate(date3) {
    if (date3.length !== 24 || date3[7] !== " " || date3[10] !== " " || date3[19] !== " ") {
      return void 0;
    }
    let weekday = -1;
    if (date3[0] === "S" && date3[1] === "u" && date3[2] === "n") {
      weekday = 0;
    } else if (date3[0] === "M" && date3[1] === "o" && date3[2] === "n") {
      weekday = 1;
    } else if (date3[0] === "T" && date3[1] === "u" && date3[2] === "e") {
      weekday = 2;
    } else if (date3[0] === "W" && date3[1] === "e" && date3[2] === "d") {
      weekday = 3;
    } else if (date3[0] === "T" && date3[1] === "h" && date3[2] === "u") {
      weekday = 4;
    } else if (date3[0] === "F" && date3[1] === "r" && date3[2] === "i") {
      weekday = 5;
    } else if (date3[0] === "S" && date3[1] === "a" && date3[2] === "t") {
      weekday = 6;
    } else {
      return void 0;
    }
    let monthIdx = -1;
    if (date3[4] === "J" && date3[5] === "a" && date3[6] === "n") {
      monthIdx = 0;
    } else if (date3[4] === "F" && date3[5] === "e" && date3[6] === "b") {
      monthIdx = 1;
    } else if (date3[4] === "M" && date3[5] === "a") {
      if (date3[6] === "r") {
        monthIdx = 2;
      } else if (date3[6] === "y") {
        monthIdx = 4;
      } else {
        return void 0;
      }
    } else if (date3[4] === "J") {
      if (date3[5] === "a" && date3[6] === "n") {
        monthIdx = 0;
      } else if (date3[5] === "u") {
        if (date3[6] === "n") {
          monthIdx = 5;
        } else if (date3[6] === "l") {
          monthIdx = 6;
        } else {
          return void 0;
        }
      } else {
        return void 0;
      }
    } else if (date3[4] === "A") {
      if (date3[5] === "p" && date3[6] === "r") {
        monthIdx = 3;
      } else if (date3[5] === "u" && date3[6] === "g") {
        monthIdx = 7;
      } else {
        return void 0;
      }
    } else if (date3[4] === "S" && date3[5] === "e" && date3[6] === "p") {
      monthIdx = 8;
    } else if (date3[4] === "O" && date3[5] === "c" && date3[6] === "t") {
      monthIdx = 9;
    } else if (date3[4] === "N" && date3[5] === "o" && date3[6] === "v") {
      monthIdx = 10;
    } else if (date3[4] === "D" && date3[5] === "e" && date3[6] === "c") {
      monthIdx = 11;
    } else {
      return void 0;
    }
    let day = 0;
    if (date3[8] === " ") {
      const code = date3.charCodeAt(9);
      if (code < 49 || code > 57) {
        return void 0;
      }
      day = code - 48;
    } else {
      const code1 = date3.charCodeAt(8);
      if (code1 < 49 || code1 > 51) {
        return void 0;
      }
      const code2 = date3.charCodeAt(9);
      if (code2 < 48 || code2 > 57) {
        return void 0;
      }
      day = (code1 - 48) * 10 + (code2 - 48);
    }
    let hour = 0;
    if (date3[11] === "0") {
      const code = date3.charCodeAt(12);
      if (code < 48 || code > 57) {
        return void 0;
      }
      hour = code - 48;
    } else {
      const code1 = date3.charCodeAt(11);
      if (code1 < 48 || code1 > 50) {
        return void 0;
      }
      const code2 = date3.charCodeAt(12);
      if (code2 < 48 || code2 > 57) {
        return void 0;
      }
      if (code1 === 50 && code2 > 51) {
        return void 0;
      }
      hour = (code1 - 48) * 10 + (code2 - 48);
    }
    let minute = 0;
    if (date3[14] === "0") {
      const code = date3.charCodeAt(15);
      if (code < 48 || code > 57) {
        return void 0;
      }
      minute = code - 48;
    } else {
      const code1 = date3.charCodeAt(14);
      if (code1 < 48 || code1 > 53) {
        return void 0;
      }
      const code2 = date3.charCodeAt(15);
      if (code2 < 48 || code2 > 57) {
        return void 0;
      }
      minute = (code1 - 48) * 10 + (code2 - 48);
    }
    let second = 0;
    if (date3[17] === "0") {
      const code = date3.charCodeAt(18);
      if (code < 48 || code > 57) {
        return void 0;
      }
      second = code - 48;
    } else {
      const code1 = date3.charCodeAt(17);
      if (code1 < 48 || code1 > 53) {
        return void 0;
      }
      const code2 = date3.charCodeAt(18);
      if (code2 < 48 || code2 > 57) {
        return void 0;
      }
      second = (code1 - 48) * 10 + (code2 - 48);
    }
    const yearDigit1 = date3.charCodeAt(20);
    if (yearDigit1 < 48 || yearDigit1 > 57) {
      return void 0;
    }
    const yearDigit2 = date3.charCodeAt(21);
    if (yearDigit2 < 48 || yearDigit2 > 57) {
      return void 0;
    }
    const yearDigit3 = date3.charCodeAt(22);
    if (yearDigit3 < 48 || yearDigit3 > 57) {
      return void 0;
    }
    const yearDigit4 = date3.charCodeAt(23);
    if (yearDigit4 < 48 || yearDigit4 > 57) {
      return void 0;
    }
    const year2 = (yearDigit1 - 48) * 1e3 + (yearDigit2 - 48) * 100 + (yearDigit3 - 48) * 10 + (yearDigit4 - 48);
    const result = new Date(Date.UTC(year2, monthIdx, day, hour, minute, second));
    return result.getUTCDay() === weekday ? result : void 0;
  }
  function parseRfc850Date(date3) {
    let commaIndex = -1;
    let weekday = -1;
    if (date3[0] === "S") {
      if (date3[1] === "u" && date3[2] === "n" && date3[3] === "d" && date3[4] === "a" && date3[5] === "y") {
        weekday = 0;
        commaIndex = 6;
      } else if (date3[1] === "a" && date3[2] === "t" && date3[3] === "u" && date3[4] === "r" && date3[5] === "d" && date3[6] === "a" && date3[7] === "y") {
        weekday = 6;
        commaIndex = 8;
      }
    } else if (date3[0] === "M" && date3[1] === "o" && date3[2] === "n" && date3[3] === "d" && date3[4] === "a" && date3[5] === "y") {
      weekday = 1;
      commaIndex = 6;
    } else if (date3[0] === "T") {
      if (date3[1] === "u" && date3[2] === "e" && date3[3] === "s" && date3[4] === "d" && date3[5] === "a" && date3[6] === "y") {
        weekday = 2;
        commaIndex = 7;
      } else if (date3[1] === "h" && date3[2] === "u" && date3[3] === "r" && date3[4] === "s" && date3[5] === "d" && date3[6] === "a" && date3[7] === "y") {
        weekday = 4;
        commaIndex = 8;
      }
    } else if (date3[0] === "W" && date3[1] === "e" && date3[2] === "d" && date3[3] === "n" && date3[4] === "e" && date3[5] === "s" && date3[6] === "d" && date3[7] === "a" && date3[8] === "y") {
      weekday = 3;
      commaIndex = 9;
    } else if (date3[0] === "F" && date3[1] === "r" && date3[2] === "i" && date3[3] === "d" && date3[4] === "a" && date3[5] === "y") {
      weekday = 5;
      commaIndex = 6;
    } else {
      return void 0;
    }
    if (date3[commaIndex] !== "," || date3.length - commaIndex - 1 !== 23 || date3[commaIndex + 1] !== " " || date3[commaIndex + 4] !== "-" || date3[commaIndex + 8] !== "-" || date3[commaIndex + 11] !== " " || date3[commaIndex + 14] !== ":" || date3[commaIndex + 17] !== ":" || date3[commaIndex + 20] !== " " || date3[commaIndex + 21] !== "G" || date3[commaIndex + 22] !== "M" || date3[commaIndex + 23] !== "T") {
      return void 0;
    }
    let day = 0;
    if (date3[commaIndex + 2] === "0") {
      const code = date3.charCodeAt(commaIndex + 3);
      if (code < 49 || code > 57) {
        return void 0;
      }
      day = code - 48;
    } else {
      const code1 = date3.charCodeAt(commaIndex + 2);
      if (code1 < 49 || code1 > 51) {
        return void 0;
      }
      const code2 = date3.charCodeAt(commaIndex + 3);
      if (code2 < 48 || code2 > 57) {
        return void 0;
      }
      day = (code1 - 48) * 10 + (code2 - 48);
    }
    let monthIdx = -1;
    if (date3[commaIndex + 5] === "J" && date3[commaIndex + 6] === "a" && date3[commaIndex + 7] === "n") {
      monthIdx = 0;
    } else if (date3[commaIndex + 5] === "F" && date3[commaIndex + 6] === "e" && date3[commaIndex + 7] === "b") {
      monthIdx = 1;
    } else if (date3[commaIndex + 5] === "M" && date3[commaIndex + 6] === "a" && date3[commaIndex + 7] === "r") {
      monthIdx = 2;
    } else if (date3[commaIndex + 5] === "A" && date3[commaIndex + 6] === "p" && date3[commaIndex + 7] === "r") {
      monthIdx = 3;
    } else if (date3[commaIndex + 5] === "M" && date3[commaIndex + 6] === "a" && date3[commaIndex + 7] === "y") {
      monthIdx = 4;
    } else if (date3[commaIndex + 5] === "J" && date3[commaIndex + 6] === "u" && date3[commaIndex + 7] === "n") {
      monthIdx = 5;
    } else if (date3[commaIndex + 5] === "J" && date3[commaIndex + 6] === "u" && date3[commaIndex + 7] === "l") {
      monthIdx = 6;
    } else if (date3[commaIndex + 5] === "A" && date3[commaIndex + 6] === "u" && date3[commaIndex + 7] === "g") {
      monthIdx = 7;
    } else if (date3[commaIndex + 5] === "S" && date3[commaIndex + 6] === "e" && date3[commaIndex + 7] === "p") {
      monthIdx = 8;
    } else if (date3[commaIndex + 5] === "O" && date3[commaIndex + 6] === "c" && date3[commaIndex + 7] === "t") {
      monthIdx = 9;
    } else if (date3[commaIndex + 5] === "N" && date3[commaIndex + 6] === "o" && date3[commaIndex + 7] === "v") {
      monthIdx = 10;
    } else if (date3[commaIndex + 5] === "D" && date3[commaIndex + 6] === "e" && date3[commaIndex + 7] === "c") {
      monthIdx = 11;
    } else {
      return void 0;
    }
    const yearDigit1 = date3.charCodeAt(commaIndex + 9);
    if (yearDigit1 < 48 || yearDigit1 > 57) {
      return void 0;
    }
    const yearDigit2 = date3.charCodeAt(commaIndex + 10);
    if (yearDigit2 < 48 || yearDigit2 > 57) {
      return void 0;
    }
    let year2 = (yearDigit1 - 48) * 10 + (yearDigit2 - 48);
    year2 += year2 < 70 ? 2e3 : 1900;
    let hour = 0;
    if (date3[commaIndex + 12] === "0") {
      const code = date3.charCodeAt(commaIndex + 13);
      if (code < 48 || code > 57) {
        return void 0;
      }
      hour = code - 48;
    } else {
      const code1 = date3.charCodeAt(commaIndex + 12);
      if (code1 < 48 || code1 > 50) {
        return void 0;
      }
      const code2 = date3.charCodeAt(commaIndex + 13);
      if (code2 < 48 || code2 > 57) {
        return void 0;
      }
      if (code1 === 50 && code2 > 51) {
        return void 0;
      }
      hour = (code1 - 48) * 10 + (code2 - 48);
    }
    let minute = 0;
    if (date3[commaIndex + 15] === "0") {
      const code = date3.charCodeAt(commaIndex + 16);
      if (code < 48 || code > 57) {
        return void 0;
      }
      minute = code - 48;
    } else {
      const code1 = date3.charCodeAt(commaIndex + 15);
      if (code1 < 48 || code1 > 53) {
        return void 0;
      }
      const code2 = date3.charCodeAt(commaIndex + 16);
      if (code2 < 48 || code2 > 57) {
        return void 0;
      }
      minute = (code1 - 48) * 10 + (code2 - 48);
    }
    let second = 0;
    if (date3[commaIndex + 18] === "0") {
      const code = date3.charCodeAt(commaIndex + 19);
      if (code < 48 || code > 57) {
        return void 0;
      }
      second = code - 48;
    } else {
      const code1 = date3.charCodeAt(commaIndex + 18);
      if (code1 < 48 || code1 > 53) {
        return void 0;
      }
      const code2 = date3.charCodeAt(commaIndex + 19);
      if (code2 < 48 || code2 > 57) {
        return void 0;
      }
      second = (code1 - 48) * 10 + (code2 - 48);
    }
    const result = new Date(Date.UTC(year2, monthIdx, day, hour, minute, second));
    return result.getUTCDay() === weekday ? result : void 0;
  }
  date2 = {
    parseHttpDate
  };
  return date2;
}
var cacheHandler;
var hasRequiredCacheHandler;
function requireCacheHandler() {
  if (hasRequiredCacheHandler) return cacheHandler;
  hasRequiredCacheHandler = 1;
  const util2 = requireUtil$5();
  const {
    parseCacheControlHeader,
    parseVaryHeader,
    isEtagUsable
  } = requireCache$2();
  const { parseHttpDate } = requireDate();
  function noop2() {
  }
  const HEURISTICALLY_CACHEABLE_STATUS_CODES = [
    200,
    203,
    204,
    206,
    300,
    301,
    308,
    404,
    405,
    410,
    414,
    501
  ];
  const NOT_UNDERSTOOD_STATUS_CODES = [
    206
  ];
  const MAX_RESPONSE_AGE = 2147483647e3;
  class CacheHandler {
    /**
     * @type {import('../../types/cache-interceptor.d.ts').default.CacheKey}
     */
    #cacheKey;
    /**
     * @type {import('../../types/cache-interceptor.d.ts').default.CacheHandlerOptions['type']}
     */
    #cacheType;
    /**
     * @type {number | undefined}
     */
    #cacheByDefault;
    /**
     * @type {import('../../types/cache-interceptor.d.ts').default.CacheStore}
     */
    #store;
    /**
     * @type {import('../../types/dispatcher.d.ts').default.DispatchHandler}
     */
    #handler;
    /**
     * @type {import('node:stream').Writable | undefined}
     */
    #writeStream;
    /**
     * @param {import('../../types/cache-interceptor.d.ts').default.CacheHandlerOptions} opts
     * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} cacheKey
     * @param {import('../../types/dispatcher.d.ts').default.DispatchHandler} handler
     */
    constructor({ store, type, cacheByDefault }, cacheKey, handler) {
      this.#store = store;
      this.#cacheType = type;
      this.#cacheByDefault = cacheByDefault;
      this.#cacheKey = cacheKey;
      this.#handler = handler;
    }
    onRequestStart(controller, context) {
      this.#writeStream?.destroy();
      this.#writeStream = void 0;
      this.#handler.onRequestStart?.(controller, context);
    }
    onRequestUpgrade(controller, statusCode, headers2, socket) {
      this.#handler.onRequestUpgrade?.(controller, statusCode, headers2, socket);
    }
    /**
     * @param {import('../../types/dispatcher.d.ts').default.DispatchController} controller
     * @param {number} statusCode
     * @param {import('../../types/header.d.ts').IncomingHttpHeaders} resHeaders
     * @param {string} statusMessage
     */
    onResponseStart(controller, statusCode, resHeaders, statusMessage) {
      const downstreamOnHeaders = () => this.#handler.onResponseStart?.(
        controller,
        statusCode,
        resHeaders,
        statusMessage
      );
      const handler = this;
      if (!util2.safeHTTPMethods.includes(this.#cacheKey.method) && statusCode >= 200 && statusCode <= 399) {
        try {
          this.#store.delete(this.#cacheKey)?.catch?.(noop2);
        } catch {
        }
        return downstreamOnHeaders();
      }
      const cacheControlHeader = resHeaders["cache-control"];
      const heuristicallyCacheable = resHeaders["last-modified"] && HEURISTICALLY_CACHEABLE_STATUS_CODES.includes(statusCode);
      if (!cacheControlHeader && !resHeaders["expires"] && !heuristicallyCacheable && !this.#cacheByDefault) {
        return downstreamOnHeaders();
      }
      const cacheControlDirectives = cacheControlHeader ? parseCacheControlHeader(cacheControlHeader) : {};
      if (!canCacheResponse(this.#cacheType, statusCode, resHeaders, cacheControlDirectives)) {
        return downstreamOnHeaders();
      }
      const now = Date.now();
      const resAge = resHeaders.age ? getAge(resHeaders.age) : void 0;
      if (resAge && resAge >= MAX_RESPONSE_AGE) {
        return downstreamOnHeaders();
      }
      const resDate = typeof resHeaders.date === "string" ? parseHttpDate(resHeaders.date) : void 0;
      const staleAt = determineStaleAt(this.#cacheType, now, resAge, resHeaders, resDate, cacheControlDirectives) ?? this.#cacheByDefault;
      if (staleAt === void 0 || resAge && resAge > staleAt) {
        return downstreamOnHeaders();
      }
      const baseTime = resDate ? resDate.getTime() : now;
      const absoluteStaleAt = staleAt + baseTime;
      if (now >= absoluteStaleAt) {
        return downstreamOnHeaders();
      }
      let varyDirectives;
      if (this.#cacheKey.headers && resHeaders.vary) {
        varyDirectives = parseVaryHeader(resHeaders.vary, this.#cacheKey.headers);
        if (!varyDirectives) {
          return downstreamOnHeaders();
        }
      }
      const deleteAt = determineDeleteAt(baseTime, cacheControlDirectives, absoluteStaleAt);
      const strippedHeaders = stripNecessaryHeaders(resHeaders, cacheControlDirectives);
      const value = {
        statusCode,
        statusMessage,
        headers: strippedHeaders,
        vary: varyDirectives,
        cacheControlDirectives,
        cachedAt: resAge ? now - resAge : now,
        staleAt: absoluteStaleAt,
        deleteAt
      };
      if (statusCode === 304) {
        const cachedValue = this.#store.get(this.#cacheKey);
        if (!cachedValue) {
          return downstreamOnHeaders();
        }
        value.statusCode = cachedValue.statusCode;
        value.statusMessage = cachedValue.statusMessage;
        value.etag = cachedValue.etag;
        value.headers = { ...cachedValue.headers, ...strippedHeaders };
        downstreamOnHeaders();
        this.#writeStream = this.#store.createWriteStream(this.#cacheKey, value);
        if (!this.#writeStream || !cachedValue?.body) {
          return;
        }
        const bodyIterator = cachedValue.body.values();
        const streamCachedBody = () => {
          for (const chunk2 of bodyIterator) {
            const full = this.#writeStream.write(chunk2) === false;
            this.#handler.onResponseData?.(controller, chunk2);
            if (full) {
              break;
            }
          }
        };
        this.#writeStream.on("error", function() {
          handler.#writeStream = void 0;
          handler.#store.delete(handler.#cacheKey);
        }).on("drain", () => {
          streamCachedBody();
        }).on("close", function() {
          if (handler.#writeStream === this) {
            handler.#writeStream = void 0;
          }
        });
        streamCachedBody();
      } else {
        if (typeof resHeaders.etag === "string" && isEtagUsable(resHeaders.etag)) {
          value.etag = resHeaders.etag;
        }
        this.#writeStream = this.#store.createWriteStream(this.#cacheKey, value);
        if (!this.#writeStream) {
          return downstreamOnHeaders();
        }
        this.#writeStream.on("drain", () => controller.resume()).on("error", function() {
          handler.#writeStream = void 0;
          handler.#store.delete(handler.#cacheKey);
        }).on("close", function() {
          if (handler.#writeStream === this) {
            handler.#writeStream = void 0;
          }
          controller.resume();
        });
        downstreamOnHeaders();
      }
    }
    onResponseData(controller, chunk2) {
      if (this.#writeStream?.write(chunk2) === false) {
        controller.pause();
      }
      this.#handler.onResponseData?.(controller, chunk2);
    }
    onResponseEnd(controller, trailers) {
      this.#writeStream?.end();
      this.#handler.onResponseEnd?.(controller, trailers);
    }
    onResponseError(controller, err) {
      this.#writeStream?.destroy(err);
      this.#writeStream = void 0;
      this.#handler.onResponseError?.(controller, err);
    }
  }
  function canCacheResponse(cacheType, statusCode, resHeaders, cacheControlDirectives) {
    if (statusCode < 200 || NOT_UNDERSTOOD_STATUS_CODES.includes(statusCode)) {
      return false;
    }
    if (!HEURISTICALLY_CACHEABLE_STATUS_CODES.includes(statusCode) && !resHeaders["expires"] && !cacheControlDirectives.public && cacheControlDirectives["max-age"] === void 0 && // RFC 9111: a private response directive, if the cache is not shared
    !(cacheControlDirectives.private && cacheType === "private") && !(cacheControlDirectives["s-maxage"] !== void 0 && cacheType === "shared")) {
      return false;
    }
    if (cacheControlDirectives["no-store"]) {
      return false;
    }
    if (cacheType === "shared" && cacheControlDirectives.private === true) {
      return false;
    }
    if (resHeaders.vary?.includes("*")) {
      return false;
    }
    if (resHeaders.authorization) {
      if (!cacheControlDirectives.public || typeof resHeaders.authorization !== "string") {
        return false;
      }
      if (Array.isArray(cacheControlDirectives["no-cache"]) && cacheControlDirectives["no-cache"].includes("authorization")) {
        return false;
      }
      if (Array.isArray(cacheControlDirectives["private"]) && cacheControlDirectives["private"].includes("authorization")) {
        return false;
      }
    }
    return true;
  }
  function getAge(ageHeader) {
    const age = parseInt(Array.isArray(ageHeader) ? ageHeader[0] : ageHeader);
    return isNaN(age) ? void 0 : age * 1e3;
  }
  function determineStaleAt(cacheType, now, age, resHeaders, responseDate, cacheControlDirectives) {
    if (cacheType === "shared") {
      const sMaxAge = cacheControlDirectives["s-maxage"];
      if (sMaxAge !== void 0) {
        return sMaxAge > 0 ? sMaxAge * 1e3 : void 0;
      }
    }
    const maxAge = cacheControlDirectives["max-age"];
    if (maxAge !== void 0) {
      return maxAge > 0 ? maxAge * 1e3 : void 0;
    }
    if (typeof resHeaders.expires === "string") {
      const expiresDate = parseHttpDate(resHeaders.expires);
      if (expiresDate) {
        if (now >= expiresDate.getTime()) {
          return void 0;
        }
        if (responseDate) {
          if (responseDate >= expiresDate) {
            return void 0;
          }
          if (age !== void 0 && age > expiresDate - responseDate) {
            return void 0;
          }
        }
        return expiresDate.getTime() - now;
      }
    }
    if (typeof resHeaders["last-modified"] === "string") {
      const lastModified = new Date(resHeaders["last-modified"]);
      if (isValidDate(lastModified)) {
        if (lastModified.getTime() >= now) {
          return void 0;
        }
        const responseAge = now - lastModified.getTime();
        return responseAge * 0.1;
      }
    }
    if (cacheControlDirectives.immutable) {
      return 31536e3;
    }
    return void 0;
  }
  function determineDeleteAt(now, cacheControlDirectives, staleAt) {
    let staleWhileRevalidate = -Infinity;
    let staleIfError = -Infinity;
    let immutable = -Infinity;
    if (cacheControlDirectives["stale-while-revalidate"]) {
      staleWhileRevalidate = staleAt + cacheControlDirectives["stale-while-revalidate"] * 1e3;
    }
    if (cacheControlDirectives["stale-if-error"]) {
      staleIfError = staleAt + cacheControlDirectives["stale-if-error"] * 1e3;
    }
    if (staleWhileRevalidate === -Infinity && staleIfError === -Infinity) {
      immutable = now + 31536e6;
    }
    return Math.max(staleAt, staleWhileRevalidate, staleIfError, immutable);
  }
  function stripNecessaryHeaders(resHeaders, cacheControlDirectives) {
    const headersToRemove = [
      "connection",
      "proxy-authenticate",
      "proxy-authentication-info",
      "proxy-authorization",
      "proxy-connection",
      "te",
      "transfer-encoding",
      "upgrade",
      // We'll add age back when serving it
      "age"
    ];
    if (resHeaders["connection"]) {
      if (Array.isArray(resHeaders["connection"])) {
        headersToRemove.push(...resHeaders["connection"].map((header) => header.trim()));
      } else {
        headersToRemove.push(...resHeaders["connection"].split(",").map((header) => header.trim()));
      }
    }
    if (Array.isArray(cacheControlDirectives["no-cache"])) {
      headersToRemove.push(...cacheControlDirectives["no-cache"]);
    }
    if (Array.isArray(cacheControlDirectives["private"])) {
      headersToRemove.push(...cacheControlDirectives["private"]);
    }
    let strippedHeaders;
    for (const headerName of headersToRemove) {
      if (resHeaders[headerName]) {
        strippedHeaders ??= { ...resHeaders };
        delete strippedHeaders[headerName];
      }
    }
    return strippedHeaders ?? resHeaders;
  }
  function isValidDate(date3) {
    return date3 instanceof Date && Number.isFinite(date3.valueOf());
  }
  cacheHandler = CacheHandler;
  return cacheHandler;
}
var memoryCacheStore;
var hasRequiredMemoryCacheStore;
function requireMemoryCacheStore() {
  if (hasRequiredMemoryCacheStore) return memoryCacheStore;
  hasRequiredMemoryCacheStore = 1;
  const { Writable: Writable2 } = import_node_stream.default;
  const { EventEmitter: EventEmitter2 } = import_node_events.default;
  const { assertCacheKey, assertCacheValue } = requireCache$2();
  class MemoryCacheStore extends EventEmitter2 {
    #maxCount = 1024;
    #maxSize = 104857600;
    // 100MB
    #maxEntrySize = 5242880;
    // 5MB
    #size = 0;
    #count = 0;
    #entries = /* @__PURE__ */ new Map();
    #hasEmittedMaxSizeEvent = false;
    /**
     * @param {import('../../types/cache-interceptor.d.ts').default.MemoryCacheStoreOpts | undefined} [opts]
     */
    constructor(opts) {
      super();
      if (opts) {
        if (typeof opts !== "object") {
          throw new TypeError("MemoryCacheStore options must be an object");
        }
        if (opts.maxCount !== void 0) {
          if (typeof opts.maxCount !== "number" || !Number.isInteger(opts.maxCount) || opts.maxCount < 0) {
            throw new TypeError("MemoryCacheStore options.maxCount must be a non-negative integer");
          }
          this.#maxCount = opts.maxCount;
        }
        if (opts.maxSize !== void 0) {
          if (typeof opts.maxSize !== "number" || !Number.isInteger(opts.maxSize) || opts.maxSize < 0) {
            throw new TypeError("MemoryCacheStore options.maxSize must be a non-negative integer");
          }
          this.#maxSize = opts.maxSize;
        }
        if (opts.maxEntrySize !== void 0) {
          if (typeof opts.maxEntrySize !== "number" || !Number.isInteger(opts.maxEntrySize) || opts.maxEntrySize < 0) {
            throw new TypeError("MemoryCacheStore options.maxEntrySize must be a non-negative integer");
          }
          this.#maxEntrySize = opts.maxEntrySize;
        }
      }
    }
    /**
     * Get the current size of the cache in bytes
     * @returns {number} The current size of the cache in bytes
     */
    get size() {
      return this.#size;
    }
    /**
     * Check if the cache is full (either max size or max count reached)
     * @returns {boolean} True if the cache is full, false otherwise
     */
    isFull() {
      return this.#size >= this.#maxSize || this.#count >= this.#maxCount;
    }
    /**
     * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} req
     * @returns {import('../../types/cache-interceptor.d.ts').default.GetResult | undefined}
     */
    get(key) {
      assertCacheKey(key);
      const topLevelKey = `${key.origin}:${key.path}`;
      const now = Date.now();
      const entries = this.#entries.get(topLevelKey);
      const entry = entries ? findEntry(key, entries, now) : null;
      return entry == null ? void 0 : {
        statusMessage: entry.statusMessage,
        statusCode: entry.statusCode,
        headers: entry.headers,
        body: entry.body,
        vary: entry.vary ? entry.vary : void 0,
        etag: entry.etag,
        cacheControlDirectives: entry.cacheControlDirectives,
        cachedAt: entry.cachedAt,
        staleAt: entry.staleAt,
        deleteAt: entry.deleteAt
      };
    }
    /**
     * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key
     * @param {import('../../types/cache-interceptor.d.ts').default.CacheValue} val
     * @returns {Writable | undefined}
     */
    createWriteStream(key, val) {
      assertCacheKey(key);
      assertCacheValue(val);
      const topLevelKey = `${key.origin}:${key.path}`;
      const store = this;
      const entry = { ...key, ...val, body: [], size: 0 };
      return new Writable2({
        write(chunk2, encoding2, callback) {
          if (typeof chunk2 === "string") {
            chunk2 = Buffer.from(chunk2, encoding2);
          }
          entry.size += chunk2.byteLength;
          if (entry.size >= store.#maxEntrySize) {
            this.destroy();
          } else {
            entry.body.push(chunk2);
          }
          callback(null);
        },
        final(callback) {
          let entries = store.#entries.get(topLevelKey);
          if (!entries) {
            entries = [];
            store.#entries.set(topLevelKey, entries);
          }
          const previousEntry = findEntry(key, entries, Date.now());
          if (previousEntry) {
            const index = entries.indexOf(previousEntry);
            entries.splice(index, 1, entry);
            store.#size -= previousEntry.size;
          } else {
            entries.push(entry);
            store.#count += 1;
          }
          store.#size += entry.size;
          if (store.#size > store.#maxSize || store.#count > store.#maxCount) {
            if (!store.#hasEmittedMaxSizeEvent) {
              store.emit("maxSizeExceeded", {
                size: store.#size,
                maxSize: store.#maxSize,
                count: store.#count,
                maxCount: store.#maxCount
              });
              store.#hasEmittedMaxSizeEvent = true;
            }
            for (const [key2, entries2] of store.#entries) {
              for (const entry2 of entries2.splice(0, entries2.length / 2)) {
                store.#size -= entry2.size;
                store.#count -= 1;
              }
              if (entries2.length === 0) {
                store.#entries.delete(key2);
              }
            }
            if (store.#size < store.#maxSize && store.#count < store.#maxCount) {
              store.#hasEmittedMaxSizeEvent = false;
            }
          }
          callback(null);
        }
      });
    }
    /**
     * @param {CacheKey} key
     */
    delete(key) {
      if (typeof key !== "object") {
        throw new TypeError(`expected key to be object, got ${typeof key}`);
      }
      const topLevelKey = `${key.origin}:${key.path}`;
      for (const entry of this.#entries.get(topLevelKey) ?? []) {
        this.#size -= entry.size;
        this.#count -= 1;
      }
      this.#entries.delete(topLevelKey);
    }
  }
  function findEntry(key, entries, now) {
    return entries.find((entry) => entry.deleteAt > now && entry.method === key.method && (entry.vary == null || Object.keys(entry.vary).every((headerName) => {
      if (entry.vary[headerName] === null) {
        return key.headers[headerName] === void 0;
      }
      return entry.vary[headerName] === key.headers[headerName];
    })));
  }
  memoryCacheStore = MemoryCacheStore;
  return memoryCacheStore;
}
var cacheRevalidationHandler;
var hasRequiredCacheRevalidationHandler;
function requireCacheRevalidationHandler() {
  if (hasRequiredCacheRevalidationHandler) return cacheRevalidationHandler;
  hasRequiredCacheRevalidationHandler = 1;
  const assert = import_node_assert.default;
  class CacheRevalidationHandler {
    #successful = false;
    /**
     * @type {((boolean, any) => void) | null}
     */
    #callback;
    /**
     * @type {(import('../../types/dispatcher.d.ts').default.DispatchHandler)}
     */
    #handler;
    #context;
    /**
     * @type {boolean}
     */
    #allowErrorStatusCodes;
    /**
     * @param {(boolean) => void} callback Function to call if the cached value is valid
     * @param {import('../../types/dispatcher.d.ts').default.DispatchHandlers} handler
     * @param {boolean} allowErrorStatusCodes
     */
    constructor(callback, handler, allowErrorStatusCodes) {
      if (typeof callback !== "function") {
        throw new TypeError("callback must be a function");
      }
      this.#callback = callback;
      this.#handler = handler;
      this.#allowErrorStatusCodes = allowErrorStatusCodes;
    }
    onRequestStart(_, context) {
      this.#successful = false;
      this.#context = context;
    }
    onRequestUpgrade(controller, statusCode, headers2, socket) {
      this.#handler.onRequestUpgrade?.(controller, statusCode, headers2, socket);
    }
    onResponseStart(controller, statusCode, headers2, statusMessage) {
      assert(this.#callback != null);
      this.#successful = statusCode === 304 || this.#allowErrorStatusCodes && statusCode >= 500 && statusCode <= 504;
      this.#callback(this.#successful, this.#context);
      this.#callback = null;
      if (this.#successful) {
        return true;
      }
      this.#handler.onRequestStart?.(controller, this.#context);
      this.#handler.onResponseStart?.(
        controller,
        statusCode,
        headers2,
        statusMessage
      );
    }
    onResponseData(controller, chunk2) {
      if (this.#successful) {
        return;
      }
      return this.#handler.onResponseData?.(controller, chunk2);
    }
    onResponseEnd(controller, trailers) {
      if (this.#successful) {
        return;
      }
      this.#handler.onResponseEnd?.(controller, trailers);
    }
    onResponseError(controller, err) {
      if (this.#successful) {
        return;
      }
      if (this.#callback) {
        this.#callback(false);
        this.#callback = null;
      }
      if (typeof this.#handler.onResponseError === "function") {
        this.#handler.onResponseError(controller, err);
      } else {
        throw err;
      }
    }
  }
  cacheRevalidationHandler = CacheRevalidationHandler;
  return cacheRevalidationHandler;
}
var cache$1;
var hasRequiredCache$1;
function requireCache$1() {
  if (hasRequiredCache$1) return cache$1;
  hasRequiredCache$1 = 1;
  const assert = import_node_assert.default;
  const { Readable: Readable2 } = import_node_stream.default;
  const util2 = requireUtil$5();
  const CacheHandler = requireCacheHandler();
  const MemoryCacheStore = requireMemoryCacheStore();
  const CacheRevalidationHandler = requireCacheRevalidationHandler();
  const { assertCacheStore, assertCacheMethods, makeCacheKey, normalizeHeaders, parseCacheControlHeader } = requireCache$2();
  const { AbortError } = requireErrors();
  const nop = () => {
  };
  function needsRevalidation(result, cacheControlDirectives, { headers: headers2 = {} }) {
    if (cacheControlDirectives?.["no-cache"]) {
      return true;
    }
    if (result.cacheControlDirectives?.["no-cache"] && !Array.isArray(result.cacheControlDirectives["no-cache"])) {
      return true;
    }
    if (headers2["if-modified-since"] || headers2["if-none-match"]) {
      return true;
    }
    return false;
  }
  function isStale(result, cacheControlDirectives) {
    const now = Date.now();
    if (now > result.staleAt) {
      if (cacheControlDirectives?.["max-stale"]) {
        const gracePeriod = result.staleAt + cacheControlDirectives["max-stale"] * 1e3;
        return now > gracePeriod;
      }
      return true;
    }
    if (cacheControlDirectives?.["min-fresh"]) {
      const timeLeftTillStale = result.staleAt - now;
      const threshold = cacheControlDirectives["min-fresh"] * 1e3;
      return timeLeftTillStale <= threshold;
    }
    return false;
  }
  function withinStaleWhileRevalidateWindow(result) {
    const staleWhileRevalidate = result.cacheControlDirectives?.["stale-while-revalidate"];
    if (!staleWhileRevalidate) {
      return false;
    }
    const now = Date.now();
    const staleWhileRevalidateExpiry = result.staleAt + staleWhileRevalidate * 1e3;
    return now <= staleWhileRevalidateExpiry;
  }
  function handleUncachedResponse(dispatch, globalOpts, cacheKey, handler, opts, reqCacheControl) {
    if (reqCacheControl?.["only-if-cached"]) {
      let aborted = false;
      try {
        if (typeof handler.onConnect === "function") {
          handler.onConnect(() => {
            aborted = true;
          });
          if (aborted) {
            return;
          }
        }
        if (typeof handler.onHeaders === "function") {
          handler.onHeaders(504, [], nop, "Gateway Timeout");
          if (aborted) {
            return;
          }
        }
        if (typeof handler.onComplete === "function") {
          handler.onComplete([]);
        }
      } catch (err) {
        if (typeof handler.onError === "function") {
          handler.onError(err);
        }
      }
      return true;
    }
    return dispatch(opts, new CacheHandler(globalOpts, cacheKey, handler));
  }
  function sendCachedValue(handler, opts, result, age, context, isStale2) {
    const stream = util2.isStream(result.body) ? result.body : Readable2.from(result.body ?? []);
    assert(!stream.destroyed, "stream should not be destroyed");
    assert(!stream.readableDidRead, "stream should not be readableDidRead");
    const controller = {
      resume() {
        stream.resume();
      },
      pause() {
        stream.pause();
      },
      get paused() {
        return stream.isPaused();
      },
      get aborted() {
        return stream.destroyed;
      },
      get reason() {
        return stream.errored;
      },
      abort(reason) {
        stream.destroy(reason ?? new AbortError());
      }
    };
    stream.on("error", function(err) {
      if (!this.readableEnded) {
        if (typeof handler.onResponseError === "function") {
          handler.onResponseError(controller, err);
        } else {
          throw err;
        }
      }
    }).on("close", function() {
      if (!this.errored) {
        handler.onResponseEnd?.(controller, {});
      }
    });
    handler.onRequestStart?.(controller, context);
    if (stream.destroyed) {
      return;
    }
    const headers2 = { ...result.headers, age: String(age) };
    if (isStale2) {
      headers2.warning = '110 - "response is stale"';
    }
    handler.onResponseStart?.(controller, result.statusCode, headers2, result.statusMessage);
    if (opts.method === "HEAD") {
      stream.destroy();
    } else {
      stream.on("data", function(chunk2) {
        handler.onResponseData?.(controller, chunk2);
      });
    }
  }
  function handleResult(dispatch, globalOpts, cacheKey, handler, opts, reqCacheControl, result) {
    if (!result) {
      return handleUncachedResponse(dispatch, globalOpts, cacheKey, handler, opts, reqCacheControl);
    }
    const now = Date.now();
    if (now > result.deleteAt) {
      return dispatch(opts, new CacheHandler(globalOpts, cacheKey, handler));
    }
    const age = Math.round((now - result.cachedAt) / 1e3);
    if (reqCacheControl?.["max-age"] && age >= reqCacheControl["max-age"]) {
      return dispatch(opts, handler);
    }
    const stale = isStale(result, reqCacheControl);
    const revalidate = needsRevalidation(result, reqCacheControl, opts);
    if (stale || revalidate) {
      if (util2.isStream(opts.body) && util2.bodyLength(opts.body) !== 0) {
        return dispatch(opts, new CacheHandler(globalOpts, cacheKey, handler));
      }
      if (!revalidate && withinStaleWhileRevalidateWindow(result)) {
        sendCachedValue(handler, opts, result, age, null, true);
        queueMicrotask(() => {
          let headers3 = {
            ...opts.headers,
            "if-modified-since": new Date(result.cachedAt).toUTCString()
          };
          if (result.etag) {
            headers3["if-none-match"] = result.etag;
          }
          if (result.vary) {
            headers3 = {
              ...headers3,
              ...result.vary
            };
          }
          dispatch(
            {
              ...opts,
              headers: headers3
            },
            new CacheHandler(globalOpts, cacheKey, {
              // Silent handler that just updates the cache
              onRequestStart() {
              },
              onRequestUpgrade() {
              },
              onResponseStart() {
              },
              onResponseData() {
              },
              onResponseEnd() {
              },
              onResponseError() {
              }
            })
          );
        });
        return true;
      }
      let withinStaleIfErrorThreshold = false;
      const staleIfErrorExpiry = result.cacheControlDirectives["stale-if-error"] ?? reqCacheControl?.["stale-if-error"];
      if (staleIfErrorExpiry) {
        withinStaleIfErrorThreshold = now < result.staleAt + staleIfErrorExpiry * 1e3;
      }
      let headers2 = {
        ...opts.headers,
        "if-modified-since": new Date(result.cachedAt).toUTCString()
      };
      if (result.etag) {
        headers2["if-none-match"] = result.etag;
      }
      if (result.vary) {
        headers2 = {
          ...headers2,
          ...result.vary
        };
      }
      return dispatch(
        {
          ...opts,
          headers: headers2
        },
        new CacheRevalidationHandler(
          (success, context) => {
            if (success) {
              sendCachedValue(handler, opts, result, age, context, stale);
            } else if (util2.isStream(result.body)) {
              result.body.on("error", nop).destroy();
            }
          },
          new CacheHandler(globalOpts, cacheKey, handler),
          withinStaleIfErrorThreshold
        )
      );
    }
    if (util2.isStream(opts.body)) {
      opts.body.on("error", nop).destroy();
    }
    sendCachedValue(handler, opts, result, age, null, false);
  }
  cache$1 = (opts = {}) => {
    const {
      store = new MemoryCacheStore(),
      methods = ["GET"],
      cacheByDefault = void 0,
      type = "shared"
    } = opts;
    if (typeof opts !== "object" || opts === null) {
      throw new TypeError(`expected type of opts to be an Object, got ${opts === null ? "null" : typeof opts}`);
    }
    assertCacheStore(store, "opts.store");
    assertCacheMethods(methods, "opts.methods");
    if (typeof cacheByDefault !== "undefined" && typeof cacheByDefault !== "number") {
      throw new TypeError(`expected opts.cacheByDefault to be number or undefined, got ${typeof cacheByDefault}`);
    }
    if (typeof type !== "undefined" && type !== "shared" && type !== "private") {
      throw new TypeError(`expected opts.type to be shared, private, or undefined, got ${typeof type}`);
    }
    const globalOpts = {
      store,
      methods,
      cacheByDefault,
      type
    };
    const safeMethodsToNotCache = util2.safeHTTPMethods.filter((method) => methods.includes(method) === false);
    return (dispatch) => {
      return (opts2, handler) => {
        if (!opts2.origin || safeMethodsToNotCache.includes(opts2.method)) {
          return dispatch(opts2, handler);
        }
        opts2 = {
          ...opts2,
          headers: normalizeHeaders(opts2)
        };
        const reqCacheControl = opts2.headers?.["cache-control"] ? parseCacheControlHeader(opts2.headers["cache-control"]) : void 0;
        if (reqCacheControl?.["no-store"]) {
          return dispatch(opts2, handler);
        }
        const cacheKey = makeCacheKey(opts2);
        const result = store.get(cacheKey);
        if (result && typeof result.then === "function") {
          return result.then((result2) => handleResult(
            dispatch,
            globalOpts,
            cacheKey,
            handler,
            opts2,
            reqCacheControl,
            result2
          ));
        } else {
          return handleResult(
            dispatch,
            globalOpts,
            cacheKey,
            handler,
            opts2,
            reqCacheControl,
            result
          );
        }
      };
    };
  };
  return cache$1;
}
var decompress;
var hasRequiredDecompress;
function requireDecompress() {
  if (hasRequiredDecompress) return decompress;
  hasRequiredDecompress = 1;
  const { createInflate, createGunzip, createBrotliDecompress, createZstdDecompress } = import_node_zlib.default;
  const { pipeline } = import_node_stream.default;
  const DecoratorHandler = requireDecoratorHandler();
  const { runtimeFeatures: runtimeFeatures2 } = requireRuntimeFeatures();
  const supportedEncodings = {
    gzip: createGunzip,
    "x-gzip": createGunzip,
    br: createBrotliDecompress,
    deflate: createInflate,
    compress: createInflate,
    "x-compress": createInflate,
    ...runtimeFeatures2.has("zstd") ? { zstd: createZstdDecompress } : {}
  };
  const defaultSkipStatusCodes = (
    /** @type {const} */
    [204, 304]
  );
  let warningEmitted = (
    /** @type {boolean} */
    false
  );
  class DecompressHandler extends DecoratorHandler {
    /** @type {Transform[]} */
    #decompressors = [];
    /** @type {NodeJS.WritableStream&NodeJS.ReadableStream|null} */
    #pipelineStream;
    /** @type {Readonly<number[]>} */
    #skipStatusCodes;
    /** @type {boolean} */
    #skipErrorResponses;
    constructor(handler, { skipStatusCodes = defaultSkipStatusCodes, skipErrorResponses = true } = {}) {
      super(handler);
      this.#skipStatusCodes = skipStatusCodes;
      this.#skipErrorResponses = skipErrorResponses;
    }
    /**
     * Determines if decompression should be skipped based on encoding and status code
     * @param {string} contentEncoding - Content-Encoding header value
     * @param {number} statusCode - HTTP status code of the response
     * @returns {boolean} - True if decompression should be skipped
     */
    #shouldSkipDecompression(contentEncoding, statusCode) {
      if (!contentEncoding || statusCode < 200) return true;
      if (this.#skipStatusCodes.includes(statusCode)) return true;
      if (this.#skipErrorResponses && statusCode >= 400) return true;
      return false;
    }
    /**
     * Creates a chain of decompressors for multiple content encodings
     *
     * @param {string} encodings - Comma-separated list of content encodings
     * @returns {Array<DecompressorStream>} - Array of decompressor streams
     * @throws {Error} - If the number of content-encodings exceeds the maximum allowed
     */
    #createDecompressionChain(encodings) {
      const parts = encodings.split(",");
      const maxContentEncodings = 5;
      if (parts.length > maxContentEncodings) {
        throw new Error(`too many content-encodings in response: ${parts.length}, maximum allowed is ${maxContentEncodings}`);
      }
      const decompressors = [];
      for (let i4 = parts.length - 1; i4 >= 0; i4--) {
        const encoding2 = parts[i4].trim();
        if (!encoding2) continue;
        if (!supportedEncodings[encoding2]) {
          decompressors.length = 0;
          return decompressors;
        }
        decompressors.push(supportedEncodings[encoding2]());
      }
      return decompressors;
    }
    /**
     * Sets up event handlers for a decompressor stream using readable events
     * @param {DecompressorStream} decompressor - The decompressor stream
     * @param {Controller} controller - The controller to coordinate with
     * @returns {void}
     */
    #setupDecompressorEvents(decompressor, controller) {
      decompressor.on("readable", () => {
        let chunk2;
        while ((chunk2 = decompressor.read()) !== null) {
          const result = super.onResponseData(controller, chunk2);
          if (result === false) {
            break;
          }
        }
      });
      decompressor.on("error", (error2) => {
        super.onResponseError(controller, error2);
      });
    }
    /**
     * Sets up event handling for a single decompressor
     * @param {Controller} controller - The controller to handle events
     * @returns {void}
     */
    #setupSingleDecompressor(controller) {
      const decompressor = this.#decompressors[0];
      this.#setupDecompressorEvents(decompressor, controller);
      decompressor.on("end", () => {
        super.onResponseEnd(controller, {});
      });
    }
    /**
     * Sets up event handling for multiple chained decompressors using pipeline
     * @param {Controller} controller - The controller to handle events
     * @returns {void}
     */
    #setupMultipleDecompressors(controller) {
      const lastDecompressor = this.#decompressors[this.#decompressors.length - 1];
      this.#setupDecompressorEvents(lastDecompressor, controller);
      this.#pipelineStream = pipeline(this.#decompressors, (err) => {
        if (err) {
          super.onResponseError(controller, err);
          return;
        }
        super.onResponseEnd(controller, {});
      });
    }
    /**
     * Cleans up decompressor references to prevent memory leaks
     * @returns {void}
     */
    #cleanupDecompressors() {
      this.#decompressors.length = 0;
      this.#pipelineStream = null;
    }
    /**
     * @param {Controller} controller
     * @param {number} statusCode
     * @param {Record<string, string | string[] | undefined>} headers
     * @param {string} statusMessage
     * @returns {void}
     */
    onResponseStart(controller, statusCode, headers2, statusMessage) {
      const contentEncoding = headers2["content-encoding"];
      if (this.#shouldSkipDecompression(contentEncoding, statusCode)) {
        return super.onResponseStart(controller, statusCode, headers2, statusMessage);
      }
      const decompressors = this.#createDecompressionChain(contentEncoding.toLowerCase());
      if (decompressors.length === 0) {
        this.#cleanupDecompressors();
        return super.onResponseStart(controller, statusCode, headers2, statusMessage);
      }
      this.#decompressors = decompressors;
      const { "content-encoding": _, "content-length": __, ...newHeaders } = headers2;
      if (this.#decompressors.length === 1) {
        this.#setupSingleDecompressor(controller);
      } else {
        this.#setupMultipleDecompressors(controller);
      }
      super.onResponseStart(controller, statusCode, newHeaders, statusMessage);
    }
    /**
     * @param {Controller} controller
     * @param {Buffer} chunk
     * @returns {void}
     */
    onResponseData(controller, chunk2) {
      if (this.#decompressors.length > 0) {
        this.#decompressors[0].write(chunk2);
        return;
      }
      super.onResponseData(controller, chunk2);
    }
    /**
     * @param {Controller} controller
     * @param {Record<string, string | string[]> | undefined} trailers
     * @returns {void}
     */
    onResponseEnd(controller, trailers) {
      if (this.#decompressors.length > 0) {
        this.#decompressors[0].end();
        this.#cleanupDecompressors();
        return;
      }
      super.onResponseEnd(controller, trailers);
    }
    /**
     * @param {Controller} controller
     * @param {Error} err
     * @returns {void}
     */
    onResponseError(controller, err) {
      if (this.#decompressors.length > 0) {
        for (const decompressor of this.#decompressors) {
          decompressor.destroy(err);
        }
        this.#cleanupDecompressors();
      }
      super.onResponseError(controller, err);
    }
  }
  function createDecompressInterceptor(options = {}) {
    if (!warningEmitted) {
      process.emitWarning(
        "DecompressInterceptor is experimental and subject to change",
        "ExperimentalWarning"
      );
      warningEmitted = true;
    }
    return (dispatch) => {
      return (opts, handler) => {
        const decompressHandler = new DecompressHandler(handler, options);
        return dispatch(opts, decompressHandler);
      };
    };
  }
  decompress = createDecompressInterceptor;
  return decompress;
}
var deduplicationHandler;
var hasRequiredDeduplicationHandler;
function requireDeduplicationHandler() {
  if (hasRequiredDeduplicationHandler) return deduplicationHandler;
  hasRequiredDeduplicationHandler = 1;
  class DeduplicationHandler {
    /**
     * @type {DispatchHandler}
     */
    #primaryHandler;
    /**
     * @type {DispatchHandler[]}
     */
    #waitingHandlers = [];
    /**
     * @type {Buffer[]}
     */
    #chunks = [];
    /**
     * @type {number}
     */
    #statusCode = 0;
    /**
     * @type {Record<string, string | string[]>}
     */
    #headers = {};
    /**
     * @type {string}
     */
    #statusMessage = "";
    /**
     * @type {boolean}
     */
    #aborted = false;
    /**
     * @type {import('../../types/dispatcher.d.ts').default.DispatchController | null}
     */
    #controller = null;
    /**
     * @type {(() => void) | null}
     */
    #onComplete = null;
    /**
     * @param {DispatchHandler} primaryHandler The primary handler
     * @param {() => void} onComplete Callback when request completes
     */
    constructor(primaryHandler, onComplete) {
      this.#primaryHandler = primaryHandler;
      this.#onComplete = onComplete;
    }
    /**
     * Add a waiting handler that will receive the buffered response
     * @param {DispatchHandler} handler
     */
    addWaitingHandler(handler) {
      this.#waitingHandlers.push(handler);
    }
    /**
     * @param {() => void} abort
     * @param {any} context
     */
    onRequestStart(controller, context) {
      this.#controller = controller;
      this.#primaryHandler.onRequestStart?.(controller, context);
    }
    /**
     * @param {import('../../types/dispatcher.d.ts').default.DispatchController} controller
     * @param {number} statusCode
     * @param {import('../../types/header.d.ts').IncomingHttpHeaders} headers
     * @param {Socket} socket
     */
    onRequestUpgrade(controller, statusCode, headers2, socket) {
      this.#primaryHandler.onRequestUpgrade?.(controller, statusCode, headers2, socket);
    }
    /**
     * @param {import('../../types/dispatcher.d.ts').default.DispatchController} controller
     * @param {number} statusCode
     * @param {Record<string, string | string[]>} headers
     * @param {string} statusMessage
     */
    onResponseStart(controller, statusCode, headers2, statusMessage) {
      this.#statusCode = statusCode;
      this.#headers = headers2;
      this.#statusMessage = statusMessage;
      this.#primaryHandler.onResponseStart?.(controller, statusCode, headers2, statusMessage);
    }
    /**
     * @param {import('../../types/dispatcher.d.ts').default.DispatchController} controller
     * @param {Buffer} chunk
     */
    onResponseData(controller, chunk2) {
      this.#chunks.push(Buffer.from(chunk2));
      this.#primaryHandler.onResponseData?.(controller, chunk2);
    }
    /**
     * @param {import('../../types/dispatcher.d.ts').default.DispatchController} controller
     * @param {object} trailers
     */
    onResponseEnd(controller, trailers) {
      this.#primaryHandler.onResponseEnd?.(controller, trailers);
      this.#notifyWaitingHandlers();
      this.#onComplete?.();
    }
    /**
     * @param {import('../../types/dispatcher.d.ts').default.DispatchController} controller
     * @param {Error} err
     */
    onResponseError(controller, err) {
      this.#aborted = true;
      this.#primaryHandler.onResponseError?.(controller, err);
      this.#notifyWaitingHandlersError(err);
      this.#onComplete?.();
    }
    /**
     * Notify all waiting handlers with the buffered response
     */
    #notifyWaitingHandlers() {
      const body2 = Buffer.concat(this.#chunks);
      for (const handler of this.#waitingHandlers) {
        const waitingController = {
          resume() {
          },
          pause() {
          },
          get paused() {
            return false;
          },
          get aborted() {
            return false;
          },
          get reason() {
            return null;
          },
          abort() {
          }
        };
        try {
          handler.onRequestStart?.(waitingController, null);
          if (waitingController.aborted) {
            continue;
          }
          handler.onResponseStart?.(
            waitingController,
            this.#statusCode,
            this.#headers,
            this.#statusMessage
          );
          if (waitingController.aborted) {
            continue;
          }
          if (body2.length > 0) {
            handler.onResponseData?.(waitingController, body2);
          }
          handler.onResponseEnd?.(waitingController, {});
        } catch {
        }
      }
      this.#waitingHandlers = [];
      this.#chunks = [];
    }
    /**
     * Notify all waiting handlers of an error
     * @param {Error} err
     */
    #notifyWaitingHandlersError(err) {
      for (const handler of this.#waitingHandlers) {
        const waitingController = {
          resume() {
          },
          pause() {
          },
          get paused() {
            return false;
          },
          get aborted() {
            return true;
          },
          get reason() {
            return err;
          },
          abort() {
          }
        };
        try {
          handler.onRequestStart?.(waitingController, null);
          handler.onResponseError?.(waitingController, err);
        } catch {
        }
      }
      this.#waitingHandlers = [];
      this.#chunks = [];
    }
  }
  deduplicationHandler = DeduplicationHandler;
  return deduplicationHandler;
}
var deduplicate;
var hasRequiredDeduplicate;
function requireDeduplicate() {
  if (hasRequiredDeduplicate) return deduplicate;
  hasRequiredDeduplicate = 1;
  const diagnosticsChannel = import_node_diagnostics_channel.default;
  const util2 = requireUtil$5();
  const DeduplicationHandler = requireDeduplicationHandler();
  const { normalizeHeaders, makeCacheKey, makeDeduplicationKey } = requireCache$2();
  const pendingRequestsChannel = diagnosticsChannel.channel("undici:request:pending-requests");
  deduplicate = (opts = {}) => {
    const {
      methods = ["GET"],
      skipHeaderNames = [],
      excludeHeaderNames = []
    } = opts;
    if (typeof opts !== "object" || opts === null) {
      throw new TypeError(`expected type of opts to be an Object, got ${opts === null ? "null" : typeof opts}`);
    }
    if (!Array.isArray(methods)) {
      throw new TypeError(`expected opts.methods to be an array, got ${typeof methods}`);
    }
    for (const method of methods) {
      if (!util2.safeHTTPMethods.includes(method)) {
        throw new TypeError(`expected opts.methods to only contain safe HTTP methods, got ${method}`);
      }
    }
    if (!Array.isArray(skipHeaderNames)) {
      throw new TypeError(`expected opts.skipHeaderNames to be an array, got ${typeof skipHeaderNames}`);
    }
    if (!Array.isArray(excludeHeaderNames)) {
      throw new TypeError(`expected opts.excludeHeaderNames to be an array, got ${typeof excludeHeaderNames}`);
    }
    const skipHeaderNamesSet = new Set(skipHeaderNames.map((name) => name.toLowerCase()));
    const excludeHeaderNamesSet = new Set(excludeHeaderNames.map((name) => name.toLowerCase()));
    const safeMethodsToNotDeduplicate = util2.safeHTTPMethods.filter((method) => methods.includes(method) === false);
    const pendingRequests = /* @__PURE__ */ new Map();
    return (dispatch) => {
      return (opts2, handler) => {
        if (!opts2.origin || safeMethodsToNotDeduplicate.includes(opts2.method)) {
          return dispatch(opts2, handler);
        }
        opts2 = {
          ...opts2,
          headers: normalizeHeaders(opts2)
        };
        if (skipHeaderNamesSet.size > 0) {
          for (const headerName of Object.keys(opts2.headers)) {
            if (skipHeaderNamesSet.has(headerName.toLowerCase())) {
              return dispatch(opts2, handler);
            }
          }
        }
        const cacheKey = makeCacheKey(opts2);
        const dedupeKey = makeDeduplicationKey(cacheKey, excludeHeaderNamesSet);
        const pendingHandler = pendingRequests.get(dedupeKey);
        if (pendingHandler) {
          pendingHandler.addWaitingHandler(handler);
          return true;
        }
        const deduplicationHandler2 = new DeduplicationHandler(
          handler,
          () => {
            pendingRequests.delete(dedupeKey);
            if (pendingRequestsChannel.hasSubscribers) {
              pendingRequestsChannel.publish({ size: pendingRequests.size, key: dedupeKey, type: "removed" });
            }
          }
        );
        pendingRequests.set(dedupeKey, deduplicationHandler2);
        if (pendingRequestsChannel.hasSubscribers) {
          pendingRequestsChannel.publish({ size: pendingRequests.size, key: dedupeKey, type: "added" });
        }
        return dispatch(opts2, deduplicationHandler2);
      };
    };
  };
  return deduplicate;
}
var sqliteCacheStore;
var hasRequiredSqliteCacheStore;
function requireSqliteCacheStore() {
  if (hasRequiredSqliteCacheStore) return sqliteCacheStore;
  hasRequiredSqliteCacheStore = 1;
  const { Writable: Writable2 } = import_node_stream.default;
  const { assertCacheKey, assertCacheValue } = requireCache$2();
  let DatabaseSync;
  const VERSION2 = 3;
  const MAX_ENTRY_SIZE = 2 * 1e3 * 1e3 * 1e3;
  sqliteCacheStore = class SqliteCacheStore {
    #maxEntrySize = MAX_ENTRY_SIZE;
    #maxCount = Infinity;
    /**
     * @type {import('node:sqlite').DatabaseSync}
     */
    #db;
    /**
     * @type {import('node:sqlite').StatementSync}
     */
    #getValuesQuery;
    /**
     * @type {import('node:sqlite').StatementSync}
     */
    #updateValueQuery;
    /**
     * @type {import('node:sqlite').StatementSync}
     */
    #insertValueQuery;
    /**
     * @type {import('node:sqlite').StatementSync}
     */
    #deleteExpiredValuesQuery;
    /**
     * @type {import('node:sqlite').StatementSync}
     */
    #deleteByUrlQuery;
    /**
     * @type {import('node:sqlite').StatementSync}
     */
    #countEntriesQuery;
    /**
     * @type {import('node:sqlite').StatementSync | null}
     */
    #deleteOldValuesQuery;
    /**
     * @param {import('../../types/cache-interceptor.d.ts').default.SqliteCacheStoreOpts | undefined} opts
     */
    constructor(opts) {
      if (opts) {
        if (typeof opts !== "object") {
          throw new TypeError("SqliteCacheStore options must be an object");
        }
        if (opts.maxEntrySize !== void 0) {
          if (typeof opts.maxEntrySize !== "number" || !Number.isInteger(opts.maxEntrySize) || opts.maxEntrySize < 0) {
            throw new TypeError("SqliteCacheStore options.maxEntrySize must be a non-negative integer");
          }
          if (opts.maxEntrySize > MAX_ENTRY_SIZE) {
            throw new TypeError("SqliteCacheStore options.maxEntrySize must be less than 2gb");
          }
          this.#maxEntrySize = opts.maxEntrySize;
        }
        if (opts.maxCount !== void 0) {
          if (typeof opts.maxCount !== "number" || !Number.isInteger(opts.maxCount) || opts.maxCount < 0) {
            throw new TypeError("SqliteCacheStore options.maxCount must be a non-negative integer");
          }
          this.#maxCount = opts.maxCount;
        }
      }
      if (!DatabaseSync) {
        DatabaseSync = import_node_sqlite.default.DatabaseSync;
      }
      this.#db = new DatabaseSync(opts?.location ?? ":memory:");
      this.#db.exec(`
      PRAGMA journal_mode = WAL;
      PRAGMA synchronous = NORMAL;
      PRAGMA temp_store = memory;
      PRAGMA optimize;

      CREATE TABLE IF NOT EXISTS cacheInterceptorV${VERSION2} (
        -- Data specific to us
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        url TEXT NOT NULL,
        method TEXT NOT NULL,

        -- Data returned to the interceptor
        body BUF NULL,
        deleteAt INTEGER NOT NULL,
        statusCode INTEGER NOT NULL,
        statusMessage TEXT NOT NULL,
        headers TEXT NULL,
        cacheControlDirectives TEXT NULL,
        etag TEXT NULL,
        vary TEXT NULL,
        cachedAt INTEGER NOT NULL,
        staleAt INTEGER NOT NULL
      );

      CREATE INDEX IF NOT EXISTS idx_cacheInterceptorV${VERSION2}_getValuesQuery ON cacheInterceptorV${VERSION2}(url, method, deleteAt);
      CREATE INDEX IF NOT EXISTS idx_cacheInterceptorV${VERSION2}_deleteByUrlQuery ON cacheInterceptorV${VERSION2}(deleteAt);
    `);
      this.#getValuesQuery = this.#db.prepare(`
      SELECT
        id,
        body,
        deleteAt,
        statusCode,
        statusMessage,
        headers,
        etag,
        cacheControlDirectives,
        vary,
        cachedAt,
        staleAt
      FROM cacheInterceptorV${VERSION2}
      WHERE
        url = ?
        AND method = ?
      ORDER BY
        deleteAt ASC
    `);
      this.#updateValueQuery = this.#db.prepare(`
      UPDATE cacheInterceptorV${VERSION2} SET
        body = ?,
        deleteAt = ?,
        statusCode = ?,
        statusMessage = ?,
        headers = ?,
        etag = ?,
        cacheControlDirectives = ?,
        cachedAt = ?,
        staleAt = ?
      WHERE
        id = ?
    `);
      this.#insertValueQuery = this.#db.prepare(`
      INSERT INTO cacheInterceptorV${VERSION2} (
        url,
        method,
        body,
        deleteAt,
        statusCode,
        statusMessage,
        headers,
        etag,
        cacheControlDirectives,
        vary,
        cachedAt,
        staleAt
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);
      this.#deleteByUrlQuery = this.#db.prepare(
        `DELETE FROM cacheInterceptorV${VERSION2} WHERE url = ?`
      );
      this.#countEntriesQuery = this.#db.prepare(
        `SELECT COUNT(*) AS total FROM cacheInterceptorV${VERSION2}`
      );
      this.#deleteExpiredValuesQuery = this.#db.prepare(
        `DELETE FROM cacheInterceptorV${VERSION2} WHERE deleteAt <= ?`
      );
      this.#deleteOldValuesQuery = this.#maxCount === Infinity ? null : this.#db.prepare(`
        DELETE FROM cacheInterceptorV${VERSION2}
        WHERE id IN (
          SELECT
            id
          FROM cacheInterceptorV${VERSION2}
          ORDER BY cachedAt DESC
          LIMIT ?
        )
      `);
    }
    close() {
      this.#db.close();
    }
    /**
     * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key
     * @returns {(import('../../types/cache-interceptor.d.ts').default.GetResult & { body?: Buffer }) | undefined}
     */
    get(key) {
      assertCacheKey(key);
      const value = this.#findValue(key);
      return value ? {
        body: value.body ? Buffer.from(value.body.buffer, value.body.byteOffset, value.body.byteLength) : void 0,
        statusCode: value.statusCode,
        statusMessage: value.statusMessage,
        headers: value.headers ? JSON.parse(value.headers) : void 0,
        etag: value.etag ? value.etag : void 0,
        vary: value.vary ? JSON.parse(value.vary) : void 0,
        cacheControlDirectives: value.cacheControlDirectives ? JSON.parse(value.cacheControlDirectives) : void 0,
        cachedAt: value.cachedAt,
        staleAt: value.staleAt,
        deleteAt: value.deleteAt
      } : void 0;
    }
    /**
     * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key
     * @param {import('../../types/cache-interceptor.d.ts').default.CacheValue & { body: null | Buffer | Array<Buffer>}} value
     */
    set(key, value) {
      assertCacheKey(key);
      const url = this.#makeValueUrl(key);
      const body2 = Array.isArray(value.body) ? Buffer.concat(value.body) : value.body;
      const size = body2?.byteLength;
      if (size && size > this.#maxEntrySize) {
        return;
      }
      const existingValue = this.#findValue(key, true);
      if (existingValue) {
        this.#updateValueQuery.run(
          body2,
          value.deleteAt,
          value.statusCode,
          value.statusMessage,
          value.headers ? JSON.stringify(value.headers) : null,
          value.etag ? value.etag : null,
          value.cacheControlDirectives ? JSON.stringify(value.cacheControlDirectives) : null,
          value.cachedAt,
          value.staleAt,
          existingValue.id
        );
      } else {
        this.#prune();
        this.#insertValueQuery.run(
          url,
          key.method,
          body2,
          value.deleteAt,
          value.statusCode,
          value.statusMessage,
          value.headers ? JSON.stringify(value.headers) : null,
          value.etag ? value.etag : null,
          value.cacheControlDirectives ? JSON.stringify(value.cacheControlDirectives) : null,
          value.vary ? JSON.stringify(value.vary) : null,
          value.cachedAt,
          value.staleAt
        );
      }
    }
    /**
     * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key
     * @param {import('../../types/cache-interceptor.d.ts').default.CacheValue} value
     * @returns {Writable | undefined}
     */
    createWriteStream(key, value) {
      assertCacheKey(key);
      assertCacheValue(value);
      let size = 0;
      const body2 = [];
      const store = this;
      return new Writable2({
        decodeStrings: true,
        write(chunk2, encoding2, callback) {
          size += chunk2.byteLength;
          if (size < store.#maxEntrySize) {
            body2.push(chunk2);
          } else {
            this.destroy();
          }
          callback();
        },
        final(callback) {
          store.set(key, { ...value, body: body2 });
          callback();
        }
      });
    }
    /**
     * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key
     */
    delete(key) {
      if (typeof key !== "object") {
        throw new TypeError(`expected key to be object, got ${typeof key}`);
      }
      this.#deleteByUrlQuery.run(this.#makeValueUrl(key));
    }
    #prune() {
      if (Number.isFinite(this.#maxCount) && this.size <= this.#maxCount) {
        return 0;
      }
      {
        const removed = this.#deleteExpiredValuesQuery.run(Date.now()).changes;
        if (removed) {
          return removed;
        }
      }
      {
        const removed = this.#deleteOldValuesQuery?.run(Math.max(Math.floor(this.#maxCount * 0.1), 1)).changes;
        if (removed) {
          return removed;
        }
      }
      return 0;
    }
    /**
     * Counts the number of rows in the cache
     * @returns {Number}
     */
    get size() {
      const { total } = this.#countEntriesQuery.get();
      return total;
    }
    /**
     * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key
     * @returns {string}
     */
    #makeValueUrl(key) {
      return `${key.origin}/${key.path}`;
    }
    /**
     * @param {import('../../types/cache-interceptor.d.ts').default.CacheKey} key
     * @param {boolean} [canBeExpired=false]
     * @returns {SqliteStoreValue | undefined}
     */
    #findValue(key, canBeExpired = false) {
      const url = this.#makeValueUrl(key);
      const { headers: headers2, method } = key;
      const values = this.#getValuesQuery.all(url, method);
      if (values.length === 0) {
        return void 0;
      }
      const now = Date.now();
      for (const value of values) {
        if (now >= value.deleteAt && !canBeExpired) {
          return void 0;
        }
        let matches = true;
        if (value.vary) {
          const vary = JSON.parse(value.vary);
          for (const header in vary) {
            if (!headerValueEquals(headers2[header], vary[header])) {
              matches = false;
              break;
            }
          }
        }
        if (matches) {
          return value;
        }
      }
      return void 0;
    }
  };
  function headerValueEquals(lhs, rhs) {
    if (lhs == null && rhs == null) {
      return true;
    }
    if (lhs == null && rhs != null || lhs != null && rhs == null) {
      return false;
    }
    if (Array.isArray(lhs) && Array.isArray(rhs)) {
      if (lhs.length !== rhs.length) {
        return false;
      }
      return lhs.every((x4, i4) => x4 === rhs[i4]);
    }
    return lhs === rhs;
  }
  return sqliteCacheStore;
}
var headers;
var hasRequiredHeaders;
function requireHeaders() {
  if (hasRequiredHeaders) return headers;
  hasRequiredHeaders = 1;
  const { kConstruct } = requireSymbols();
  const { kEnumerableProperty } = requireUtil$5();
  const {
    iteratorMixin,
    isValidHeaderName,
    isValidHeaderValue
  } = requireUtil$4();
  const { webidl } = requireWebidl();
  const assert = import_node_assert.default;
  const util2 = import_node_util.default;
  function isHTTPWhiteSpaceCharCode(code) {
    return code === 10 || code === 13 || code === 9 || code === 32;
  }
  function headerValueNormalize(potentialValue) {
    let i4 = 0;
    let j4 = potentialValue.length;
    while (j4 > i4 && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j4 - 1))) --j4;
    while (j4 > i4 && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i4))) ++i4;
    return i4 === 0 && j4 === potentialValue.length ? potentialValue : potentialValue.substring(i4, j4);
  }
  function fill(headers2, object) {
    if (Array.isArray(object)) {
      for (let i4 = 0; i4 < object.length; ++i4) {
        const header = object[i4];
        if (header.length !== 2) {
          throw webidl.errors.exception({
            header: "Headers constructor",
            message: `expected name/value pair to be length 2, found ${header.length}.`
          });
        }
        appendHeader(headers2, header[0], header[1]);
      }
    } else if (typeof object === "object" && object !== null) {
      const keys2 = Object.keys(object);
      for (let i4 = 0; i4 < keys2.length; ++i4) {
        appendHeader(headers2, keys2[i4], object[keys2[i4]]);
      }
    } else {
      throw webidl.errors.conversionFailed({
        prefix: "Headers constructor",
        argument: "Argument 1",
        types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
      });
    }
  }
  function appendHeader(headers2, name, value) {
    value = headerValueNormalize(value);
    if (!isValidHeaderName(name)) {
      throw webidl.errors.invalidArgument({
        prefix: "Headers.append",
        value: name,
        type: "header name"
      });
    } else if (!isValidHeaderValue(value)) {
      throw webidl.errors.invalidArgument({
        prefix: "Headers.append",
        value,
        type: "header value"
      });
    }
    if (getHeadersGuard(headers2) === "immutable") {
      throw new TypeError("immutable");
    }
    return getHeadersList(headers2).append(name, value, false);
  }
  function headersListSortAndCombine(target) {
    const headersList = getHeadersList(target);
    if (!headersList) {
      return [];
    }
    if (headersList.sortedMap) {
      return headersList.sortedMap;
    }
    const headers2 = [];
    const names = headersList.toSortedArray();
    const cookies2 = headersList.cookies;
    if (cookies2 === null || cookies2.length === 1) {
      return headersList.sortedMap = names;
    }
    for (let i4 = 0; i4 < names.length; ++i4) {
      const { 0: name, 1: value } = names[i4];
      if (name === "set-cookie") {
        for (let j4 = 0; j4 < cookies2.length; ++j4) {
          headers2.push([name, cookies2[j4]]);
        }
      } else {
        headers2.push([name, value]);
      }
    }
    return headersList.sortedMap = headers2;
  }
  function compareHeaderName(a4, b4) {
    return a4[0] < b4[0] ? -1 : 1;
  }
  class HeadersList {
    /** @type {[string, string][]|null} */
    cookies = null;
    sortedMap;
    headersMap;
    constructor(init) {
      if (init instanceof HeadersList) {
        this.headersMap = new Map(init.headersMap);
        this.sortedMap = init.sortedMap;
        this.cookies = init.cookies === null ? null : [...init.cookies];
      } else {
        this.headersMap = new Map(init);
        this.sortedMap = null;
      }
    }
    /**
     * @see https://fetch.spec.whatwg.org/#header-list-contains
     * @param {string} name
     * @param {boolean} isLowerCase
     */
    contains(name, isLowerCase) {
      return this.headersMap.has(isLowerCase ? name : name.toLowerCase());
    }
    clear() {
      this.headersMap.clear();
      this.sortedMap = null;
      this.cookies = null;
    }
    /**
     * @see https://fetch.spec.whatwg.org/#concept-header-list-append
     * @param {string} name
     * @param {string} value
     * @param {boolean} isLowerCase
     */
    append(name, value, isLowerCase) {
      this.sortedMap = null;
      const lowercaseName = isLowerCase ? name : name.toLowerCase();
      const exists = this.headersMap.get(lowercaseName);
      if (exists) {
        const delimiter = lowercaseName === "cookie" ? "; " : ", ";
        this.headersMap.set(lowercaseName, {
          name: exists.name,
          value: `${exists.value}${delimiter}${value}`
        });
      } else {
        this.headersMap.set(lowercaseName, { name, value });
      }
      if (lowercaseName === "set-cookie") {
        (this.cookies ??= []).push(value);
      }
    }
    /**
     * @see https://fetch.spec.whatwg.org/#concept-header-list-set
     * @param {string} name
     * @param {string} value
     * @param {boolean} isLowerCase
     */
    set(name, value, isLowerCase) {
      this.sortedMap = null;
      const lowercaseName = isLowerCase ? name : name.toLowerCase();
      if (lowercaseName === "set-cookie") {
        this.cookies = [value];
      }
      this.headersMap.set(lowercaseName, { name, value });
    }
    /**
     * @see https://fetch.spec.whatwg.org/#concept-header-list-delete
     * @param {string} name
     * @param {boolean} isLowerCase
     */
    delete(name, isLowerCase) {
      this.sortedMap = null;
      if (!isLowerCase) name = name.toLowerCase();
      if (name === "set-cookie") {
        this.cookies = null;
      }
      this.headersMap.delete(name);
    }
    /**
     * @see https://fetch.spec.whatwg.org/#concept-header-list-get
     * @param {string} name
     * @param {boolean} isLowerCase
     * @returns {string | null}
     */
    get(name, isLowerCase) {
      return this.headersMap.get(isLowerCase ? name : name.toLowerCase())?.value ?? null;
    }
    *[Symbol.iterator]() {
      for (const { 0: name, 1: { value } } of this.headersMap) {
        yield [name, value];
      }
    }
    get entries() {
      const headers2 = {};
      if (this.headersMap.size !== 0) {
        for (const { name, value } of this.headersMap.values()) {
          headers2[name] = value;
        }
      }
      return headers2;
    }
    rawValues() {
      return this.headersMap.values();
    }
    get entriesList() {
      const headers2 = [];
      if (this.headersMap.size !== 0) {
        for (const { 0: lowerName, 1: { name, value } } of this.headersMap) {
          if (lowerName === "set-cookie") {
            for (const cookie of this.cookies) {
              headers2.push([name, cookie]);
            }
          } else {
            headers2.push([name, value]);
          }
        }
      }
      return headers2;
    }
    // https://fetch.spec.whatwg.org/#convert-header-names-to-a-sorted-lowercase-set
    toSortedArray() {
      const size = this.headersMap.size;
      const array = new Array(size);
      if (size <= 32) {
        if (size === 0) {
          return array;
        }
        const iterator = this.headersMap[Symbol.iterator]();
        const firstValue = iterator.next().value;
        array[0] = [firstValue[0], firstValue[1].value];
        assert(firstValue[1].value !== null);
        for (let i4 = 1, j4 = 0, right = 0, left = 0, pivot = 0, x4, value; i4 < size; ++i4) {
          value = iterator.next().value;
          x4 = array[i4] = [value[0], value[1].value];
          assert(x4[1] !== null);
          left = 0;
          right = i4;
          while (left < right) {
            pivot = left + (right - left >> 1);
            if (array[pivot][0] <= x4[0]) {
              left = pivot + 1;
            } else {
              right = pivot;
            }
          }
          if (i4 !== pivot) {
            j4 = i4;
            while (j4 > left) {
              array[j4] = array[--j4];
            }
            array[left] = x4;
          }
        }
        if (!iterator.next().done) {
          throw new TypeError("Unreachable");
        }
        return array;
      } else {
        let i4 = 0;
        for (const { 0: name, 1: { value } } of this.headersMap) {
          array[i4++] = [name, value];
          assert(value !== null);
        }
        return array.sort(compareHeaderName);
      }
    }
  }
  class Headers2 {
    #guard;
    /**
     * @type {HeadersList}
     */
    #headersList;
    /**
     * @param {HeadersInit|Symbol} [init]
     * @returns
     */
    constructor(init = void 0) {
      webidl.util.markAsUncloneable(this);
      if (init === kConstruct) {
        return;
      }
      this.#headersList = new HeadersList();
      this.#guard = "none";
      if (init !== void 0) {
        init = webidl.converters.HeadersInit(init, "Headers constructor", "init");
        fill(this, init);
      }
    }
    // https://fetch.spec.whatwg.org/#dom-headers-append
    append(name, value) {
      webidl.brandCheck(this, Headers2);
      webidl.argumentLengthCheck(arguments, 2, "Headers.append");
      const prefix = "Headers.append";
      name = webidl.converters.ByteString(name, prefix, "name");
      value = webidl.converters.ByteString(value, prefix, "value");
      return appendHeader(this, name, value);
    }
    // https://fetch.spec.whatwg.org/#dom-headers-delete
    delete(name) {
      webidl.brandCheck(this, Headers2);
      webidl.argumentLengthCheck(arguments, 1, "Headers.delete");
      const prefix = "Headers.delete";
      name = webidl.converters.ByteString(name, prefix, "name");
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.delete",
          value: name,
          type: "header name"
        });
      }
      if (this.#guard === "immutable") {
        throw new TypeError("immutable");
      }
      if (!this.#headersList.contains(name, false)) {
        return;
      }
      this.#headersList.delete(name, false);
    }
    // https://fetch.spec.whatwg.org/#dom-headers-get
    get(name) {
      webidl.brandCheck(this, Headers2);
      webidl.argumentLengthCheck(arguments, 1, "Headers.get");
      const prefix = "Headers.get";
      name = webidl.converters.ByteString(name, prefix, "name");
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix,
          value: name,
          type: "header name"
        });
      }
      return this.#headersList.get(name, false);
    }
    // https://fetch.spec.whatwg.org/#dom-headers-has
    has(name) {
      webidl.brandCheck(this, Headers2);
      webidl.argumentLengthCheck(arguments, 1, "Headers.has");
      const prefix = "Headers.has";
      name = webidl.converters.ByteString(name, prefix, "name");
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix,
          value: name,
          type: "header name"
        });
      }
      return this.#headersList.contains(name, false);
    }
    // https://fetch.spec.whatwg.org/#dom-headers-set
    set(name, value) {
      webidl.brandCheck(this, Headers2);
      webidl.argumentLengthCheck(arguments, 2, "Headers.set");
      const prefix = "Headers.set";
      name = webidl.converters.ByteString(name, prefix, "name");
      value = webidl.converters.ByteString(value, prefix, "value");
      value = headerValueNormalize(value);
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix,
          value: name,
          type: "header name"
        });
      } else if (!isValidHeaderValue(value)) {
        throw webidl.errors.invalidArgument({
          prefix,
          value,
          type: "header value"
        });
      }
      if (this.#guard === "immutable") {
        throw new TypeError("immutable");
      }
      this.#headersList.set(name, value, false);
    }
    // https://fetch.spec.whatwg.org/#dom-headers-getsetcookie
    getSetCookie() {
      webidl.brandCheck(this, Headers2);
      const list2 = this.#headersList.cookies;
      if (list2) {
        return [...list2];
      }
      return [];
    }
    [util2.inspect.custom](depth, options) {
      options.depth ??= depth;
      return `Headers ${util2.formatWithOptions(options, this.#headersList.entries)}`;
    }
    static getHeadersGuard(o4) {
      return o4.#guard;
    }
    static setHeadersGuard(o4, guard) {
      o4.#guard = guard;
    }
    /**
     * @param {Headers} o
     */
    static getHeadersList(o4) {
      return o4.#headersList;
    }
    /**
     * @param {Headers} target
     * @param {HeadersList} list
     */
    static setHeadersList(target, list2) {
      target.#headersList = list2;
    }
  }
  const { getHeadersGuard, setHeadersGuard, getHeadersList, setHeadersList } = Headers2;
  Reflect.deleteProperty(Headers2, "getHeadersGuard");
  Reflect.deleteProperty(Headers2, "setHeadersGuard");
  Reflect.deleteProperty(Headers2, "getHeadersList");
  Reflect.deleteProperty(Headers2, "setHeadersList");
  iteratorMixin("Headers", Headers2, headersListSortAndCombine, 0, 1);
  Object.defineProperties(Headers2.prototype, {
    append: kEnumerableProperty,
    delete: kEnumerableProperty,
    get: kEnumerableProperty,
    has: kEnumerableProperty,
    set: kEnumerableProperty,
    getSetCookie: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "Headers",
      configurable: true
    },
    [util2.inspect.custom]: {
      enumerable: false
    }
  });
  webidl.converters.HeadersInit = function(V, prefix, argument) {
    if (webidl.util.Type(V) === webidl.util.Types.OBJECT) {
      const iterator = Reflect.get(V, Symbol.iterator);
      if (!util2.types.isProxy(V) && iterator === Headers2.prototype.entries) {
        try {
          return getHeadersList(V).entriesList;
        } catch {
        }
      }
      if (typeof iterator === "function") {
        return webidl.converters["sequence<sequence<ByteString>>"](V, prefix, argument, iterator.bind(V));
      }
      return webidl.converters["record<ByteString, ByteString>"](V, prefix, argument);
    }
    throw webidl.errors.conversionFailed({
      prefix: "Headers constructor",
      argument: "Argument 1",
      types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
    });
  };
  headers = {
    fill,
    // for test.
    compareHeaderName,
    Headers: Headers2,
    HeadersList,
    getHeadersGuard,
    setHeadersGuard,
    setHeadersList,
    getHeadersList
  };
  return headers;
}
var response;
var hasRequiredResponse;
function requireResponse() {
  if (hasRequiredResponse) return response;
  hasRequiredResponse = 1;
  const { Headers: Headers2, HeadersList, fill, getHeadersGuard, setHeadersGuard, setHeadersList } = requireHeaders();
  const { extractBody, cloneBody, mixinBody, streamRegistry, bodyUnusable } = requireBody();
  const util2 = requireUtil$5();
  const nodeUtil2 = import_node_util.default;
  const { kEnumerableProperty } = util2;
  const {
    isValidReasonPhrase,
    isCancelled,
    isAborted,
    isErrorLike,
    environmentSettingsObject: relevantRealm
  } = requireUtil$4();
  const {
    redirectStatusSet,
    nullBodyStatus
  } = requireConstants$2();
  const { webidl } = requireWebidl();
  const { URLSerializer } = requireDataUrl();
  const { kConstruct } = requireSymbols();
  const assert = import_node_assert.default;
  const { isomorphicEncode, serializeJavascriptValueToJSONString } = requireInfra();
  const textEncoder2 = new TextEncoder("utf-8");
  class Response2 {
    /** @type {Headers} */
    #headers;
    #state;
    // Creates network error Response.
    static error() {
      const responseObject = fromInnerResponse(makeNetworkError(), "immutable");
      return responseObject;
    }
    // https://fetch.spec.whatwg.org/#dom-response-json
    static json(data2, init = void 0) {
      webidl.argumentLengthCheck(arguments, 1, "Response.json");
      if (init !== null) {
        init = webidl.converters.ResponseInit(init);
      }
      const bytes = textEncoder2.encode(
        serializeJavascriptValueToJSONString(data2)
      );
      const body2 = extractBody(bytes);
      const responseObject = fromInnerResponse(makeResponse({}), "response");
      initializeResponse(responseObject, init, { body: body2[0], type: "application/json" });
      return responseObject;
    }
    // Creates a redirect Response that redirects to url with status status.
    static redirect(url, status = 302) {
      webidl.argumentLengthCheck(arguments, 1, "Response.redirect");
      url = webidl.converters.USVString(url);
      status = webidl.converters["unsigned short"](status);
      let parsedURL;
      try {
        parsedURL = new URL(url, relevantRealm.settingsObject.baseUrl);
      } catch (err) {
        throw new TypeError(`Failed to parse URL from ${url}`, { cause: err });
      }
      if (!redirectStatusSet.has(status)) {
        throw new RangeError(`Invalid status code ${status}`);
      }
      const responseObject = fromInnerResponse(makeResponse({}), "immutable");
      responseObject.#state.status = status;
      const value = isomorphicEncode(URLSerializer(parsedURL));
      responseObject.#state.headersList.append("location", value, true);
      return responseObject;
    }
    // https://fetch.spec.whatwg.org/#dom-response
    constructor(body2 = null, init = void 0) {
      webidl.util.markAsUncloneable(this);
      if (body2 === kConstruct) {
        return;
      }
      if (body2 !== null) {
        body2 = webidl.converters.BodyInit(body2, "Response", "body");
      }
      init = webidl.converters.ResponseInit(init);
      this.#state = makeResponse({});
      this.#headers = new Headers2(kConstruct);
      setHeadersGuard(this.#headers, "response");
      setHeadersList(this.#headers, this.#state.headersList);
      let bodyWithType = null;
      if (body2 != null) {
        const [extractedBody, type] = extractBody(body2);
        bodyWithType = { body: extractedBody, type };
      }
      initializeResponse(this, init, bodyWithType);
    }
    // Returns responses type, e.g., "cors".
    get type() {
      webidl.brandCheck(this, Response2);
      return this.#state.type;
    }
    // Returns responses URL, if it has one; otherwise the empty string.
    get url() {
      webidl.brandCheck(this, Response2);
      const urlList = this.#state.urlList;
      const url = urlList[urlList.length - 1] ?? null;
      if (url === null) {
        return "";
      }
      return URLSerializer(url, true);
    }
    // Returns whether response was obtained through a redirect.
    get redirected() {
      webidl.brandCheck(this, Response2);
      return this.#state.urlList.length > 1;
    }
    // Returns responses status.
    get status() {
      webidl.brandCheck(this, Response2);
      return this.#state.status;
    }
    // Returns whether responses status is an ok status.
    get ok() {
      webidl.brandCheck(this, Response2);
      return this.#state.status >= 200 && this.#state.status <= 299;
    }
    // Returns responses status message.
    get statusText() {
      webidl.brandCheck(this, Response2);
      return this.#state.statusText;
    }
    // Returns responses headers as Headers.
    get headers() {
      webidl.brandCheck(this, Response2);
      return this.#headers;
    }
    get body() {
      webidl.brandCheck(this, Response2);
      return this.#state.body ? this.#state.body.stream : null;
    }
    get bodyUsed() {
      webidl.brandCheck(this, Response2);
      return !!this.#state.body && util2.isDisturbed(this.#state.body.stream);
    }
    // Returns a clone of response.
    clone() {
      webidl.brandCheck(this, Response2);
      if (bodyUnusable(this.#state)) {
        throw webidl.errors.exception({
          header: "Response.clone",
          message: "Body has already been consumed."
        });
      }
      const clonedResponse = cloneResponse(this.#state);
      if (this.#state.body?.stream) {
        streamRegistry.register(this, new WeakRef(this.#state.body.stream));
      }
      return fromInnerResponse(clonedResponse, getHeadersGuard(this.#headers));
    }
    [nodeUtil2.inspect.custom](depth, options) {
      if (options.depth === null) {
        options.depth = 2;
      }
      options.colors ??= true;
      const properties = {
        status: this.status,
        statusText: this.statusText,
        headers: this.headers,
        body: this.body,
        bodyUsed: this.bodyUsed,
        ok: this.ok,
        redirected: this.redirected,
        type: this.type,
        url: this.url
      };
      return `Response ${nodeUtil2.formatWithOptions(options, properties)}`;
    }
    /**
     * @param {Response} response
     */
    static getResponseHeaders(response2) {
      return response2.#headers;
    }
    /**
     * @param {Response} response
     * @param {Headers} newHeaders
     */
    static setResponseHeaders(response2, newHeaders) {
      response2.#headers = newHeaders;
    }
    /**
     * @param {Response} response
     */
    static getResponseState(response2) {
      return response2.#state;
    }
    /**
     * @param {Response} response
     * @param {any} newState
     */
    static setResponseState(response2, newState) {
      response2.#state = newState;
    }
  }
  const { getResponseHeaders, setResponseHeaders, getResponseState, setResponseState } = Response2;
  Reflect.deleteProperty(Response2, "getResponseHeaders");
  Reflect.deleteProperty(Response2, "setResponseHeaders");
  Reflect.deleteProperty(Response2, "getResponseState");
  Reflect.deleteProperty(Response2, "setResponseState");
  mixinBody(Response2, getResponseState);
  Object.defineProperties(Response2.prototype, {
    type: kEnumerableProperty,
    url: kEnumerableProperty,
    status: kEnumerableProperty,
    ok: kEnumerableProperty,
    redirected: kEnumerableProperty,
    statusText: kEnumerableProperty,
    headers: kEnumerableProperty,
    clone: kEnumerableProperty,
    body: kEnumerableProperty,
    bodyUsed: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "Response",
      configurable: true
    }
  });
  Object.defineProperties(Response2, {
    json: kEnumerableProperty,
    redirect: kEnumerableProperty,
    error: kEnumerableProperty
  });
  function cloneResponse(response2) {
    if (response2.internalResponse) {
      return filterResponse(
        cloneResponse(response2.internalResponse),
        response2.type
      );
    }
    const newResponse = makeResponse({ ...response2, body: null });
    if (response2.body != null) {
      newResponse.body = cloneBody(response2.body);
    }
    return newResponse;
  }
  function makeResponse(init) {
    return {
      aborted: false,
      rangeRequested: false,
      timingAllowPassed: false,
      requestIncludesCredentials: false,
      type: "default",
      status: 200,
      timingInfo: null,
      cacheState: "",
      statusText: "",
      ...init,
      headersList: init?.headersList ? new HeadersList(init?.headersList) : new HeadersList(),
      urlList: init?.urlList ? [...init.urlList] : []
    };
  }
  function makeNetworkError(reason) {
    const isError = isErrorLike(reason);
    return makeResponse({
      type: "error",
      status: 0,
      error: isError ? reason : new Error(reason ? String(reason) : reason),
      aborted: reason && reason.name === "AbortError"
    });
  }
  function isNetworkError(response2) {
    return (
      // A network error is a response whose type is "error",
      response2.type === "error" && // status is 0
      response2.status === 0
    );
  }
  function makeFilteredResponse(response2, state2) {
    state2 = {
      internalResponse: response2,
      ...state2
    };
    return new Proxy(response2, {
      get(target, p4) {
        return p4 in state2 ? state2[p4] : target[p4];
      },
      set(target, p4, value) {
        assert(!(p4 in state2));
        target[p4] = value;
        return true;
      }
    });
  }
  function filterResponse(response2, type) {
    if (type === "basic") {
      return makeFilteredResponse(response2, {
        type: "basic",
        headersList: response2.headersList
      });
    } else if (type === "cors") {
      return makeFilteredResponse(response2, {
        type: "cors",
        headersList: response2.headersList
      });
    } else if (type === "opaque") {
      return makeFilteredResponse(response2, {
        type: "opaque",
        urlList: [],
        status: 0,
        statusText: "",
        body: null
      });
    } else if (type === "opaqueredirect") {
      return makeFilteredResponse(response2, {
        type: "opaqueredirect",
        status: 0,
        statusText: "",
        headersList: [],
        body: null
      });
    } else {
      assert(false);
    }
  }
  function makeAppropriateNetworkError(fetchParams, err = null) {
    assert(isCancelled(fetchParams));
    return isAborted(fetchParams) ? makeNetworkError(Object.assign(new DOMException("The operation was aborted.", "AbortError"), { cause: err })) : makeNetworkError(Object.assign(new DOMException("Request was cancelled."), { cause: err }));
  }
  function initializeResponse(response2, init, body2) {
    if (init.status !== null && (init.status < 200 || init.status > 599)) {
      throw new RangeError('init["status"] must be in the range of 200 to 599, inclusive.');
    }
    if ("statusText" in init && init.statusText != null) {
      if (!isValidReasonPhrase(String(init.statusText))) {
        throw new TypeError("Invalid statusText");
      }
    }
    if ("status" in init && init.status != null) {
      getResponseState(response2).status = init.status;
    }
    if ("statusText" in init && init.statusText != null) {
      getResponseState(response2).statusText = init.statusText;
    }
    if ("headers" in init && init.headers != null) {
      fill(getResponseHeaders(response2), init.headers);
    }
    if (body2) {
      if (nullBodyStatus.includes(response2.status)) {
        throw webidl.errors.exception({
          header: "Response constructor",
          message: `Invalid response status code ${response2.status}`
        });
      }
      getResponseState(response2).body = body2.body;
      if (body2.type != null && !getResponseState(response2).headersList.contains("content-type", true)) {
        getResponseState(response2).headersList.append("content-type", body2.type, true);
      }
    }
  }
  function fromInnerResponse(innerResponse, guard) {
    const response2 = new Response2(kConstruct);
    setResponseState(response2, innerResponse);
    const headers2 = new Headers2(kConstruct);
    setResponseHeaders(response2, headers2);
    setHeadersList(headers2, innerResponse.headersList);
    setHeadersGuard(headers2, guard);
    if (innerResponse.body?.stream) {
      streamRegistry.register(response2, new WeakRef(innerResponse.body.stream));
    }
    return response2;
  }
  webidl.converters.XMLHttpRequestBodyInit = function(V, prefix, name) {
    if (typeof V === "string") {
      return webidl.converters.USVString(V, prefix, name);
    }
    if (webidl.is.Blob(V)) {
      return V;
    }
    if (webidl.is.BufferSource(V)) {
      return V;
    }
    if (webidl.is.FormData(V)) {
      return V;
    }
    if (webidl.is.URLSearchParams(V)) {
      return V;
    }
    return webidl.converters.DOMString(V, prefix, name);
  };
  webidl.converters.BodyInit = function(V, prefix, argument) {
    if (webidl.is.ReadableStream(V)) {
      return V;
    }
    if (V?.[Symbol.asyncIterator]) {
      return V;
    }
    return webidl.converters.XMLHttpRequestBodyInit(V, prefix, argument);
  };
  webidl.converters.ResponseInit = webidl.dictionaryConverter([
    {
      key: "status",
      converter: webidl.converters["unsigned short"],
      defaultValue: () => 200
    },
    {
      key: "statusText",
      converter: webidl.converters.ByteString,
      defaultValue: () => ""
    },
    {
      key: "headers",
      converter: webidl.converters.HeadersInit
    }
  ]);
  webidl.is.Response = webidl.util.MakeTypeAssertion(Response2);
  response = {
    isNetworkError,
    makeNetworkError,
    makeResponse,
    makeAppropriateNetworkError,
    filterResponse,
    Response: Response2,
    cloneResponse,
    fromInnerResponse,
    getResponseState
  };
  return response;
}
var request;
var hasRequiredRequest;
function requireRequest() {
  if (hasRequiredRequest) return request;
  hasRequiredRequest = 1;
  const { extractBody, mixinBody, cloneBody, bodyUnusable } = requireBody();
  const { Headers: Headers2, fill: fillHeaders, HeadersList, setHeadersGuard, getHeadersGuard, setHeadersList, getHeadersList } = requireHeaders();
  const util2 = requireUtil$5();
  const nodeUtil2 = import_node_util.default;
  const {
    isValidHTTPToken,
    sameOrigin,
    environmentSettingsObject
  } = requireUtil$4();
  const {
    forbiddenMethodsSet,
    corsSafeListedMethodsSet,
    referrerPolicy,
    requestRedirect,
    requestMode,
    requestCredentials,
    requestCache,
    requestDuplex
  } = requireConstants$2();
  const { kEnumerableProperty, normalizedMethodRecordsBase, normalizedMethodRecords } = util2;
  const { webidl } = requireWebidl();
  const { URLSerializer } = requireDataUrl();
  const { kConstruct } = requireSymbols();
  const assert = import_node_assert.default;
  const { getMaxListeners, setMaxListeners, defaultMaxListeners } = import_node_events.default;
  const kAbortController = /* @__PURE__ */ Symbol("abortController");
  const requestFinalizer = new FinalizationRegistry(({ signal, abort }) => {
    signal.removeEventListener("abort", abort);
  });
  const dependentControllerMap = /* @__PURE__ */ new WeakMap();
  let abortSignalHasEventHandlerLeakWarning;
  try {
    abortSignalHasEventHandlerLeakWarning = getMaxListeners(new AbortController().signal) > 0;
  } catch {
    abortSignalHasEventHandlerLeakWarning = false;
  }
  function buildAbort(acRef) {
    return abort;
    function abort() {
      const ac = acRef.deref();
      if (ac !== void 0) {
        requestFinalizer.unregister(abort);
        this.removeEventListener("abort", abort);
        ac.abort(this.reason);
        const controllerList = dependentControllerMap.get(ac.signal);
        if (controllerList !== void 0) {
          if (controllerList.size !== 0) {
            for (const ref of controllerList) {
              const ctrl = ref.deref();
              if (ctrl !== void 0) {
                ctrl.abort(this.reason);
              }
            }
            controllerList.clear();
          }
          dependentControllerMap.delete(ac.signal);
        }
      }
    }
  }
  let patchMethodWarning = false;
  class Request2 {
    /** @type {AbortSignal} */
    #signal;
    /** @type {import('../../dispatcher/dispatcher')} */
    #dispatcher;
    /** @type {Headers} */
    #headers;
    #state;
    // https://fetch.spec.whatwg.org/#dom-request
    constructor(input, init = void 0) {
      webidl.util.markAsUncloneable(this);
      if (input === kConstruct) {
        return;
      }
      const prefix = "Request constructor";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      input = webidl.converters.RequestInfo(input);
      init = webidl.converters.RequestInit(init);
      let request2 = null;
      let fallbackMode = null;
      const baseUrl = environmentSettingsObject.settingsObject.baseUrl;
      let signal = null;
      if (typeof input === "string") {
        this.#dispatcher = init.dispatcher;
        let parsedURL;
        try {
          parsedURL = new URL(input, baseUrl);
        } catch (err) {
          throw new TypeError("Failed to parse URL from " + input, { cause: err });
        }
        if (parsedURL.username || parsedURL.password) {
          throw new TypeError(
            "Request cannot be constructed from a URL that includes credentials: " + input
          );
        }
        request2 = makeRequest({ urlList: [parsedURL] });
        fallbackMode = "cors";
      } else {
        assert(webidl.is.Request(input));
        request2 = input.#state;
        signal = input.#signal;
        this.#dispatcher = init.dispatcher || input.#dispatcher;
      }
      const origin = environmentSettingsObject.settingsObject.origin;
      let window2 = "client";
      if (request2.window?.constructor?.name === "EnvironmentSettingsObject" && sameOrigin(request2.window, origin)) {
        window2 = request2.window;
      }
      if (init.window != null) {
        throw new TypeError(`'window' option '${window2}' must be null`);
      }
      if ("window" in init) {
        window2 = "no-window";
      }
      request2 = makeRequest({
        // URL requests URL.
        // undici implementation note: this is set as the first item in request's urlList in makeRequest
        // method requests method.
        method: request2.method,
        // header list A copy of requests header list.
        // undici implementation note: headersList is cloned in makeRequest
        headersList: request2.headersList,
        // unsafe-request flag Set.
        unsafeRequest: request2.unsafeRequest,
        // client Thiss relevant settings object.
        client: environmentSettingsObject.settingsObject,
        // window window.
        window: window2,
        // priority requests priority.
        priority: request2.priority,
        // origin requests origin. The propagation of the origin is only significant for navigation requests
        // being handled by a service worker. In this scenario a request can have an origin that is different
        // from the current client.
        origin: request2.origin,
        // referrer requests referrer.
        referrer: request2.referrer,
        // referrer policy requests referrer policy.
        referrerPolicy: request2.referrerPolicy,
        // mode requests mode.
        mode: request2.mode,
        // credentials mode requests credentials mode.
        credentials: request2.credentials,
        // cache mode requests cache mode.
        cache: request2.cache,
        // redirect mode requests redirect mode.
        redirect: request2.redirect,
        // integrity metadata requests integrity metadata.
        integrity: request2.integrity,
        // keepalive requests keepalive.
        keepalive: request2.keepalive,
        // reload-navigation flag requests reload-navigation flag.
        reloadNavigation: request2.reloadNavigation,
        // history-navigation flag requests history-navigation flag.
        historyNavigation: request2.historyNavigation,
        // URL list A clone of requests URL list.
        urlList: [...request2.urlList]
      });
      const initHasKey = Object.keys(init).length !== 0;
      if (initHasKey) {
        if (request2.mode === "navigate") {
          request2.mode = "same-origin";
        }
        request2.reloadNavigation = false;
        request2.historyNavigation = false;
        request2.origin = "client";
        request2.referrer = "client";
        request2.referrerPolicy = "";
        request2.url = request2.urlList[request2.urlList.length - 1];
        request2.urlList = [request2.url];
      }
      if (init.referrer !== void 0) {
        const referrer = init.referrer;
        if (referrer === "") {
          request2.referrer = "no-referrer";
        } else {
          let parsedReferrer;
          try {
            parsedReferrer = new URL(referrer, baseUrl);
          } catch (err) {
            throw new TypeError(`Referrer "${referrer}" is not a valid URL.`, { cause: err });
          }
          if (parsedReferrer.protocol === "about:" && parsedReferrer.hostname === "client" || origin && !sameOrigin(parsedReferrer, environmentSettingsObject.settingsObject.baseUrl)) {
            request2.referrer = "client";
          } else {
            request2.referrer = parsedReferrer;
          }
        }
      }
      if (init.referrerPolicy !== void 0) {
        request2.referrerPolicy = init.referrerPolicy;
      }
      let mode;
      if (init.mode !== void 0) {
        mode = init.mode;
      } else {
        mode = fallbackMode;
      }
      if (mode === "navigate") {
        throw webidl.errors.exception({
          header: "Request constructor",
          message: "invalid request mode navigate."
        });
      }
      if (mode != null) {
        request2.mode = mode;
      }
      if (init.credentials !== void 0) {
        request2.credentials = init.credentials;
      }
      if (init.cache !== void 0) {
        request2.cache = init.cache;
      }
      if (request2.cache === "only-if-cached" && request2.mode !== "same-origin") {
        throw new TypeError(
          "'only-if-cached' can be set only with 'same-origin' mode"
        );
      }
      if (init.redirect !== void 0) {
        request2.redirect = init.redirect;
      }
      if (init.integrity != null) {
        request2.integrity = String(init.integrity);
      }
      if (init.keepalive !== void 0) {
        request2.keepalive = Boolean(init.keepalive);
      }
      if (init.method !== void 0) {
        let method = init.method;
        const mayBeNormalized = normalizedMethodRecords[method];
        if (mayBeNormalized !== void 0) {
          request2.method = mayBeNormalized;
        } else {
          if (!isValidHTTPToken(method)) {
            throw new TypeError(`'${method}' is not a valid HTTP method.`);
          }
          const upperCase = method.toUpperCase();
          if (forbiddenMethodsSet.has(upperCase)) {
            throw new TypeError(`'${method}' HTTP method is unsupported.`);
          }
          method = normalizedMethodRecordsBase[upperCase] ?? method;
          request2.method = method;
        }
        if (!patchMethodWarning && request2.method === "patch") {
          process.emitWarning("Using `patch` is highly likely to result in a `405 Method Not Allowed`. `PATCH` is much more likely to succeed.", {
            code: "UNDICI-FETCH-patch"
          });
          patchMethodWarning = true;
        }
      }
      if (init.signal !== void 0) {
        signal = init.signal;
      }
      this.#state = request2;
      const ac = new AbortController();
      this.#signal = ac.signal;
      if (signal != null) {
        if (signal.aborted) {
          ac.abort(signal.reason);
        } else {
          this[kAbortController] = ac;
          const acRef = new WeakRef(ac);
          const abort = buildAbort(acRef);
          if (abortSignalHasEventHandlerLeakWarning && getMaxListeners(signal) === defaultMaxListeners) {
            setMaxListeners(1500, signal);
          }
          util2.addAbortListener(signal, abort);
          requestFinalizer.register(ac, { signal, abort }, abort);
        }
      }
      this.#headers = new Headers2(kConstruct);
      setHeadersList(this.#headers, request2.headersList);
      setHeadersGuard(this.#headers, "request");
      if (mode === "no-cors") {
        if (!corsSafeListedMethodsSet.has(request2.method)) {
          throw new TypeError(
            `'${request2.method} is unsupported in no-cors mode.`
          );
        }
        setHeadersGuard(this.#headers, "request-no-cors");
      }
      if (initHasKey) {
        const headersList = getHeadersList(this.#headers);
        const headers2 = init.headers !== void 0 ? init.headers : new HeadersList(headersList);
        headersList.clear();
        if (headers2 instanceof HeadersList) {
          for (const { name, value } of headers2.rawValues()) {
            headersList.append(name, value, false);
          }
          headersList.cookies = headers2.cookies;
        } else {
          fillHeaders(this.#headers, headers2);
        }
      }
      const inputBody = webidl.is.Request(input) ? input.#state.body : null;
      if ((init.body != null || inputBody != null) && (request2.method === "GET" || request2.method === "HEAD")) {
        throw new TypeError("Request with GET/HEAD method cannot have body.");
      }
      let initBody = null;
      if (init.body != null) {
        const [extractedBody, contentType] = extractBody(
          init.body,
          request2.keepalive
        );
        initBody = extractedBody;
        if (contentType && !getHeadersList(this.#headers).contains("content-type", true)) {
          this.#headers.append("content-type", contentType, true);
        }
      }
      const inputOrInitBody = initBody ?? inputBody;
      if (inputOrInitBody != null && inputOrInitBody.source == null) {
        if (initBody != null && init.duplex == null) {
          throw new TypeError("RequestInit: duplex option is required when sending a body.");
        }
        if (request2.mode !== "same-origin" && request2.mode !== "cors") {
          throw new TypeError(
            'If request is made from ReadableStream, mode should be "same-origin" or "cors"'
          );
        }
        request2.useCORSPreflightFlag = true;
      }
      let finalBody = inputOrInitBody;
      if (initBody == null && inputBody != null) {
        if (bodyUnusable(input.#state)) {
          throw new TypeError(
            "Cannot construct a Request with a Request object that has already been used."
          );
        }
        const identityTransform = new TransformStream();
        inputBody.stream.pipeThrough(identityTransform);
        finalBody = {
          source: inputBody.source,
          length: inputBody.length,
          stream: identityTransform.readable
        };
      }
      this.#state.body = finalBody;
    }
    // Returns requests HTTP method, which is "GET" by default.
    get method() {
      webidl.brandCheck(this, Request2);
      return this.#state.method;
    }
    // Returns the URL of request as a string.
    get url() {
      webidl.brandCheck(this, Request2);
      return URLSerializer(this.#state.url);
    }
    // Returns a Headers object consisting of the headers associated with request.
    // Note that headers added in the network layer by the user agent will not
    // be accounted for in this object, e.g., the "Host" header.
    get headers() {
      webidl.brandCheck(this, Request2);
      return this.#headers;
    }
    // Returns the kind of resource requested by request, e.g., "document"
    // or "script".
    get destination() {
      webidl.brandCheck(this, Request2);
      return this.#state.destination;
    }
    // Returns the referrer of request. Its value can be a same-origin URL if
    // explicitly set in init, the empty string to indicate no referrer, and
    // "about:client" when defaulting to the globals default. This is used
    // during fetching to determine the value of the `Referer` header of the
    // request being made.
    get referrer() {
      webidl.brandCheck(this, Request2);
      if (this.#state.referrer === "no-referrer") {
        return "";
      }
      if (this.#state.referrer === "client") {
        return "about:client";
      }
      return this.#state.referrer.toString();
    }
    // Returns the referrer policy associated with request.
    // This is used during fetching to compute the value of the requests
    // referrer.
    get referrerPolicy() {
      webidl.brandCheck(this, Request2);
      return this.#state.referrerPolicy;
    }
    // Returns the mode associated with request, which is a string indicating
    // whether the request will use CORS, or will be restricted to same-origin
    // URLs.
    get mode() {
      webidl.brandCheck(this, Request2);
      return this.#state.mode;
    }
    // Returns the credentials mode associated with request,
    // which is a string indicating whether credentials will be sent with the
    // request always, never, or only when sent to a same-origin URL.
    get credentials() {
      webidl.brandCheck(this, Request2);
      return this.#state.credentials;
    }
    // Returns the cache mode associated with request,
    // which is a string indicating how the request will
    // interact with the browsers cache when fetching.
    get cache() {
      webidl.brandCheck(this, Request2);
      return this.#state.cache;
    }
    // Returns the redirect mode associated with request,
    // which is a string indicating how redirects for the
    // request will be handled during fetching. A request
    // will follow redirects by default.
    get redirect() {
      webidl.brandCheck(this, Request2);
      return this.#state.redirect;
    }
    // Returns requests subresource integrity metadata, which is a
    // cryptographic hash of the resource being fetched. Its value
    // consists of multiple hashes separated by whitespace. [SRI]
    get integrity() {
      webidl.brandCheck(this, Request2);
      return this.#state.integrity;
    }
    // Returns a boolean indicating whether or not request can outlive the
    // global in which it was created.
    get keepalive() {
      webidl.brandCheck(this, Request2);
      return this.#state.keepalive;
    }
    // Returns a boolean indicating whether or not request is for a reload
    // navigation.
    get isReloadNavigation() {
      webidl.brandCheck(this, Request2);
      return this.#state.reloadNavigation;
    }
    // Returns a boolean indicating whether or not request is for a history
    // navigation (a.k.a. back-forward navigation).
    get isHistoryNavigation() {
      webidl.brandCheck(this, Request2);
      return this.#state.historyNavigation;
    }
    // Returns the signal associated with request, which is an AbortSignal
    // object indicating whether or not request has been aborted, and its
    // abort event handler.
    get signal() {
      webidl.brandCheck(this, Request2);
      return this.#signal;
    }
    get body() {
      webidl.brandCheck(this, Request2);
      return this.#state.body ? this.#state.body.stream : null;
    }
    get bodyUsed() {
      webidl.brandCheck(this, Request2);
      return !!this.#state.body && util2.isDisturbed(this.#state.body.stream);
    }
    get duplex() {
      webidl.brandCheck(this, Request2);
      return "half";
    }
    // Returns a clone of request.
    clone() {
      webidl.brandCheck(this, Request2);
      if (bodyUnusable(this.#state)) {
        throw new TypeError("unusable");
      }
      const clonedRequest = cloneRequest(this.#state);
      const ac = new AbortController();
      if (this.signal.aborted) {
        ac.abort(this.signal.reason);
      } else {
        let list2 = dependentControllerMap.get(this.signal);
        if (list2 === void 0) {
          list2 = /* @__PURE__ */ new Set();
          dependentControllerMap.set(this.signal, list2);
        }
        const acRef = new WeakRef(ac);
        list2.add(acRef);
        util2.addAbortListener(
          ac.signal,
          buildAbort(acRef)
        );
      }
      return fromInnerRequest(clonedRequest, this.#dispatcher, ac.signal, getHeadersGuard(this.#headers));
    }
    [nodeUtil2.inspect.custom](depth, options) {
      if (options.depth === null) {
        options.depth = 2;
      }
      options.colors ??= true;
      const properties = {
        method: this.method,
        url: this.url,
        headers: this.headers,
        destination: this.destination,
        referrer: this.referrer,
        referrerPolicy: this.referrerPolicy,
        mode: this.mode,
        credentials: this.credentials,
        cache: this.cache,
        redirect: this.redirect,
        integrity: this.integrity,
        keepalive: this.keepalive,
        isReloadNavigation: this.isReloadNavigation,
        isHistoryNavigation: this.isHistoryNavigation,
        signal: this.signal
      };
      return `Request ${nodeUtil2.formatWithOptions(options, properties)}`;
    }
    /**
     * @param {Request} request
     * @param {AbortSignal} newSignal
     */
    static setRequestSignal(request2, newSignal) {
      request2.#signal = newSignal;
      return request2;
    }
    /**
     * @param {Request} request
     */
    static getRequestDispatcher(request2) {
      return request2.#dispatcher;
    }
    /**
     * @param {Request} request
     * @param {import('../../dispatcher/dispatcher')} newDispatcher
     */
    static setRequestDispatcher(request2, newDispatcher) {
      request2.#dispatcher = newDispatcher;
    }
    /**
     * @param {Request} request
     * @param {Headers} newHeaders
     */
    static setRequestHeaders(request2, newHeaders) {
      request2.#headers = newHeaders;
    }
    /**
     * @param {Request} request
     */
    static getRequestState(request2) {
      return request2.#state;
    }
    /**
     * @param {Request} request
     * @param {any} newState
     */
    static setRequestState(request2, newState) {
      request2.#state = newState;
    }
  }
  const { setRequestSignal, getRequestDispatcher, setRequestDispatcher, setRequestHeaders, getRequestState, setRequestState } = Request2;
  Reflect.deleteProperty(Request2, "setRequestSignal");
  Reflect.deleteProperty(Request2, "getRequestDispatcher");
  Reflect.deleteProperty(Request2, "setRequestDispatcher");
  Reflect.deleteProperty(Request2, "setRequestHeaders");
  Reflect.deleteProperty(Request2, "getRequestState");
  Reflect.deleteProperty(Request2, "setRequestState");
  mixinBody(Request2, getRequestState);
  function makeRequest(init) {
    return {
      method: init.method ?? "GET",
      localURLsOnly: init.localURLsOnly ?? false,
      unsafeRequest: init.unsafeRequest ?? false,
      body: init.body ?? null,
      client: init.client ?? null,
      reservedClient: init.reservedClient ?? null,
      replacesClientId: init.replacesClientId ?? "",
      window: init.window ?? "client",
      keepalive: init.keepalive ?? false,
      serviceWorkers: init.serviceWorkers ?? "all",
      initiator: init.initiator ?? "",
      destination: init.destination ?? "",
      priority: init.priority ?? null,
      origin: init.origin ?? "client",
      policyContainer: init.policyContainer ?? "client",
      referrer: init.referrer ?? "client",
      referrerPolicy: init.referrerPolicy ?? "",
      mode: init.mode ?? "no-cors",
      useCORSPreflightFlag: init.useCORSPreflightFlag ?? false,
      credentials: init.credentials ?? "same-origin",
      useCredentials: init.useCredentials ?? false,
      cache: init.cache ?? "default",
      redirect: init.redirect ?? "follow",
      integrity: init.integrity ?? "",
      cryptoGraphicsNonceMetadata: init.cryptoGraphicsNonceMetadata ?? "",
      parserMetadata: init.parserMetadata ?? "",
      reloadNavigation: init.reloadNavigation ?? false,
      historyNavigation: init.historyNavigation ?? false,
      userActivation: init.userActivation ?? false,
      taintedOrigin: init.taintedOrigin ?? false,
      redirectCount: init.redirectCount ?? 0,
      responseTainting: init.responseTainting ?? "basic",
      preventNoCacheCacheControlHeaderModification: init.preventNoCacheCacheControlHeaderModification ?? false,
      done: init.done ?? false,
      timingAllowFailed: init.timingAllowFailed ?? false,
      urlList: init.urlList,
      url: init.urlList[0],
      headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList()
    };
  }
  function cloneRequest(request2) {
    const newRequest = makeRequest({ ...request2, body: null });
    if (request2.body != null) {
      newRequest.body = cloneBody(request2.body);
    }
    return newRequest;
  }
  function fromInnerRequest(innerRequest, dispatcher2, signal, guard) {
    const request2 = new Request2(kConstruct);
    setRequestState(request2, innerRequest);
    setRequestDispatcher(request2, dispatcher2);
    setRequestSignal(request2, signal);
    const headers2 = new Headers2(kConstruct);
    setRequestHeaders(request2, headers2);
    setHeadersList(headers2, innerRequest.headersList);
    setHeadersGuard(headers2, guard);
    return request2;
  }
  Object.defineProperties(Request2.prototype, {
    method: kEnumerableProperty,
    url: kEnumerableProperty,
    headers: kEnumerableProperty,
    redirect: kEnumerableProperty,
    clone: kEnumerableProperty,
    signal: kEnumerableProperty,
    duplex: kEnumerableProperty,
    destination: kEnumerableProperty,
    body: kEnumerableProperty,
    bodyUsed: kEnumerableProperty,
    isHistoryNavigation: kEnumerableProperty,
    isReloadNavigation: kEnumerableProperty,
    keepalive: kEnumerableProperty,
    integrity: kEnumerableProperty,
    cache: kEnumerableProperty,
    credentials: kEnumerableProperty,
    attribute: kEnumerableProperty,
    referrerPolicy: kEnumerableProperty,
    referrer: kEnumerableProperty,
    mode: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "Request",
      configurable: true
    }
  });
  webidl.is.Request = webidl.util.MakeTypeAssertion(Request2);
  webidl.converters.RequestInfo = function(V) {
    if (typeof V === "string") {
      return webidl.converters.USVString(V);
    }
    if (webidl.is.Request(V)) {
      return V;
    }
    return webidl.converters.USVString(V);
  };
  webidl.converters.RequestInit = webidl.dictionaryConverter([
    {
      key: "method",
      converter: webidl.converters.ByteString
    },
    {
      key: "headers",
      converter: webidl.converters.HeadersInit
    },
    {
      key: "body",
      converter: webidl.nullableConverter(
        webidl.converters.BodyInit
      )
    },
    {
      key: "referrer",
      converter: webidl.converters.USVString
    },
    {
      key: "referrerPolicy",
      converter: webidl.converters.DOMString,
      // https://w3c.github.io/webappsec-referrer-policy/#referrer-policy
      allowedValues: referrerPolicy
    },
    {
      key: "mode",
      converter: webidl.converters.DOMString,
      // https://fetch.spec.whatwg.org/#concept-request-mode
      allowedValues: requestMode
    },
    {
      key: "credentials",
      converter: webidl.converters.DOMString,
      // https://fetch.spec.whatwg.org/#requestcredentials
      allowedValues: requestCredentials
    },
    {
      key: "cache",
      converter: webidl.converters.DOMString,
      // https://fetch.spec.whatwg.org/#requestcache
      allowedValues: requestCache
    },
    {
      key: "redirect",
      converter: webidl.converters.DOMString,
      // https://fetch.spec.whatwg.org/#requestredirect
      allowedValues: requestRedirect
    },
    {
      key: "integrity",
      converter: webidl.converters.DOMString
    },
    {
      key: "keepalive",
      converter: webidl.converters.boolean
    },
    {
      key: "signal",
      converter: webidl.nullableConverter(
        (signal) => webidl.converters.AbortSignal(
          signal,
          "RequestInit",
          "signal"
        )
      )
    },
    {
      key: "window",
      converter: webidl.converters.any
    },
    {
      key: "duplex",
      converter: webidl.converters.DOMString,
      allowedValues: requestDuplex
    },
    {
      key: "dispatcher",
      // undici specific option
      converter: webidl.converters.any
    },
    {
      key: "priority",
      converter: webidl.converters.DOMString,
      allowedValues: ["high", "low", "auto"],
      defaultValue: () => "auto"
    }
  ]);
  request = {
    Request: Request2,
    makeRequest,
    fromInnerRequest,
    cloneRequest,
    getRequestDispatcher,
    getRequestState
  };
  return request;
}
var subresourceIntegrity;
var hasRequiredSubresourceIntegrity;
function requireSubresourceIntegrity() {
  if (hasRequiredSubresourceIntegrity) return subresourceIntegrity;
  hasRequiredSubresourceIntegrity = 1;
  const assert = import_node_assert.default;
  const { runtimeFeatures: runtimeFeatures2 } = requireRuntimeFeatures();
  const validSRIHashAlgorithmTokenSet = /* @__PURE__ */ new Map([["sha256", 0], ["sha384", 1], ["sha512", 2]]);
  let crypto5;
  if (runtimeFeatures2.has("crypto")) {
    crypto5 = import_node_crypto2.default;
    const cryptoHashes = crypto5.getHashes();
    if (cryptoHashes.length === 0) {
      validSRIHashAlgorithmTokenSet.clear();
    }
    for (const algorithm of validSRIHashAlgorithmTokenSet.keys()) {
      if (cryptoHashes.includes(algorithm) === false) {
        validSRIHashAlgorithmTokenSet.delete(algorithm);
      }
    }
  } else {
    validSRIHashAlgorithmTokenSet.clear();
  }
  const getSRIHashAlgorithmIndex = (
    /** @type {GetSRIHashAlgorithmIndex} */
    Map.prototype.get.bind(
      validSRIHashAlgorithmTokenSet
    )
  );
  const isValidSRIHashAlgorithm = (
    /** @type {IsValidSRIHashAlgorithm} */
    Map.prototype.has.bind(validSRIHashAlgorithmTokenSet)
  );
  const bytesMatch = runtimeFeatures2.has("crypto") === false || validSRIHashAlgorithmTokenSet.size === 0 ? () => true : (bytes, metadataList) => {
    const parsedMetadata = parseMetadata(metadataList);
    if (parsedMetadata.length === 0) {
      return true;
    }
    const metadata = getStrongestMetadata(parsedMetadata);
    for (const item of metadata) {
      const algorithm = item.alg;
      const expectedValue = item.val;
      const actualValue = applyAlgorithmToBytes(algorithm, bytes);
      if (caseSensitiveMatch(actualValue, expectedValue)) {
        return true;
      }
    }
    return false;
  };
  function getStrongestMetadata(metadataList) {
    const result = [];
    let strongest = null;
    for (const item of metadataList) {
      assert(isValidSRIHashAlgorithm(item.alg), "Invalid SRI hash algorithm token");
      if (result.length === 0) {
        result.push(item);
        strongest = item;
        continue;
      }
      const currentAlgorithm = (
        /** @type {Metadata} */
        strongest.alg
      );
      const currentAlgorithmIndex = getSRIHashAlgorithmIndex(currentAlgorithm);
      const newAlgorithm = item.alg;
      const newAlgorithmIndex = getSRIHashAlgorithmIndex(newAlgorithm);
      if (newAlgorithmIndex < currentAlgorithmIndex) {
        continue;
      } else if (newAlgorithmIndex > currentAlgorithmIndex) {
        strongest = item;
        result[0] = item;
        result.length = 1;
      } else {
        result.push(item);
      }
    }
    return result;
  }
  function parseMetadata(metadata) {
    const result = [];
    for (const item of metadata.split(" ")) {
      const expressionAndOptions = item.split("?", 1);
      const algorithmExpression = expressionAndOptions[0];
      let base64Value = "";
      const algorithmAndValue = [algorithmExpression.slice(0, 6), algorithmExpression.slice(7)];
      const algorithm = algorithmAndValue[0];
      if (!isValidSRIHashAlgorithm(algorithm)) {
        continue;
      }
      if (algorithmAndValue[1]) {
        base64Value = algorithmAndValue[1];
      }
      const metadata2 = {
        alg: algorithm,
        val: base64Value
      };
      result.push(metadata2);
    }
    return result;
  }
  const applyAlgorithmToBytes = (algorithm, bytes) => {
    return crypto5.hash(algorithm, bytes, "base64");
  };
  function caseSensitiveMatch(actualValue, expectedValue) {
    let actualValueLength = actualValue.length;
    if (actualValueLength !== 0 && actualValue[actualValueLength - 1] === "=") {
      actualValueLength -= 1;
    }
    if (actualValueLength !== 0 && actualValue[actualValueLength - 1] === "=") {
      actualValueLength -= 1;
    }
    let expectedValueLength = expectedValue.length;
    if (expectedValueLength !== 0 && expectedValue[expectedValueLength - 1] === "=") {
      expectedValueLength -= 1;
    }
    if (expectedValueLength !== 0 && expectedValue[expectedValueLength - 1] === "=") {
      expectedValueLength -= 1;
    }
    if (actualValueLength !== expectedValueLength) {
      return false;
    }
    for (let i4 = 0; i4 < actualValueLength; ++i4) {
      if (actualValue[i4] === expectedValue[i4] || actualValue[i4] === "+" && expectedValue[i4] === "-" || actualValue[i4] === "/" && expectedValue[i4] === "_") {
        continue;
      }
      return false;
    }
    return true;
  }
  subresourceIntegrity = {
    applyAlgorithmToBytes,
    bytesMatch,
    caseSensitiveMatch,
    isValidSRIHashAlgorithm,
    getStrongestMetadata,
    parseMetadata
  };
  return subresourceIntegrity;
}
var fetch_1;
var hasRequiredFetch;
function requireFetch() {
  if (hasRequiredFetch) return fetch_1;
  hasRequiredFetch = 1;
  const {
    makeNetworkError,
    makeAppropriateNetworkError,
    filterResponse,
    makeResponse,
    fromInnerResponse,
    getResponseState
  } = requireResponse();
  const { HeadersList } = requireHeaders();
  const { Request: Request2, cloneRequest, getRequestDispatcher, getRequestState } = requireRequest();
  const zlib2 = import_node_zlib.default;
  const {
    makePolicyContainer,
    clonePolicyContainer,
    requestBadPort,
    TAOCheck,
    appendRequestOriginHeader,
    responseLocationURL,
    requestCurrentURL,
    setRequestReferrerPolicyOnRedirect,
    tryUpgradeRequestToAPotentiallyTrustworthyURL,
    createOpaqueTimingInfo,
    appendFetchMetadata,
    corsCheck,
    crossOriginResourcePolicyCheck,
    determineRequestsReferrer,
    coarsenedSharedCurrentTime,
    sameOrigin,
    isCancelled,
    isAborted,
    isErrorLike,
    fullyReadBody,
    readableStreamClose,
    urlIsLocal,
    urlIsHttpHttpsScheme,
    urlHasHttpsScheme,
    clampAndCoarsenConnectionTimingInfo,
    simpleRangeHeaderValue,
    buildContentRange,
    createInflate,
    extractMimeType
  } = requireUtil$4();
  const assert = import_node_assert.default;
  const { safelyExtractBody, extractBody } = requireBody();
  const {
    redirectStatusSet,
    nullBodyStatus,
    safeMethodsSet,
    requestBodyHeader,
    subresourceSet
  } = requireConstants$2();
  const EE = import_node_events.default;
  const { Readable: Readable2, pipeline, finished, isErrored, isReadable } = import_node_stream.default;
  const { addAbortListener, bufferToLowerCasedHeaderName } = requireUtil$5();
  const { dataURLProcessor, serializeAMimeType, minimizeSupportedMimeType } = requireDataUrl();
  const { getGlobalDispatcher } = requireGlobal();
  const { webidl } = requireWebidl();
  const { STATUS_CODES } = import_node_http.default;
  const { bytesMatch } = requireSubresourceIntegrity();
  const { createDeferredPromise } = requirePromise();
  const { isomorphicEncode } = requireInfra();
  const { runtimeFeatures: runtimeFeatures2 } = requireRuntimeFeatures();
  const hasZstd = runtimeFeatures2.has("zstd");
  const GET_OR_HEAD = ["GET", "HEAD"];
  const defaultUserAgent = typeof __UNDICI_IS_NODE__ !== "undefined" || typeof esbuildDetection !== "undefined" ? "node" : "undici";
  let resolveObjectURL;
  class Fetch extends EE {
    constructor(dispatcher2) {
      super();
      this.dispatcher = dispatcher2;
      this.connection = null;
      this.dump = false;
      this.state = "ongoing";
    }
    terminate(reason) {
      if (this.state !== "ongoing") {
        return;
      }
      this.state = "terminated";
      this.connection?.destroy(reason);
      this.emit("terminated", reason);
    }
    // https://fetch.spec.whatwg.org/#fetch-controller-abort
    abort(error2) {
      if (this.state !== "ongoing") {
        return;
      }
      this.state = "aborted";
      if (!error2) {
        error2 = new DOMException("The operation was aborted.", "AbortError");
      }
      this.serializedAbortReason = error2;
      this.connection?.destroy(error2);
      this.emit("terminated", error2);
    }
  }
  function handleFetchDone(response2) {
    finalizeAndReportTiming(response2, "fetch");
  }
  function fetch3(input, init = void 0) {
    webidl.argumentLengthCheck(arguments, 1, "globalThis.fetch");
    let p4 = createDeferredPromise();
    let requestObject;
    try {
      requestObject = new Request2(input, init);
    } catch (e4) {
      p4.reject(e4);
      return p4.promise;
    }
    const request2 = getRequestState(requestObject);
    if (requestObject.signal.aborted) {
      abortFetch(p4, request2, null, requestObject.signal.reason);
      return p4.promise;
    }
    const globalObject = request2.client.globalObject;
    if (globalObject?.constructor?.name === "ServiceWorkerGlobalScope") {
      request2.serviceWorkers = "none";
    }
    let responseObject = null;
    let locallyAborted = false;
    let controller = null;
    addAbortListener(
      requestObject.signal,
      () => {
        locallyAborted = true;
        assert(controller != null);
        controller.abort(requestObject.signal.reason);
        const realResponse = responseObject?.deref();
        abortFetch(p4, request2, realResponse, requestObject.signal.reason);
      }
    );
    const processResponse = (response2) => {
      if (locallyAborted) {
        return;
      }
      if (response2.aborted) {
        abortFetch(p4, request2, responseObject, controller.serializedAbortReason);
        return;
      }
      if (response2.type === "error") {
        p4.reject(new TypeError("fetch failed", { cause: response2.error }));
        return;
      }
      responseObject = new WeakRef(fromInnerResponse(response2, "immutable"));
      p4.resolve(responseObject.deref());
      p4 = null;
    };
    controller = fetching({
      request: request2,
      processResponseEndOfBody: handleFetchDone,
      processResponse,
      dispatcher: getRequestDispatcher(requestObject)
      // undici
    });
    return p4.promise;
  }
  function finalizeAndReportTiming(response2, initiatorType = "other") {
    if (response2.type === "error" && response2.aborted) {
      return;
    }
    if (!response2.urlList?.length) {
      return;
    }
    const originalURL = response2.urlList[0];
    let timingInfo = response2.timingInfo;
    let cacheState = response2.cacheState;
    if (!urlIsHttpHttpsScheme(originalURL)) {
      return;
    }
    if (timingInfo === null) {
      return;
    }
    if (!response2.timingAllowPassed) {
      timingInfo = createOpaqueTimingInfo({
        startTime: timingInfo.startTime
      });
      cacheState = "";
    }
    timingInfo.endTime = coarsenedSharedCurrentTime();
    response2.timingInfo = timingInfo;
    markResourceTiming(
      timingInfo,
      originalURL.href,
      initiatorType,
      globalThis,
      cacheState,
      "",
      // bodyType
      response2.status
    );
  }
  const markResourceTiming = performance.markResourceTiming;
  function abortFetch(p4, request2, responseObject, error2) {
    if (p4) {
      p4.reject(error2);
    }
    if (request2.body?.stream != null && isReadable(request2.body.stream)) {
      request2.body.stream.cancel(error2).catch((err) => {
        if (err.code === "ERR_INVALID_STATE") {
          return;
        }
        throw err;
      });
    }
    if (responseObject == null) {
      return;
    }
    const response2 = getResponseState(responseObject);
    if (response2.body?.stream != null && isReadable(response2.body.stream)) {
      response2.body.stream.cancel(error2).catch((err) => {
        if (err.code === "ERR_INVALID_STATE") {
          return;
        }
        throw err;
      });
    }
  }
  function fetching({
    request: request2,
    processRequestBodyChunkLength,
    processRequestEndOfBody,
    processResponse,
    processResponseEndOfBody,
    processResponseConsumeBody,
    useParallelQueue = false,
    dispatcher: dispatcher2 = getGlobalDispatcher()
    // undici
  }) {
    assert(dispatcher2);
    let taskDestination = null;
    let crossOriginIsolatedCapability = false;
    if (request2.client != null) {
      taskDestination = request2.client.globalObject;
      crossOriginIsolatedCapability = request2.client.crossOriginIsolatedCapability;
    }
    const currentTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability);
    const timingInfo = createOpaqueTimingInfo({
      startTime: currentTime
    });
    const fetchParams = {
      controller: new Fetch(dispatcher2),
      request: request2,
      timingInfo,
      processRequestBodyChunkLength,
      processRequestEndOfBody,
      processResponse,
      processResponseConsumeBody,
      processResponseEndOfBody,
      taskDestination,
      crossOriginIsolatedCapability
    };
    assert(!request2.body || request2.body.stream);
    if (request2.window === "client") {
      request2.window = request2.client?.globalObject?.constructor?.name === "Window" ? request2.client : "no-window";
    }
    if (request2.origin === "client") {
      request2.origin = request2.client.origin;
    }
    if (request2.policyContainer === "client") {
      if (request2.client != null) {
        request2.policyContainer = clonePolicyContainer(
          request2.client.policyContainer
        );
      } else {
        request2.policyContainer = makePolicyContainer();
      }
    }
    if (!request2.headersList.contains("accept", true)) {
      const value = "*/*";
      request2.headersList.append("accept", value, true);
    }
    if (!request2.headersList.contains("accept-language", true)) {
      request2.headersList.append("accept-language", "*", true);
    }
    if (request2.priority === null) ;
    if (subresourceSet.has(request2.destination)) ;
    mainFetch(fetchParams, false);
    return fetchParams.controller;
  }
  async function mainFetch(fetchParams, recursive) {
    try {
      const request2 = fetchParams.request;
      let response2 = null;
      if (request2.localURLsOnly && !urlIsLocal(requestCurrentURL(request2))) {
        response2 = makeNetworkError("local URLs only");
      }
      tryUpgradeRequestToAPotentiallyTrustworthyURL(request2);
      if (requestBadPort(request2) === "blocked") {
        response2 = makeNetworkError("bad port");
      }
      if (request2.referrerPolicy === "") {
        request2.referrerPolicy = request2.policyContainer.referrerPolicy;
      }
      if (request2.referrer !== "no-referrer") {
        request2.referrer = determineRequestsReferrer(request2);
      }
      if (response2 === null) {
        const currentURL = requestCurrentURL(request2);
        if (
          // - requests current URLs origin is same origin with requests origin,
          //   and requests response tainting is "basic"
          sameOrigin(currentURL, request2.url) && request2.responseTainting === "basic" || // requests current URLs scheme is "data"
          currentURL.protocol === "data:" || // - requests mode is "navigate" or "websocket"
          (request2.mode === "navigate" || request2.mode === "websocket")
        ) {
          request2.responseTainting = "basic";
          response2 = await schemeFetch(fetchParams);
        } else if (request2.mode === "same-origin") {
          response2 = makeNetworkError('request mode cannot be "same-origin"');
        } else if (request2.mode === "no-cors") {
          if (request2.redirect !== "follow") {
            response2 = makeNetworkError(
              'redirect mode cannot be "follow" for "no-cors" request'
            );
          } else {
            request2.responseTainting = "opaque";
            response2 = await schemeFetch(fetchParams);
          }
        } else if (!urlIsHttpHttpsScheme(requestCurrentURL(request2))) {
          response2 = makeNetworkError("URL scheme must be a HTTP(S) scheme");
        } else {
          request2.responseTainting = "cors";
          response2 = await httpFetch(fetchParams);
        }
      }
      if (recursive) {
        return response2;
      }
      if (response2.status !== 0 && !response2.internalResponse) {
        if (request2.responseTainting === "cors") {
        }
        if (request2.responseTainting === "basic") {
          response2 = filterResponse(response2, "basic");
        } else if (request2.responseTainting === "cors") {
          response2 = filterResponse(response2, "cors");
        } else if (request2.responseTainting === "opaque") {
          response2 = filterResponse(response2, "opaque");
        } else {
          assert(false);
        }
      }
      let internalResponse = response2.status === 0 ? response2 : response2.internalResponse;
      if (internalResponse.urlList.length === 0) {
        internalResponse.urlList.push(...request2.urlList);
      }
      if (!request2.timingAllowFailed) {
        response2.timingAllowPassed = true;
      }
      if (response2.type === "opaque" && internalResponse.status === 206 && internalResponse.rangeRequested && !request2.headers.contains("range", true)) {
        response2 = internalResponse = makeNetworkError();
      }
      if (response2.status !== 0 && (request2.method === "HEAD" || request2.method === "CONNECT" || nullBodyStatus.includes(internalResponse.status))) {
        internalResponse.body = null;
        fetchParams.controller.dump = true;
      }
      if (request2.integrity) {
        const processBodyError = (reason) => fetchFinale(fetchParams, makeNetworkError(reason));
        if (request2.responseTainting === "opaque" || response2.body == null) {
          processBodyError(response2.error);
          return;
        }
        const processBody2 = (bytes) => {
          if (!bytesMatch(bytes, request2.integrity)) {
            processBodyError("integrity mismatch");
            return;
          }
          response2.body = safelyExtractBody(bytes)[0];
          fetchFinale(fetchParams, response2);
        };
        fullyReadBody(response2.body, processBody2, processBodyError);
      } else {
        fetchFinale(fetchParams, response2);
      }
    } catch (err) {
      fetchParams.controller.terminate(err);
    }
  }
  function schemeFetch(fetchParams) {
    if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) {
      return Promise.resolve(makeAppropriateNetworkError(fetchParams));
    }
    const { request: request2 } = fetchParams;
    const { protocol: scheme } = requestCurrentURL(request2);
    switch (scheme) {
      case "about:": {
        return Promise.resolve(makeNetworkError("about scheme is not supported"));
      }
      case "blob:": {
        if (!resolveObjectURL) {
          resolveObjectURL = import_node_buffer.default.resolveObjectURL;
        }
        const blobURLEntry = requestCurrentURL(request2);
        if (blobURLEntry.search.length !== 0) {
          return Promise.resolve(makeNetworkError("NetworkError when attempting to fetch resource."));
        }
        const blob = resolveObjectURL(blobURLEntry.toString());
        if (request2.method !== "GET" || !webidl.is.Blob(blob)) {
          return Promise.resolve(makeNetworkError("invalid method"));
        }
        const response2 = makeResponse();
        const fullLength = blob.size;
        const serializedFullLength = isomorphicEncode(`${fullLength}`);
        const type = blob.type;
        if (!request2.headersList.contains("range", true)) {
          const bodyWithType = extractBody(blob);
          response2.statusText = "OK";
          response2.body = bodyWithType[0];
          response2.headersList.set("content-length", serializedFullLength, true);
          response2.headersList.set("content-type", type, true);
        } else {
          response2.rangeRequested = true;
          const rangeHeader = request2.headersList.get("range", true);
          const rangeValue = simpleRangeHeaderValue(rangeHeader, true);
          if (rangeValue === "failure") {
            return Promise.resolve(makeNetworkError("failed to fetch the data URL"));
          }
          let { rangeStartValue: rangeStart, rangeEndValue: rangeEnd } = rangeValue;
          if (rangeStart === null) {
            rangeStart = fullLength - rangeEnd;
            rangeEnd = rangeStart + rangeEnd - 1;
          } else {
            if (rangeStart >= fullLength) {
              return Promise.resolve(makeNetworkError("Range start is greater than the blob's size."));
            }
            if (rangeEnd === null || rangeEnd >= fullLength) {
              rangeEnd = fullLength - 1;
            }
          }
          const slicedBlob = blob.slice(rangeStart, rangeEnd + 1, type);
          const slicedBodyWithType = extractBody(slicedBlob);
          response2.body = slicedBodyWithType[0];
          const serializedSlicedLength = isomorphicEncode(`${slicedBlob.size}`);
          const contentRange = buildContentRange(rangeStart, rangeEnd, fullLength);
          response2.status = 206;
          response2.statusText = "Partial Content";
          response2.headersList.set("content-length", serializedSlicedLength, true);
          response2.headersList.set("content-type", type, true);
          response2.headersList.set("content-range", contentRange, true);
        }
        return Promise.resolve(response2);
      }
      case "data:": {
        const currentURL = requestCurrentURL(request2);
        const dataURLStruct = dataURLProcessor(currentURL);
        if (dataURLStruct === "failure") {
          return Promise.resolve(makeNetworkError("failed to fetch the data URL"));
        }
        const mimeType = serializeAMimeType(dataURLStruct.mimeType);
        return Promise.resolve(makeResponse({
          statusText: "OK",
          headersList: [
            ["content-type", { name: "Content-Type", value: mimeType }]
          ],
          body: safelyExtractBody(dataURLStruct.body)[0]
        }));
      }
      case "file:": {
        return Promise.resolve(makeNetworkError("not implemented... yet..."));
      }
      case "http:":
      case "https:": {
        return httpFetch(fetchParams).catch((err) => makeNetworkError(err));
      }
      default: {
        return Promise.resolve(makeNetworkError("unknown scheme"));
      }
    }
  }
  function finalizeResponse(fetchParams, response2) {
    fetchParams.request.done = true;
    if (fetchParams.processResponseDone != null) {
      queueMicrotask(() => fetchParams.processResponseDone(response2));
    }
  }
  function fetchFinale(fetchParams, response2) {
    let timingInfo = fetchParams.timingInfo;
    const processResponseEndOfBody = () => {
      const unsafeEndTime = Date.now();
      if (fetchParams.request.destination === "document") {
        fetchParams.controller.fullTimingInfo = timingInfo;
      }
      fetchParams.controller.reportTimingSteps = () => {
        if (!urlIsHttpHttpsScheme(fetchParams.request.url)) {
          return;
        }
        timingInfo.endTime = unsafeEndTime;
        let cacheState = response2.cacheState;
        const bodyInfo = response2.bodyInfo;
        if (!response2.timingAllowPassed) {
          timingInfo = createOpaqueTimingInfo(timingInfo);
          cacheState = "";
        }
        let responseStatus = 0;
        if (fetchParams.request.mode !== "navigator" || !response2.hasCrossOriginRedirects) {
          responseStatus = response2.status;
          const mimeType = extractMimeType(response2.headersList);
          if (mimeType !== "failure") {
            bodyInfo.contentType = minimizeSupportedMimeType(mimeType);
          }
        }
        if (fetchParams.request.initiatorType != null) {
          markResourceTiming(timingInfo, fetchParams.request.url.href, fetchParams.request.initiatorType, globalThis, cacheState, bodyInfo, responseStatus);
        }
      };
      const processResponseEndOfBodyTask = () => {
        fetchParams.request.done = true;
        if (fetchParams.processResponseEndOfBody != null) {
          queueMicrotask(() => fetchParams.processResponseEndOfBody(response2));
        }
        if (fetchParams.request.initiatorType != null) {
          fetchParams.controller.reportTimingSteps();
        }
      };
      queueMicrotask(() => processResponseEndOfBodyTask());
    };
    if (fetchParams.processResponse != null) {
      queueMicrotask(() => {
        fetchParams.processResponse(response2);
        fetchParams.processResponse = null;
      });
    }
    const internalResponse = response2.type === "error" ? response2 : response2.internalResponse ?? response2;
    if (internalResponse.body == null) {
      processResponseEndOfBody();
    } else {
      finished(internalResponse.body.stream, () => {
        processResponseEndOfBody();
      });
    }
  }
  async function httpFetch(fetchParams) {
    const request2 = fetchParams.request;
    let response2 = null;
    let actualResponse = null;
    const timingInfo = fetchParams.timingInfo;
    if (request2.serviceWorkers === "all") ;
    if (response2 === null) {
      if (request2.redirect === "follow") {
        request2.serviceWorkers = "none";
      }
      actualResponse = response2 = await httpNetworkOrCacheFetch(fetchParams);
      if (request2.responseTainting === "cors" && corsCheck(request2, response2) === "failure") {
        return makeNetworkError("cors failure");
      }
      if (TAOCheck(request2, response2) === "failure") {
        request2.timingAllowFailed = true;
      }
    }
    if ((request2.responseTainting === "opaque" || response2.type === "opaque") && crossOriginResourcePolicyCheck(
      request2.origin,
      request2.client,
      request2.destination,
      actualResponse
    ) === "blocked") {
      return makeNetworkError("blocked");
    }
    if (redirectStatusSet.has(actualResponse.status)) {
      if (request2.redirect !== "manual") {
        fetchParams.controller.connection.destroy(void 0, false);
      }
      if (request2.redirect === "error") {
        response2 = makeNetworkError("unexpected redirect");
      } else if (request2.redirect === "manual") {
        response2 = actualResponse;
      } else if (request2.redirect === "follow") {
        response2 = await httpRedirectFetch(fetchParams, response2);
      } else {
        assert(false);
      }
    }
    response2.timingInfo = timingInfo;
    return response2;
  }
  function httpRedirectFetch(fetchParams, response2) {
    const request2 = fetchParams.request;
    const actualResponse = response2.internalResponse ? response2.internalResponse : response2;
    let locationURL;
    try {
      locationURL = responseLocationURL(
        actualResponse,
        requestCurrentURL(request2).hash
      );
      if (locationURL == null) {
        return response2;
      }
    } catch (err) {
      return Promise.resolve(makeNetworkError(err));
    }
    if (!urlIsHttpHttpsScheme(locationURL)) {
      return Promise.resolve(makeNetworkError("URL scheme must be a HTTP(S) scheme"));
    }
    if (request2.redirectCount === 20) {
      return Promise.resolve(makeNetworkError("redirect count exceeded"));
    }
    request2.redirectCount += 1;
    if (request2.mode === "cors" && (locationURL.username || locationURL.password) && !sameOrigin(request2, locationURL)) {
      return Promise.resolve(makeNetworkError('cross origin not allowed for request mode "cors"'));
    }
    if (request2.responseTainting === "cors" && (locationURL.username || locationURL.password)) {
      return Promise.resolve(makeNetworkError(
        'URL cannot contain credentials for request mode "cors"'
      ));
    }
    if (actualResponse.status !== 303 && request2.body != null && request2.body.source == null) {
      return Promise.resolve(makeNetworkError());
    }
    if ([301, 302].includes(actualResponse.status) && request2.method === "POST" || actualResponse.status === 303 && !GET_OR_HEAD.includes(request2.method)) {
      request2.method = "GET";
      request2.body = null;
      for (const headerName of requestBodyHeader) {
        request2.headersList.delete(headerName);
      }
    }
    if (!sameOrigin(requestCurrentURL(request2), locationURL)) {
      request2.headersList.delete("authorization", true);
      request2.headersList.delete("proxy-authorization", true);
      request2.headersList.delete("cookie", true);
      request2.headersList.delete("host", true);
    }
    if (request2.body != null) {
      assert(request2.body.source != null);
      request2.body = safelyExtractBody(request2.body.source)[0];
    }
    const timingInfo = fetchParams.timingInfo;
    timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
    if (timingInfo.redirectStartTime === 0) {
      timingInfo.redirectStartTime = timingInfo.startTime;
    }
    request2.urlList.push(locationURL);
    setRequestReferrerPolicyOnRedirect(request2, actualResponse);
    return mainFetch(fetchParams, true);
  }
  async function httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch = false, isNewConnectionFetch = false) {
    const request2 = fetchParams.request;
    let httpFetchParams = null;
    let httpRequest = null;
    let response2 = null;
    if (request2.window === "no-window" && request2.redirect === "error") {
      httpFetchParams = fetchParams;
      httpRequest = request2;
    } else {
      httpRequest = cloneRequest(request2);
      httpFetchParams = { ...fetchParams };
      httpFetchParams.request = httpRequest;
    }
    const includeCredentials = request2.credentials === "include" || request2.credentials === "same-origin" && request2.responseTainting === "basic";
    const contentLength = httpRequest.body ? httpRequest.body.length : null;
    let contentLengthHeaderValue = null;
    if (httpRequest.body == null && ["POST", "PUT"].includes(httpRequest.method)) {
      contentLengthHeaderValue = "0";
    }
    if (contentLength != null) {
      contentLengthHeaderValue = isomorphicEncode(`${contentLength}`);
    }
    if (contentLengthHeaderValue != null) {
      httpRequest.headersList.append("content-length", contentLengthHeaderValue, true);
    }
    if (contentLength != null && httpRequest.keepalive) ;
    if (webidl.is.URL(httpRequest.referrer)) {
      httpRequest.headersList.append("referer", isomorphicEncode(httpRequest.referrer.href), true);
    }
    appendRequestOriginHeader(httpRequest);
    appendFetchMetadata(httpRequest);
    if (!httpRequest.headersList.contains("user-agent", true)) {
      httpRequest.headersList.append("user-agent", defaultUserAgent, true);
    }
    if (httpRequest.cache === "default" && (httpRequest.headersList.contains("if-modified-since", true) || httpRequest.headersList.contains("if-none-match", true) || httpRequest.headersList.contains("if-unmodified-since", true) || httpRequest.headersList.contains("if-match", true) || httpRequest.headersList.contains("if-range", true))) {
      httpRequest.cache = "no-store";
    }
    if (httpRequest.cache === "no-cache" && !httpRequest.preventNoCacheCacheControlHeaderModification && !httpRequest.headersList.contains("cache-control", true)) {
      httpRequest.headersList.append("cache-control", "max-age=0", true);
    }
    if (httpRequest.cache === "no-store" || httpRequest.cache === "reload") {
      if (!httpRequest.headersList.contains("pragma", true)) {
        httpRequest.headersList.append("pragma", "no-cache", true);
      }
      if (!httpRequest.headersList.contains("cache-control", true)) {
        httpRequest.headersList.append("cache-control", "no-cache", true);
      }
    }
    if (httpRequest.headersList.contains("range", true)) {
      httpRequest.headersList.append("accept-encoding", "identity", true);
    }
    if (!httpRequest.headersList.contains("accept-encoding", true)) {
      if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) {
        httpRequest.headersList.append("accept-encoding", "br, gzip, deflate", true);
      } else {
        httpRequest.headersList.append("accept-encoding", "gzip, deflate", true);
      }
    }
    httpRequest.headersList.delete("host", true);
    {
      httpRequest.cache = "no-store";
    }
    if (httpRequest.cache !== "no-store" && httpRequest.cache !== "reload") ;
    if (response2 == null) {
      if (httpRequest.cache === "only-if-cached") {
        return makeNetworkError("only if cached");
      }
      const forwardResponse = await httpNetworkFetch(
        httpFetchParams,
        includeCredentials,
        isNewConnectionFetch
      );
      if (!safeMethodsSet.has(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status <= 399) ;
      if (response2 == null) {
        response2 = forwardResponse;
      }
    }
    response2.urlList = [...httpRequest.urlList];
    if (httpRequest.headersList.contains("range", true)) {
      response2.rangeRequested = true;
    }
    response2.requestIncludesCredentials = includeCredentials;
    if (response2.status === 407) {
      if (request2.window === "no-window") {
        return makeNetworkError();
      }
      if (isCancelled(fetchParams)) {
        return makeAppropriateNetworkError(fetchParams);
      }
      return makeNetworkError("proxy authentication required");
    }
    if (
      // responses status is 421
      response2.status === 421 && // isNewConnectionFetch is false
      !isNewConnectionFetch && // requests body is null, or requests body is non-null and requests bodys source is non-null
      (request2.body == null || request2.body.source != null)
    ) {
      if (isCancelled(fetchParams)) {
        return makeAppropriateNetworkError(fetchParams);
      }
      fetchParams.controller.connection.destroy();
      response2 = await httpNetworkOrCacheFetch(
        fetchParams,
        isAuthenticationFetch,
        true
      );
    }
    return response2;
  }
  async function httpNetworkFetch(fetchParams, includeCredentials = false, forceNewConnection = false) {
    assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);
    fetchParams.controller.connection = {
      abort: null,
      destroyed: false,
      destroy(err, abort = true) {
        if (!this.destroyed) {
          this.destroyed = true;
          if (abort) {
            this.abort?.(err ?? new DOMException("The operation was aborted.", "AbortError"));
          }
        }
      }
    };
    const request2 = fetchParams.request;
    let response2 = null;
    const timingInfo = fetchParams.timingInfo;
    {
      request2.cache = "no-store";
    }
    if (request2.mode === "websocket") ;
    let requestBody = null;
    if (request2.body == null && fetchParams.processRequestEndOfBody) {
      queueMicrotask(() => fetchParams.processRequestEndOfBody());
    } else if (request2.body != null) {
      const processBodyChunk = async function* (bytes) {
        if (isCancelled(fetchParams)) {
          return;
        }
        yield bytes;
        fetchParams.processRequestBodyChunkLength?.(bytes.byteLength);
      };
      const processEndOfBody = () => {
        if (isCancelled(fetchParams)) {
          return;
        }
        if (fetchParams.processRequestEndOfBody) {
          fetchParams.processRequestEndOfBody();
        }
      };
      const processBodyError = (e4) => {
        if (isCancelled(fetchParams)) {
          return;
        }
        if (e4.name === "AbortError") {
          fetchParams.controller.abort();
        } else {
          fetchParams.controller.terminate(e4);
        }
      };
      requestBody = (async function* () {
        try {
          for await (const bytes of request2.body.stream) {
            yield* processBodyChunk(bytes);
          }
          processEndOfBody();
        } catch (err) {
          processBodyError(err);
        }
      })();
    }
    try {
      const { body: body2, status, statusText, headersList, socket } = await dispatch({ body: requestBody });
      if (socket) {
        response2 = makeResponse({ status, statusText, headersList, socket });
      } else {
        const iterator = body2[Symbol.asyncIterator]();
        fetchParams.controller.next = () => iterator.next();
        response2 = makeResponse({ status, statusText, headersList });
      }
    } catch (err) {
      if (err.name === "AbortError") {
        fetchParams.controller.connection.destroy();
        return makeAppropriateNetworkError(fetchParams, err);
      }
      return makeNetworkError(err);
    }
    const pullAlgorithm = () => {
      return fetchParams.controller.resume();
    };
    const cancelAlgorithm = (reason) => {
      if (!isCancelled(fetchParams)) {
        fetchParams.controller.abort(reason);
      }
    };
    const stream = new ReadableStream(
      {
        start(controller) {
          fetchParams.controller.controller = controller;
        },
        pull: pullAlgorithm,
        cancel: cancelAlgorithm,
        type: "bytes"
      }
    );
    response2.body = { stream, source: null, length: null };
    if (!fetchParams.controller.resume) {
      fetchParams.controller.on("terminated", onAborted);
    }
    fetchParams.controller.resume = async () => {
      while (true) {
        let bytes;
        let isFailure;
        try {
          const { done, value } = await fetchParams.controller.next();
          if (isAborted(fetchParams)) {
            break;
          }
          bytes = done ? void 0 : value;
        } catch (err) {
          if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {
            bytes = void 0;
          } else {
            bytes = err;
            isFailure = true;
          }
        }
        if (bytes === void 0) {
          readableStreamClose(fetchParams.controller.controller);
          finalizeResponse(fetchParams, response2);
          return;
        }
        timingInfo.decodedBodySize += bytes?.byteLength ?? 0;
        if (isFailure) {
          fetchParams.controller.terminate(bytes);
          return;
        }
        const buffer = new Uint8Array(bytes);
        if (buffer.byteLength) {
          fetchParams.controller.controller.enqueue(buffer);
        }
        if (isErrored(stream)) {
          fetchParams.controller.terminate();
          return;
        }
        if (fetchParams.controller.controller.desiredSize <= 0) {
          return;
        }
      }
    };
    function onAborted(reason) {
      if (isAborted(fetchParams)) {
        response2.aborted = true;
        if (isReadable(stream)) {
          fetchParams.controller.controller.error(
            fetchParams.controller.serializedAbortReason
          );
        }
      } else {
        if (isReadable(stream)) {
          fetchParams.controller.controller.error(new TypeError("terminated", {
            cause: isErrorLike(reason) ? reason : void 0
          }));
        }
      }
      fetchParams.controller.connection.destroy();
    }
    return response2;
    function dispatch({ body: body2 }) {
      const url = requestCurrentURL(request2);
      const agent2 = fetchParams.controller.dispatcher;
      return new Promise((resolve, reject) => agent2.dispatch(
        {
          path: url.pathname + url.search,
          origin: url.origin,
          method: request2.method,
          body: agent2.isMockActive ? request2.body && (request2.body.source || request2.body.stream) : body2,
          headers: request2.headersList.entries,
          maxRedirections: 0,
          upgrade: request2.mode === "websocket" ? "websocket" : void 0
        },
        {
          body: null,
          abort: null,
          onConnect(abort) {
            const { connection: connection2 } = fetchParams.controller;
            timingInfo.finalConnectionTimingInfo = clampAndCoarsenConnectionTimingInfo(void 0, timingInfo.postRedirectStartTime, fetchParams.crossOriginIsolatedCapability);
            if (connection2.destroyed) {
              abort(new DOMException("The operation was aborted.", "AbortError"));
            } else {
              fetchParams.controller.on("terminated", abort);
              this.abort = connection2.abort = abort;
            }
            timingInfo.finalNetworkRequestStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
          },
          onResponseStarted() {
            timingInfo.finalNetworkResponseStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
          },
          onHeaders(status, rawHeaders, resume, statusText) {
            if (status < 200) {
              return false;
            }
            const headersList = new HeadersList();
            for (let i4 = 0; i4 < rawHeaders.length; i4 += 2) {
              headersList.append(bufferToLowerCasedHeaderName(rawHeaders[i4]), rawHeaders[i4 + 1].toString("latin1"), true);
            }
            const location = headersList.get("location", true);
            this.body = new Readable2({ read: resume });
            const willFollow = location && request2.redirect === "follow" && redirectStatusSet.has(status);
            const decoders = [];
            if (request2.method !== "HEAD" && request2.method !== "CONNECT" && !nullBodyStatus.includes(status) && !willFollow) {
              const contentEncoding = headersList.get("content-encoding", true);
              const codings = contentEncoding ? contentEncoding.toLowerCase().split(",") : [];
              const maxContentEncodings = 5;
              if (codings.length > maxContentEncodings) {
                reject(new Error(`too many content-encodings in response: ${codings.length}, maximum allowed is ${maxContentEncodings}`));
                return true;
              }
              for (let i4 = codings.length - 1; i4 >= 0; --i4) {
                const coding = codings[i4].trim();
                if (coding === "x-gzip" || coding === "gzip") {
                  decoders.push(zlib2.createGunzip({
                    // Be less strict when decoding compressed responses, since sometimes
                    // servers send slightly invalid responses that are still accepted
                    // by common browsers.
                    // Always using Z_SYNC_FLUSH is what cURL does.
                    flush: zlib2.constants.Z_SYNC_FLUSH,
                    finishFlush: zlib2.constants.Z_SYNC_FLUSH
                  }));
                } else if (coding === "deflate") {
                  decoders.push(createInflate({
                    flush: zlib2.constants.Z_SYNC_FLUSH,
                    finishFlush: zlib2.constants.Z_SYNC_FLUSH
                  }));
                } else if (coding === "br") {
                  decoders.push(zlib2.createBrotliDecompress({
                    flush: zlib2.constants.BROTLI_OPERATION_FLUSH,
                    finishFlush: zlib2.constants.BROTLI_OPERATION_FLUSH
                  }));
                } else if (coding === "zstd" && hasZstd) {
                  decoders.push(zlib2.createZstdDecompress({
                    flush: zlib2.constants.ZSTD_e_continue,
                    finishFlush: zlib2.constants.ZSTD_e_end
                  }));
                } else {
                  decoders.length = 0;
                  break;
                }
              }
            }
            const onError = this.onError.bind(this);
            resolve({
              status,
              statusText,
              headersList,
              body: decoders.length ? pipeline(this.body, ...decoders, (err) => {
                if (err) {
                  this.onError(err);
                }
              }).on("error", onError) : this.body.on("error", onError)
            });
            return true;
          },
          onData(chunk2) {
            if (fetchParams.controller.dump) {
              return;
            }
            const bytes = chunk2;
            timingInfo.encodedBodySize += bytes.byteLength;
            return this.body.push(bytes);
          },
          onComplete() {
            if (this.abort) {
              fetchParams.controller.off("terminated", this.abort);
            }
            fetchParams.controller.ended = true;
            this.body.push(null);
          },
          onError(error2) {
            if (this.abort) {
              fetchParams.controller.off("terminated", this.abort);
            }
            this.body?.destroy(error2);
            fetchParams.controller.terminate(error2);
            reject(error2);
          },
          onUpgrade(status, rawHeaders, socket) {
            if (socket.session != null && status !== 200 || socket.session == null && status !== 101) {
              return false;
            }
            const headersList = new HeadersList();
            for (let i4 = 0; i4 < rawHeaders.length; i4 += 2) {
              headersList.append(bufferToLowerCasedHeaderName(rawHeaders[i4]), rawHeaders[i4 + 1].toString("latin1"), true);
            }
            resolve({
              status,
              statusText: STATUS_CODES[status],
              headersList,
              socket
            });
            return true;
          }
        }
      ));
    }
  }
  fetch_1 = {
    fetch: fetch3,
    Fetch,
    fetching,
    finalizeAndReportTiming
  };
  return fetch_1;
}
var util$3;
var hasRequiredUtil$3;
function requireUtil$3() {
  if (hasRequiredUtil$3) return util$3;
  hasRequiredUtil$3 = 1;
  const assert = import_node_assert.default;
  const { URLSerializer } = requireDataUrl();
  const { isValidHeaderName } = requireUtil$4();
  function urlEquals(A2, B2, excludeFragment = false) {
    const serializedA = URLSerializer(A2, excludeFragment);
    const serializedB = URLSerializer(B2, excludeFragment);
    return serializedA === serializedB;
  }
  function getFieldValues(header) {
    assert(header !== null);
    const values = [];
    for (let value of header.split(",")) {
      value = value.trim();
      if (isValidHeaderName(value)) {
        values.push(value);
      }
    }
    return values;
  }
  util$3 = {
    urlEquals,
    getFieldValues
  };
  return util$3;
}
var cache4;
var hasRequiredCache;
function requireCache() {
  if (hasRequiredCache) return cache4;
  hasRequiredCache = 1;
  const assert = import_node_assert.default;
  const { kConstruct } = requireSymbols();
  const { urlEquals, getFieldValues } = requireUtil$3();
  const { kEnumerableProperty, isDisturbed } = requireUtil$5();
  const { webidl } = requireWebidl();
  const { cloneResponse, fromInnerResponse, getResponseState } = requireResponse();
  const { Request: Request2, fromInnerRequest, getRequestState } = requireRequest();
  const { fetching } = requireFetch();
  const { urlIsHttpHttpsScheme, readAllBytes } = requireUtil$4();
  const { createDeferredPromise } = requirePromise();
  class Cache {
    /**
     * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-request-response-list
     * @type {requestResponseList}
     */
    #relevantRequestResponseList;
    constructor() {
      if (arguments[0] !== kConstruct) {
        webidl.illegalConstructor();
      }
      webidl.util.markAsUncloneable(this);
      this.#relevantRequestResponseList = arguments[1];
    }
    async match(request2, options = {}) {
      webidl.brandCheck(this, Cache);
      const prefix = "Cache.match";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      request2 = webidl.converters.RequestInfo(request2);
      options = webidl.converters.CacheQueryOptions(options, prefix, "options");
      const p4 = this.#internalMatchAll(request2, options, 1);
      if (p4.length === 0) {
        return;
      }
      return p4[0];
    }
    async matchAll(request2 = void 0, options = {}) {
      webidl.brandCheck(this, Cache);
      const prefix = "Cache.matchAll";
      if (request2 !== void 0) request2 = webidl.converters.RequestInfo(request2);
      options = webidl.converters.CacheQueryOptions(options, prefix, "options");
      return this.#internalMatchAll(request2, options);
    }
    async add(request2) {
      webidl.brandCheck(this, Cache);
      const prefix = "Cache.add";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      request2 = webidl.converters.RequestInfo(request2);
      const requests = [request2];
      const responseArrayPromise = this.addAll(requests);
      return await responseArrayPromise;
    }
    async addAll(requests) {
      webidl.brandCheck(this, Cache);
      const prefix = "Cache.addAll";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      const responsePromises = [];
      const requestList = [];
      for (let request2 of requests) {
        if (request2 === void 0) {
          throw webidl.errors.conversionFailed({
            prefix,
            argument: "Argument 1",
            types: ["undefined is not allowed"]
          });
        }
        request2 = webidl.converters.RequestInfo(request2);
        if (typeof request2 === "string") {
          continue;
        }
        const r4 = getRequestState(request2);
        if (!urlIsHttpHttpsScheme(r4.url) || r4.method !== "GET") {
          throw webidl.errors.exception({
            header: prefix,
            message: "Expected http/s scheme when method is not GET."
          });
        }
      }
      const fetchControllers = [];
      for (const request2 of requests) {
        const r4 = getRequestState(new Request2(request2));
        if (!urlIsHttpHttpsScheme(r4.url)) {
          throw webidl.errors.exception({
            header: prefix,
            message: "Expected http/s scheme."
          });
        }
        r4.initiator = "fetch";
        r4.destination = "subresource";
        requestList.push(r4);
        const responsePromise = createDeferredPromise();
        fetchControllers.push(fetching({
          request: r4,
          processResponse(response2) {
            if (response2.type === "error" || response2.status === 206 || response2.status < 200 || response2.status > 299) {
              responsePromise.reject(webidl.errors.exception({
                header: "Cache.addAll",
                message: "Received an invalid status code or the request failed."
              }));
            } else if (response2.headersList.contains("vary")) {
              const fieldValues = getFieldValues(response2.headersList.get("vary"));
              for (const fieldValue of fieldValues) {
                if (fieldValue === "*") {
                  responsePromise.reject(webidl.errors.exception({
                    header: "Cache.addAll",
                    message: "invalid vary field value"
                  }));
                  for (const controller of fetchControllers) {
                    controller.abort();
                  }
                  return;
                }
              }
            }
          },
          processResponseEndOfBody(response2) {
            if (response2.aborted) {
              responsePromise.reject(new DOMException("aborted", "AbortError"));
              return;
            }
            responsePromise.resolve(response2);
          }
        }));
        responsePromises.push(responsePromise.promise);
      }
      const p4 = Promise.all(responsePromises);
      const responses = await p4;
      const operations = [];
      let index = 0;
      for (const response2 of responses) {
        const operation2 = {
          type: "put",
          // 7.3.2
          request: requestList[index],
          // 7.3.3
          response: response2
          // 7.3.4
        };
        operations.push(operation2);
        index++;
      }
      const cacheJobPromise = createDeferredPromise();
      let errorData = null;
      try {
        this.#batchCacheOperations(operations);
      } catch (e4) {
        errorData = e4;
      }
      queueMicrotask(() => {
        if (errorData === null) {
          cacheJobPromise.resolve(void 0);
        } else {
          cacheJobPromise.reject(errorData);
        }
      });
      return cacheJobPromise.promise;
    }
    async put(request2, response2) {
      webidl.brandCheck(this, Cache);
      const prefix = "Cache.put";
      webidl.argumentLengthCheck(arguments, 2, prefix);
      request2 = webidl.converters.RequestInfo(request2);
      response2 = webidl.converters.Response(response2, prefix, "response");
      let innerRequest = null;
      if (webidl.is.Request(request2)) {
        innerRequest = getRequestState(request2);
      } else {
        innerRequest = getRequestState(new Request2(request2));
      }
      if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== "GET") {
        throw webidl.errors.exception({
          header: prefix,
          message: "Expected an http/s scheme when method is not GET"
        });
      }
      const innerResponse = getResponseState(response2);
      if (innerResponse.status === 206) {
        throw webidl.errors.exception({
          header: prefix,
          message: "Got 206 status"
        });
      }
      if (innerResponse.headersList.contains("vary")) {
        const fieldValues = getFieldValues(innerResponse.headersList.get("vary"));
        for (const fieldValue of fieldValues) {
          if (fieldValue === "*") {
            throw webidl.errors.exception({
              header: prefix,
              message: "Got * vary field value"
            });
          }
        }
      }
      if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)) {
        throw webidl.errors.exception({
          header: prefix,
          message: "Response body is locked or disturbed"
        });
      }
      const clonedResponse = cloneResponse(innerResponse);
      const bodyReadPromise = createDeferredPromise();
      if (innerResponse.body != null) {
        const stream = innerResponse.body.stream;
        const reader = stream.getReader();
        readAllBytes(reader, bodyReadPromise.resolve, bodyReadPromise.reject);
      } else {
        bodyReadPromise.resolve(void 0);
      }
      const operations = [];
      const operation2 = {
        type: "put",
        // 14.
        request: innerRequest,
        // 15.
        response: clonedResponse
        // 16.
      };
      operations.push(operation2);
      const bytes = await bodyReadPromise.promise;
      if (clonedResponse.body != null) {
        clonedResponse.body.source = bytes;
      }
      const cacheJobPromise = createDeferredPromise();
      let errorData = null;
      try {
        this.#batchCacheOperations(operations);
      } catch (e4) {
        errorData = e4;
      }
      queueMicrotask(() => {
        if (errorData === null) {
          cacheJobPromise.resolve();
        } else {
          cacheJobPromise.reject(errorData);
        }
      });
      return cacheJobPromise.promise;
    }
    async delete(request2, options = {}) {
      webidl.brandCheck(this, Cache);
      const prefix = "Cache.delete";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      request2 = webidl.converters.RequestInfo(request2);
      options = webidl.converters.CacheQueryOptions(options, prefix, "options");
      let r4 = null;
      if (webidl.is.Request(request2)) {
        r4 = getRequestState(request2);
        if (r4.method !== "GET" && !options.ignoreMethod) {
          return false;
        }
      } else {
        assert(typeof request2 === "string");
        r4 = getRequestState(new Request2(request2));
      }
      const operations = [];
      const operation2 = {
        type: "delete",
        request: r4,
        options
      };
      operations.push(operation2);
      const cacheJobPromise = createDeferredPromise();
      let errorData = null;
      let requestResponses;
      try {
        requestResponses = this.#batchCacheOperations(operations);
      } catch (e4) {
        errorData = e4;
      }
      queueMicrotask(() => {
        if (errorData === null) {
          cacheJobPromise.resolve(!!requestResponses?.length);
        } else {
          cacheJobPromise.reject(errorData);
        }
      });
      return cacheJobPromise.promise;
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#dom-cache-keys
     * @param {any} request
     * @param {import('../../../types/cache').CacheQueryOptions} options
     * @returns {Promise<readonly Request[]>}
     */
    async keys(request2 = void 0, options = {}) {
      webidl.brandCheck(this, Cache);
      const prefix = "Cache.keys";
      if (request2 !== void 0) request2 = webidl.converters.RequestInfo(request2);
      options = webidl.converters.CacheQueryOptions(options, prefix, "options");
      let r4 = null;
      if (request2 !== void 0) {
        if (webidl.is.Request(request2)) {
          r4 = getRequestState(request2);
          if (r4.method !== "GET" && !options.ignoreMethod) {
            return [];
          }
        } else if (typeof request2 === "string") {
          r4 = getRequestState(new Request2(request2));
        }
      }
      const promise2 = createDeferredPromise();
      const requests = [];
      if (request2 === void 0) {
        for (const requestResponse of this.#relevantRequestResponseList) {
          requests.push(requestResponse[0]);
        }
      } else {
        const requestResponses = this.#queryCache(r4, options);
        for (const requestResponse of requestResponses) {
          requests.push(requestResponse[0]);
        }
      }
      queueMicrotask(() => {
        const requestList = [];
        for (const request3 of requests) {
          const requestObject = fromInnerRequest(
            request3,
            void 0,
            new AbortController().signal,
            "immutable"
          );
          requestList.push(requestObject);
        }
        promise2.resolve(Object.freeze(requestList));
      });
      return promise2.promise;
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#batch-cache-operations-algorithm
     * @param {CacheBatchOperation[]} operations
     * @returns {requestResponseList}
     */
    #batchCacheOperations(operations) {
      const cache5 = this.#relevantRequestResponseList;
      const backupCache = [...cache5];
      const addedItems = [];
      const resultList = [];
      try {
        for (const operation2 of operations) {
          if (operation2.type !== "delete" && operation2.type !== "put") {
            throw webidl.errors.exception({
              header: "Cache.#batchCacheOperations",
              message: 'operation type does not match "delete" or "put"'
            });
          }
          if (operation2.type === "delete" && operation2.response != null) {
            throw webidl.errors.exception({
              header: "Cache.#batchCacheOperations",
              message: "delete operation should not have an associated response"
            });
          }
          if (this.#queryCache(operation2.request, operation2.options, addedItems).length) {
            throw new DOMException("???", "InvalidStateError");
          }
          let requestResponses;
          if (operation2.type === "delete") {
            requestResponses = this.#queryCache(operation2.request, operation2.options);
            if (requestResponses.length === 0) {
              return [];
            }
            for (const requestResponse of requestResponses) {
              const idx = cache5.indexOf(requestResponse);
              assert(idx !== -1);
              cache5.splice(idx, 1);
            }
          } else if (operation2.type === "put") {
            if (operation2.response == null) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "put operation should have an associated response"
              });
            }
            const r4 = operation2.request;
            if (!urlIsHttpHttpsScheme(r4.url)) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "expected http or https scheme"
              });
            }
            if (r4.method !== "GET") {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "not get method"
              });
            }
            if (operation2.options != null) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "options must not be defined"
              });
            }
            requestResponses = this.#queryCache(operation2.request);
            for (const requestResponse of requestResponses) {
              const idx = cache5.indexOf(requestResponse);
              assert(idx !== -1);
              cache5.splice(idx, 1);
            }
            cache5.push([operation2.request, operation2.response]);
            addedItems.push([operation2.request, operation2.response]);
          }
          resultList.push([operation2.request, operation2.response]);
        }
        return resultList;
      } catch (e4) {
        this.#relevantRequestResponseList.length = 0;
        this.#relevantRequestResponseList = backupCache;
        throw e4;
      }
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#query-cache
     * @param {any} requestQuery
     * @param {import('../../../types/cache').CacheQueryOptions} options
     * @param {requestResponseList} targetStorage
     * @returns {requestResponseList}
     */
    #queryCache(requestQuery, options, targetStorage) {
      const resultList = [];
      const storage = targetStorage ?? this.#relevantRequestResponseList;
      for (const requestResponse of storage) {
        const [cachedRequest, cachedResponse] = requestResponse;
        if (this.#requestMatchesCachedItem(requestQuery, cachedRequest, cachedResponse, options)) {
          resultList.push(requestResponse);
        }
      }
      return resultList;
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#request-matches-cached-item-algorithm
     * @param {any} requestQuery
     * @param {any} request
     * @param {any | null} response
     * @param {import('../../../types/cache').CacheQueryOptions | undefined} options
     * @returns {boolean}
     */
    #requestMatchesCachedItem(requestQuery, request2, response2 = null, options) {
      const queryURL = new URL(requestQuery.url);
      const cachedURL = new URL(request2.url);
      if (options?.ignoreSearch) {
        cachedURL.search = "";
        queryURL.search = "";
      }
      if (!urlEquals(queryURL, cachedURL, true)) {
        return false;
      }
      if (response2 == null || options?.ignoreVary || !response2.headersList.contains("vary")) {
        return true;
      }
      const fieldValues = getFieldValues(response2.headersList.get("vary"));
      for (const fieldValue of fieldValues) {
        if (fieldValue === "*") {
          return false;
        }
        const requestValue = request2.headersList.get(fieldValue);
        const queryValue = requestQuery.headersList.get(fieldValue);
        if (requestValue !== queryValue) {
          return false;
        }
      }
      return true;
    }
    #internalMatchAll(request2, options, maxResponses = Infinity) {
      let r4 = null;
      if (request2 !== void 0) {
        if (webidl.is.Request(request2)) {
          r4 = getRequestState(request2);
          if (r4.method !== "GET" && !options.ignoreMethod) {
            return [];
          }
        } else if (typeof request2 === "string") {
          r4 = getRequestState(new Request2(request2));
        }
      }
      const responses = [];
      if (request2 === void 0) {
        for (const requestResponse of this.#relevantRequestResponseList) {
          responses.push(requestResponse[1]);
        }
      } else {
        const requestResponses = this.#queryCache(r4, options);
        for (const requestResponse of requestResponses) {
          responses.push(requestResponse[1]);
        }
      }
      const responseList = [];
      for (const response2 of responses) {
        const responseObject = fromInnerResponse(response2, "immutable");
        responseList.push(responseObject.clone());
        if (responseList.length >= maxResponses) {
          break;
        }
      }
      return Object.freeze(responseList);
    }
  }
  Object.defineProperties(Cache.prototype, {
    [Symbol.toStringTag]: {
      value: "Cache",
      configurable: true
    },
    match: kEnumerableProperty,
    matchAll: kEnumerableProperty,
    add: kEnumerableProperty,
    addAll: kEnumerableProperty,
    put: kEnumerableProperty,
    delete: kEnumerableProperty,
    keys: kEnumerableProperty
  });
  const cacheQueryOptionConverters = [
    {
      key: "ignoreSearch",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "ignoreMethod",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "ignoreVary",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    }
  ];
  webidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters);
  webidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([
    ...cacheQueryOptionConverters,
    {
      key: "cacheName",
      converter: webidl.converters.DOMString
    }
  ]);
  webidl.converters.Response = webidl.interfaceConverter(
    webidl.is.Response,
    "Response"
  );
  webidl.converters["sequence<RequestInfo>"] = webidl.sequenceConverter(
    webidl.converters.RequestInfo
  );
  cache4 = {
    Cache
  };
  return cache4;
}
var cachestorage;
var hasRequiredCachestorage;
function requireCachestorage() {
  if (hasRequiredCachestorage) return cachestorage;
  hasRequiredCachestorage = 1;
  const { Cache } = requireCache();
  const { webidl } = requireWebidl();
  const { kEnumerableProperty } = requireUtil$5();
  const { kConstruct } = requireSymbols();
  class CacheStorage {
    /**
     * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-name-to-cache-map
     * @type {Map<string, import('./cache').requestResponseList}
     */
    #caches = /* @__PURE__ */ new Map();
    constructor() {
      if (arguments[0] !== kConstruct) {
        webidl.illegalConstructor();
      }
      webidl.util.markAsUncloneable(this);
    }
    async match(request2, options = {}) {
      webidl.brandCheck(this, CacheStorage);
      webidl.argumentLengthCheck(arguments, 1, "CacheStorage.match");
      request2 = webidl.converters.RequestInfo(request2);
      options = webidl.converters.MultiCacheQueryOptions(options);
      if (options.cacheName != null) {
        if (this.#caches.has(options.cacheName)) {
          const cacheList = this.#caches.get(options.cacheName);
          const cache5 = new Cache(kConstruct, cacheList);
          return await cache5.match(request2, options);
        }
      } else {
        for (const cacheList of this.#caches.values()) {
          const cache5 = new Cache(kConstruct, cacheList);
          const response2 = await cache5.match(request2, options);
          if (response2 !== void 0) {
            return response2;
          }
        }
      }
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#cache-storage-has
     * @param {string} cacheName
     * @returns {Promise<boolean>}
     */
    async has(cacheName) {
      webidl.brandCheck(this, CacheStorage);
      const prefix = "CacheStorage.has";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      cacheName = webidl.converters.DOMString(cacheName, prefix, "cacheName");
      return this.#caches.has(cacheName);
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#dom-cachestorage-open
     * @param {string} cacheName
     * @returns {Promise<Cache>}
     */
    async open(cacheName) {
      webidl.brandCheck(this, CacheStorage);
      const prefix = "CacheStorage.open";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      cacheName = webidl.converters.DOMString(cacheName, prefix, "cacheName");
      if (this.#caches.has(cacheName)) {
        const cache6 = this.#caches.get(cacheName);
        return new Cache(kConstruct, cache6);
      }
      const cache5 = [];
      this.#caches.set(cacheName, cache5);
      return new Cache(kConstruct, cache5);
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#cache-storage-delete
     * @param {string} cacheName
     * @returns {Promise<boolean>}
     */
    async delete(cacheName) {
      webidl.brandCheck(this, CacheStorage);
      const prefix = "CacheStorage.delete";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      cacheName = webidl.converters.DOMString(cacheName, prefix, "cacheName");
      return this.#caches.delete(cacheName);
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#cache-storage-keys
     * @returns {Promise<string[]>}
     */
    async keys() {
      webidl.brandCheck(this, CacheStorage);
      const keys2 = this.#caches.keys();
      return [...keys2];
    }
  }
  Object.defineProperties(CacheStorage.prototype, {
    [Symbol.toStringTag]: {
      value: "CacheStorage",
      configurable: true
    },
    match: kEnumerableProperty,
    has: kEnumerableProperty,
    open: kEnumerableProperty,
    delete: kEnumerableProperty,
    keys: kEnumerableProperty
  });
  cachestorage = {
    CacheStorage
  };
  return cachestorage;
}
var constants$1;
var hasRequiredConstants$1;
function requireConstants$1() {
  if (hasRequiredConstants$1) return constants$1;
  hasRequiredConstants$1 = 1;
  const maxAttributeValueSize = 1024;
  const maxNameValuePairSize = 4096;
  constants$1 = {
    maxAttributeValueSize,
    maxNameValuePairSize
  };
  return constants$1;
}
var util$2;
var hasRequiredUtil$2;
function requireUtil$2() {
  if (hasRequiredUtil$2) return util$2;
  hasRequiredUtil$2 = 1;
  function isCTLExcludingHtab(value) {
    for (let i4 = 0; i4 < value.length; ++i4) {
      const code = value.charCodeAt(i4);
      if (code >= 0 && code <= 8 || code >= 10 && code <= 31 || code === 127) {
        return true;
      }
    }
    return false;
  }
  function validateCookieName(name) {
    for (let i4 = 0; i4 < name.length; ++i4) {
      const code = name.charCodeAt(i4);
      if (code < 33 || // exclude CTLs (0-31), SP and HT
      code > 126 || // exclude non-ascii and DEL
      code === 34 || // "
      code === 40 || // (
      code === 41 || // )
      code === 60 || // <
      code === 62 || // >
      code === 64 || // @
      code === 44 || // ,
      code === 59 || // ;
      code === 58 || // :
      code === 92 || // \
      code === 47 || // /
      code === 91 || // [
      code === 93 || // ]
      code === 63 || // ?
      code === 61 || // =
      code === 123 || // {
      code === 125) {
        throw new Error("Invalid cookie name");
      }
    }
  }
  function validateCookieValue(value) {
    let len = value.length;
    let i4 = 0;
    if (value[0] === '"') {
      if (len === 1 || value[len - 1] !== '"') {
        throw new Error("Invalid cookie value");
      }
      --len;
      ++i4;
    }
    while (i4 < len) {
      const code = value.charCodeAt(i4++);
      if (code < 33 || // exclude CTLs (0-31)
      code > 126 || // non-ascii and DEL (127)
      code === 34 || // "
      code === 44 || // ,
      code === 59 || // ;
      code === 92) {
        throw new Error("Invalid cookie value");
      }
    }
  }
  function validateCookiePath(path3) {
    for (let i4 = 0; i4 < path3.length; ++i4) {
      const code = path3.charCodeAt(i4);
      if (code < 32 || // exclude CTLs (0-31)
      code === 127 || // DEL
      code === 59) {
        throw new Error("Invalid cookie path");
      }
    }
  }
  function validateCookieDomain(domain) {
    if (domain.startsWith("-") || domain.endsWith(".") || domain.endsWith("-")) {
      throw new Error("Invalid cookie domain");
    }
  }
  const IMFDays = [
    "Sun",
    "Mon",
    "Tue",
    "Wed",
    "Thu",
    "Fri",
    "Sat"
  ];
  const IMFMonths = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  const IMFPaddedNumbers = Array(61).fill(0).map((_, i4) => i4.toString().padStart(2, "0"));
  function toIMFDate(date3) {
    if (typeof date3 === "number") {
      date3 = new Date(date3);
    }
    return `${IMFDays[date3.getUTCDay()]}, ${IMFPaddedNumbers[date3.getUTCDate()]} ${IMFMonths[date3.getUTCMonth()]} ${date3.getUTCFullYear()} ${IMFPaddedNumbers[date3.getUTCHours()]}:${IMFPaddedNumbers[date3.getUTCMinutes()]}:${IMFPaddedNumbers[date3.getUTCSeconds()]} GMT`;
  }
  function validateCookieMaxAge(maxAge) {
    if (maxAge < 0) {
      throw new Error("Invalid cookie max-age");
    }
  }
  function stringify(cookie) {
    if (cookie.name.length === 0) {
      return null;
    }
    validateCookieName(cookie.name);
    validateCookieValue(cookie.value);
    const out = [`${cookie.name}=${cookie.value}`];
    if (cookie.name.startsWith("__Secure-")) {
      cookie.secure = true;
    }
    if (cookie.name.startsWith("__Host-")) {
      cookie.secure = true;
      cookie.domain = null;
      cookie.path = "/";
    }
    if (cookie.secure) {
      out.push("Secure");
    }
    if (cookie.httpOnly) {
      out.push("HttpOnly");
    }
    if (typeof cookie.maxAge === "number") {
      validateCookieMaxAge(cookie.maxAge);
      out.push(`Max-Age=${cookie.maxAge}`);
    }
    if (cookie.domain) {
      validateCookieDomain(cookie.domain);
      out.push(`Domain=${cookie.domain}`);
    }
    if (cookie.path) {
      validateCookiePath(cookie.path);
      out.push(`Path=${cookie.path}`);
    }
    if (cookie.expires && cookie.expires.toString() !== "Invalid Date") {
      out.push(`Expires=${toIMFDate(cookie.expires)}`);
    }
    if (cookie.sameSite) {
      out.push(`SameSite=${cookie.sameSite}`);
    }
    for (const part of cookie.unparsed) {
      if (!part.includes("=")) {
        throw new Error("Invalid unparsed");
      }
      const [key, ...value] = part.split("=");
      out.push(`${key.trim()}=${value.join("=")}`);
    }
    return out.join("; ");
  }
  util$2 = {
    isCTLExcludingHtab,
    validateCookieName,
    validateCookiePath,
    validateCookieValue,
    toIMFDate,
    stringify
  };
  return util$2;
}
var parse$4;
var hasRequiredParse;
function requireParse() {
  if (hasRequiredParse) return parse$4;
  hasRequiredParse = 1;
  const { collectASequenceOfCodePointsFast } = requireInfra();
  const { maxNameValuePairSize, maxAttributeValueSize } = requireConstants$1();
  const { isCTLExcludingHtab } = requireUtil$2();
  const assert = import_node_assert.default;
  const { unescape: qsUnescape } = import_node_querystring.default;
  function parseSetCookie(header) {
    if (isCTLExcludingHtab(header)) {
      return null;
    }
    let nameValuePair = "";
    let unparsedAttributes = "";
    let name = "";
    let value = "";
    if (header.includes(";")) {
      const position = { position: 0 };
      nameValuePair = collectASequenceOfCodePointsFast(";", header, position);
      unparsedAttributes = header.slice(position.position);
    } else {
      nameValuePair = header;
    }
    if (!nameValuePair.includes("=")) {
      value = nameValuePair;
    } else {
      const position = { position: 0 };
      name = collectASequenceOfCodePointsFast(
        "=",
        nameValuePair,
        position
      );
      value = nameValuePair.slice(position.position + 1);
    }
    name = name.trim();
    value = value.trim();
    if (name.length + value.length > maxNameValuePairSize) {
      return null;
    }
    return {
      name,
      value: qsUnescape(value),
      ...parseUnparsedAttributes(unparsedAttributes)
    };
  }
  function parseUnparsedAttributes(unparsedAttributes, cookieAttributeList = {}) {
    if (unparsedAttributes.length === 0) {
      return cookieAttributeList;
    }
    assert(unparsedAttributes[0] === ";");
    unparsedAttributes = unparsedAttributes.slice(1);
    let cookieAv = "";
    if (unparsedAttributes.includes(";")) {
      cookieAv = collectASequenceOfCodePointsFast(
        ";",
        unparsedAttributes,
        { position: 0 }
      );
      unparsedAttributes = unparsedAttributes.slice(cookieAv.length);
    } else {
      cookieAv = unparsedAttributes;
      unparsedAttributes = "";
    }
    let attributeName = "";
    let attributeValue = "";
    if (cookieAv.includes("=")) {
      const position = { position: 0 };
      attributeName = collectASequenceOfCodePointsFast(
        "=",
        cookieAv,
        position
      );
      attributeValue = cookieAv.slice(position.position + 1);
    } else {
      attributeName = cookieAv;
    }
    attributeName = attributeName.trim();
    attributeValue = attributeValue.trim();
    if (attributeValue.length > maxAttributeValueSize) {
      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
    }
    const attributeNameLowercase = attributeName.toLowerCase();
    if (attributeNameLowercase === "expires") {
      const expiryTime = new Date(attributeValue);
      cookieAttributeList.expires = expiryTime;
    } else if (attributeNameLowercase === "max-age") {
      const charCode = attributeValue.charCodeAt(0);
      if ((charCode < 48 || charCode > 57) && attributeValue[0] !== "-") {
        return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
      }
      if (!/^\d+$/.test(attributeValue)) {
        return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
      }
      const deltaSeconds = Number(attributeValue);
      cookieAttributeList.maxAge = deltaSeconds;
    } else if (attributeNameLowercase === "domain") {
      let cookieDomain = attributeValue;
      if (cookieDomain[0] === ".") {
        cookieDomain = cookieDomain.slice(1);
      }
      cookieDomain = cookieDomain.toLowerCase();
      cookieAttributeList.domain = cookieDomain;
    } else if (attributeNameLowercase === "path") {
      let cookiePath = "";
      if (attributeValue.length === 0 || attributeValue[0] !== "/") {
        cookiePath = "/";
      } else {
        cookiePath = attributeValue;
      }
      cookieAttributeList.path = cookiePath;
    } else if (attributeNameLowercase === "secure") {
      cookieAttributeList.secure = true;
    } else if (attributeNameLowercase === "httponly") {
      cookieAttributeList.httpOnly = true;
    } else if (attributeNameLowercase === "samesite") {
      let enforcement = "Default";
      const attributeValueLowercase = attributeValue.toLowerCase();
      if (attributeValueLowercase.includes("none")) {
        enforcement = "None";
      }
      if (attributeValueLowercase.includes("strict")) {
        enforcement = "Strict";
      }
      if (attributeValueLowercase.includes("lax")) {
        enforcement = "Lax";
      }
      cookieAttributeList.sameSite = enforcement;
    } else {
      cookieAttributeList.unparsed ??= [];
      cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`);
    }
    return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
  }
  parse$4 = {
    parseSetCookie,
    parseUnparsedAttributes
  };
  return parse$4;
}
var cookies;
var hasRequiredCookies;
function requireCookies() {
  if (hasRequiredCookies) return cookies;
  hasRequiredCookies = 1;
  const { parseSetCookie } = requireParse();
  const { stringify } = requireUtil$2();
  const { webidl } = requireWebidl();
  const { Headers: Headers2 } = requireHeaders();
  const brandChecks = webidl.brandCheckMultiple([Headers2, globalThis.Headers].filter(Boolean));
  function getCookies(headers2) {
    webidl.argumentLengthCheck(arguments, 1, "getCookies");
    brandChecks(headers2);
    const cookie = headers2.get("cookie");
    const out = {};
    if (!cookie) {
      return out;
    }
    for (const piece of cookie.split(";")) {
      const [name, ...value] = piece.split("=");
      out[name.trim()] = value.join("=");
    }
    return out;
  }
  function deleteCookie(headers2, name, attributes) {
    brandChecks(headers2);
    const prefix = "deleteCookie";
    webidl.argumentLengthCheck(arguments, 2, prefix);
    name = webidl.converters.DOMString(name, prefix, "name");
    attributes = webidl.converters.DeleteCookieAttributes(attributes);
    setCookie(headers2, {
      name,
      value: "",
      expires: /* @__PURE__ */ new Date(0),
      ...attributes
    });
  }
  function getSetCookies(headers2) {
    webidl.argumentLengthCheck(arguments, 1, "getSetCookies");
    brandChecks(headers2);
    const cookies2 = headers2.getSetCookie();
    if (!cookies2) {
      return [];
    }
    return cookies2.map((pair) => parseSetCookie(pair));
  }
  function parseCookie(cookie) {
    cookie = webidl.converters.DOMString(cookie);
    return parseSetCookie(cookie);
  }
  function setCookie(headers2, cookie) {
    webidl.argumentLengthCheck(arguments, 2, "setCookie");
    brandChecks(headers2);
    cookie = webidl.converters.Cookie(cookie);
    const str = stringify(cookie);
    if (str) {
      headers2.append("set-cookie", str, true);
    }
  }
  webidl.converters.DeleteCookieAttributes = webidl.dictionaryConverter([
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "path",
      defaultValue: () => null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "domain",
      defaultValue: () => null
    }
  ]);
  webidl.converters.Cookie = webidl.dictionaryConverter([
    {
      converter: webidl.converters.DOMString,
      key: "name"
    },
    {
      converter: webidl.converters.DOMString,
      key: "value"
    },
    {
      converter: webidl.nullableConverter((value) => {
        if (typeof value === "number") {
          return webidl.converters["unsigned long long"](value);
        }
        return new Date(value);
      }),
      key: "expires",
      defaultValue: () => null
    },
    {
      converter: webidl.nullableConverter(webidl.converters["long long"]),
      key: "maxAge",
      defaultValue: () => null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "domain",
      defaultValue: () => null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "path",
      defaultValue: () => null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.boolean),
      key: "secure",
      defaultValue: () => null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.boolean),
      key: "httpOnly",
      defaultValue: () => null
    },
    {
      converter: webidl.converters.USVString,
      key: "sameSite",
      allowedValues: ["Strict", "Lax", "None"]
    },
    {
      converter: webidl.sequenceConverter(webidl.converters.DOMString),
      key: "unparsed",
      defaultValue: () => []
    }
  ]);
  cookies = {
    getCookies,
    deleteCookie,
    getSetCookies,
    setCookie,
    parseCookie
  };
  return cookies;
}
var events;
var hasRequiredEvents;
function requireEvents() {
  if (hasRequiredEvents) return events;
  hasRequiredEvents = 1;
  const { webidl } = requireWebidl();
  const { kEnumerableProperty } = requireUtil$5();
  const { kConstruct } = requireSymbols();
  class MessageEvent extends Event {
    #eventInit;
    constructor(type, eventInitDict = {}) {
      if (type === kConstruct) {
        super(arguments[1], arguments[2]);
        webidl.util.markAsUncloneable(this);
        return;
      }
      const prefix = "MessageEvent constructor";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      type = webidl.converters.DOMString(type, prefix, "type");
      eventInitDict = webidl.converters.MessageEventInit(eventInitDict, prefix, "eventInitDict");
      super(type, eventInitDict);
      this.#eventInit = eventInitDict;
      webidl.util.markAsUncloneable(this);
    }
    get data() {
      webidl.brandCheck(this, MessageEvent);
      return this.#eventInit.data;
    }
    get origin() {
      webidl.brandCheck(this, MessageEvent);
      return this.#eventInit.origin;
    }
    get lastEventId() {
      webidl.brandCheck(this, MessageEvent);
      return this.#eventInit.lastEventId;
    }
    get source() {
      webidl.brandCheck(this, MessageEvent);
      return this.#eventInit.source;
    }
    get ports() {
      webidl.brandCheck(this, MessageEvent);
      if (!Object.isFrozen(this.#eventInit.ports)) {
        Object.freeze(this.#eventInit.ports);
      }
      return this.#eventInit.ports;
    }
    initMessageEvent(type, bubbles = false, cancelable = false, data2 = null, origin = "", lastEventId = "", source = null, ports = []) {
      webidl.brandCheck(this, MessageEvent);
      webidl.argumentLengthCheck(arguments, 1, "MessageEvent.initMessageEvent");
      return new MessageEvent(type, {
        bubbles,
        cancelable,
        data: data2,
        origin,
        lastEventId,
        source,
        ports
      });
    }
    static createFastMessageEvent(type, init) {
      const messageEvent = new MessageEvent(kConstruct, type, init);
      messageEvent.#eventInit = init;
      messageEvent.#eventInit.data ??= null;
      messageEvent.#eventInit.origin ??= "";
      messageEvent.#eventInit.lastEventId ??= "";
      messageEvent.#eventInit.source ??= null;
      messageEvent.#eventInit.ports ??= [];
      return messageEvent;
    }
  }
  const { createFastMessageEvent } = MessageEvent;
  delete MessageEvent.createFastMessageEvent;
  class CloseEvent extends Event {
    #eventInit;
    constructor(type, eventInitDict = {}) {
      const prefix = "CloseEvent constructor";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      type = webidl.converters.DOMString(type, prefix, "type");
      eventInitDict = webidl.converters.CloseEventInit(eventInitDict);
      super(type, eventInitDict);
      this.#eventInit = eventInitDict;
      webidl.util.markAsUncloneable(this);
    }
    get wasClean() {
      webidl.brandCheck(this, CloseEvent);
      return this.#eventInit.wasClean;
    }
    get code() {
      webidl.brandCheck(this, CloseEvent);
      return this.#eventInit.code;
    }
    get reason() {
      webidl.brandCheck(this, CloseEvent);
      return this.#eventInit.reason;
    }
  }
  class ErrorEvent extends Event {
    #eventInit;
    constructor(type, eventInitDict) {
      const prefix = "ErrorEvent constructor";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      super(type, eventInitDict);
      webidl.util.markAsUncloneable(this);
      type = webidl.converters.DOMString(type, prefix, "type");
      eventInitDict = webidl.converters.ErrorEventInit(eventInitDict ?? {});
      this.#eventInit = eventInitDict;
    }
    get message() {
      webidl.brandCheck(this, ErrorEvent);
      return this.#eventInit.message;
    }
    get filename() {
      webidl.brandCheck(this, ErrorEvent);
      return this.#eventInit.filename;
    }
    get lineno() {
      webidl.brandCheck(this, ErrorEvent);
      return this.#eventInit.lineno;
    }
    get colno() {
      webidl.brandCheck(this, ErrorEvent);
      return this.#eventInit.colno;
    }
    get error() {
      webidl.brandCheck(this, ErrorEvent);
      return this.#eventInit.error;
    }
  }
  Object.defineProperties(MessageEvent.prototype, {
    [Symbol.toStringTag]: {
      value: "MessageEvent",
      configurable: true
    },
    data: kEnumerableProperty,
    origin: kEnumerableProperty,
    lastEventId: kEnumerableProperty,
    source: kEnumerableProperty,
    ports: kEnumerableProperty,
    initMessageEvent: kEnumerableProperty
  });
  Object.defineProperties(CloseEvent.prototype, {
    [Symbol.toStringTag]: {
      value: "CloseEvent",
      configurable: true
    },
    reason: kEnumerableProperty,
    code: kEnumerableProperty,
    wasClean: kEnumerableProperty
  });
  Object.defineProperties(ErrorEvent.prototype, {
    [Symbol.toStringTag]: {
      value: "ErrorEvent",
      configurable: true
    },
    message: kEnumerableProperty,
    filename: kEnumerableProperty,
    lineno: kEnumerableProperty,
    colno: kEnumerableProperty,
    error: kEnumerableProperty
  });
  webidl.converters.MessagePort = webidl.interfaceConverter(
    webidl.is.MessagePort,
    "MessagePort"
  );
  webidl.converters["sequence<MessagePort>"] = webidl.sequenceConverter(
    webidl.converters.MessagePort
  );
  const eventInit = [
    {
      key: "bubbles",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "cancelable",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "composed",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    }
  ];
  webidl.converters.MessageEventInit = webidl.dictionaryConverter([
    ...eventInit,
    {
      key: "data",
      converter: webidl.converters.any,
      defaultValue: () => null
    },
    {
      key: "origin",
      converter: webidl.converters.USVString,
      defaultValue: () => ""
    },
    {
      key: "lastEventId",
      converter: webidl.converters.DOMString,
      defaultValue: () => ""
    },
    {
      key: "source",
      // Node doesn't implement WindowProxy or ServiceWorker, so the only
      // valid value for source is a MessagePort.
      converter: webidl.nullableConverter(webidl.converters.MessagePort),
      defaultValue: () => null
    },
    {
      key: "ports",
      converter: webidl.converters["sequence<MessagePort>"],
      defaultValue: () => []
    }
  ]);
  webidl.converters.CloseEventInit = webidl.dictionaryConverter([
    ...eventInit,
    {
      key: "wasClean",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "code",
      converter: webidl.converters["unsigned short"],
      defaultValue: () => 0
    },
    {
      key: "reason",
      converter: webidl.converters.USVString,
      defaultValue: () => ""
    }
  ]);
  webidl.converters.ErrorEventInit = webidl.dictionaryConverter([
    ...eventInit,
    {
      key: "message",
      converter: webidl.converters.DOMString,
      defaultValue: () => ""
    },
    {
      key: "filename",
      converter: webidl.converters.USVString,
      defaultValue: () => ""
    },
    {
      key: "lineno",
      converter: webidl.converters["unsigned long"],
      defaultValue: () => 0
    },
    {
      key: "colno",
      converter: webidl.converters["unsigned long"],
      defaultValue: () => 0
    },
    {
      key: "error",
      converter: webidl.converters.any
    }
  ]);
  events = {
    MessageEvent,
    CloseEvent,
    ErrorEvent,
    createFastMessageEvent
  };
  return events;
}
var constants;
var hasRequiredConstants;
function requireConstants() {
  if (hasRequiredConstants) return constants;
  hasRequiredConstants = 1;
  const uid = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
  const staticPropertyDescriptors = {
    enumerable: true,
    writable: false,
    configurable: false
  };
  const states = {
    CONNECTING: 0,
    OPEN: 1,
    CLOSING: 2,
    CLOSED: 3
  };
  const sentCloseFrameState = {
    SENT: 1,
    RECEIVED: 2
  };
  const opcodes = {
    CONTINUATION: 0,
    TEXT: 1,
    BINARY: 2,
    CLOSE: 8,
    PING: 9,
    PONG: 10
  };
  const maxUnsigned16Bit = 65535;
  const parserStates = {
    INFO: 0,
    PAYLOADLENGTH_16: 2,
    PAYLOADLENGTH_64: 3,
    READ_DATA: 4
  };
  const emptyBuffer = Buffer.allocUnsafe(0);
  const sendHints = {
    text: 1,
    typedArray: 2,
    arrayBuffer: 3,
    blob: 4
  };
  constants = {
    uid,
    sentCloseFrameState,
    staticPropertyDescriptors,
    states,
    opcodes,
    maxUnsigned16Bit,
    parserStates,
    emptyBuffer,
    sendHints
  };
  return constants;
}
var util$1;
var hasRequiredUtil$1;
function requireUtil$1() {
  if (hasRequiredUtil$1) return util$1;
  hasRequiredUtil$1 = 1;
  const { states, opcodes } = requireConstants();
  const { isUtf8 } = import_node_buffer.default;
  const { removeHTTPWhitespace } = requireDataUrl();
  const { collectASequenceOfCodePointsFast } = requireInfra();
  function isConnecting(readyState) {
    return readyState === states.CONNECTING;
  }
  function isEstablished(readyState) {
    return readyState === states.OPEN;
  }
  function isClosing(readyState) {
    return readyState === states.CLOSING;
  }
  function isClosed(readyState) {
    return readyState === states.CLOSED;
  }
  function fireEvent(e4, target, eventFactory = (type, init) => new Event(type, init), eventInitDict = {}) {
    const event = eventFactory(e4, eventInitDict);
    target.dispatchEvent(event);
  }
  function websocketMessageReceived(handler, type, data2) {
    handler.onMessage(type, data2);
  }
  function toArrayBuffer(buffer) {
    if (buffer.byteLength === buffer.buffer.byteLength) {
      return buffer.buffer;
    }
    return new Uint8Array(buffer).buffer;
  }
  function isValidSubprotocol(protocol) {
    if (protocol.length === 0) {
      return false;
    }
    for (let i4 = 0; i4 < protocol.length; ++i4) {
      const code = protocol.charCodeAt(i4);
      if (code < 33 || // CTL, contains SP (0x20) and HT (0x09)
      code > 126 || code === 34 || // "
      code === 40 || // (
      code === 41 || // )
      code === 44 || // ,
      code === 47 || // /
      code === 58 || // :
      code === 59 || // ;
      code === 60 || // <
      code === 61 || // =
      code === 62 || // >
      code === 63 || // ?
      code === 64 || // @
      code === 91 || // [
      code === 92 || // \
      code === 93 || // ]
      code === 123 || // {
      code === 125) {
        return false;
      }
    }
    return true;
  }
  function isValidStatusCode(code) {
    if (code >= 1e3 && code < 1015) {
      return code !== 1004 && // reserved
      code !== 1005 && // "MUST NOT be set as a status code"
      code !== 1006;
    }
    return code >= 3e3 && code <= 4999;
  }
  function isControlFrame(opcode) {
    return opcode === opcodes.CLOSE || opcode === opcodes.PING || opcode === opcodes.PONG;
  }
  function isContinuationFrame(opcode) {
    return opcode === opcodes.CONTINUATION;
  }
  function isTextBinaryFrame(opcode) {
    return opcode === opcodes.TEXT || opcode === opcodes.BINARY;
  }
  function isValidOpcode(opcode) {
    return isTextBinaryFrame(opcode) || isContinuationFrame(opcode) || isControlFrame(opcode);
  }
  function parseExtensions(extensions) {
    const position = { position: 0 };
    const extensionList = /* @__PURE__ */ new Map();
    while (position.position < extensions.length) {
      const pair = collectASequenceOfCodePointsFast(";", extensions, position);
      const [name, value = ""] = pair.split("=", 2);
      extensionList.set(
        removeHTTPWhitespace(name, true, false),
        removeHTTPWhitespace(value, false, true)
      );
      position.position++;
    }
    return extensionList;
  }
  function isValidClientWindowBits(value) {
    for (let i4 = 0; i4 < value.length; i4++) {
      const byte = value.charCodeAt(i4);
      if (byte < 48 || byte > 57) {
        return false;
      }
    }
    return true;
  }
  function getURLRecord(url, baseURL) {
    let urlRecord;
    try {
      urlRecord = new URL(url, baseURL);
    } catch (e4) {
      throw new DOMException(e4, "SyntaxError");
    }
    if (urlRecord.protocol === "http:") {
      urlRecord.protocol = "ws:";
    } else if (urlRecord.protocol === "https:") {
      urlRecord.protocol = "wss:";
    }
    if (urlRecord.protocol !== "ws:" && urlRecord.protocol !== "wss:") {
      throw new DOMException("expected a ws: or wss: url", "SyntaxError");
    }
    if (urlRecord.hash.length || urlRecord.href.endsWith("#")) {
      throw new DOMException("hash", "SyntaxError");
    }
    return urlRecord;
  }
  function validateCloseCodeAndReason(code, reason) {
    if (code !== null) {
      if (code !== 1e3 && (code < 3e3 || code > 4999)) {
        throw new DOMException("invalid code", "InvalidAccessError");
      }
    }
    if (reason !== null) {
      const reasonBytesLength = Buffer.byteLength(reason);
      if (reasonBytesLength > 123) {
        throw new DOMException(`Reason must be less than 123 bytes; received ${reasonBytesLength}`, "SyntaxError");
      }
    }
  }
  const utf8Decode = (() => {
    if (typeof process.versions.icu === "string") {
      const fatalDecoder = new TextDecoder("utf-8", { fatal: true });
      return fatalDecoder.decode.bind(fatalDecoder);
    }
    return function(buffer) {
      if (isUtf8(buffer)) {
        return buffer.toString("utf-8");
      }
      throw new TypeError("Invalid utf-8 received.");
    };
  })();
  util$1 = {
    isConnecting,
    isEstablished,
    isClosing,
    isClosed,
    fireEvent,
    isValidSubprotocol,
    isValidStatusCode,
    websocketMessageReceived,
    utf8Decode,
    isControlFrame,
    isContinuationFrame,
    isTextBinaryFrame,
    isValidOpcode,
    parseExtensions,
    isValidClientWindowBits,
    toArrayBuffer,
    getURLRecord,
    validateCloseCodeAndReason
  };
  return util$1;
}
var frame;
var hasRequiredFrame;
function requireFrame() {
  if (hasRequiredFrame) return frame;
  hasRequiredFrame = 1;
  const { runtimeFeatures: runtimeFeatures2 } = requireRuntimeFeatures();
  const { maxUnsigned16Bit, opcodes } = requireConstants();
  const BUFFER_SIZE = 8 * 1024;
  let buffer = null;
  let bufIdx = BUFFER_SIZE;
  const randomFillSync2 = runtimeFeatures2.has("crypto") ? import_node_crypto2.default.randomFillSync : function randomFillSync3(buffer2, _offset2, _size) {
    for (let i4 = 0; i4 < buffer2.length; ++i4) {
      buffer2[i4] = Math.random() * 255 | 0;
    }
    return buffer2;
  };
  function generateMask() {
    if (bufIdx === BUFFER_SIZE) {
      bufIdx = 0;
      randomFillSync2(buffer ??= Buffer.allocUnsafeSlow(BUFFER_SIZE), 0, BUFFER_SIZE);
    }
    return [buffer[bufIdx++], buffer[bufIdx++], buffer[bufIdx++], buffer[bufIdx++]];
  }
  class WebsocketFrameSend {
    /**
     * @param {Buffer|undefined} data
     */
    constructor(data2) {
      this.frameData = data2;
    }
    createFrame(opcode) {
      const frameData = this.frameData;
      const maskKey = generateMask();
      const bodyLength = frameData?.byteLength ?? 0;
      let payloadLength = bodyLength;
      let offset = 6;
      if (bodyLength > maxUnsigned16Bit) {
        offset += 8;
        payloadLength = 127;
      } else if (bodyLength > 125) {
        offset += 2;
        payloadLength = 126;
      }
      const buffer2 = Buffer.allocUnsafe(bodyLength + offset);
      buffer2[0] = buffer2[1] = 0;
      buffer2[0] |= 128;
      buffer2[0] = (buffer2[0] & 240) + opcode;
      buffer2[offset - 4] = maskKey[0];
      buffer2[offset - 3] = maskKey[1];
      buffer2[offset - 2] = maskKey[2];
      buffer2[offset - 1] = maskKey[3];
      buffer2[1] = payloadLength;
      if (payloadLength === 126) {
        buffer2.writeUInt16BE(bodyLength, 2);
      } else if (payloadLength === 127) {
        buffer2[2] = buffer2[3] = 0;
        buffer2.writeUIntBE(bodyLength, 4, 6);
      }
      buffer2[1] |= 128;
      for (let i4 = 0; i4 < bodyLength; ++i4) {
        buffer2[offset + i4] = frameData[i4] ^ maskKey[i4 & 3];
      }
      return buffer2;
    }
    /**
     * @param {Uint8Array} buffer
     */
    static createFastTextFrame(buffer2) {
      const maskKey = generateMask();
      const bodyLength = buffer2.length;
      for (let i4 = 0; i4 < bodyLength; ++i4) {
        buffer2[i4] ^= maskKey[i4 & 3];
      }
      let payloadLength = bodyLength;
      let offset = 6;
      if (bodyLength > maxUnsigned16Bit) {
        offset += 8;
        payloadLength = 127;
      } else if (bodyLength > 125) {
        offset += 2;
        payloadLength = 126;
      }
      const head = Buffer.allocUnsafeSlow(offset);
      head[0] = 128 | opcodes.TEXT;
      head[1] = payloadLength | 128;
      head[offset - 4] = maskKey[0];
      head[offset - 3] = maskKey[1];
      head[offset - 2] = maskKey[2];
      head[offset - 1] = maskKey[3];
      if (payloadLength === 126) {
        head.writeUInt16BE(bodyLength, 2);
      } else if (payloadLength === 127) {
        head[2] = head[3] = 0;
        head.writeUIntBE(bodyLength, 4, 6);
      }
      return [head, buffer2];
    }
  }
  frame = {
    WebsocketFrameSend,
    generateMask
    // for benchmark
  };
  return frame;
}
var connection;
var hasRequiredConnection;
function requireConnection() {
  if (hasRequiredConnection) return connection;
  hasRequiredConnection = 1;
  const { uid, states, sentCloseFrameState, emptyBuffer, opcodes } = requireConstants();
  const { parseExtensions, isClosed, isClosing, isEstablished, isConnecting, validateCloseCodeAndReason } = requireUtil$1();
  const { makeRequest } = requireRequest();
  const { fetching } = requireFetch();
  const { Headers: Headers2, getHeadersList } = requireHeaders();
  const { getDecodeSplit } = requireUtil$4();
  const { WebsocketFrameSend } = requireFrame();
  const assert = import_node_assert.default;
  const { runtimeFeatures: runtimeFeatures2 } = requireRuntimeFeatures();
  const crypto5 = runtimeFeatures2.has("crypto") ? import_node_crypto2.default : null;
  let warningEmitted = false;
  function establishWebSocketConnection(url, protocols, client2, handler, options) {
    const requestURL = url;
    requestURL.protocol = url.protocol === "ws:" ? "http:" : "https:";
    const request2 = makeRequest({
      urlList: [requestURL],
      client: client2,
      serviceWorkers: "none",
      referrer: "no-referrer",
      mode: "websocket",
      credentials: "include",
      cache: "no-store",
      redirect: "error"
    });
    if (options.headers) {
      const headersList = getHeadersList(new Headers2(options.headers));
      request2.headersList = headersList;
    }
    const keyValue = crypto5.randomBytes(16).toString("base64");
    request2.headersList.append("sec-websocket-key", keyValue, true);
    request2.headersList.append("sec-websocket-version", "13", true);
    for (const protocol of protocols) {
      request2.headersList.append("sec-websocket-protocol", protocol, true);
    }
    const permessageDeflate2 = "permessage-deflate; client_max_window_bits";
    request2.headersList.append("sec-websocket-extensions", permessageDeflate2, true);
    const controller = fetching({
      request: request2,
      useParallelQueue: true,
      dispatcher: options.dispatcher,
      processResponse(response2) {
        if (response2.type === "error" || response2.status !== 101) {
          if (response2.socket?.session == null) {
            failWebsocketConnection(handler, 1002, "Received network error or non-101 status code.", response2.error);
            return;
          }
          if (response2.status !== 200) {
            failWebsocketConnection(handler, 1002, "Received network error or non-200 status code.", response2.error);
            return;
          }
        }
        if (warningEmitted === false && response2.socket?.session != null) {
          process.emitWarning("WebSocket over HTTP2 is experimental, and subject to change.", "ExperimentalWarning");
          warningEmitted = true;
        }
        if (protocols.length !== 0 && !response2.headersList.get("Sec-WebSocket-Protocol")) {
          failWebsocketConnection(handler, 1002, "Server did not respond with sent protocols.");
          return;
        }
        if (response2.socket.session == null && response2.headersList.get("Upgrade")?.toLowerCase() !== "websocket") {
          failWebsocketConnection(handler, 1002, 'Server did not set Upgrade header to "websocket".');
          return;
        }
        if (response2.socket.session == null && response2.headersList.get("Connection")?.toLowerCase() !== "upgrade") {
          failWebsocketConnection(handler, 1002, 'Server did not set Connection header to "upgrade".');
          return;
        }
        const secWSAccept = response2.headersList.get("Sec-WebSocket-Accept");
        const digest = crypto5.hash("sha1", keyValue + uid, "base64");
        if (secWSAccept !== digest) {
          failWebsocketConnection(handler, 1002, "Incorrect hash received in Sec-WebSocket-Accept header.");
          return;
        }
        const secExtension = response2.headersList.get("Sec-WebSocket-Extensions");
        let extensions;
        if (secExtension !== null) {
          extensions = parseExtensions(secExtension);
          if (!extensions.has("permessage-deflate")) {
            failWebsocketConnection(handler, 1002, "Sec-WebSocket-Extensions header does not match.");
            return;
          }
        }
        const secProtocol = response2.headersList.get("Sec-WebSocket-Protocol");
        if (secProtocol !== null) {
          const requestProtocols = getDecodeSplit("sec-websocket-protocol", request2.headersList);
          if (!requestProtocols.includes(secProtocol)) {
            failWebsocketConnection(handler, 1002, "Protocol was not set in the opening handshake.");
            return;
          }
        }
        response2.socket.on("data", handler.onSocketData);
        response2.socket.on("close", handler.onSocketClose);
        response2.socket.on("error", handler.onSocketError);
        handler.wasEverConnected = true;
        handler.onConnectionEstablished(response2, extensions);
      }
    });
    return controller;
  }
  function closeWebSocketConnection(object, code, reason, validate = false) {
    code ??= null;
    reason ??= "";
    if (validate) validateCloseCodeAndReason(code, reason);
    if (isClosed(object.readyState) || isClosing(object.readyState)) ;
    else if (!isEstablished(object.readyState)) {
      failWebsocketConnection(object);
      object.readyState = states.CLOSING;
    } else if (!object.closeState.has(sentCloseFrameState.SENT) && !object.closeState.has(sentCloseFrameState.RECEIVED)) {
      const frame2 = new WebsocketFrameSend();
      if (reason.length !== 0 && code === null) {
        code = 1e3;
      }
      assert(code === null || Number.isInteger(code));
      if (code === null && reason.length === 0) {
        frame2.frameData = emptyBuffer;
      } else if (code !== null && reason === null) {
        frame2.frameData = Buffer.allocUnsafe(2);
        frame2.frameData.writeUInt16BE(code, 0);
      } else if (code !== null && reason !== null) {
        frame2.frameData = Buffer.allocUnsafe(2 + Buffer.byteLength(reason));
        frame2.frameData.writeUInt16BE(code, 0);
        frame2.frameData.write(reason, 2, "utf-8");
      } else {
        frame2.frameData = emptyBuffer;
      }
      object.socket.write(frame2.createFrame(opcodes.CLOSE));
      object.closeState.add(sentCloseFrameState.SENT);
      object.readyState = states.CLOSING;
    } else {
      object.readyState = states.CLOSING;
    }
  }
  function failWebsocketConnection(handler, code, reason, cause) {
    if (isEstablished(handler.readyState)) {
      closeWebSocketConnection(handler, code, reason, false);
    }
    handler.controller.abort();
    if (isConnecting(handler.readyState)) {
      handler.onSocketClose();
    } else if (handler.socket?.destroyed === false) {
      handler.socket.destroy();
    }
  }
  connection = {
    establishWebSocketConnection,
    failWebsocketConnection,
    closeWebSocketConnection
  };
  return connection;
}
var permessageDeflate;
var hasRequiredPermessageDeflate;
function requirePermessageDeflate() {
  if (hasRequiredPermessageDeflate) return permessageDeflate;
  hasRequiredPermessageDeflate = 1;
  const { createInflateRaw, Z_DEFAULT_WINDOWBITS } = import_node_zlib.default;
  const { isValidClientWindowBits } = requireUtil$1();
  const tail = Buffer.from([0, 0, 255, 255]);
  const kBuffer = /* @__PURE__ */ Symbol("kBuffer");
  const kLength = /* @__PURE__ */ Symbol("kLength");
  class PerMessageDeflate {
    /** @type {import('node:zlib').InflateRaw} */
    #inflate;
    #options = {};
    constructor(extensions) {
      this.#options.serverNoContextTakeover = extensions.has("server_no_context_takeover");
      this.#options.serverMaxWindowBits = extensions.get("server_max_window_bits");
    }
    decompress(chunk2, fin, callback) {
      if (!this.#inflate) {
        let windowBits = Z_DEFAULT_WINDOWBITS;
        if (this.#options.serverMaxWindowBits) {
          if (!isValidClientWindowBits(this.#options.serverMaxWindowBits)) {
            callback(new Error("Invalid server_max_window_bits"));
            return;
          }
          windowBits = Number.parseInt(this.#options.serverMaxWindowBits);
        }
        this.#inflate = createInflateRaw({ windowBits });
        this.#inflate[kBuffer] = [];
        this.#inflate[kLength] = 0;
        this.#inflate.on("data", (data2) => {
          this.#inflate[kBuffer].push(data2);
          this.#inflate[kLength] += data2.length;
        });
        this.#inflate.on("error", (err) => {
          this.#inflate = null;
          callback(err);
        });
      }
      this.#inflate.write(chunk2);
      if (fin) {
        this.#inflate.write(tail);
      }
      this.#inflate.flush(() => {
        const full = Buffer.concat(this.#inflate[kBuffer], this.#inflate[kLength]);
        this.#inflate[kBuffer].length = 0;
        this.#inflate[kLength] = 0;
        callback(null, full);
      });
    }
  }
  permessageDeflate = { PerMessageDeflate };
  return permessageDeflate;
}
var receiver;
var hasRequiredReceiver;
function requireReceiver() {
  if (hasRequiredReceiver) return receiver;
  hasRequiredReceiver = 1;
  const { Writable: Writable2 } = import_node_stream.default;
  const assert = import_node_assert.default;
  const { parserStates, opcodes, states, emptyBuffer, sentCloseFrameState } = requireConstants();
  const {
    isValidStatusCode,
    isValidOpcode,
    websocketMessageReceived,
    utf8Decode,
    isControlFrame,
    isTextBinaryFrame,
    isContinuationFrame
  } = requireUtil$1();
  const { failWebsocketConnection } = requireConnection();
  const { WebsocketFrameSend } = requireFrame();
  const { PerMessageDeflate } = requirePermessageDeflate();
  class ByteParser extends Writable2 {
    #buffers = [];
    #fragmentsBytes = 0;
    #byteOffset = 0;
    #loop = false;
    #state = parserStates.INFO;
    #info = {};
    #fragments = [];
    /** @type {Map<string, PerMessageDeflate>} */
    #extensions;
    /** @type {import('./websocket').Handler} */
    #handler;
    constructor(handler, extensions) {
      super();
      this.#handler = handler;
      this.#extensions = extensions == null ? /* @__PURE__ */ new Map() : extensions;
      if (this.#extensions.has("permessage-deflate")) {
        this.#extensions.set("permessage-deflate", new PerMessageDeflate(extensions));
      }
    }
    /**
     * @param {Buffer} chunk
     * @param {() => void} callback
     */
    _write(chunk2, _, callback) {
      this.#buffers.push(chunk2);
      this.#byteOffset += chunk2.length;
      this.#loop = true;
      this.run(callback);
    }
    /**
     * Runs whenever a new chunk is received.
     * Callback is called whenever there are no more chunks buffering,
     * or not enough bytes are buffered to parse.
     */
    run(callback) {
      while (this.#loop) {
        if (this.#state === parserStates.INFO) {
          if (this.#byteOffset < 2) {
            return callback();
          }
          const buffer = this.consume(2);
          const fin = (buffer[0] & 128) !== 0;
          const opcode = buffer[0] & 15;
          const masked = (buffer[1] & 128) === 128;
          const fragmented = !fin && opcode !== opcodes.CONTINUATION;
          const payloadLength = buffer[1] & 127;
          const rsv1 = buffer[0] & 64;
          const rsv2 = buffer[0] & 32;
          const rsv3 = buffer[0] & 16;
          if (!isValidOpcode(opcode)) {
            failWebsocketConnection(this.#handler, 1002, "Invalid opcode received");
            return callback();
          }
          if (masked) {
            failWebsocketConnection(this.#handler, 1002, "Frame cannot be masked");
            return callback();
          }
          if (rsv1 !== 0 && !this.#extensions.has("permessage-deflate")) {
            failWebsocketConnection(this.#handler, 1002, "Expected RSV1 to be clear.");
            return;
          }
          if (rsv2 !== 0 || rsv3 !== 0) {
            failWebsocketConnection(this.#handler, 1002, "RSV1, RSV2, RSV3 must be clear");
            return;
          }
          if (fragmented && !isTextBinaryFrame(opcode)) {
            failWebsocketConnection(this.#handler, 1002, "Invalid frame type was fragmented.");
            return;
          }
          if (isTextBinaryFrame(opcode) && this.#fragments.length > 0) {
            failWebsocketConnection(this.#handler, 1002, "Expected continuation frame");
            return;
          }
          if (this.#info.fragmented && fragmented) {
            failWebsocketConnection(this.#handler, 1002, "Fragmented frame exceeded 125 bytes.");
            return;
          }
          if ((payloadLength > 125 || fragmented) && isControlFrame(opcode)) {
            failWebsocketConnection(this.#handler, 1002, "Control frame either too large or fragmented");
            return;
          }
          if (isContinuationFrame(opcode) && this.#fragments.length === 0 && !this.#info.compressed) {
            failWebsocketConnection(this.#handler, 1002, "Unexpected continuation frame");
            return;
          }
          if (payloadLength <= 125) {
            this.#info.payloadLength = payloadLength;
            this.#state = parserStates.READ_DATA;
          } else if (payloadLength === 126) {
            this.#state = parserStates.PAYLOADLENGTH_16;
          } else if (payloadLength === 127) {
            this.#state = parserStates.PAYLOADLENGTH_64;
          }
          if (isTextBinaryFrame(opcode)) {
            this.#info.binaryType = opcode;
            this.#info.compressed = rsv1 !== 0;
          }
          this.#info.opcode = opcode;
          this.#info.masked = masked;
          this.#info.fin = fin;
          this.#info.fragmented = fragmented;
        } else if (this.#state === parserStates.PAYLOADLENGTH_16) {
          if (this.#byteOffset < 2) {
            return callback();
          }
          const buffer = this.consume(2);
          this.#info.payloadLength = buffer.readUInt16BE(0);
          this.#state = parserStates.READ_DATA;
        } else if (this.#state === parserStates.PAYLOADLENGTH_64) {
          if (this.#byteOffset < 8) {
            return callback();
          }
          const buffer = this.consume(8);
          const upper = buffer.readUInt32BE(0);
          if (upper > 2 ** 31 - 1) {
            failWebsocketConnection(this.#handler, 1009, "Received payload length > 2^31 bytes.");
            return;
          }
          const lower = buffer.readUInt32BE(4);
          this.#info.payloadLength = (upper << 8) + lower;
          this.#state = parserStates.READ_DATA;
        } else if (this.#state === parserStates.READ_DATA) {
          if (this.#byteOffset < this.#info.payloadLength) {
            return callback();
          }
          const body2 = this.consume(this.#info.payloadLength);
          if (isControlFrame(this.#info.opcode)) {
            this.#loop = this.parseControlFrame(body2);
            this.#state = parserStates.INFO;
          } else {
            if (!this.#info.compressed) {
              this.writeFragments(body2);
              if (!this.#info.fragmented && this.#info.fin) {
                websocketMessageReceived(this.#handler, this.#info.binaryType, this.consumeFragments());
              }
              this.#state = parserStates.INFO;
            } else {
              this.#extensions.get("permessage-deflate").decompress(body2, this.#info.fin, (error2, data2) => {
                if (error2) {
                  failWebsocketConnection(this.#handler, 1007, error2.message);
                  return;
                }
                this.writeFragments(data2);
                if (!this.#info.fin) {
                  this.#state = parserStates.INFO;
                  this.#loop = true;
                  this.run(callback);
                  return;
                }
                websocketMessageReceived(this.#handler, this.#info.binaryType, this.consumeFragments());
                this.#loop = true;
                this.#state = parserStates.INFO;
                this.run(callback);
              });
              this.#loop = false;
              break;
            }
          }
        }
      }
    }
    /**
     * Take n bytes from the buffered Buffers
     * @param {number} n
     * @returns {Buffer}
     */
    consume(n4) {
      if (n4 > this.#byteOffset) {
        throw new Error("Called consume() before buffers satiated.");
      } else if (n4 === 0) {
        return emptyBuffer;
      }
      this.#byteOffset -= n4;
      const first = this.#buffers[0];
      if (first.length > n4) {
        this.#buffers[0] = first.subarray(n4, first.length);
        return first.subarray(0, n4);
      } else if (first.length === n4) {
        return this.#buffers.shift();
      } else {
        let offset = 0;
        const buffer = Buffer.allocUnsafeSlow(n4);
        while (offset !== n4) {
          const next = this.#buffers[0];
          const length = next.length;
          if (length + offset === n4) {
            buffer.set(this.#buffers.shift(), offset);
            break;
          } else if (length + offset > n4) {
            buffer.set(next.subarray(0, n4 - offset), offset);
            this.#buffers[0] = next.subarray(n4 - offset);
            break;
          } else {
            buffer.set(this.#buffers.shift(), offset);
            offset += length;
          }
        }
        return buffer;
      }
    }
    writeFragments(fragment) {
      this.#fragmentsBytes += fragment.length;
      this.#fragments.push(fragment);
    }
    consumeFragments() {
      const fragments = this.#fragments;
      if (fragments.length === 1) {
        this.#fragmentsBytes = 0;
        return fragments.shift();
      }
      let offset = 0;
      const output = Buffer.allocUnsafeSlow(this.#fragmentsBytes);
      for (let i4 = 0; i4 < fragments.length; ++i4) {
        const buffer = fragments[i4];
        output.set(buffer, offset);
        offset += buffer.length;
      }
      this.#fragments = [];
      this.#fragmentsBytes = 0;
      return output;
    }
    parseCloseBody(data2) {
      assert(data2.length !== 1);
      let code;
      if (data2.length >= 2) {
        code = data2.readUInt16BE(0);
      }
      if (code !== void 0 && !isValidStatusCode(code)) {
        return { code: 1002, reason: "Invalid status code", error: true };
      }
      let reason = data2.subarray(2);
      if (reason[0] === 239 && reason[1] === 187 && reason[2] === 191) {
        reason = reason.subarray(3);
      }
      try {
        reason = utf8Decode(reason);
      } catch {
        return { code: 1007, reason: "Invalid UTF-8", error: true };
      }
      return { code, reason, error: false };
    }
    /**
     * Parses control frames.
     * @param {Buffer} body
     */
    parseControlFrame(body2) {
      const { opcode, payloadLength } = this.#info;
      if (opcode === opcodes.CLOSE) {
        if (payloadLength === 1) {
          failWebsocketConnection(this.#handler, 1002, "Received close frame with a 1-byte body.");
          return false;
        }
        this.#info.closeInfo = this.parseCloseBody(body2);
        if (this.#info.closeInfo.error) {
          const { code, reason } = this.#info.closeInfo;
          failWebsocketConnection(this.#handler, code, reason);
          return false;
        }
        if (!this.#handler.closeState.has(sentCloseFrameState.SENT) && !this.#handler.closeState.has(sentCloseFrameState.RECEIVED)) {
          let body3 = emptyBuffer;
          if (this.#info.closeInfo.code) {
            body3 = Buffer.allocUnsafe(2);
            body3.writeUInt16BE(this.#info.closeInfo.code, 0);
          }
          const closeFrame = new WebsocketFrameSend(body3);
          this.#handler.socket.write(closeFrame.createFrame(opcodes.CLOSE));
          this.#handler.closeState.add(sentCloseFrameState.SENT);
        }
        this.#handler.readyState = states.CLOSING;
        this.#handler.closeState.add(sentCloseFrameState.RECEIVED);
        return false;
      } else if (opcode === opcodes.PING) {
        if (!this.#handler.closeState.has(sentCloseFrameState.RECEIVED)) {
          const frame2 = new WebsocketFrameSend(body2);
          this.#handler.socket.write(frame2.createFrame(opcodes.PONG));
          this.#handler.onPing(body2);
        }
      } else if (opcode === opcodes.PONG) {
        this.#handler.onPong(body2);
      }
      return true;
    }
    get closingInfo() {
      return this.#info.closeInfo;
    }
  }
  receiver = {
    ByteParser
  };
  return receiver;
}
var sender;
var hasRequiredSender;
function requireSender() {
  if (hasRequiredSender) return sender;
  hasRequiredSender = 1;
  const { WebsocketFrameSend } = requireFrame();
  const { opcodes, sendHints } = requireConstants();
  const FixedQueue = requireFixedQueue();
  class SendQueue {
    /**
     * @type {FixedQueue}
     */
    #queue = new FixedQueue();
    /**
     * @type {boolean}
     */
    #running = false;
    /** @type {import('node:net').Socket} */
    #socket;
    constructor(socket) {
      this.#socket = socket;
    }
    add(item, cb, hint) {
      if (hint !== sendHints.blob) {
        if (!this.#running) {
          if (hint === sendHints.text) {
            const { 0: head, 1: body2 } = WebsocketFrameSend.createFastTextFrame(item);
            this.#socket.cork();
            this.#socket.write(head);
            this.#socket.write(body2, cb);
            this.#socket.uncork();
          } else {
            this.#socket.write(createFrame(item, hint), cb);
          }
        } else {
          const node2 = {
            promise: null,
            callback: cb,
            frame: createFrame(item, hint)
          };
          this.#queue.push(node2);
        }
        return;
      }
      const node = {
        promise: item.arrayBuffer().then((ab) => {
          node.promise = null;
          node.frame = createFrame(ab, hint);
        }),
        callback: cb,
        frame: null
      };
      this.#queue.push(node);
      if (!this.#running) {
        this.#run();
      }
    }
    async #run() {
      this.#running = true;
      const queue = this.#queue;
      while (!queue.isEmpty()) {
        const node = queue.shift();
        if (node.promise !== null) {
          await node.promise;
        }
        this.#socket.write(node.frame, node.callback);
        node.callback = node.frame = null;
      }
      this.#running = false;
    }
  }
  function createFrame(data2, hint) {
    return new WebsocketFrameSend(toBuffer(data2, hint)).createFrame(hint === sendHints.text ? opcodes.TEXT : opcodes.BINARY);
  }
  function toBuffer(data2, hint) {
    switch (hint) {
      case sendHints.text:
      case sendHints.typedArray:
        return new Uint8Array(data2.buffer, data2.byteOffset, data2.byteLength);
      case sendHints.arrayBuffer:
      case sendHints.blob:
        return new Uint8Array(data2);
    }
  }
  sender = { SendQueue };
  return sender;
}
var websocket;
var hasRequiredWebsocket;
function requireWebsocket() {
  if (hasRequiredWebsocket) return websocket;
  hasRequiredWebsocket = 1;
  const { isArrayBuffer } = import_types3.default;
  const { webidl } = requireWebidl();
  const { URLSerializer } = requireDataUrl();
  const { environmentSettingsObject } = requireUtil$4();
  const { staticPropertyDescriptors, states, sentCloseFrameState, sendHints, opcodes } = requireConstants();
  const {
    isConnecting,
    isEstablished,
    isClosing,
    isClosed,
    isValidSubprotocol,
    fireEvent,
    utf8Decode,
    toArrayBuffer,
    getURLRecord
  } = requireUtil$1();
  const { establishWebSocketConnection, closeWebSocketConnection, failWebsocketConnection } = requireConnection();
  const { ByteParser } = requireReceiver();
  const { kEnumerableProperty } = requireUtil$5();
  const { getGlobalDispatcher } = requireGlobal();
  const { ErrorEvent, CloseEvent, createFastMessageEvent } = requireEvents();
  const { SendQueue } = requireSender();
  const { WebsocketFrameSend } = requireFrame();
  const { channels } = requireDiagnostics();
  class WebSocket extends EventTarget {
    #events = {
      open: null,
      error: null,
      close: null,
      message: null
    };
    #bufferedAmount = 0;
    #protocol = "";
    #extensions = "";
    /** @type {SendQueue} */
    #sendQueue;
    /** @type {Handler} */
    #handler = {
      onConnectionEstablished: (response2, extensions) => this.#onConnectionEstablished(response2, extensions),
      onMessage: (opcode, data2) => this.#onMessage(opcode, data2),
      onParserError: (err) => failWebsocketConnection(this.#handler, null, err.message),
      onParserDrain: () => this.#onParserDrain(),
      onSocketData: (chunk2) => {
        if (!this.#parser.write(chunk2)) {
          this.#handler.socket.pause();
        }
      },
      onSocketError: (err) => {
        this.#handler.readyState = states.CLOSING;
        if (channels.socketError.hasSubscribers) {
          channels.socketError.publish(err);
        }
        this.#handler.socket.destroy();
      },
      onSocketClose: () => this.#onSocketClose(),
      onPing: (body2) => {
        if (channels.ping.hasSubscribers) {
          channels.ping.publish({
            payload: body2,
            websocket: this
          });
        }
      },
      onPong: (body2) => {
        if (channels.pong.hasSubscribers) {
          channels.pong.publish({
            payload: body2,
            websocket: this
          });
        }
      },
      readyState: states.CONNECTING,
      socket: null,
      closeState: /* @__PURE__ */ new Set(),
      controller: null,
      wasEverConnected: false
    };
    #url;
    #binaryType;
    /** @type {import('./receiver').ByteParser} */
    #parser;
    /**
     * @param {string} url
     * @param {string|string[]} protocols
     */
    constructor(url, protocols = []) {
      super();
      webidl.util.markAsUncloneable(this);
      const prefix = "WebSocket constructor";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      const options = webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"](protocols, prefix, "options");
      url = webidl.converters.USVString(url);
      protocols = options.protocols;
      const baseURL = environmentSettingsObject.settingsObject.baseUrl;
      const urlRecord = getURLRecord(url, baseURL);
      if (typeof protocols === "string") {
        protocols = [protocols];
      }
      if (protocols.length !== new Set(protocols.map((p4) => p4.toLowerCase())).size) {
        throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
      }
      if (protocols.length > 0 && !protocols.every((p4) => isValidSubprotocol(p4))) {
        throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
      }
      this.#url = new URL(urlRecord.href);
      const client2 = environmentSettingsObject.settingsObject;
      this.#handler.controller = establishWebSocketConnection(
        urlRecord,
        protocols,
        client2,
        this.#handler,
        options
      );
      this.#handler.readyState = WebSocket.CONNECTING;
      this.#binaryType = "blob";
    }
    /**
     * @see https://websockets.spec.whatwg.org/#dom-websocket-close
     * @param {number|undefined} code
     * @param {string|undefined} reason
     */
    close(code = void 0, reason = void 0) {
      webidl.brandCheck(this, WebSocket);
      const prefix = "WebSocket.close";
      if (code !== void 0) {
        code = webidl.converters["unsigned short"](code, prefix, "code", webidl.attributes.Clamp);
      }
      if (reason !== void 0) {
        reason = webidl.converters.USVString(reason);
      }
      code ??= null;
      reason ??= "";
      closeWebSocketConnection(this.#handler, code, reason, true);
    }
    /**
     * @see https://websockets.spec.whatwg.org/#dom-websocket-send
     * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data
     */
    send(data2) {
      webidl.brandCheck(this, WebSocket);
      const prefix = "WebSocket.send";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      data2 = webidl.converters.WebSocketSendData(data2, prefix, "data");
      if (isConnecting(this.#handler.readyState)) {
        throw new DOMException("Sent before connected.", "InvalidStateError");
      }
      if (!isEstablished(this.#handler.readyState) || isClosing(this.#handler.readyState)) {
        return;
      }
      if (typeof data2 === "string") {
        const buffer = Buffer.from(data2);
        this.#bufferedAmount += buffer.byteLength;
        this.#sendQueue.add(buffer, () => {
          this.#bufferedAmount -= buffer.byteLength;
        }, sendHints.text);
      } else if (isArrayBuffer(data2)) {
        this.#bufferedAmount += data2.byteLength;
        this.#sendQueue.add(data2, () => {
          this.#bufferedAmount -= data2.byteLength;
        }, sendHints.arrayBuffer);
      } else if (ArrayBuffer.isView(data2)) {
        this.#bufferedAmount += data2.byteLength;
        this.#sendQueue.add(data2, () => {
          this.#bufferedAmount -= data2.byteLength;
        }, sendHints.typedArray);
      } else if (webidl.is.Blob(data2)) {
        this.#bufferedAmount += data2.size;
        this.#sendQueue.add(data2, () => {
          this.#bufferedAmount -= data2.size;
        }, sendHints.blob);
      }
    }
    get readyState() {
      webidl.brandCheck(this, WebSocket);
      return this.#handler.readyState;
    }
    get bufferedAmount() {
      webidl.brandCheck(this, WebSocket);
      return this.#bufferedAmount;
    }
    get url() {
      webidl.brandCheck(this, WebSocket);
      return URLSerializer(this.#url);
    }
    get extensions() {
      webidl.brandCheck(this, WebSocket);
      return this.#extensions;
    }
    get protocol() {
      webidl.brandCheck(this, WebSocket);
      return this.#protocol;
    }
    get onopen() {
      webidl.brandCheck(this, WebSocket);
      return this.#events.open;
    }
    set onopen(fn) {
      webidl.brandCheck(this, WebSocket);
      if (this.#events.open) {
        this.removeEventListener("open", this.#events.open);
      }
      const listener = webidl.converters.EventHandlerNonNull(fn);
      if (listener !== null) {
        this.addEventListener("open", listener);
        this.#events.open = fn;
      } else {
        this.#events.open = null;
      }
    }
    get onerror() {
      webidl.brandCheck(this, WebSocket);
      return this.#events.error;
    }
    set onerror(fn) {
      webidl.brandCheck(this, WebSocket);
      if (this.#events.error) {
        this.removeEventListener("error", this.#events.error);
      }
      const listener = webidl.converters.EventHandlerNonNull(fn);
      if (listener !== null) {
        this.addEventListener("error", listener);
        this.#events.error = fn;
      } else {
        this.#events.error = null;
      }
    }
    get onclose() {
      webidl.brandCheck(this, WebSocket);
      return this.#events.close;
    }
    set onclose(fn) {
      webidl.brandCheck(this, WebSocket);
      if (this.#events.close) {
        this.removeEventListener("close", this.#events.close);
      }
      const listener = webidl.converters.EventHandlerNonNull(fn);
      if (listener !== null) {
        this.addEventListener("close", listener);
        this.#events.close = fn;
      } else {
        this.#events.close = null;
      }
    }
    get onmessage() {
      webidl.brandCheck(this, WebSocket);
      return this.#events.message;
    }
    set onmessage(fn) {
      webidl.brandCheck(this, WebSocket);
      if (this.#events.message) {
        this.removeEventListener("message", this.#events.message);
      }
      const listener = webidl.converters.EventHandlerNonNull(fn);
      if (listener !== null) {
        this.addEventListener("message", listener);
        this.#events.message = fn;
      } else {
        this.#events.message = null;
      }
    }
    get binaryType() {
      webidl.brandCheck(this, WebSocket);
      return this.#binaryType;
    }
    set binaryType(type) {
      webidl.brandCheck(this, WebSocket);
      if (type !== "blob" && type !== "arraybuffer") {
        this.#binaryType = "blob";
      } else {
        this.#binaryType = type;
      }
    }
    /**
     * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
     */
    #onConnectionEstablished(response2, parsedExtensions) {
      this.#handler.socket = response2.socket;
      const parser = new ByteParser(this.#handler, parsedExtensions);
      parser.on("drain", () => this.#handler.onParserDrain());
      parser.on("error", (err) => this.#handler.onParserError(err));
      this.#parser = parser;
      this.#sendQueue = new SendQueue(response2.socket);
      this.#handler.readyState = states.OPEN;
      const extensions = response2.headersList.get("sec-websocket-extensions");
      if (extensions !== null) {
        this.#extensions = extensions;
      }
      const protocol = response2.headersList.get("sec-websocket-protocol");
      if (protocol !== null) {
        this.#protocol = protocol;
      }
      fireEvent("open", this);
      if (channels.open.hasSubscribers) {
        const headers2 = response2.headersList.entries;
        channels.open.publish({
          address: response2.socket.address(),
          protocol: this.#protocol,
          extensions: this.#extensions,
          websocket: this,
          handshakeResponse: {
            status: response2.status,
            statusText: response2.statusText,
            headers: headers2
          }
        });
      }
    }
    #onMessage(type, data2) {
      if (this.#handler.readyState !== states.OPEN) {
        return;
      }
      let dataForEvent;
      if (type === opcodes.TEXT) {
        try {
          dataForEvent = utf8Decode(data2);
        } catch {
          failWebsocketConnection(this.#handler, 1007, "Received invalid UTF-8 in text frame.");
          return;
        }
      } else if (type === opcodes.BINARY) {
        if (this.#binaryType === "blob") {
          dataForEvent = new Blob([data2]);
        } else {
          dataForEvent = toArrayBuffer(data2);
        }
      }
      fireEvent("message", this, createFastMessageEvent, {
        origin: this.#url.origin,
        data: dataForEvent
      });
    }
    #onParserDrain() {
      this.#handler.socket.resume();
    }
    /**
     * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
     * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.4
     */
    #onSocketClose() {
      const wasClean = this.#handler.closeState.has(sentCloseFrameState.SENT) && this.#handler.closeState.has(sentCloseFrameState.RECEIVED);
      let code = 1005;
      let reason = "";
      const result = this.#parser?.closingInfo;
      if (result && !result.error) {
        code = result.code ?? 1005;
        reason = result.reason;
      }
      this.#handler.readyState = states.CLOSED;
      if (!this.#handler.closeState.has(sentCloseFrameState.RECEIVED)) {
        code = 1006;
        fireEvent("error", this, (type, init) => new ErrorEvent(type, init), {
          error: new TypeError(reason)
        });
      }
      fireEvent("close", this, (type, init) => new CloseEvent(type, init), {
        wasClean,
        code,
        reason
      });
      if (channels.close.hasSubscribers) {
        channels.close.publish({
          websocket: this,
          code,
          reason
        });
      }
    }
    /**
     * @param {WebSocket} ws
     * @param {Buffer|undefined} buffer
     */
    static ping(ws, buffer) {
      if (Buffer.isBuffer(buffer)) {
        if (buffer.length > 125) {
          throw new TypeError("A PING frame cannot have a body larger than 125 bytes.");
        }
      } else if (buffer !== void 0) {
        throw new TypeError("Expected buffer payload");
      }
      const readyState = ws.#handler.readyState;
      if (isEstablished(readyState) && !isClosing(readyState) && !isClosed(readyState)) {
        const frame2 = new WebsocketFrameSend(buffer);
        ws.#handler.socket.write(frame2.createFrame(opcodes.PING));
      }
    }
  }
  const { ping } = WebSocket;
  Reflect.deleteProperty(WebSocket, "ping");
  WebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING;
  WebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN;
  WebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING;
  WebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED;
  Object.defineProperties(WebSocket.prototype, {
    CONNECTING: staticPropertyDescriptors,
    OPEN: staticPropertyDescriptors,
    CLOSING: staticPropertyDescriptors,
    CLOSED: staticPropertyDescriptors,
    url: kEnumerableProperty,
    readyState: kEnumerableProperty,
    bufferedAmount: kEnumerableProperty,
    onopen: kEnumerableProperty,
    onerror: kEnumerableProperty,
    onclose: kEnumerableProperty,
    close: kEnumerableProperty,
    onmessage: kEnumerableProperty,
    binaryType: kEnumerableProperty,
    send: kEnumerableProperty,
    extensions: kEnumerableProperty,
    protocol: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "WebSocket",
      writable: false,
      enumerable: false,
      configurable: true
    }
  });
  Object.defineProperties(WebSocket, {
    CONNECTING: staticPropertyDescriptors,
    OPEN: staticPropertyDescriptors,
    CLOSING: staticPropertyDescriptors,
    CLOSED: staticPropertyDescriptors
  });
  webidl.converters["sequence<DOMString>"] = webidl.sequenceConverter(
    webidl.converters.DOMString
  );
  webidl.converters["DOMString or sequence<DOMString>"] = function(V, prefix, argument) {
    if (webidl.util.Type(V) === webidl.util.Types.OBJECT && Symbol.iterator in V) {
      return webidl.converters["sequence<DOMString>"](V);
    }
    return webidl.converters.DOMString(V, prefix, argument);
  };
  webidl.converters.WebSocketInit = webidl.dictionaryConverter([
    {
      key: "protocols",
      converter: webidl.converters["DOMString or sequence<DOMString>"],
      defaultValue: () => []
    },
    {
      key: "dispatcher",
      converter: webidl.converters.any,
      defaultValue: () => getGlobalDispatcher()
    },
    {
      key: "headers",
      converter: webidl.nullableConverter(webidl.converters.HeadersInit)
    }
  ]);
  webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"] = function(V) {
    if (webidl.util.Type(V) === webidl.util.Types.OBJECT && !(Symbol.iterator in V)) {
      return webidl.converters.WebSocketInit(V);
    }
    return { protocols: webidl.converters["DOMString or sequence<DOMString>"](V) };
  };
  webidl.converters.WebSocketSendData = function(V) {
    if (webidl.util.Type(V) === webidl.util.Types.OBJECT) {
      if (webidl.is.Blob(V)) {
        return V;
      }
      if (webidl.is.BufferSource(V)) {
        return V;
      }
    }
    return webidl.converters.USVString(V);
  };
  websocket = {
    WebSocket,
    ping
  };
  return websocket;
}
var websocketerror;
var hasRequiredWebsocketerror;
function requireWebsocketerror() {
  if (hasRequiredWebsocketerror) return websocketerror;
  hasRequiredWebsocketerror = 1;
  const { webidl } = requireWebidl();
  const { validateCloseCodeAndReason } = requireUtil$1();
  const { kConstruct } = requireSymbols();
  const { kEnumerableProperty } = requireUtil$5();
  function createInheritableDOMException() {
    class Test extends DOMException {
      get reason() {
        return "";
      }
    }
    if (new Test().reason !== void 0) {
      return DOMException;
    }
    return new Proxy(DOMException, {
      construct(target, args, newTarget) {
        const instance = Reflect.construct(target, args, target);
        Object.setPrototypeOf(instance, newTarget.prototype);
        return instance;
      }
    });
  }
  class WebSocketError extends createInheritableDOMException() {
    #closeCode;
    #reason;
    constructor(message = "", init = void 0) {
      message = webidl.converters.DOMString(message, "WebSocketError", "message");
      super(message, "WebSocketError");
      if (init === kConstruct) {
        return;
      } else if (init !== null) {
        init = webidl.converters.WebSocketCloseInfo(init);
      }
      let code = init.closeCode ?? null;
      const reason = init.reason ?? "";
      validateCloseCodeAndReason(code, reason);
      if (reason.length !== 0 && code === null) {
        code = 1e3;
      }
      this.#closeCode = code;
      this.#reason = reason;
    }
    get closeCode() {
      return this.#closeCode;
    }
    get reason() {
      return this.#reason;
    }
    /**
     * @param {string} message
     * @param {number|null} code
     * @param {string} reason
     */
    static createUnvalidatedWebSocketError(message, code, reason) {
      const error2 = new WebSocketError(message, kConstruct);
      error2.#closeCode = code;
      error2.#reason = reason;
      return error2;
    }
  }
  const { createUnvalidatedWebSocketError } = WebSocketError;
  delete WebSocketError.createUnvalidatedWebSocketError;
  Object.defineProperties(WebSocketError.prototype, {
    closeCode: kEnumerableProperty,
    reason: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "WebSocketError",
      writable: false,
      enumerable: false,
      configurable: true
    }
  });
  webidl.is.WebSocketError = webidl.util.MakeTypeAssertion(WebSocketError);
  websocketerror = { WebSocketError, createUnvalidatedWebSocketError };
  return websocketerror;
}
var websocketstream;
var hasRequiredWebsocketstream;
function requireWebsocketstream() {
  if (hasRequiredWebsocketstream) return websocketstream;
  hasRequiredWebsocketstream = 1;
  const { createDeferredPromise } = requirePromise();
  const { environmentSettingsObject } = requireUtil$4();
  const { states, opcodes, sentCloseFrameState } = requireConstants();
  const { webidl } = requireWebidl();
  const { getURLRecord, isValidSubprotocol, isEstablished, utf8Decode } = requireUtil$1();
  const { establishWebSocketConnection, failWebsocketConnection, closeWebSocketConnection } = requireConnection();
  const { channels } = requireDiagnostics();
  const { WebsocketFrameSend } = requireFrame();
  const { ByteParser } = requireReceiver();
  const { WebSocketError, createUnvalidatedWebSocketError } = requireWebsocketerror();
  const { kEnumerableProperty } = requireUtil$5();
  const { utf8DecodeBytes } = requireEncoding();
  let emittedExperimentalWarning = false;
  class WebSocketStream {
    // Each WebSocketStream object has an associated url , which is a URL record .
    /** @type {URL} */
    #url;
    // Each WebSocketStream object has an associated opened promise , which is a promise.
    /** @type {import('../../../util/promise').DeferredPromise} */
    #openedPromise;
    // Each WebSocketStream object has an associated closed promise , which is a promise.
    /** @type {import('../../../util/promise').DeferredPromise} */
    #closedPromise;
    // Each WebSocketStream object has an associated readable stream , which is a ReadableStream .
    /** @type {ReadableStream} */
    #readableStream;
    /** @type {ReadableStreamDefaultController} */
    #readableStreamController;
    // Each WebSocketStream object has an associated writable stream , which is a WritableStream .
    /** @type {WritableStream} */
    #writableStream;
    // Each WebSocketStream object has an associated boolean handshake aborted , which is initially false.
    #handshakeAborted = false;
    /** @type {import('../websocket').Handler} */
    #handler = {
      // https://whatpr.org/websockets/48/7b748d3...d5570f3.html#feedback-to-websocket-stream-from-the-protocol
      onConnectionEstablished: (response2, extensions) => this.#onConnectionEstablished(response2, extensions),
      onMessage: (opcode, data2) => this.#onMessage(opcode, data2),
      onParserError: (err) => failWebsocketConnection(this.#handler, null, err.message),
      onParserDrain: () => this.#handler.socket.resume(),
      onSocketData: (chunk2) => {
        if (!this.#parser.write(chunk2)) {
          this.#handler.socket.pause();
        }
      },
      onSocketError: (err) => {
        this.#handler.readyState = states.CLOSING;
        if (channels.socketError.hasSubscribers) {
          channels.socketError.publish(err);
        }
        this.#handler.socket.destroy();
      },
      onSocketClose: () => this.#onSocketClose(),
      onPing: () => {
      },
      onPong: () => {
      },
      readyState: states.CONNECTING,
      socket: null,
      closeState: /* @__PURE__ */ new Set(),
      controller: null,
      wasEverConnected: false
    };
    /** @type {import('../receiver').ByteParser} */
    #parser;
    constructor(url, options = void 0) {
      if (!emittedExperimentalWarning) {
        process.emitWarning("WebSocketStream is experimental! Expect it to change at any time.", {
          code: "UNDICI-WSS"
        });
        emittedExperimentalWarning = true;
      }
      webidl.argumentLengthCheck(arguments, 1, "WebSocket");
      url = webidl.converters.USVString(url);
      if (options !== null) {
        options = webidl.converters.WebSocketStreamOptions(options);
      }
      const baseURL = environmentSettingsObject.settingsObject.baseUrl;
      const urlRecord = getURLRecord(url, baseURL);
      const protocols = options.protocols;
      if (protocols.length !== new Set(protocols.map((p4) => p4.toLowerCase())).size) {
        throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
      }
      if (protocols.length > 0 && !protocols.every((p4) => isValidSubprotocol(p4))) {
        throw new DOMException("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
      }
      this.#url = urlRecord.toString();
      this.#openedPromise = createDeferredPromise();
      this.#closedPromise = createDeferredPromise();
      if (options.signal != null) {
        const signal = options.signal;
        if (signal.aborted) {
          this.#openedPromise.reject(signal.reason);
          this.#closedPromise.reject(signal.reason);
          return;
        }
        signal.addEventListener("abort", () => {
          if (!isEstablished(this.#handler.readyState)) {
            failWebsocketConnection(this.#handler);
            this.#handler.readyState = states.CLOSING;
            this.#openedPromise.reject(signal.reason);
            this.#closedPromise.reject(signal.reason);
            this.#handshakeAborted = true;
          }
        }, { once: true });
      }
      const client2 = environmentSettingsObject.settingsObject;
      this.#handler.controller = establishWebSocketConnection(
        urlRecord,
        protocols,
        client2,
        this.#handler,
        options
      );
    }
    // The url getter steps are to return this 's url , serialized .
    get url() {
      return this.#url.toString();
    }
    // The opened getter steps are to return this 's opened promise .
    get opened() {
      return this.#openedPromise.promise;
    }
    // The closed getter steps are to return this 's closed promise .
    get closed() {
      return this.#closedPromise.promise;
    }
    // The close( closeInfo ) method steps are:
    close(closeInfo = void 0) {
      if (closeInfo !== null) {
        closeInfo = webidl.converters.WebSocketCloseInfo(closeInfo);
      }
      const code = closeInfo.closeCode ?? null;
      const reason = closeInfo.reason;
      closeWebSocketConnection(this.#handler, code, reason, true);
    }
    #write(chunk2) {
      chunk2 = webidl.converters.WebSocketStreamWrite(chunk2);
      const promise2 = createDeferredPromise();
      let data2 = null;
      let opcode = null;
      if (webidl.is.BufferSource(chunk2)) {
        data2 = new Uint8Array(ArrayBuffer.isView(chunk2) ? new Uint8Array(chunk2.buffer, chunk2.byteOffset, chunk2.byteLength) : chunk2.slice());
        opcode = opcodes.BINARY;
      } else {
        let string;
        try {
          string = webidl.converters.DOMString(chunk2);
        } catch (e4) {
          promise2.reject(e4);
          return promise2.promise;
        }
        data2 = new TextEncoder().encode(string);
        opcode = opcodes.TEXT;
      }
      if (!this.#handler.closeState.has(sentCloseFrameState.SENT) && !this.#handler.closeState.has(sentCloseFrameState.RECEIVED)) {
        const frame2 = new WebsocketFrameSend(data2);
        this.#handler.socket.write(frame2.createFrame(opcode), () => {
          promise2.resolve(void 0);
        });
      }
      return promise2.promise;
    }
    /** @type {import('../websocket').Handler['onConnectionEstablished']} */
    #onConnectionEstablished(response2, parsedExtensions) {
      this.#handler.socket = response2.socket;
      const parser = new ByteParser(this.#handler, parsedExtensions);
      parser.on("drain", () => this.#handler.onParserDrain());
      parser.on("error", (err) => this.#handler.onParserError(err));
      this.#parser = parser;
      this.#handler.readyState = states.OPEN;
      const extensions = parsedExtensions ?? "";
      const protocol = response2.headersList.get("sec-websocket-protocol") ?? "";
      const readable2 = new ReadableStream({
        start: (controller) => {
          this.#readableStreamController = controller;
        },
        pull(controller) {
          let chunk2;
          while (controller.desiredSize > 0 && (chunk2 = response2.socket.read()) !== null) {
            controller.enqueue(chunk2);
          }
        },
        cancel: (reason) => this.#cancel(reason)
      });
      const writable = new WritableStream({
        write: (chunk2) => this.#write(chunk2),
        close: () => closeWebSocketConnection(this.#handler, null, null),
        abort: (reason) => this.#closeUsingReason(reason)
      });
      this.#readableStream = readable2;
      this.#writableStream = writable;
      this.#openedPromise.resolve({
        extensions,
        protocol,
        readable: readable2,
        writable
      });
    }
    /** @type {import('../websocket').Handler['onMessage']} */
    #onMessage(type, data2) {
      if (this.#handler.readyState !== states.OPEN) {
        return;
      }
      let chunk2;
      if (type === opcodes.TEXT) {
        try {
          chunk2 = utf8Decode(data2);
        } catch {
          failWebsocketConnection(this.#handler, "Received invalid UTF-8 in text frame.");
          return;
        }
      } else if (type === opcodes.BINARY) {
        chunk2 = new Uint8Array(data2.buffer, data2.byteOffset, data2.byteLength);
      }
      this.#readableStreamController.enqueue(chunk2);
    }
    /** @type {import('../websocket').Handler['onSocketClose']} */
    #onSocketClose() {
      const wasClean = this.#handler.closeState.has(sentCloseFrameState.SENT) && this.#handler.closeState.has(sentCloseFrameState.RECEIVED);
      this.#handler.readyState = states.CLOSED;
      if (this.#handshakeAborted) {
        return;
      }
      if (!this.#handler.wasEverConnected) {
        this.#openedPromise.reject(new WebSocketError("Socket never opened"));
      }
      const result = this.#parser.closingInfo;
      let code = result?.code ?? 1005;
      if (!this.#handler.closeState.has(sentCloseFrameState.SENT) && !this.#handler.closeState.has(sentCloseFrameState.RECEIVED)) {
        code = 1006;
      }
      const reason = result?.reason == null ? "" : utf8DecodeBytes(Buffer.from(result.reason));
      if (wasClean) {
        this.#readableStreamController.close();
        if (!this.#writableStream.locked) {
          this.#writableStream.abort(new DOMException("A closed WebSocketStream cannot be written to", "InvalidStateError"));
        }
        this.#closedPromise.resolve({
          closeCode: code,
          reason
        });
      } else {
        const error2 = createUnvalidatedWebSocketError("unclean close", code, reason);
        this.#readableStreamController.error(error2);
        this.#writableStream.abort(error2);
        this.#closedPromise.reject(error2);
      }
    }
    #closeUsingReason(reason) {
      let code = null;
      let reasonString = "";
      if (webidl.is.WebSocketError(reason)) {
        code = reason.closeCode;
        reasonString = reason.reason;
      }
      closeWebSocketConnection(this.#handler, code, reasonString);
    }
    //  To cancel a WebSocketStream stream given reason , close using reason giving stream and reason .
    #cancel(reason) {
      this.#closeUsingReason(reason);
    }
  }
  Object.defineProperties(WebSocketStream.prototype, {
    url: kEnumerableProperty,
    opened: kEnumerableProperty,
    closed: kEnumerableProperty,
    close: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "WebSocketStream",
      writable: false,
      enumerable: false,
      configurable: true
    }
  });
  webidl.converters.WebSocketStreamOptions = webidl.dictionaryConverter([
    {
      key: "protocols",
      converter: webidl.sequenceConverter(webidl.converters.USVString),
      defaultValue: () => []
    },
    {
      key: "signal",
      converter: webidl.nullableConverter(webidl.converters.AbortSignal),
      defaultValue: () => null
    }
  ]);
  webidl.converters.WebSocketCloseInfo = webidl.dictionaryConverter([
    {
      key: "closeCode",
      converter: (V) => webidl.converters["unsigned short"](V, webidl.attributes.EnforceRange)
    },
    {
      key: "reason",
      converter: webidl.converters.USVString,
      defaultValue: () => ""
    }
  ]);
  webidl.converters.WebSocketStreamWrite = function(V) {
    if (typeof V === "string") {
      return webidl.converters.USVString(V);
    }
    return webidl.converters.BufferSource(V);
  };
  websocketstream = { WebSocketStream };
  return websocketstream;
}
var util;
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util;
  hasRequiredUtil = 1;
  function isValidLastEventId(value) {
    return value.indexOf("\0") === -1;
  }
  function isASCIINumber(value) {
    if (value.length === 0) return false;
    for (let i4 = 0; i4 < value.length; i4++) {
      if (value.charCodeAt(i4) < 48 || value.charCodeAt(i4) > 57) return false;
    }
    return true;
  }
  util = {
    isValidLastEventId,
    isASCIINumber
  };
  return util;
}
var eventsourceStream;
var hasRequiredEventsourceStream;
function requireEventsourceStream() {
  if (hasRequiredEventsourceStream) return eventsourceStream;
  hasRequiredEventsourceStream = 1;
  const { Transform: Transform2 } = import_node_stream.default;
  const { isASCIINumber, isValidLastEventId } = requireUtil();
  const BOM = [239, 187, 191];
  const LF = 10;
  const CR = 13;
  const COLON = 58;
  const SPACE = 32;
  class EventSourceStream extends Transform2 {
    /**
     * @type {eventSourceSettings}
     */
    state;
    /**
     * Leading byte-order-mark check.
     * @type {boolean}
     */
    checkBOM = true;
    /**
     * @type {boolean}
     */
    crlfCheck = false;
    /**
     * @type {boolean}
     */
    eventEndCheck = false;
    /**
     * @type {Buffer|null}
     */
    buffer = null;
    pos = 0;
    event = {
      data: void 0,
      event: void 0,
      id: void 0,
      retry: void 0
    };
    /**
     * @param {object} options
     * @param {boolean} [options.readableObjectMode]
     * @param {eventSourceSettings} [options.eventSourceSettings]
     * @param {(chunk: any, encoding?: BufferEncoding | undefined) => boolean} [options.push]
     */
    constructor(options = {}) {
      options.readableObjectMode = true;
      super(options);
      this.state = options.eventSourceSettings || {};
      if (options.push) {
        this.push = options.push;
      }
    }
    /**
     * @param {Buffer} chunk
     * @param {string} _encoding
     * @param {Function} callback
     * @returns {void}
     */
    _transform(chunk2, _encoding, callback) {
      if (chunk2.length === 0) {
        callback();
        return;
      }
      if (this.buffer) {
        this.buffer = Buffer.concat([this.buffer, chunk2]);
      } else {
        this.buffer = chunk2;
      }
      if (this.checkBOM) {
        switch (this.buffer.length) {
          case 1:
            if (this.buffer[0] === BOM[0]) {
              callback();
              return;
            }
            this.checkBOM = false;
            callback();
            return;
          case 2:
            if (this.buffer[0] === BOM[0] && this.buffer[1] === BOM[1]) {
              callback();
              return;
            }
            this.checkBOM = false;
            break;
          case 3:
            if (this.buffer[0] === BOM[0] && this.buffer[1] === BOM[1] && this.buffer[2] === BOM[2]) {
              this.buffer = Buffer.alloc(0);
              this.checkBOM = false;
              callback();
              return;
            }
            this.checkBOM = false;
            break;
          default:
            if (this.buffer[0] === BOM[0] && this.buffer[1] === BOM[1] && this.buffer[2] === BOM[2]) {
              this.buffer = this.buffer.subarray(3);
            }
            this.checkBOM = false;
            break;
        }
      }
      while (this.pos < this.buffer.length) {
        if (this.eventEndCheck) {
          if (this.crlfCheck) {
            if (this.buffer[this.pos] === LF) {
              this.buffer = this.buffer.subarray(this.pos + 1);
              this.pos = 0;
              this.crlfCheck = false;
              continue;
            }
            this.crlfCheck = false;
          }
          if (this.buffer[this.pos] === LF || this.buffer[this.pos] === CR) {
            if (this.buffer[this.pos] === CR) {
              this.crlfCheck = true;
            }
            this.buffer = this.buffer.subarray(this.pos + 1);
            this.pos = 0;
            if (this.event.data !== void 0 || this.event.event || this.event.id !== void 0 || this.event.retry) {
              this.processEvent(this.event);
            }
            this.clearEvent();
            continue;
          }
          this.eventEndCheck = false;
          continue;
        }
        if (this.buffer[this.pos] === LF || this.buffer[this.pos] === CR) {
          if (this.buffer[this.pos] === CR) {
            this.crlfCheck = true;
          }
          this.parseLine(this.buffer.subarray(0, this.pos), this.event);
          this.buffer = this.buffer.subarray(this.pos + 1);
          this.pos = 0;
          this.eventEndCheck = true;
          continue;
        }
        this.pos++;
      }
      callback();
    }
    /**
     * @param {Buffer} line
     * @param {EventSourceStreamEvent} event
     */
    parseLine(line, event) {
      if (line.length === 0) {
        return;
      }
      const colonPosition = line.indexOf(COLON);
      if (colonPosition === 0) {
        return;
      }
      let field = "";
      let value = "";
      if (colonPosition !== -1) {
        field = line.subarray(0, colonPosition).toString("utf8");
        let valueStart = colonPosition + 1;
        if (line[valueStart] === SPACE) {
          ++valueStart;
        }
        value = line.subarray(valueStart).toString("utf8");
      } else {
        field = line.toString("utf8");
        value = "";
      }
      switch (field) {
        case "data":
          if (event[field] === void 0) {
            event[field] = value;
          } else {
            event[field] += `
${value}`;
          }
          break;
        case "retry":
          if (isASCIINumber(value)) {
            event[field] = value;
          }
          break;
        case "id":
          if (isValidLastEventId(value)) {
            event[field] = value;
          }
          break;
        case "event":
          if (value.length > 0) {
            event[field] = value;
          }
          break;
      }
    }
    /**
     * @param {EventSourceStreamEvent} event
     */
    processEvent(event) {
      if (event.retry && isASCIINumber(event.retry)) {
        this.state.reconnectionTime = parseInt(event.retry, 10);
      }
      if (event.id !== void 0 && isValidLastEventId(event.id)) {
        this.state.lastEventId = event.id;
      }
      if (event.data !== void 0) {
        this.push({
          type: event.event || "message",
          options: {
            data: event.data,
            lastEventId: this.state.lastEventId,
            origin: this.state.origin
          }
        });
      }
    }
    clearEvent() {
      this.event = {
        data: void 0,
        event: void 0,
        id: void 0,
        retry: void 0
      };
    }
  }
  eventsourceStream = {
    EventSourceStream
  };
  return eventsourceStream;
}
var eventsource;
var hasRequiredEventsource;
function requireEventsource() {
  if (hasRequiredEventsource) return eventsource;
  hasRequiredEventsource = 1;
  const { pipeline } = import_node_stream.default;
  const { fetching } = requireFetch();
  const { makeRequest } = requireRequest();
  const { webidl } = requireWebidl();
  const { EventSourceStream } = requireEventsourceStream();
  const { parseMIMEType } = requireDataUrl();
  const { createFastMessageEvent } = requireEvents();
  const { isNetworkError } = requireResponse();
  const { kEnumerableProperty } = requireUtil$5();
  const { environmentSettingsObject } = requireUtil$4();
  let experimentalWarned = false;
  const defaultReconnectionTime = 3e3;
  const CONNECTING = 0;
  const OPEN = 1;
  const CLOSED = 2;
  const ANONYMOUS = "anonymous";
  const USE_CREDENTIALS = "use-credentials";
  class EventSource extends EventTarget {
    #events = {
      open: null,
      error: null,
      message: null
    };
    #url;
    #withCredentials = false;
    /**
     * @type {ReadyState}
     */
    #readyState = CONNECTING;
    #request = null;
    #controller = null;
    #dispatcher;
    /**
     * @type {import('./eventsource-stream').eventSourceSettings}
     */
    #state;
    /**
     * Creates a new EventSource object.
     * @param {string} url
     * @param {EventSourceInit} [eventSourceInitDict={}]
     * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#the-eventsource-interface
     */
    constructor(url, eventSourceInitDict = {}) {
      super();
      webidl.util.markAsUncloneable(this);
      const prefix = "EventSource constructor";
      webidl.argumentLengthCheck(arguments, 1, prefix);
      if (!experimentalWarned) {
        experimentalWarned = true;
        process.emitWarning("EventSource is experimental, expect them to change at any time.", {
          code: "UNDICI-ES"
        });
      }
      url = webidl.converters.USVString(url);
      eventSourceInitDict = webidl.converters.EventSourceInitDict(eventSourceInitDict, prefix, "eventSourceInitDict");
      this.#dispatcher = eventSourceInitDict.node.dispatcher || eventSourceInitDict.dispatcher;
      this.#state = {
        lastEventId: "",
        reconnectionTime: eventSourceInitDict.node.reconnectionTime
      };
      const settings = environmentSettingsObject;
      let urlRecord;
      try {
        urlRecord = new URL(url, settings.settingsObject.baseUrl);
        this.#state.origin = urlRecord.origin;
      } catch (e4) {
        throw new DOMException(e4, "SyntaxError");
      }
      this.#url = urlRecord.href;
      let corsAttributeState = ANONYMOUS;
      if (eventSourceInitDict.withCredentials === true) {
        corsAttributeState = USE_CREDENTIALS;
        this.#withCredentials = true;
      }
      const initRequest = {
        redirect: "follow",
        keepalive: true,
        // @see https://html.spec.whatwg.org/multipage/urls-and-fetching.html#cors-settings-attributes
        mode: "cors",
        credentials: corsAttributeState === "anonymous" ? "same-origin" : "omit",
        referrer: "no-referrer"
      };
      initRequest.client = environmentSettingsObject.settingsObject;
      initRequest.headersList = [["accept", { name: "accept", value: "text/event-stream" }]];
      initRequest.cache = "no-store";
      initRequest.initiator = "other";
      initRequest.urlList = [new URL(this.#url)];
      this.#request = makeRequest(initRequest);
      this.#connect();
    }
    /**
     * Returns the state of this EventSource object's connection. It can have the
     * values described below.
     * @returns {ReadyState}
     * @readonly
     */
    get readyState() {
      return this.#readyState;
    }
    /**
     * Returns the URL providing the event stream.
     * @readonly
     * @returns {string}
     */
    get url() {
      return this.#url;
    }
    /**
     * Returns a boolean indicating whether the EventSource object was
     * instantiated with CORS credentials set (true), or not (false, the default).
     */
    get withCredentials() {
      return this.#withCredentials;
    }
    #connect() {
      if (this.#readyState === CLOSED) return;
      this.#readyState = CONNECTING;
      const fetchParams = {
        request: this.#request,
        dispatcher: this.#dispatcher
      };
      const processEventSourceEndOfBody = (response2) => {
        if (!isNetworkError(response2)) {
          return this.#reconnect();
        }
      };
      fetchParams.processResponseEndOfBody = processEventSourceEndOfBody;
      fetchParams.processResponse = (response2) => {
        if (isNetworkError(response2)) {
          if (response2.aborted) {
            this.close();
            this.dispatchEvent(new Event("error"));
            return;
          } else {
            this.#reconnect();
            return;
          }
        }
        const contentType = response2.headersList.get("content-type", true);
        const mimeType = contentType !== null ? parseMIMEType(contentType) : "failure";
        const contentTypeValid = mimeType !== "failure" && mimeType.essence === "text/event-stream";
        if (response2.status !== 200 || contentTypeValid === false) {
          this.close();
          this.dispatchEvent(new Event("error"));
          return;
        }
        this.#readyState = OPEN;
        this.dispatchEvent(new Event("open"));
        this.#state.origin = response2.urlList[response2.urlList.length - 1].origin;
        const eventSourceStream = new EventSourceStream({
          eventSourceSettings: this.#state,
          push: (event) => {
            this.dispatchEvent(createFastMessageEvent(
              event.type,
              event.options
            ));
          }
        });
        pipeline(
          response2.body.stream,
          eventSourceStream,
          (error2) => {
            if (error2?.aborted === false) {
              this.close();
              this.dispatchEvent(new Event("error"));
            }
          }
        );
      };
      this.#controller = fetching(fetchParams);
    }
    /**
     * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#sse-processing-model
     * @returns {void}
     */
    #reconnect() {
      if (this.#readyState === CLOSED) return;
      this.#readyState = CONNECTING;
      this.dispatchEvent(new Event("error"));
      setTimeout(() => {
        if (this.#readyState !== CONNECTING) return;
        if (this.#state.lastEventId.length) {
          this.#request.headersList.set("last-event-id", this.#state.lastEventId, true);
        }
        this.#connect();
      }, this.#state.reconnectionTime)?.unref();
    }
    /**
     * Closes the connection, if any, and sets the readyState attribute to
     * CLOSED.
     */
    close() {
      webidl.brandCheck(this, EventSource);
      if (this.#readyState === CLOSED) return;
      this.#readyState = CLOSED;
      this.#controller.abort();
      this.#request = null;
    }
    get onopen() {
      return this.#events.open;
    }
    set onopen(fn) {
      if (this.#events.open) {
        this.removeEventListener("open", this.#events.open);
      }
      const listener = webidl.converters.EventHandlerNonNull(fn);
      if (listener !== null) {
        this.addEventListener("open", listener);
        this.#events.open = fn;
      } else {
        this.#events.open = null;
      }
    }
    get onmessage() {
      return this.#events.message;
    }
    set onmessage(fn) {
      if (this.#events.message) {
        this.removeEventListener("message", this.#events.message);
      }
      const listener = webidl.converters.EventHandlerNonNull(fn);
      if (listener !== null) {
        this.addEventListener("message", listener);
        this.#events.message = fn;
      } else {
        this.#events.message = null;
      }
    }
    get onerror() {
      return this.#events.error;
    }
    set onerror(fn) {
      if (this.#events.error) {
        this.removeEventListener("error", this.#events.error);
      }
      const listener = webidl.converters.EventHandlerNonNull(fn);
      if (listener !== null) {
        this.addEventListener("error", listener);
        this.#events.error = fn;
      } else {
        this.#events.error = null;
      }
    }
  }
  const constantsPropertyDescriptors = {
    CONNECTING: {
      __proto__: null,
      configurable: false,
      enumerable: true,
      value: CONNECTING,
      writable: false
    },
    OPEN: {
      __proto__: null,
      configurable: false,
      enumerable: true,
      value: OPEN,
      writable: false
    },
    CLOSED: {
      __proto__: null,
      configurable: false,
      enumerable: true,
      value: CLOSED,
      writable: false
    }
  };
  Object.defineProperties(EventSource, constantsPropertyDescriptors);
  Object.defineProperties(EventSource.prototype, constantsPropertyDescriptors);
  Object.defineProperties(EventSource.prototype, {
    close: kEnumerableProperty,
    onerror: kEnumerableProperty,
    onmessage: kEnumerableProperty,
    onopen: kEnumerableProperty,
    readyState: kEnumerableProperty,
    url: kEnumerableProperty,
    withCredentials: kEnumerableProperty
  });
  webidl.converters.EventSourceInitDict = webidl.dictionaryConverter([
    {
      key: "withCredentials",
      converter: webidl.converters.boolean,
      defaultValue: () => false
    },
    {
      key: "dispatcher",
      // undici only
      converter: webidl.converters.any
    },
    {
      key: "node",
      // undici only
      converter: webidl.dictionaryConverter([
        {
          key: "reconnectionTime",
          converter: webidl.converters["unsigned long"],
          defaultValue: () => defaultReconnectionTime
        },
        {
          key: "dispatcher",
          converter: webidl.converters.any
        }
      ]),
      defaultValue: () => ({})
    }
  ]);
  eventsource = {
    EventSource,
    defaultReconnectionTime
  };
  return eventsource;
}
undici$1.exports;
var hasRequiredUndici;
function requireUndici() {
  if (hasRequiredUndici) return undici$1.exports;
  hasRequiredUndici = 1;
  (function(module2) {
    const Client2 = requireClient();
    const Dispatcher = requireDispatcher();
    const Pool = requirePool();
    const BalancedPool = requireBalancedPool();
    const RoundRobinPool = requireRoundRobinPool();
    const Agent = requireAgent();
    const ProxyAgent = requireProxyAgent();
    const EnvHttpProxyAgent = requireEnvHttpProxyAgent();
    const RetryAgent = requireRetryAgent();
    const H2CClient = requireH2cClient();
    const errors2 = requireErrors();
    const util2 = requireUtil$5();
    const { InvalidArgumentError } = errors2;
    const api2 = requireApi();
    const buildConnector = requireConnect();
    const MockClient = requireMockClient();
    const { MockCallHistory, MockCallHistoryLog } = requireMockCallHistory();
    const MockAgent = requireMockAgent();
    const MockPool = requireMockPool();
    const SnapshotAgent = requireSnapshotAgent();
    const mockErrors2 = requireMockErrors();
    const RetryHandler = requireRetryHandler();
    const { getGlobalDispatcher, setGlobalDispatcher } = requireGlobal();
    const DecoratorHandler = requireDecoratorHandler();
    const RedirectHandler = requireRedirectHandler();
    Object.assign(Dispatcher.prototype, api2);
    module2.exports.Dispatcher = Dispatcher;
    module2.exports.Client = Client2;
    module2.exports.Pool = Pool;
    module2.exports.BalancedPool = BalancedPool;
    module2.exports.RoundRobinPool = RoundRobinPool;
    module2.exports.Agent = Agent;
    module2.exports.ProxyAgent = ProxyAgent;
    module2.exports.EnvHttpProxyAgent = EnvHttpProxyAgent;
    module2.exports.RetryAgent = RetryAgent;
    module2.exports.H2CClient = H2CClient;
    module2.exports.RetryHandler = RetryHandler;
    module2.exports.DecoratorHandler = DecoratorHandler;
    module2.exports.RedirectHandler = RedirectHandler;
    module2.exports.interceptors = {
      redirect: requireRedirect(),
      responseError: requireResponseError(),
      retry: requireRetry(),
      dump: requireDump(),
      dns: requireDns(),
      cache: requireCache$1(),
      decompress: requireDecompress(),
      deduplicate: requireDeduplicate()
    };
    module2.exports.cacheStores = {
      MemoryCacheStore: requireMemoryCacheStore()
    };
    const SqliteCacheStore = requireSqliteCacheStore();
    module2.exports.cacheStores.SqliteCacheStore = SqliteCacheStore;
    module2.exports.buildConnector = buildConnector;
    module2.exports.errors = errors2;
    module2.exports.util = {
      parseHeaders: util2.parseHeaders,
      headerNameToString: util2.headerNameToString
    };
    function makeDispatcher(fn) {
      return (url, opts, handler) => {
        if (typeof opts === "function") {
          handler = opts;
          opts = null;
        }
        if (!url || typeof url !== "string" && typeof url !== "object" && !(url instanceof URL)) {
          throw new InvalidArgumentError("invalid url");
        }
        if (opts != null && typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (opts && opts.path != null) {
          if (typeof opts.path !== "string") {
            throw new InvalidArgumentError("invalid opts.path");
          }
          let path3 = opts.path;
          if (!opts.path.startsWith("/")) {
            path3 = `/${path3}`;
          }
          url = new URL(util2.parseOrigin(url).origin + path3);
        } else {
          if (!opts) {
            opts = typeof url === "object" ? url : {};
          }
          url = util2.parseURL(url);
        }
        const { agent: agent2, dispatcher: dispatcher2 = getGlobalDispatcher() } = opts;
        if (agent2) {
          throw new InvalidArgumentError("unsupported opts.agent. Did you mean opts.client?");
        }
        return fn.call(dispatcher2, {
          ...opts,
          origin: url.origin,
          path: url.search ? `${url.pathname}${url.search}` : url.pathname,
          method: opts.method || (opts.body ? "PUT" : "GET")
        }, handler);
      };
    }
    module2.exports.setGlobalDispatcher = setGlobalDispatcher;
    module2.exports.getGlobalDispatcher = getGlobalDispatcher;
    const fetchImpl = requireFetch().fetch;
    module2.exports.fetch = function fetch3(init, options = void 0) {
      return fetchImpl(init, options).catch((err) => {
        if (err && typeof err === "object") {
          Error.captureStackTrace(err);
        }
        throw err;
      });
    };
    module2.exports.Headers = requireHeaders().Headers;
    module2.exports.Response = requireResponse().Response;
    module2.exports.Request = requireRequest().Request;
    module2.exports.FormData = requireFormdata().FormData;
    const { setGlobalOrigin, getGlobalOrigin } = requireGlobal$1();
    module2.exports.setGlobalOrigin = setGlobalOrigin;
    module2.exports.getGlobalOrigin = getGlobalOrigin;
    const { CacheStorage } = requireCachestorage();
    const { kConstruct } = requireSymbols();
    module2.exports.caches = new CacheStorage(kConstruct);
    const { deleteCookie, getCookies, getSetCookies, setCookie, parseCookie } = requireCookies();
    module2.exports.deleteCookie = deleteCookie;
    module2.exports.getCookies = getCookies;
    module2.exports.getSetCookies = getSetCookies;
    module2.exports.setCookie = setCookie;
    module2.exports.parseCookie = parseCookie;
    const { parseMIMEType, serializeAMimeType } = requireDataUrl();
    module2.exports.parseMIMEType = parseMIMEType;
    module2.exports.serializeAMimeType = serializeAMimeType;
    const { CloseEvent, ErrorEvent, MessageEvent } = requireEvents();
    const { WebSocket, ping } = requireWebsocket();
    module2.exports.WebSocket = WebSocket;
    module2.exports.CloseEvent = CloseEvent;
    module2.exports.ErrorEvent = ErrorEvent;
    module2.exports.MessageEvent = MessageEvent;
    module2.exports.ping = ping;
    module2.exports.WebSocketStream = requireWebsocketstream().WebSocketStream;
    module2.exports.WebSocketError = requireWebsocketerror().WebSocketError;
    module2.exports.request = makeDispatcher(api2.request);
    module2.exports.stream = makeDispatcher(api2.stream);
    module2.exports.pipeline = makeDispatcher(api2.pipeline);
    module2.exports.connect = makeDispatcher(api2.connect);
    module2.exports.upgrade = makeDispatcher(api2.upgrade);
    module2.exports.MockClient = MockClient;
    module2.exports.MockCallHistory = MockCallHistory;
    module2.exports.MockCallHistoryLog = MockCallHistoryLog;
    module2.exports.MockPool = MockPool;
    module2.exports.MockAgent = MockAgent;
    module2.exports.SnapshotAgent = SnapshotAgent;
    module2.exports.mockErrors = mockErrors2;
    const { EventSource } = requireEventsource();
    module2.exports.EventSource = EventSource;
    function install() {
      globalThis.fetch = module2.exports.fetch;
      globalThis.Headers = module2.exports.Headers;
      globalThis.Response = module2.exports.Response;
      globalThis.Request = module2.exports.Request;
      globalThis.FormData = module2.exports.FormData;
      globalThis.WebSocket = module2.exports.WebSocket;
      globalThis.CloseEvent = module2.exports.CloseEvent;
      globalThis.ErrorEvent = module2.exports.ErrorEvent;
      globalThis.MessageEvent = module2.exports.MessageEvent;
      globalThis.EventSource = module2.exports.EventSource;
    }
    module2.exports.install = install;
  })(undici$1);
  return undici$1.exports;
}
var undiciExports = requireUndici();
async function* parseSSE(response2) {
  if (!response2.body) {
    throw new StreamError$1("Response body is empty; cannot parse SSE stream.", {
      streamType: "sse",
      retriable: true
    });
  }
  const reader = response2.body.getReader();
  const decoder = new TextDecoder();
  let buffer = "";
  let currentEvent = { data: "" };
  try {
    while (true) {
      const { done, value } = await reader.read();
      if (done)
        break;
      buffer += decoder.decode(value, { stream: true });
      const lines = buffer.split(/\r\n|\r|\n/);
      buffer = lines.pop() || "";
      for (const line of lines) {
        if (line.trim() === "") {
          if (currentEvent.data || currentEvent.event || currentEvent.id) {
            if (currentEvent.data.endsWith("\n")) {
              currentEvent.data = currentEvent.data.slice(0, -1);
            }
            yield currentEvent;
            currentEvent = { data: "" };
          }
          continue;
        }
        const colonIndex = line.indexOf(":");
        let field = line;
        let value2 = "";
        if (colonIndex !== -1) {
          field = line.slice(0, colonIndex);
          value2 = line.slice(colonIndex + 1);
          if (value2.startsWith(" ")) {
            value2 = value2.slice(1);
          }
        }
        switch (field) {
          case "data":
            currentEvent.data += value2 + "\n";
            break;
          case "event":
            currentEvent.event = value2;
            break;
          case "id":
            currentEvent.id = value2;
            break;
          case "retry":
            const retry2 = parseInt(value2, 10);
            if (!isNaN(retry2)) {
              currentEvent.retry = retry2;
            }
            break;
        }
      }
    }
    if (buffer.trim() !== "") {
    }
  } finally {
    reader.releaseLock();
  }
}
function cleanHtml(html) {
  if (!html)
    return "";
  let text = html;
  text = text.replace(/<script\b[^>]*>[\s\S]*?<\/script>/gi, "");
  text = text.replace(/<style\b[^>]*>[\s\S]*?<\/style>/gi, "");
  text = text.replace(/<!--[\s\S]*?-->/g, "");
  text = text.replace(/<\/(div|p|h[1-6]|li|ul|ol|tr|table|section|article|main|header|footer|nav)>/gi, "\n");
  text = text.replace(/<(br|hr)\s*\/?>/gi, "\n");
  text = text.replace(/<[^>]+>/g, " ");
  text = text.replace(/&nbsp;/g, " ").replace(/&amp;/g, "&").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, '"').replace(/&#39;/g, "'");
  text = text.replace(/[ \t]+/g, " ");
  text = text.replace(/\n\s*\n\s*\n+/g, "\n\n");
  return text.trim();
}
function webToNodeStream(webStream) {
  const reader = webStream.getReader();
  return new import_node_stream.Readable({
    async read() {
      try {
        const { done, value } = await reader.read();
        if (done) {
          this.push(null);
        } else {
          this.push(value);
        }
      } catch (error2) {
        this.destroy(error2);
      }
    },
    destroy(error2, callback) {
      reader.cancel().finally(() => callback(error2));
    }
  });
}
function nodeToWebStream(nodeStream) {
  return new ReadableStream({
    start(controller) {
      nodeStream.on("data", (chunk2) => {
        controller.enqueue(new Uint8Array(chunk2));
      });
      nodeStream.on("end", () => {
        controller.close();
      });
      nodeStream.on("error", (err) => {
        controller.error(err);
      });
    },
    cancel() {
      nodeStream.destroy();
    }
  });
}
function parseCacheInfo(headers2) {
  const info2 = { hit: false };
  const cfCacheStatus = headers2.get("cf-cache-status");
  if (cfCacheStatus) {
    info2.provider = "cloudflare";
    info2.status = cfCacheStatus.toUpperCase();
    info2.hit = cfCacheStatus.toUpperCase() === "HIT";
  }
  const xCache = headers2.get("x-cache");
  if (xCache) {
    const upper = xCache.toUpperCase();
    info2.hit = upper.includes("HIT");
    if (upper.includes("FASTLY"))
      info2.provider = "fastly";
    else if (upper.includes("VARNISH"))
      info2.provider = "varnish";
    if (upper.includes("HIT"))
      info2.status = "HIT";
    else if (upper.includes("MISS"))
      info2.status = "MISS";
    else if (upper.includes("EXPIRED"))
      info2.status = "EXPIRED";
    else if (upper.includes("STALE"))
      info2.status = "STALE";
  }
  const akamaiCache = headers2.get("x-akamai-cache-status");
  if (akamaiCache) {
    info2.provider = "akamai";
    info2.hit = akamaiCache.toUpperCase().includes("HIT");
  }
  headers2.get("x-cache");
  const cloudFrontId = headers2.get("x-amz-cf-id");
  if (cloudFrontId) {
    info2.provider = "cloudfront";
  }
  const cacheControl = headers2.get("cache-control");
  if (cacheControl) {
    const maxAgeMatch = cacheControl.match(/max-age=(\d+)/);
    if (maxAgeMatch) {
      info2.maxAge = parseInt(maxAgeMatch[1], 10);
    }
  }
  const age = headers2.get("age");
  if (age) {
    info2.age = parseInt(age, 10);
  }
  return info2;
}
var PLATFORM_DETECTORS = [
  {
    name: "cloudflare",
    category: "cdn",
    headers: ["cf-ray", "cf-cache-status"],
    detect: (headers2) => headers2.get("cf-ray") !== null,
    extract: (headers2) => {
      const ray = headers2.get("cf-ray");
      const metadata = {};
      if (ray) {
        metadata.ray = ray;
        const parts = ray.split("-");
        if (parts.length > 1) {
          return { region: parts[1], metadata };
        }
      }
      return { metadata };
    }
  },
  {
    name: "fastly",
    category: "cdn",
    headers: ["fastly-debug-digest", "x-served-by"],
    detect: (headers2) => {
      const servedBy = headers2.get("x-served-by");
      return servedBy?.includes("cache-") || headers2.get("fastly-debug-digest") !== null;
    },
    extract: (headers2) => ({
      server: headers2.get("x-served-by") || void 0,
      metadata: {
        digest: headers2.get("fastly-debug-digest")
      }
    })
  },
  {
    name: "akamai",
    category: "cdn",
    headers: ["x-akamai-request-id", "x-akamai-cache-status"],
    detect: (headers2) => headers2.get("x-akamai-request-id") !== null,
    extract: (headers2) => ({
      metadata: {
        requestId: headers2.get("x-akamai-request-id"),
        cacheId: headers2.get("x-akamai-cache-status")
      }
    })
  },
  {
    name: "aws-cloudfront",
    category: "cloud",
    headers: ["x-amz-cf-id", "x-amz-cf-pop"],
    detect: (headers2) => headers2.get("x-amz-cf-id") !== null,
    extract: (headers2) => ({
      region: headers2.get("x-amz-cf-pop") || void 0,
      metadata: {
        requestId: headers2.get("x-amz-cf-id"),
        pop: headers2.get("x-amz-cf-pop")
      }
    })
  },
  {
    name: "gcp",
    category: "cloud",
    headers: ["x-cloud-trace-context", "x-goog-request-id"],
    detect: (headers2) => headers2.get("x-cloud-trace-context") !== null || headers2.get("x-goog-request-id") !== null,
    extract: (headers2) => {
      const trace = headers2.get("x-cloud-trace-context");
      return {
        metadata: {
          traceId: trace ? trace.split("/")[0] : void 0,
          requestId: headers2.get("x-goog-request-id")
        }
      };
    }
  },
  {
    name: "azure",
    category: "cloud",
    headers: ["x-ms-request-id", "x-azure-ref"],
    detect: (headers2) => headers2.get("x-ms-request-id") !== null,
    extract: (headers2) => ({
      metadata: {
        requestId: headers2.get("x-ms-request-id"),
        ref: headers2.get("x-azure-ref")
      }
    })
  },
  {
    name: "oracle-cloud",
    category: "cloud",
    headers: ["x-oracle-dms-rid", "x-oracle-dms-ecid"],
    detect: (headers2) => headers2.get("x-oracle-dms-rid") !== null,
    extract: (headers2) => ({
      metadata: {
        requestId: headers2.get("x-oracle-dms-rid"),
        ecid: headers2.get("x-oracle-dms-ecid")
      }
    })
  },
  {
    name: "alibaba-cloud",
    category: "cloud",
    headers: ["ali-swift-global-savetime", "eagleeye-traceid"],
    detect: (headers2) => headers2.get("eagleeye-traceid") !== null,
    extract: (headers2) => ({
      metadata: {
        traceId: headers2.get("eagleeye-traceid")
      }
    })
  },
  {
    name: "vercel",
    category: "hosting",
    headers: ["x-vercel-id", "x-vercel-cache"],
    detect: (headers2) => headers2.get("x-vercel-id") !== null,
    extract: (headers2) => ({
      metadata: {
        requestId: headers2.get("x-vercel-id"),
        cache: headers2.get("x-vercel-cache")
      }
    })
  },
  {
    name: "netlify",
    category: "hosting",
    headers: ["x-nf-request-id", "x-nf-trace-id"],
    detect: (headers2) => headers2.get("x-nf-request-id") !== null,
    extract: (headers2) => ({
      metadata: {
        requestId: headers2.get("x-nf-request-id"),
        traceId: headers2.get("x-nf-trace-id")
      }
    })
  },
  {
    name: "render",
    category: "hosting",
    headers: ["x-render-origin-server"],
    detect: (headers2) => headers2.get("x-render-origin-server") !== null,
    extract: (headers2) => ({
      metadata: {
        origin: headers2.get("x-render-origin-server")
      }
    })
  },
  {
    name: "datadome",
    category: "security",
    headers: ["x-datadome", "x-datadome-cid"],
    detect: (headers2) => headers2.get("x-datadome") !== null || headers2.get("x-datadome-cid") !== null,
    extract: (headers2) => ({
      metadata: { cid: headers2.get("x-datadome-cid") }
    })
  },
  {
    name: "incapsula",
    category: "security",
    headers: ["x-iinfo", "x-cdn"],
    detect: (headers2) => headers2.get("x-iinfo") !== null || (headers2.get("x-cdn") || "").includes("Incapsula"),
    extract: (headers2) => ({
      metadata: { iinfo: headers2.get("x-iinfo") }
    })
  },
  {
    name: "imperva",
    category: "security",
    headers: ["x-imperva-uuid"],
    detect: (headers2) => headers2.get("x-imperva-uuid") !== null,
    extract: (headers2) => ({
      metadata: { uuid: headers2.get("x-imperva-uuid") }
    })
  },
  {
    name: "aws-waf",
    category: "security",
    headers: ["x-amzn-waf-action"],
    detect: (headers2) => headers2.get("server") === "awselb/2.0",
    extract: (headers2) => ({})
  },
  {
    name: "envoy",
    category: "proxy",
    headers: ["x-envoy-upstream-service-time"],
    detect: (headers2) => headers2.get("x-envoy-upstream-service-time") !== null || headers2.get("server") === "envoy",
    extract: (headers2) => ({})
  },
  {
    name: "traefik",
    category: "proxy",
    headers: [],
    detect: (headers2) => (headers2.get("server") || "").toLowerCase().includes("traefik"),
    extract: (headers2) => ({})
  },
  {
    name: "caddy",
    category: "server",
    headers: [],
    detect: (headers2) => (headers2.get("server") || "").toLowerCase().includes("caddy"),
    extract: (headers2) => ({})
  },
  {
    name: "haproxy",
    category: "proxy",
    headers: [],
    detect: (headers2) => (headers2.get("server") || "").toLowerCase().includes("haproxy"),
    extract: (headers2) => ({})
  },
  {
    name: "iis",
    category: "server",
    headers: ["x-powered-by"],
    detect: (headers2) => (headers2.get("server") || "").toLowerCase().includes("iis"),
    extract: (headers2) => ({})
  },
  {
    name: "kestrel",
    category: "server",
    headers: [],
    detect: (headers2) => (headers2.get("server") || "").toLowerCase().includes("kestrel"),
    extract: (headers2) => ({})
  },
  {
    name: "express",
    category: "framework",
    headers: ["x-powered-by"],
    detect: (headers2) => (headers2.get("x-powered-by") || "").toLowerCase().includes("express"),
    extract: (headers2) => ({})
  },
  {
    name: "rails",
    category: "framework",
    headers: ["x-runtime", "x-request-id"],
    detect: (headers2) => headers2.get("x-runtime") !== null && !(headers2.get("x-powered-by") || "").includes("Express"),
    extract: (headers2) => ({
      metadata: { runtime: headers2.get("x-runtime") }
    })
  },
  {
    name: "django",
    category: "framework",
    headers: [],
    detect: (headers2) => (headers2.get("server") || "").toLowerCase().includes("wsgi"),
    extract: (headers2) => ({})
  },
  {
    name: "aspnet",
    category: "framework",
    headers: ["x-aspnet-version", "x-powered-by"],
    detect: (headers2) => headers2.get("x-aspnet-version") !== null || (headers2.get("x-powered-by") || "").includes("ASP.NET"),
    extract: (headers2) => ({
      metadata: { version: headers2.get("x-aspnet-version") }
    })
  },
  {
    name: "php",
    category: "framework",
    headers: ["x-powered-by"],
    detect: (headers2) => (headers2.get("x-powered-by") || "").toLowerCase().includes("php"),
    extract: (headers2) => ({
      metadata: { version: headers2.get("x-powered-by") }
    })
  }
];
function parsePlatformInfo(headers2) {
  const info2 = {
    metadata: {}
  };
  for (const detector of PLATFORM_DETECTORS) {
    if (detector.detect(headers2)) {
      info2.provider = detector.name;
      info2.category = detector.category;
      const extracted = detector.extract(headers2);
      if (extracted.region)
        info2.region = extracted.region;
      if (extracted.server)
        info2.server = extracted.server;
      if (extracted.metadata) {
        Object.assign(info2.metadata, extracted.metadata);
      }
      break;
    }
  }
  if (!info2.provider) {
    const server = headers2.get("server");
    if (server) {
      info2.server = server;
      const serverLower = server.toLowerCase();
      if (serverLower.includes("cloudflare")) {
        info2.provider = "cloudflare";
        info2.category = "cdn";
      } else if (serverLower.includes("cloudfront")) {
        info2.provider = "aws-cloudfront";
        info2.category = "cloud";
      } else if (serverLower.includes("fastly")) {
        info2.provider = "fastly";
        info2.category = "cdn";
      } else if (serverLower.includes("akamai")) {
        info2.provider = "akamai";
        info2.category = "cdn";
      } else if (serverLower.includes("nginx")) {
        info2.provider = "nginx";
        info2.category = "server";
      } else if (serverLower.includes("apache")) {
        info2.provider = "apache";
        info2.category = "server";
      } else if (serverLower.includes("varnish")) {
        info2.provider = "varnish";
        info2.category = "proxy";
      } else {
        info2.provider = "unknown";
        info2.category = "unknown";
      }
    }
  }
  if (!info2.provider) {
    const via = headers2.get("via");
    if (via) {
      const viaLower = via.toLowerCase();
      if (viaLower.includes("cloudflare")) {
        info2.provider = "cloudflare";
        info2.category = "cdn";
      } else if (viaLower.includes("akamai")) {
        info2.provider = "akamai";
        info2.category = "cdn";
      } else if (viaLower.includes("varnish")) {
        info2.provider = "varnish";
        info2.category = "proxy";
      } else if (viaLower.includes("squid")) {
        info2.provider = "squid";
        info2.category = "proxy";
      }
    }
  }
  if (Object.keys(info2.metadata || {}).length === 0) {
    delete info2.metadata;
  }
  return info2;
}
function parseRateLimitInfo(headers2, status) {
  const info2 = { limited: status === 429 };
  const limit = headers2.get("x-ratelimit-limit") || headers2.get("ratelimit-limit");
  const remaining = headers2.get("x-ratelimit-remaining") || headers2.get("ratelimit-remaining");
  const reset = headers2.get("x-ratelimit-reset") || headers2.get("ratelimit-reset");
  if (limit)
    info2.limit = parseInt(limit, 10);
  if (remaining)
    info2.remaining = parseInt(remaining, 10);
  if (reset) {
    const resetValue = parseInt(reset, 10);
    if (resetValue > 1e9) {
      info2.reset = new Date(resetValue * 1e3);
    } else {
      info2.reset = new Date(Date.now() + resetValue * 1e3);
    }
  }
  const retryAfter = headers2.get("retry-after");
  if (retryAfter) {
    const seconds = parseInt(retryAfter, 10);
    if (!isNaN(seconds)) {
      info2.retryAfter = seconds;
    } else {
      const retryDate = new Date(retryAfter);
      if (!isNaN(retryDate.getTime())) {
        info2.retryAfter = Math.ceil((retryDate.getTime() - Date.now()) / 1e3);
      }
    }
  }
  const policy = headers2.get("ratelimit-policy");
  if (policy) {
    info2.policy = policy;
  }
  if (info2.remaining !== void 0 && info2.remaining === 0) {
    info2.limited = true;
  }
  return info2;
}
function parseCompressionInfo(headers2) {
  const info2 = {};
  const encoding2 = headers2.get("content-encoding");
  if (encoding2) {
    info2.encoding = encoding2.toLowerCase();
  }
  const xOriginalSize = headers2.get("x-original-size") || headers2.get("x-uncompressed-size");
  if (xOriginalSize) {
    info2.originalSize = parseInt(xOriginalSize, 10);
  }
  const contentLength = headers2.get("content-length");
  if (contentLength) {
    info2.compressedSize = parseInt(contentLength, 10);
  }
  if (info2.originalSize && info2.compressedSize) {
    info2.ratio = info2.originalSize / info2.compressedSize;
  }
  return info2;
}
function parseCSPInfo(headers2) {
  const info2 = {
    directives: {},
    reportOnly: false
  };
  let cspHeader = headers2.get("content-security-policy");
  if (!cspHeader) {
    cspHeader = headers2.get("content-security-policy-report-only");
    if (cspHeader) {
      info2.reportOnly = true;
    }
  }
  if (cspHeader) {
    info2.policy = cspHeader;
    const directives = cspHeader.split(";").map((d4) => d4.trim()).filter(Boolean);
    for (const directive of directives) {
      const [name, ...values] = directive.split(/\s+/);
      if (name) {
        info2.directives[name] = values;
      }
    }
  }
  return info2;
}
function parseContentType(headers2) {
  const info2 = {};
  const contentType = headers2.get("content-type");
  if (!contentType)
    return info2;
  const parts = contentType.split(";").map((p4) => p4.trim());
  if (parts[0]) {
    info2.mediaType = parts[0];
    const [type, subtype] = parts[0].split("/");
    if (type)
      info2.type = type;
    if (subtype)
      info2.subtype = subtype;
  }
  for (let i4 = 1; i4 < parts.length; i4++) {
    const param = parts[i4];
    const [key, value] = param.split("=").map((s4) => s4.trim());
    if (key === "charset" && value) {
      info2.charset = value.replace(/['"]/g, "");
    } else if (key === "boundary" && value) {
      info2.boundary = value.replace(/['"]/g, "");
    }
  }
  return info2;
}
function parseAcceptInfo(headers2) {
  const info2 = {
    types: [],
    encodings: [],
    languages: []
  };
  const accept = headers2.get("accept");
  if (accept) {
    const types = accept.split(",").map((t4) => t4.trim());
    for (const typeStr of types) {
      const [mediaType, ...params] = typeStr.split(";").map((s4) => s4.trim());
      let q4 = 1;
      for (const param of params) {
        if (param.startsWith("q=")) {
          q4 = parseFloat(param.substring(2)) || 1;
        }
      }
      const [type, subtype] = mediaType.split("/");
      info2.types.push({
        mediaType,
        q: q4,
        type: type || void 0,
        subtype: subtype || void 0
      });
    }
    info2.types.sort((a4, b4) => b4.q - a4.q);
  }
  const acceptEncoding = headers2.get("accept-encoding");
  if (acceptEncoding) {
    const encodings = acceptEncoding.split(",").map((e4) => e4.trim());
    for (const encodingStr of encodings) {
      const [encoding2, ...params] = encodingStr.split(";").map((s4) => s4.trim());
      let q4 = 1;
      for (const param of params) {
        if (param.startsWith("q=")) {
          q4 = parseFloat(param.substring(2)) || 1;
        }
      }
      info2.encodings.push({ encoding: encoding2, q: q4 });
    }
    info2.encodings.sort((a4, b4) => b4.q - a4.q);
  }
  const acceptLanguage = headers2.get("accept-language");
  if (acceptLanguage) {
    const languages = acceptLanguage.split(",").map((l4) => l4.trim());
    for (const languageStr of languages) {
      const [language, ...params] = languageStr.split(";").map((s4) => s4.trim());
      let q4 = 1;
      for (const param of params) {
        if (param.startsWith("q=")) {
          q4 = parseFloat(param.substring(2)) || 1;
        }
      }
      info2.languages.push({ language, q: q4 });
    }
    info2.languages.sort((a4, b4) => b4.q - a4.q);
  }
  return info2;
}
function parseAuthInfo(headers2) {
  const info2 = { methods: [] };
  const wwwAuth = headers2.get("www-authenticate");
  if (wwwAuth) {
    if (wwwAuth.toLowerCase().includes("basic"))
      info2.methods.push("Basic");
    if (wwwAuth.toLowerCase().includes("bearer"))
      info2.methods.push("Bearer");
    if (wwwAuth.toLowerCase().includes("digest"))
      info2.methods.push("Digest");
    if (wwwAuth.toLowerCase().includes("negotiate"))
      info2.methods.push("Negotiate");
    if (wwwAuth.toLowerCase().includes("aws4-hmac-sha256"))
      info2.methods.push("AWS4");
    const realmMatch = wwwAuth.match(/realm="([^"]+)"/);
    if (realmMatch)
      info2.realm = realmMatch[1];
    const errorMatch = wwwAuth.match(/error="([^"]+)"/);
    if (errorMatch)
      info2.error = errorMatch[1];
    const descMatch = wwwAuth.match(/error_description="([^"]+)"/);
    if (descMatch)
      info2.errorDescription = descMatch[1];
  }
  const xAuthError = headers2.get("x-auth-error") || headers2.get("x-authentication-error");
  if (xAuthError) {
    if (!info2.error)
      info2.error = xAuthError;
  }
  return info2;
}
function parseClockSkew(headers2) {
  const dateHeader = headers2.get("date");
  if (!dateHeader)
    return {};
  const serverTime = new Date(dateHeader);
  if (isNaN(serverTime.getTime()))
    return {};
  const skewMs = serverTime.getTime() - Date.now();
  return { serverTime, skewMs };
}
function parseHeaders(headers2, status) {
  return {
    cache: parseCacheInfo(headers2),
    platform: parsePlatformInfo(headers2),
    rateLimit: parseRateLimitInfo(headers2, status),
    compression: parseCompressionInfo(headers2),
    csp: parseCSPInfo(headers2),
    contentType: parseContentType(headers2),
    accept: parseAcceptInfo(headers2),
    auth: parseAuthInfo(headers2),
    clockSkew: parseClockSkew(headers2)
  };
}
function parseLink(headerValue) {
  if (!headerValue || typeof headerValue !== "string") {
    return { all: [] };
  }
  const links = [];
  const collection = { all: links };
  const linkStrings = splitLinkHeader(headerValue);
  for (const linkString of linkStrings) {
    const link = parseSingleLink(linkString.trim());
    if (link) {
      links.push(link);
      if (link.rel) {
        const relTypes = link.rel.split(/\s+/);
        for (const rel of relTypes) {
          const existing = collection[rel];
          if (existing) {
            if (Array.isArray(existing)) {
              existing.push(link);
            } else {
              collection[rel] = [existing, link];
            }
          } else {
            collection[rel] = link;
          }
        }
      }
    }
  }
  return collection;
}
function splitLinkHeader(header) {
  const result = [];
  let current = "";
  let inBrackets = false;
  let inQuotes = false;
  for (let i4 = 0; i4 < header.length; i4++) {
    const char = header[i4];
    const prevChar = i4 > 0 ? header[i4 - 1] : "";
    if (char === "<" && !inQuotes) {
      inBrackets = true;
    } else if (char === ">" && !inQuotes) {
      inBrackets = false;
    } else if (char === '"' && prevChar !== "\\") {
      inQuotes = !inQuotes;
    } else if (char === "," && !inBrackets && !inQuotes) {
      result.push(current.trim());
      current = "";
      continue;
    }
    current += char;
  }
  if (current.trim()) {
    result.push(current.trim());
  }
  return result;
}
function parseSingleLink(linkString) {
  const uriMatch = linkString.match(/^<([^>]+)>/);
  if (!uriMatch) {
    return null;
  }
  const uri = uriMatch[1];
  const link = { uri };
  const paramsString = linkString.slice(uriMatch[0].length);
  const params = parseParameters(paramsString);
  for (const [key, value] of Object.entries(params)) {
    link[key] = value;
  }
  return link;
}
function parseParameters(paramsString) {
  const params = {};
  const paramStrings = paramsString.split(/;/).filter((s4) => s4.trim());
  for (const paramString of paramStrings) {
    const equalIndex = paramString.indexOf("=");
    if (equalIndex === -1)
      continue;
    const key = paramString.slice(0, equalIndex).trim();
    let value = paramString.slice(equalIndex + 1).trim();
    if (value.startsWith('"') && value.endsWith('"')) {
      value = value.slice(1, -1);
    } else if (value.startsWith("'") && value.endsWith("'")) {
      value = value.slice(1, -1);
    }
    value = value.replace(/\\(.)/g, "$1");
    params[key] = value;
  }
  return params;
}
var LinkRel = {
  NEXT: "next",
  PREV: "prev",
  PREVIOUS: "previous",
  FIRST: "first",
  LAST: "last",
  ALTERNATE: "alternate",
  CANONICAL: "canonical",
  PRELOAD: "preload",
  PREFETCH: "prefetch",
  PRECONNECT: "preconnect",
  DNS_PREFETCH: "dns-prefetch"
};
var LinkHeaderParser = class {
  links;
  constructor(headerValue) {
    this.links = parseLink(headerValue);
  }
  getAll() {
    return this.links.all;
  }
  getRel(rel) {
    return this.links[rel];
  }
  getFirst(rel) {
    const links = this.links[rel];
    if (!links)
      return void 0;
    return Array.isArray(links) ? links[0] : links;
  }
  has(rel) {
    return rel in this.links;
  }
  getPagination() {
    return {
      next: this.getFirst(LinkRel.NEXT)?.uri,
      prev: this.getFirst(LinkRel.PREV)?.uri || this.getFirst(LinkRel.PREVIOUS)?.uri,
      first: this.getFirst(LinkRel.FIRST)?.uri,
      last: this.getFirst(LinkRel.LAST)?.uri
    };
  }
  hasNext() {
    return this.has(LinkRel.NEXT);
  }
  hasPrev() {
    return this.has(LinkRel.PREV) || this.has(LinkRel.PREVIOUS);
  }
  getCanonical() {
    return this.getFirst(LinkRel.CANONICAL)?.uri;
  }
  getAlternates() {
    const alts = this.getRel(LinkRel.ALTERNATE);
    if (!alts)
      return [];
    return Array.isArray(alts) ? alts : [alts];
  }
  getResourceHints() {
    const getLinks = (rel) => {
      const links = this.getRel(rel);
      if (!links)
        return [];
      return Array.isArray(links) ? links : [links];
    };
    return {
      preload: getLinks(LinkRel.PRELOAD),
      prefetch: getLinks(LinkRel.PREFETCH),
      preconnect: getLinks(LinkRel.PRECONNECT),
      dnsPrefetch: getLinks(LinkRel.DNS_PREFETCH)
    };
  }
  toJSON() {
    return this.links;
  }
};
function parseLinkHeader(headers2) {
  const linkHeader = headers2.get("Link");
  if (!linkHeader)
    return null;
  return new LinkHeaderParser(linkHeader);
}
var NULL_BODY_STATUS = [101, 103, 204, 205, 304];
var HttpResponse4 = class _HttpResponse {
  timings;
  connection;
  raw;
  constructor(undiciRawResponse, options = {}) {
    this.timings = options.timings;
    this.connection = options.connection;
    if (undiciRawResponse instanceof Response) {
      this.raw = undiciRawResponse;
    } else {
      const body2 = NULL_BODY_STATUS.includes(undiciRawResponse.statusCode) ? null : undiciRawResponse.body;
      this.raw = new Response(body2, {
        status: undiciRawResponse.statusCode,
        statusText: String(undiciRawResponse.statusCode),
        headers: undiciRawResponse.headers
      });
    }
  }
  get status() {
    return this.raw.status;
  }
  get statusText() {
    return this.raw.statusText;
  }
  get headers() {
    return this.raw.headers;
  }
  get ok() {
    return this.raw.ok;
  }
  get url() {
    return this.raw.url;
  }
  get cache() {
    return parseHeaders(this.headers, this.status).cache;
  }
  get rateLimit() {
    return parseHeaders(this.headers, this.status).rateLimit;
  }
  links() {
    return parseLinkHeader(this.headers);
  }
  get headerInfo() {
    return parseHeaders(this.headers, this.status);
  }
  async json() {
    return await this.raw.json();
  }
  async yaml(options) {
    const text = await this.raw.text();
    return parseYaml(text, options);
  }
  async csv(options) {
    const text = await this.raw.text();
    return parseCsv(text, options);
  }
  async text() {
    return this.raw.text();
  }
  async cleanText() {
    const rawText = await this.text();
    return cleanHtml(rawText);
  }
  async blob() {
    return this.raw.blob();
  }
  read() {
    return this.raw.body;
  }
  toNodeStream() {
    if (!this.raw.body) {
      return null;
    }
    return webToNodeStream(this.raw.body);
  }
  async pipe(destination) {
    const nodeStream = this.toNodeStream();
    if (!nodeStream) {
      throw new StreamError$1("Response has no body to pipe", {
        streamType: "response",
        retriable: true
      });
    }
    return new Promise((resolve, reject) => {
      nodeStream.pipe(destination);
      nodeStream.on("end", resolve);
      nodeStream.on("error", reject);
      destination.on("error", reject);
    });
  }
  clone() {
    return new _HttpResponse(this.raw.clone(), {
      timings: this.timings,
      connection: this.connection
    });
  }
  sse() {
    return parseSSE(this.raw);
  }
  async *download() {
    if (!this.raw.body) {
      return;
    }
    const contentLength = this.headers.get("content-length");
    const total = contentLength ? parseInt(contentLength, 10) : void 0;
    let loaded = 0;
    const startTime = Date.now();
    let lastUpdate = 0;
    let lastLoaded = 0;
    let lastRateUpdate = startTime;
    let smoothedRate = 0;
    const rateSmoothingFactor = 0.3;
    const createProgress = (isFinal) => {
      const now = Date.now();
      const intervalMs = now - lastRateUpdate;
      const bytesInInterval = loaded - lastLoaded;
      if (intervalMs > 0) {
        const instantRate = bytesInInterval / intervalMs * 1e3;
        smoothedRate = smoothedRate === 0 ? instantRate : smoothedRate * (1 - rateSmoothingFactor) + instantRate * rateSmoothingFactor;
      }
      lastLoaded = loaded;
      lastRateUpdate = now;
      let percent;
      if (total) {
        percent = isFinal ? 100 : Math.min(loaded / total * 100, 99.9);
      }
      return {
        loaded,
        transferred: loaded,
        total,
        percent,
        rate: smoothedRate,
        estimated: total && smoothedRate > 0 ? (total - loaded) / smoothedRate * 1e3 : void 0,
        direction: "download"
      };
    };
    const reader = this.raw.body.getReader();
    try {
      yield createProgress(false);
      while (true) {
        const { done, value } = await reader.read();
        if (done) {
          yield createProgress(true);
          break;
        }
        if (value) {
          loaded += value.byteLength;
          const now = Date.now();
          if (now - lastUpdate > 100) {
            yield createProgress(false);
            lastUpdate = now;
          }
        }
      }
    } finally {
      reader.releaseLock();
    }
  }
  async *[Symbol.asyncIterator]() {
    if (!this.raw.body) {
      return;
    }
    const reader = this.raw.body.getReader();
    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done)
          break;
        if (value)
          yield value;
      }
    } finally {
      reader.releaseLock();
    }
  }
};
(0, import_node_util.promisify)(import_node_dns.lookup);
function createLookupFunction(options) {
  return (hostname, opts, callback) => {
    if (options.override?.[hostname]) {
      const ip = options.override[hostname];
      const family = ip.includes(":") ? 6 : 4;
      return callback(null, ip, family);
    }
    (0, import_node_dns.lookup)(hostname, opts, callback);
  };
}
function extractOrigin(url) {
  try {
    const parsed = new URL(url);
    return `${parsed.protocol}//${parsed.host}`;
  } catch {
    return url;
  }
}
function normalizeProtocol(protocol) {
  if (!protocol)
    return void 0;
  const lower = protocol.toLowerCase();
  if (lower === "h2" || lower === "http/2" || lower === "http/2.0") {
    return "h2";
  }
  if (lower === "h3" || lower.startsWith("h3-")) {
    return "h3";
  }
  if (lower === "http/1.1" || lower === "http/1.0" || lower === "http") {
    return "http/1.1";
  }
  return void 0;
}
var ProtocolCache = class {
  cache;
  options;
  constructor(options = {}) {
    this.cache = /* @__PURE__ */ new Map();
    this.options = {
      ttl: options.ttl ?? 60 * 60 * 1e3,
      maxSize: options.maxSize ?? 1e3,
      failureThreshold: options.failureThreshold ?? 3
    };
  }
  get(urlOrOrigin) {
    const origin = extractOrigin(urlOrOrigin);
    const entry = this.cache.get(origin);
    if (!entry)
      return void 0;
    if (Date.now() - entry.detectedAt > this.options.ttl) {
      this.cache.delete(origin);
      return void 0;
    }
    return entry.protocol;
  }
  getEntry(urlOrOrigin) {
    const origin = extractOrigin(urlOrOrigin);
    const entry = this.cache.get(origin);
    if (!entry)
      return void 0;
    if (Date.now() - entry.detectedAt > this.options.ttl) {
      this.cache.delete(origin);
      return void 0;
    }
    return entry;
  }
  set(urlOrOrigin, protocol) {
    const origin = extractOrigin(urlOrOrigin);
    const normalized = normalizeProtocol(protocol) ?? protocol;
    if (this.cache.size >= this.options.maxSize && !this.cache.has(origin)) {
      const firstKey = this.cache.keys().next().value;
      if (firstKey)
        this.cache.delete(firstKey);
    }
    const existing = this.cache.get(origin);
    this.cache.set(origin, {
      protocol: normalized,
      detectedAt: Date.now(),
      successCount: (existing?.successCount ?? 0) + 1,
      failureCount: existing?.failureCount ?? 0,
      http2Rejected: existing?.http2Rejected
    });
    this.cache.delete(origin);
    this.cache.set(origin, this.cache.get(origin) ?? {
      protocol: normalized,
      detectedAt: Date.now(),
      successCount: 1,
      failureCount: 0
    });
  }
  recordSuccess(urlOrOrigin) {
    const origin = extractOrigin(urlOrOrigin);
    const entry = this.cache.get(origin);
    if (entry) {
      entry.successCount++;
      entry.failureCount = Math.max(0, entry.failureCount - 1);
    }
  }
  recordFailure(urlOrOrigin, isHttp2Error = false) {
    const origin = extractOrigin(urlOrOrigin);
    const entry = this.cache.get(origin);
    if (entry) {
      entry.failureCount++;
      if (isHttp2Error) {
        entry.http2Rejected = true;
      }
      return entry.failureCount >= this.options.failureThreshold;
    }
    return false;
  }
  hasHttp2Issues(urlOrOrigin) {
    const entry = this.getEntry(urlOrOrigin);
    if (!entry)
      return false;
    return entry.http2Rejected === true || entry.protocol === "http/1.1" && entry.failureCount >= this.options.failureThreshold;
  }
  shouldTryHttp2(urlOrOrigin) {
    const entry = this.getEntry(urlOrOrigin);
    if (!entry)
      return true;
    if (entry.http2Rejected)
      return false;
    if (entry.protocol === "h2" || entry.protocol === "h3")
      return true;
    if (entry.failureCount >= this.options.failureThreshold)
      return false;
    return true;
  }
  delete(urlOrOrigin) {
    const origin = extractOrigin(urlOrOrigin);
    return this.cache.delete(origin);
  }
  clear() {
    this.cache.clear();
  }
  getStats() {
    const http2Origins = [];
    const http1Origins = [];
    const problematicOrigins = [];
    for (const [origin, entry] of this.cache.entries()) {
      if (entry.protocol === "h2" || entry.protocol === "h3") {
        http2Origins.push(origin);
      } else {
        http1Origins.push(origin);
      }
      if (entry.http2Rejected || entry.failureCount >= this.options.failureThreshold) {
        problematicOrigins.push(origin);
      }
    }
    return {
      size: this.cache.size,
      maxSize: this.options.maxSize,
      origins: Array.from(this.cache.keys()),
      http2Origins,
      http1Origins,
      problematicOrigins
    };
  }
  toJSON() {
    const result = {};
    for (const [origin, entry] of this.cache.entries()) {
      result[origin] = entry;
    }
    return result;
  }
  fromJSON(data2) {
    const now = Date.now();
    for (const [origin, entry] of Object.entries(data2)) {
      if (now - entry.detectedAt <= this.options.ttl) {
        this.cache.set(origin, entry);
      }
    }
  }
};
var globalProtocolCache = null;
function getGlobalProtocolCache() {
  if (!globalProtocolCache) {
    globalProtocolCache = new ProtocolCache();
  }
  return globalProtocolCache;
}
var hostTimings = /* @__PURE__ */ new Map();
var connectionCounter = /* @__PURE__ */ new Map();
var globalConnectionId = 0;
var sessionCache = /* @__PURE__ */ new Map();
function getTimingForHost(hostname) {
  const timing = hostTimings.get(hostname);
  if (process.env.DEBUG_TIMING) {
    console.log(`[TIMING] getTimingForHost(${hostname}):`, timing ? "found" : "NOT FOUND", "map size:", hostTimings.size);
  }
  return timing;
}
function getConnectionId(hostname) {
  return connectionCounter.get(hostname) ?? 0;
}
function isNewConnection(hostname, previousId) {
  const currentId = connectionCounter.get(hostname) ?? 0;
  return currentId > previousId;
}
function buildTimingConnector(options = {}) {
  const timeout = options.timeout ?? 1e4;
  const allowH2 = options.allowH2 ?? false;
  const keepAliveInitialDelay = options.keepAliveInitialDelay ?? 6e4;
  const maxCachedSessions = options.maxCachedSessions ?? 100;
  const localAddress = options.localAddress;
  return function connect2(opts, callback) {
    const { hostname, protocol, port, servername } = opts;
    const isHttps = protocol === "https:";
    const targetPort = Number(port) || (isHttps ? 443 : 80);
    const timings = {
      dns: 0,
      tcp: 0,
      tls: 0,
      total: 0
    };
    const startTime = import_node_perf_hooks.performance.now();
    doConnect();
    async function doConnect() {
      try {
        const dnsStart = import_node_perf_hooks.performance.now();
        let resolvedAddress;
        try {
          const result = await import_promises2.default.lookup(hostname, { family: 4 });
          resolvedAddress = result.address;
        } catch (dnsError) {
          try {
            const result = await import_promises2.default.lookup(hostname, { family: 6 });
            resolvedAddress = result.address;
          } catch {
            callback(dnsError, null);
            return;
          }
        }
        timings.dns = import_node_perf_hooks.performance.now() - dnsStart;
        const tcpStart = import_node_perf_hooks.performance.now();
        const tcpSocket = import_node_net.default.connect({
          host: resolvedAddress,
          port: targetPort,
          localAddress
        });
        tcpSocket.setNoDelay(true);
        tcpSocket.setKeepAlive(true, keepAliveInitialDelay);
        const timeoutTimer = setTimeout(() => {
          tcpSocket.destroy(new Error(`Connect timeout after ${timeout}ms`));
        }, timeout);
        tcpSocket.once("error", (err) => {
          clearTimeout(timeoutTimer);
          callback(err, null);
        });
        tcpSocket.once("connect", () => {
          timings.tcp = import_node_perf_hooks.performance.now() - tcpStart;
          clearTimeout(timeoutTimer);
          if (!isHttps) {
            timings.total = import_node_perf_hooks.performance.now() - startTime;
            hostTimings.set(hostname, { ...timings });
            globalConnectionId++;
            connectionCounter.set(hostname, globalConnectionId);
            callback(null, tcpSocket);
            return;
          }
          const tlsStart = import_node_perf_hooks.performance.now();
          const sn = servername || hostname;
          const sessionKey = `${sn}:${targetPort}`;
          const session = sessionCache.get(sessionKey);
          const tlsSocket = import_node_tls.default.connect({
            socket: tcpSocket,
            servername: sn,
            session,
            ALPNProtocols: allowH2 ? ["h2", "http/1.1"] : ["http/1.1"],
            rejectUnauthorized: true
          });
          tlsSocket.on("session", (newSession) => {
            if (sessionCache.size >= maxCachedSessions) {
              const firstKey = sessionCache.keys().next().value;
              if (firstKey)
                sessionCache.delete(firstKey);
            }
            sessionCache.set(sessionKey, newSession);
          });
          tlsSocket.once("error", (err) => {
            callback(err, null);
          });
          tlsSocket.once("secureConnect", () => {
            timings.tls = import_node_perf_hooks.performance.now() - tlsStart;
            timings.total = import_node_perf_hooks.performance.now() - startTime;
            hostTimings.set(hostname, { ...timings });
            globalConnectionId++;
            connectionCounter.set(hostname, globalConnectionId);
            if (process.env.DEBUG_TIMING) {
              console.log(`[TIMING] Stored for ${hostname}:`, timings);
            }
            callback(null, tlsSocket);
          });
        });
      } catch (err) {
        callback(err, null);
      }
    }
  };
}
var AgentManager = class {
  globalAgent;
  domainAgents;
  options;
  protocolCache;
  constructor(options = {}, protocolCache) {
    this.domainAgents = /* @__PURE__ */ new Map();
    this.protocolCache = protocolCache;
    this.options = {
      connections: options.connections ?? 10,
      pipelining: options.pipelining ?? 1,
      keepAlive: options.keepAlive ?? true,
      keepAliveTimeout: options.keepAliveTimeout ?? 4 * 1e3,
      keepAliveMaxTimeout: options.keepAliveMaxTimeout ?? 10 * 60 * 1e3,
      keepAliveTimeoutThreshold: options.keepAliveTimeoutThreshold ?? 1 * 1e3,
      connectTimeout: options.connectTimeout ?? 10 * 1e3,
      perDomainPooling: options.perDomainPooling ?? true,
      localAddress: options.localAddress,
      maxRequestsPerClient: options.maxRequestsPerClient ?? 0,
      maxCachedSessions: options.maxCachedSessions ?? 100,
      maxHeaderSize: options.maxHeaderSize,
      clientTtl: options.clientTtl ?? null,
      allowH2: options.allowH2,
      maxConcurrentStreams: options.maxConcurrentStreams
    };
  }
  getGlobalAgent() {
    if (!this.globalAgent) {
      this.globalAgent = this.createAgent(this.options);
    }
    return this.globalAgent;
  }
  getAgentForDomain(domain, options) {
    if (!this.options.perDomainPooling) {
      return this.getGlobalAgent();
    }
    let agent2 = this.domainAgents.get(domain);
    if (!agent2) {
      const agentOptions = { ...this.options, ...options };
      agent2 = this.createAgent(agentOptions);
      this.domainAgents.set(domain, agent2);
    }
    return agent2;
  }
  getAgentForUrl(url) {
    try {
      const parsedUrl = new URL(url);
      return this.getAgentForDomain(parsedUrl.hostname);
    } catch {
      return this.getGlobalAgent();
    }
  }
  getAdaptiveAgentForUrl(url, options) {
    const origin = extractOrigin(url);
    const domain = new URL(origin).hostname;
    if (this.options.perDomainPooling) {
      const existing = this.domainAgents.get(domain);
      if (existing)
        return existing;
    }
    const detectedProtocol = this.protocolCache?.get(origin);
    const adaptiveOptions = this.getAdaptiveOptions(detectedProtocol, options);
    if (!this.options.perDomainPooling) {
      return this.getGlobalAgent();
    }
    const agent2 = this.createAgent(adaptiveOptions);
    this.domainAgents.set(domain, agent2);
    return agent2;
  }
  getAdaptiveOptions(protocol, overrides) {
    const base2 = { ...this.options };
    if (protocol === "h2" || protocol === "h3") {
      return {
        ...base2,
        connections: Math.min(base2.connections, 2),
        pipelining: 1,
        allowH2: true,
        maxConcurrentStreams: base2.maxConcurrentStreams ?? 100,
        ...overrides
      };
    }
    if (protocol === "http/1.1") {
      return {
        ...base2,
        connections: Math.max(base2.connections, 6),
        pipelining: 2,
        allowH2: false,
        ...overrides
      };
    }
    return {
      ...base2,
      allowH2: base2.allowH2 ?? true,
      ...overrides
    };
  }
  setProtocolCache(cache5) {
    this.protocolCache = cache5;
  }
  createBatchAgent(concurrency, requestCount, options) {
    const smartConnections = Math.max(1, Math.min(Math.ceil(concurrency / 2), 50, requestCount));
    const smartPipelining = requestCount > 20 && concurrency > 5 ? 2 : 1;
    const batchOptions = {
      ...this.options,
      connections: options?.connections ?? smartConnections,
      pipelining: options?.pipelining ?? smartPipelining,
      ...options
    };
    return this.createAgent(batchOptions);
  }
  createStressTestAgent(concurrency) {
    const pipelining = 10;
    const connections = Math.min(Math.ceil(concurrency / pipelining), 100);
    return this.createAgent({
      connections,
      pipelining,
      keepAliveTimeout: 3e4,
      keepAliveMaxTimeout: 12e4,
      connectTimeout: 5e3
    });
  }
  createAgent(options) {
    const timingConnector = buildTimingConnector({
      timeout: options.connectTimeout,
      allowH2: options.allowH2,
      keepAliveInitialDelay: options.keepAliveTimeout,
      maxCachedSessions: options.maxCachedSessions,
      localAddress: options.localAddress
    });
    return new undiciExports.Agent({
      connections: options.connections,
      pipelining: options.pipelining,
      maxHeaderSize: options.maxHeaderSize,
      maxRequestsPerClient: options.maxRequestsPerClient,
      maxCachedSessions: options.maxCachedSessions,
      clientTtl: options.clientTtl ?? null,
      keepAliveTimeout: options.keepAliveTimeout,
      keepAliveMaxTimeout: options.keepAliveMaxTimeout,
      keepAliveTimeoutThreshold: options.keepAliveTimeoutThreshold,
      connectTimeout: options.connectTimeout,
      socketPath: void 0,
      allowH2: options.allowH2,
      maxConcurrentStreams: options.maxConcurrentStreams,
      connect: timingConnector
    });
  }
  getStats() {
    return {
      agentCount: 1 + this.domainAgents.size,
      domains: Array.from(this.domainAgents.keys()),
      totalConnections: (1 + this.domainAgents.size) * this.options.connections
    };
  }
  async closeDomainAgent(domain) {
    const agent2 = this.domainAgents.get(domain);
    if (agent2) {
      await agent2.close();
      this.domainAgents.delete(domain);
    }
  }
  async closeAll() {
    const closePromises = [];
    if (this.globalAgent) {
      closePromises.push(this.globalAgent.close());
      this.globalAgent = void 0;
    }
    for (const agent2 of this.domainAgents.values()) {
      closePromises.push(agent2.close());
    }
    this.domainAgents.clear();
    await Promise.all(closePromises);
  }
  async destroy() {
    const destroyPromises = [];
    if (this.globalAgent) {
      destroyPromises.push(this.globalAgent.destroy());
      this.globalAgent = void 0;
    }
    for (const agent2 of this.domainAgents.values()) {
      destroyPromises.push(agent2.destroy());
    }
    this.domainAgents.clear();
    await Promise.all(destroyPromises);
  }
};
var agentManager = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  AgentManager
});
function createProgressStream(stream, onProgress, optionsOrTotal) {
  const options = typeof optionsOrTotal === "number" ? { total: optionsOrTotal } : optionsOrTotal || {};
  const { total, direction, throttleMs = 100 } = options;
  let loaded = 0;
  let startTime = Date.now();
  let lastUpdate = 0;
  let lastLoaded = 0;
  let lastRateUpdate = startTime;
  let smoothedRate = 0;
  const rateSmoothingFactor = 0.3;
  const emitProgress = (now, isFinal) => {
    const intervalMs = now - lastRateUpdate;
    const bytesInInterval = loaded - lastLoaded;
    if (intervalMs > 0) {
      const instantRate = bytesInInterval / intervalMs * 1e3;
      smoothedRate = smoothedRate === 0 ? instantRate : smoothedRate * (1 - rateSmoothingFactor) + instantRate * rateSmoothingFactor;
    }
    lastLoaded = loaded;
    lastRateUpdate = now;
    const rate = smoothedRate;
    let percent;
    if (total) {
      percent = isFinal ? 100 : Math.min(loaded / total * 100, 99.9);
    }
    const progress = {
      loaded,
      transferred: loaded,
      total,
      percent,
      rate,
      estimated: total && rate > 0 ? (total - loaded) / rate * 1e3 : void 0,
      direction
    };
    onProgress(progress);
    lastUpdate = now;
  };
  return new ReadableStream({
    async start(controller) {
      const reader = stream.getReader();
      try {
        emitProgress(Date.now(), false);
        while (true) {
          const { done, value } = await reader.read();
          if (done) {
            emitProgress(Date.now(), true);
            controller.close();
            break;
          }
          loaded += value.byteLength;
          const now = Date.now();
          const shouldUpdate = now - lastUpdate >= throttleMs || total && loaded === total;
          if (shouldUpdate) {
            emitProgress(now, false);
          }
          controller.enqueue(value);
        }
      } catch (error2) {
        controller.error(error2);
        throw error2;
      }
    }
  });
}
var undiciRequestChannel = (0, import_node_diagnostics_channel.channel)("undici:request:create");
var undiciBodySentChannel = (0, import_node_diagnostics_channel.channel)("undici:request:bodySent");
var undiciHeadersChannel = (0, import_node_diagnostics_channel.channel)("undici:request:headers");
var undiciConnectChannel = (0, import_node_diagnostics_channel.channel)("undici:client:connect");
var requestStorage = new import_async_hooks.AsyncLocalStorage();
undiciRequestChannel.subscribe((message) => {
  const store = requestStorage.getStore();
  if (store) {
    if (store.requestStartTime === 0) {
      store.requestStartTime = import_perf_hooks.performance.now();
    }
    const hasConnectionTimings = store.timings.dns || store.timings.tcp || store.timings.tls;
    if (!hasConnectionTimings) {
      store.timings = { queuing: 0, dns: 0, tcp: 0, tls: 0, firstByte: 0, content: 0, total: 0 };
      store.connection = {};
    }
    const msg = message;
    if (msg?.request?.origin && !store.requestCorrelationId) {
      try {
        store.requestCorrelationId = new URL(msg.request.origin).hostname;
      } catch {
      }
    }
  }
});
undiciBodySentChannel.subscribe((message) => {
  const store = requestStorage.getStore();
  if (store?.hooks && store.hooks.onRequestSent) {
    store.hooks.onRequestSent();
  }
});
undiciHeadersChannel.subscribe((message) => {
  const payload2 = message;
  const store = requestStorage.getStore();
  if (!store || !payload2)
    return;
  const now = import_perf_hooks.performance.now();
  const ttfb = now - store.requestStartTime;
  if (payload2.timing) {
    const { timing } = payload2;
    store.timings.queuing = timing.queuing;
    store.timings.dns = timing.dns;
    store.timings.tcp = timing.tcp;
    store.timings.tls = timing.tls;
    store.timings.firstByte = timing.response;
    store.timings.content = timing.body;
    store.timings.total = timing.ended;
  } else {
    store.timings.firstByte = ttfb;
  }
  if (store.hooks) {
    const dns2 = store.timings.dns ?? 0;
    const tcp = store.timings.tcp ?? 0;
    const tls = store.timings.tls ?? 0;
    if (store.hooks.onDnsLookup && dns2 > 0) {
      store.hooks.onDnsLookup({ domain: payload2.request.origin, duration: dns2 });
    }
    if (store.hooks.onTcpConnect && tcp > 0) {
      store.hooks.onTcpConnect({ remoteAddress: "", duration: tcp });
    }
    if (store.hooks.onTlsHandshake && tls > 0) {
      store.hooks.onTlsHandshake({ protocol: "", cipher: "", duration: tls });
    }
    if (store.hooks.onResponseStart) {
      const headers2 = new Headers();
      for (let i4 = 0; i4 < payload2.response.headers.length; i4 += 2) {
        headers2.append(payload2.response.headers[i4], payload2.response.headers[i4 + 1]);
      }
      store.hooks.onResponseStart({ status: payload2.response.statusCode, headers: headers2 });
    }
  }
});
undiciConnectChannel.subscribe((message) => {
  const payload2 = message;
  const store = requestStorage.getStore();
  if (store && payload2 && payload2.socket) {
    const { socket } = payload2;
    store.connection.remoteAddress = socket.remoteAddress;
    store.connection.remotePort = socket.remotePort;
    store.connection.localAddress = socket.localAddress;
    store.connection.localPort = socket.localPort;
    const protocol = socket.alpnProtocol || (socket.tlsSocket ? socket.tlsSocket.getProtocol() : void 0);
    store.connection.protocol = protocol;
    store.connection.cipher = socket.tlsSocket ? socket.tlsSocket.getCipher()?.name : void 0;
    if (store.hooks) {
      if (store.hooks.onTcpConnect) {
        store.hooks.onTcpConnect({ remoteAddress: socket.remoteAddress, duration: 0 });
      }
      if (store.hooks.onTlsHandshake && socket.tlsSocket) {
        store.hooks.onTlsHandshake({
          protocol: protocol || "unknown",
          cipher: socket.tlsSocket.getCipher()?.name || "unknown",
          duration: 0
        });
      }
    }
    if (protocol === "h2") {
      const http2Session = socket.session || socket;
      const http2State = http2Session.state;
      const remoteSettings = http2Session.remoteSettings;
      const localSettings = http2Session.localSettings;
      store.connection.http2 = {
        streamId: socket.streamId,
        streamWeight: socket.weight,
        streamDependency: socket.dependency,
        serverPush: Boolean(socket.serverPush),
        settingsReceived: Boolean(remoteSettings),
        maxConcurrentStreams: remoteSettings?.maxConcurrentStreams,
        currentStreams: http2State?.streamCount,
        pendingStreams: http2State?.pendingStreamCount,
        localWindowSize: http2State?.localWindowSize ?? http2State?.effectiveLocalWindowSize,
        remoteWindowSize: http2State?.effectiveRecvDataLength,
        localSettings: localSettings ? { ...localSettings } : void 0,
        remoteSettings: remoteSettings ? { ...remoteSettings } : void 0
      };
      if (store.hooks?.onHttp2Session) {
        const origin = socket.origin || payload2.connectParams?.hostname || "";
        store.hooks.onHttp2Session({
          origin,
          event: "connect",
          maxConcurrentStreams: remoteSettings?.maxConcurrentStreams,
          activeStreams: http2State?.streamCount,
          localSettings: localSettings ? { ...localSettings } : void 0,
          remoteSettings: remoteSettings ? { ...remoteSettings } : void 0
        });
      }
      if (store.hooks?.onHttp2Stream && socket.streamId) {
        const origin = socket.origin || payload2.connectParams?.hostname || "";
        store.hooks.onHttp2Stream({
          streamId: socket.streamId,
          origin,
          event: "open",
          state: "open",
          pushed: Boolean(socket.serverPush)
        });
      }
    }
    if (protocol === "h3" || protocol?.startsWith("h3-")) {
      const quicStats = socket.stats;
      const handshakeConfirmed = socket.handshakeConfirmed;
      store.connection.http3 = {
        quicVersion: protocol,
        zeroRTT: socket.zeroRTT || false,
        maxStreams: socket.maxStreams,
        handshakeConfirmed: typeof handshakeConfirmed === "boolean" ? handshakeConfirmed : void 0
      };
      if (quicStats && typeof quicStats.rtt === "number") {
        store.connection.rtt = quicStats.rtt;
      }
    }
    store.connection.reused = Boolean(socket.reused);
  }
});
function mapTimeoutOptions(requestTimeout, transportDefaults) {
  return {
    connectTimeout: requestTimeout?.connect ?? requestTimeout?.secureConnect ?? transportDefaults?.connectTimeout,
    headersTimeout: requestTimeout?.response ?? transportDefaults?.headersTimeout,
    bodyTimeout: requestTimeout?.send ?? transportDefaults?.bodyTimeout,
    totalTimeout: requestTimeout?.request
  };
}
var UndiciTransport = class {
  baseUrl;
  options;
  proxyAgent;
  dnsAgent;
  agentManager;
  proxyBypassList;
  tlsOptions;
  socketClient;
  observability;
  protocolCache;
  constructor(baseUrl, options = {}) {
    this.baseUrl = baseUrl || "";
    this.options = options;
    this.tlsOptions = options.tls;
    this.observability = options.observability !== false;
    if (options.protocolCache === true) {
      this.protocolCache = getGlobalProtocolCache();
    } else if (options.protocolCache instanceof ProtocolCache) {
      this.protocolCache = options.protocolCache;
    }
    if (options.proxy) {
      const proxyConfig = typeof options.proxy === "string" ? { url: options.proxy } : options.proxy;
      const proxyUrl = new URL(proxyConfig.url);
      const proxyType = proxyConfig.type || detectProxyType(proxyUrl.protocol);
      if (proxyType?.startsWith("socks")) {
        throw new NetworkError(`SOCKS proxy (${proxyType}) is not supported. Use an HTTP/HTTPS proxy or a SOCKS-to-HTTP bridge.`, "ERR_UNSUPPORTED_PROXY_TYPE");
      }
      const proxyAuth = proxyConfig.auth ? `${proxyConfig.auth.username}:${proxyConfig.auth.password}` : void 0;
      const finalProxyUrl = proxyAuth ? proxyConfig.url.replace("://", `://${proxyAuth}@`) : proxyConfig.url;
      this.proxyBypassList = proxyConfig.bypass;
      const proxyAgentOptions = {
        uri: finalProxyUrl,
        headers: proxyConfig.headers,
        token: proxyConfig.token,
        proxyTunnel: proxyConfig.tunnel,
        requestTls: mapTlsOptions(proxyConfig.requestTls ?? options.tls),
        proxyTls: mapTlsOptions(proxyConfig.proxyTls)
      };
      if (proxyConfig.connectTimeout) {
        proxyAgentOptions.connectTimeout = proxyConfig.connectTimeout;
      }
      if (proxyConfig.http2) {
        if (!proxyAgentOptions.requestTls) {
          proxyAgentOptions.requestTls = {};
        }
        proxyAgentOptions.requestTls.ALPNProtocols = ["h2", "http/1.1"];
      }
      this.proxyAgent = new undiciExports.ProxyAgent(proxyAgentOptions);
    }
    this.agentManager = options.agent;
    if (options.dns && !this.agentManager) {
      const lookupFn = createLookupFunction(options.dns);
      this.dnsAgent = new undiciExports.Agent({
        connect: {
          lookup: lookupFn
        }
      });
    }
    if (!this.agentManager) {
      this.agentManager = new AgentManager({
        connections: options.connections,
        pipelining: options.pipelining,
        keepAlive: options.keepAlive,
        keepAliveTimeout: options.keepAliveTimeout,
        keepAliveMaxTimeout: options.keepAliveMaxTimeout,
        connectTimeout: options.connectTimeout,
        perDomainPooling: options.perDomainPooling,
        localAddress: options.localAddress
      });
    }
    if (options.socketPath && baseUrl) {
      this.socketClient = new undiciExports.Client(baseUrl, {
        socketPath: options.socketPath
      });
    }
  }
  updateProtocolCache(url, connection2) {
    if (!this.protocolCache || !connection2?.protocol)
      return;
    const protocol = normalizeProtocol(connection2.protocol);
    if (protocol) {
      this.protocolCache.set(url, protocol);
    }
  }
  recordProtocolFailure(url, error2) {
    if (!this.protocolCache)
      return;
    const isHttp2Error = error2.message?.includes("HTTP/2") || error2.message?.includes("h2") || error2.message?.includes("GOAWAY") || error2.message?.includes("stream");
    this.protocolCache.recordFailure(url, isHttp2Error);
  }
  shouldUseHttp2(url) {
    if (!this.protocolCache)
      return true;
    return this.protocolCache.shouldTryHttp2(url);
  }
  getProtocolCache() {
    return this.protocolCache;
  }
  async dispatch(req) {
    const headers2 = Object.fromEntries(req.headers);
    const contentLengthHeader = headers2["content-length"];
    const uploadTotal = contentLengthHeader ? parseInt(contentLengthHeader, 10) : void 0;
    let currentUrl;
    if (this.baseUrl) {
      if (req.url.startsWith(this.baseUrl)) {
        currentUrl = req.url;
      } else if (req.url.startsWith("http://") || req.url.startsWith("https://")) {
        currentUrl = req.url;
      } else {
        const base2 = this.baseUrl.endsWith("/") ? this.baseUrl.slice(0, -1) : this.baseUrl;
        const path3 = req.url.startsWith("/") ? req.url : "/" + req.url;
        currentUrl = base2 + path3;
      }
    } else {
      currentUrl = req.url;
    }
    const handleRedirectsManually = Boolean(req.beforeRedirect);
    const maxRedirects = req.maxRedirects ?? 20;
    const followRedirects = req.followRedirects !== false;
    const timeouts = mapTimeoutOptions(req.timeout, {
      connectTimeout: this.options.connectTimeout,
      headersTimeout: this.options.headersTimeout,
      bodyTimeout: this.options.bodyTimeout
    });
    let timeoutController;
    let timeoutId;
    if (!this.observability) {
      return this.dispatchFast(req, headers2, currentUrl, timeouts, handleRedirectsManually, maxRedirects, followRedirects, uploadTotal);
    }
    const requestContext = {
      timings: {},
      connection: {},
      requestStartTime: 0,
      requestCorrelationId: "",
      hooks: req._hooks
    };
    return requestStorage.run(requestContext, async () => {
      try {
        const startTime = import_perf_hooks.performance.now();
        if (requestContext.requestStartTime === 0) {
          requestContext.requestStartTime = startTime;
        }
        let redirectCount = 0;
        let currentMethod = req.method;
        let currentBody = req.body;
        let currentHeaders = { ...headers2 };
        let effectiveSignal = req.signal;
        if (timeouts.totalTimeout) {
          timeoutController = new AbortController();
          if (req.signal) {
            const originalSignal = req.signal;
            effectiveSignal = timeoutController.signal;
            const onOriginalAbort = () => {
              timeoutController.abort();
            };
            if (originalSignal.aborted) {
              timeoutController.abort();
            } else {
              originalSignal.addEventListener("abort", onOriginalAbort, { once: true });
            }
          } else {
            effectiveSignal = timeoutController.signal;
          }
          timeoutId = setTimeout(() => {
            timeoutController.abort();
          }, timeouts.totalTimeout);
        }
        while (true) {
          const dispatcher2 = this.socketClient || determineDispatcher({
            explicit: req._dispatcher,
            proxyAgent: this.proxyAgent,
            agentManager: this.agentManager,
            dnsAgent: this.dnsAgent,
            url: currentUrl,
            bypass: this.proxyBypassList
          });
          const bodyWithProgress = redirectCount === 0 ? wrapUploadBody$1(currentBody, req.onUploadProgress, uploadTotal) : currentBody;
          let finalBody = bodyWithProgress;
          if (finalBody instanceof FormData) {
            const tempResponse = new Response(finalBody);
            finalBody = tempResponse.body;
            tempResponse.headers.forEach((value, key) => {
              if (key.toLowerCase() === "content-type") {
                currentHeaders[key] = value;
                delete currentHeaders["Content-Type"];
              } else if (!currentHeaders[key]) {
                currentHeaders[key] = value;
              }
            });
          }
          const undiciOptions = {
            method: currentMethod,
            headers: currentHeaders,
            body: finalBody,
            signal: effectiveSignal,
            dispatcher: dispatcher2,
            connectTimeout: timeouts.connectTimeout,
            headersTimeout: timeouts.headersTimeout,
            bodyTimeout: timeouts.bodyTimeout,
            maxRedirections: 0
          };
          if (finalBody && (finalBody instanceof ReadableStream || typeof finalBody.pipe === "function" || finalBody[Symbol.asyncIterator])) {
            undiciOptions.duplex = "half";
          }
          const tlsOptions = mapTlsOptions(this.tlsOptions);
          if (tlsOptions) {
            undiciOptions.tls = tlsOptions;
          }
          const http2Enabled = req.http2 !== void 0 ? req.http2 : this.options.http2?.enabled;
          if (http2Enabled) {
            undiciOptions.allowH2 = true;
          } else if (req.http2 === false) {
            undiciOptions.allowH2 = false;
          }
          if (http2Enabled && this.options.http2) {
            if (this.options.http2.maxConcurrentStreams !== void 0) {
              undiciOptions.maxConcurrentStreams = this.options.http2.maxConcurrentStreams;
            }
            if (this.options.http2.pipelining !== void 0) {
              undiciOptions.pipelining = this.options.http2.pipelining;
            }
          }
          if (http2Enabled && this.options.expectContinue !== void 0 && finalBody) {
            const expectContinue = this.options.expectContinue;
            if (expectContinue === true) {
              undiciOptions.expectContinue = true;
            } else if (typeof expectContinue === "number" && uploadTotal !== void 0) {
              if (uploadTotal > expectContinue) {
                undiciOptions.expectContinue = true;
              }
            }
          }
          let undiciResponse;
          let connectionIdBefore = 0;
          try {
            connectionIdBefore = getConnectionId(new URL(currentUrl).hostname);
          } catch {
          }
          if (this.socketClient) {
            const urlPath = new URL(currentUrl).pathname + new URL(currentUrl).search;
            undiciResponse = await this.socketClient.request({
              path: urlPath || "/",
              method: currentMethod,
              headers: currentHeaders,
              body: bodyWithProgress,
              signal: req.signal
            });
          } else {
            undiciResponse = await undiciExports.request(currentUrl, undiciOptions);
          }
          const statusCode = undiciResponse.statusCode;
          const isRedirect = statusCode >= 300 && statusCode < 400;
          if (isRedirect && followRedirects && redirectCount < maxRedirects) {
            const locationHeader = undiciResponse.headers["location"];
            const location = Array.isArray(locationHeader) ? locationHeader[0] : locationHeader;
            if (location) {
              const nextUrl = new URL(location, currentUrl).toString();
              if (handleRedirectsManually) {
                const responseHeaders = new Headers();
                for (const [key, value] of Object.entries(undiciResponse.headers)) {
                  if (value !== void 0) {
                    if (Array.isArray(value)) {
                      value.forEach((v4) => responseHeaders.append(key, v4));
                    } else {
                      responseHeaders.set(key, value);
                    }
                  }
                }
                const redirectInfo = {
                  from: currentUrl,
                  to: nextUrl,
                  status: statusCode,
                  headers: responseHeaders
                };
                const hookResult = await req.beforeRedirect(redirectInfo);
                if (hookResult === false) {
                  const finalResponse2 = req.onDownloadProgress ? wrapDownloadResponse$1(undiciResponse, req.onDownloadProgress) : undiciResponse;
                  this.updateProtocolCache(currentUrl, requestContext.connection);
                  try {
                    const urlHostname = new URL(currentUrl).hostname;
                    const madeNewConnection = isNewConnection(urlHostname, connectionIdBefore);
                    if (madeNewConnection) {
                      const connTiming = getTimingForHost(urlHostname);
                      if (connTiming && !requestContext.timings.dns && !requestContext.timings.tcp && !requestContext.timings.tls) {
                        requestContext.timings.dns = connTiming.dns;
                        requestContext.timings.tcp = connTiming.tcp;
                        requestContext.timings.tls = connTiming.tls;
                      }
                    } else if (!requestContext.timings.dns && !requestContext.timings.tcp && !requestContext.timings.tls) {
                      requestContext.timings.dns = 0;
                      requestContext.timings.tcp = 0;
                      requestContext.timings.tls = 0;
                    }
                  } catch {
                  }
                  return new HttpResponse4(finalResponse2, {
                    timings: requestContext.timings,
                    connection: requestContext.connection
                  });
                }
                if (typeof hookResult === "string") {
                  currentUrl = hookResult;
                } else {
                  currentUrl = nextUrl;
                }
              } else {
                currentUrl = nextUrl;
              }
              if (statusCode === 303 || (statusCode === 301 || statusCode === 302) && currentMethod !== "GET" && currentMethod !== "HEAD") {
                currentMethod = "GET";
                currentBody = null;
                delete currentHeaders["content-type"];
                delete currentHeaders["content-length"];
                delete currentHeaders["Content-Type"];
                delete currentHeaders["Content-Length"];
              }
              await undiciResponse.body.arrayBuffer().catch(() => {
              });
              redirectCount++;
              continue;
            }
          }
          const finalResponse = req.onDownloadProgress ? wrapDownloadResponse$1(undiciResponse, req.onDownloadProgress) : undiciResponse;
          const ttfb = import_perf_hooks.performance.now() - startTime;
          const totalTime = import_perf_hooks.performance.now() - requestContext.requestStartTime;
          if (!requestContext.timings.firstByte) {
            requestContext.timings.firstByte = ttfb;
          }
          if (!requestContext.timings.total) {
            requestContext.timings.total = totalTime;
          }
          this.updateProtocolCache(currentUrl, requestContext.connection);
          try {
            const urlHostname = new URL(currentUrl).hostname;
            const madeNewConnection = isNewConnection(urlHostname, connectionIdBefore);
            if (madeNewConnection) {
              const connTiming = getTimingForHost(urlHostname);
              if (connTiming) {
                if (!requestContext.timings.dns && !requestContext.timings.tcp && !requestContext.timings.tls) {
                  requestContext.timings.dns = connTiming.dns;
                  requestContext.timings.tcp = connTiming.tcp;
                  requestContext.timings.tls = connTiming.tls;
                }
              }
            } else {
              if (!requestContext.timings.dns && !requestContext.timings.tcp && !requestContext.timings.tls) {
                requestContext.timings.dns = 0;
                requestContext.timings.tcp = 0;
                requestContext.timings.tls = 0;
              }
            }
          } catch {
          }
          return new HttpResponse4(finalResponse, {
            timings: requestContext.timings,
            connection: requestContext.connection
          });
        }
      } catch (error2) {
        this.recordProtocolFailure(currentUrl, error2);
        if (error2 instanceof undiciExports.errors.ConnectTimeoutError || error2.code === "UND_ERR_CONNECT_TIMEOUT") {
          throw new TimeoutError(req, {
            phase: "connect",
            timeout: timeouts.connectTimeout
          });
        }
        if (error2 instanceof undiciExports.errors.HeadersTimeoutError || error2.code === "UND_ERR_HEADERS_TIMEOUT") {
          throw new TimeoutError(req, {
            phase: "response",
            timeout: timeouts.headersTimeout
          });
        }
        if (error2 instanceof undiciExports.errors.BodyTimeoutError || error2.code === "UND_ERR_BODY_TIMEOUT") {
          throw new TimeoutError(req, {
            phase: "send",
            timeout: timeouts.bodyTimeout
          });
        }
        if (error2.name === "AbortError" || error2.code === "ABORT_ERR") {
          throw new TimeoutError(req, {
            phase: "request",
            timeout: timeouts.totalTimeout
          });
        }
        const code = error2.code || error2?.cause?.code;
        if (code === "UND_ERR_HEADERS_OVERFLOW") {
          throw new MaxSizeExceededError(16 * 1024, void 0, req);
        }
        const http2Error = parseHttp2Error(error2);
        if (http2Error) {
          http2Error.request = req;
          throw http2Error;
        }
        throw new NetworkError(error2.message, code, req);
      } finally {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
      }
    });
  }
  async dispatchFast(req, headers2, currentUrl, timeouts, handleRedirectsManually, maxRedirects, followRedirects, uploadTotal) {
    let timeoutController;
    let timeoutId;
    try {
      let redirectCount = 0;
      let currentMethod = req.method;
      let currentBody = req.body;
      let currentHeaders = { ...headers2 };
      let effectiveSignal = req.signal;
      if (timeouts.totalTimeout) {
        timeoutController = new AbortController();
        if (req.signal) {
          const originalSignal = req.signal;
          effectiveSignal = timeoutController.signal;
          const onOriginalAbort = () => {
            timeoutController.abort();
          };
          if (originalSignal.aborted) {
            timeoutController.abort();
          } else {
            originalSignal.addEventListener("abort", onOriginalAbort, { once: true });
          }
        } else {
          effectiveSignal = timeoutController.signal;
        }
        timeoutId = setTimeout(() => {
          timeoutController.abort();
        }, timeouts.totalTimeout);
      }
      while (true) {
        const dispatcher2 = this.socketClient || determineDispatcher({
          explicit: req._dispatcher,
          proxyAgent: this.proxyAgent,
          agentManager: this.agentManager,
          dnsAgent: this.dnsAgent,
          url: currentUrl,
          bypass: this.proxyBypassList
        });
        const bodyWithProgress = redirectCount === 0 ? wrapUploadBody$1(currentBody, req.onUploadProgress, uploadTotal) : currentBody;
        let finalBody = bodyWithProgress;
        if (finalBody instanceof FormData) {
          const tempResponse = new Response(finalBody);
          finalBody = tempResponse.body;
          tempResponse.headers.forEach((value, key) => {
            if (key.toLowerCase() === "content-type") {
              currentHeaders[key] = value;
              delete currentHeaders["Content-Type"];
            } else if (!currentHeaders[key]) {
              currentHeaders[key] = value;
            }
          });
        }
        const undiciOptions = {
          method: currentMethod,
          headers: currentHeaders,
          body: finalBody,
          signal: effectiveSignal,
          dispatcher: dispatcher2,
          connectTimeout: timeouts.connectTimeout,
          headersTimeout: timeouts.headersTimeout,
          bodyTimeout: timeouts.bodyTimeout,
          maxRedirections: 0
        };
        if (finalBody && (finalBody instanceof ReadableStream || typeof finalBody.pipe === "function" || finalBody[Symbol.asyncIterator])) {
          undiciOptions.duplex = "half";
        }
        const tlsOptions = mapTlsOptions(this.tlsOptions);
        if (tlsOptions) {
          undiciOptions.tls = tlsOptions;
        }
        const http2Enabled = req.http2 !== void 0 ? req.http2 : this.options.http2?.enabled;
        if (http2Enabled) {
          undiciOptions.allowH2 = true;
        } else if (req.http2 === false) {
          undiciOptions.allowH2 = false;
        }
        if (http2Enabled && this.options.http2) {
          if (this.options.http2.maxConcurrentStreams !== void 0) {
            undiciOptions.maxConcurrentStreams = this.options.http2.maxConcurrentStreams;
          }
          if (this.options.http2.pipelining !== void 0) {
            undiciOptions.pipelining = this.options.http2.pipelining;
          }
        }
        if (http2Enabled && this.options.expectContinue !== void 0 && finalBody) {
          const expectContinue = this.options.expectContinue;
          if (expectContinue === true) {
            undiciOptions.expectContinue = true;
          } else if (typeof expectContinue === "number" && uploadTotal !== void 0) {
            if (uploadTotal > expectContinue) {
              undiciOptions.expectContinue = true;
            }
          }
        }
        let undiciResponse;
        if (this.socketClient) {
          const urlPath = new URL(currentUrl).pathname + new URL(currentUrl).search;
          undiciResponse = await this.socketClient.request({
            path: urlPath || "/",
            method: currentMethod,
            headers: currentHeaders,
            body: bodyWithProgress,
            signal: req.signal
          });
        } else {
          undiciResponse = await undiciExports.request(currentUrl, undiciOptions);
        }
        const statusCode = undiciResponse.statusCode;
        const isRedirect = statusCode >= 300 && statusCode < 400;
        if (isRedirect && followRedirects && redirectCount < maxRedirects) {
          const locationHeader = undiciResponse.headers["location"];
          const location = Array.isArray(locationHeader) ? locationHeader[0] : locationHeader;
          if (location) {
            const nextUrl = new URL(location, currentUrl).toString();
            if (handleRedirectsManually) {
              const responseHeaders = new Headers();
              for (const [key, value] of Object.entries(undiciResponse.headers)) {
                if (value !== void 0) {
                  if (Array.isArray(value)) {
                    value.forEach((v4) => responseHeaders.append(key, v4));
                  } else {
                    responseHeaders.set(key, value);
                  }
                }
              }
              const redirectInfo = {
                from: currentUrl,
                to: nextUrl,
                status: statusCode,
                headers: responseHeaders
              };
              const hookResult = await req.beforeRedirect(redirectInfo);
              if (hookResult === false) {
                const finalResponse2 = req.onDownloadProgress ? wrapDownloadResponse$1(undiciResponse, req.onDownloadProgress) : undiciResponse;
                return new HttpResponse4(finalResponse2, {
                  timings: {},
                  connection: {}
                });
              }
              if (typeof hookResult === "string") {
                currentUrl = hookResult;
              } else {
                currentUrl = nextUrl;
              }
            } else {
              currentUrl = nextUrl;
            }
            if (statusCode === 303 || (statusCode === 301 || statusCode === 302) && currentMethod !== "GET" && currentMethod !== "HEAD") {
              currentMethod = "GET";
              currentBody = null;
              delete currentHeaders["content-type"];
              delete currentHeaders["content-length"];
              delete currentHeaders["Content-Type"];
              delete currentHeaders["Content-Length"];
            }
            await undiciResponse.body.arrayBuffer().catch(() => {
            });
            redirectCount++;
            continue;
          }
        }
        const finalResponse = req.onDownloadProgress ? wrapDownloadResponse$1(undiciResponse, req.onDownloadProgress) : undiciResponse;
        return new HttpResponse4(finalResponse, {
          timings: {},
          connection: {}
        });
      }
    } catch (error2) {
      if (error2 instanceof undiciExports.errors.ConnectTimeoutError || error2.code === "UND_ERR_CONNECT_TIMEOUT") {
        throw new TimeoutError(req, {
          phase: "connect",
          timeout: timeouts.connectTimeout
        });
      }
      if (error2 instanceof undiciExports.errors.HeadersTimeoutError || error2.code === "UND_ERR_HEADERS_TIMEOUT") {
        throw new TimeoutError(req, {
          phase: "response",
          timeout: timeouts.headersTimeout
        });
      }
      if (error2 instanceof undiciExports.errors.BodyTimeoutError || error2.code === "UND_ERR_BODY_TIMEOUT") {
        throw new TimeoutError(req, {
          phase: "send",
          timeout: timeouts.bodyTimeout
        });
      }
      if (error2.name === "AbortError" || error2.code === "ABORT_ERR") {
        throw new TimeoutError(req, {
          phase: "request",
          timeout: timeouts.totalTimeout
        });
      }
      const code = error2.code || error2?.cause?.code;
      if (code === "UND_ERR_HEADERS_OVERFLOW") {
        throw new MaxSizeExceededError(16 * 1024, void 0, req);
      }
      const http2Error = parseHttp2Error(error2);
      if (http2Error) {
        http2Error.request = req;
        throw http2Error;
      }
      throw new NetworkError(error2.message, code, req);
    } finally {
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
    }
  }
};
function mapTlsOptions(options) {
  if (!options)
    return void 0;
  const tls = {};
  if (options.minVersion)
    tls.minVersion = options.minVersion;
  if (options.maxVersion)
    tls.maxVersion = options.maxVersion;
  if (options.ciphers)
    tls.ciphers = options.ciphers;
  if (options.honorCipherOrder !== void 0)
    tls.honorCipherOrder = options.honorCipherOrder;
  if (options.ca)
    tls.ca = options.ca;
  if (options.cert)
    tls.cert = options.cert;
  if (options.key)
    tls.key = options.key;
  if (options.passphrase)
    tls.passphrase = options.passphrase;
  if (options.rejectUnauthorized !== void 0)
    tls.rejectUnauthorized = options.rejectUnauthorized;
  if (options.alpnProtocols)
    tls.ALPNProtocols = options.alpnProtocols;
  if (options.sessionTimeout !== void 0)
    tls.sessionTimeout = options.sessionTimeout;
  if (options.sessionIdContext)
    tls.sessionIdContext = options.sessionIdContext;
  if (options.servername !== void 0) {
    tls.servername = options.servername === false ? "" : options.servername;
  }
  return tls;
}
function determineDispatcher(params) {
  if (params.explicit)
    return params.explicit;
  const { proxyAgent: proxyAgent2, agentManager: agentManager2, dnsAgent, url, bypass } = params;
  const bypassProxy = shouldBypassProxy(url, bypass);
  if (proxyAgent2 && !bypassProxy)
    return proxyAgent2;
  if (agentManager2)
    return agentManager2.getAgentForUrl(url);
  if (dnsAgent)
    return dnsAgent;
  return void 0;
}
function detectProxyType(protocol) {
  const p4 = protocol.toLowerCase().replace(":", "");
  switch (p4) {
    case "http":
      return "http";
    case "https":
      return "https";
    case "socks4":
      return "socks4";
    case "socks4a":
      return "socks4a";
    case "socks5":
    case "socks":
      return "socks5";
    default:
      return void 0;
  }
}
function matchesCIDR(ip, cidr) {
  const [range2, bits] = cidr.split("/");
  if (!bits)
    return ip === range2;
  const mask = parseInt(bits, 10);
  if (isNaN(mask))
    return false;
  const ipParts = ip.split(".").map(Number);
  const rangeParts = range2.split(".").map(Number);
  if (ipParts.length !== 4 || rangeParts.length !== 4)
    return false;
  if (ipParts.some(isNaN) || rangeParts.some(isNaN))
    return false;
  const ipNum = ipParts[0] << 24 | ipParts[1] << 16 | ipParts[2] << 8 | ipParts[3];
  const rangeNum = rangeParts[0] << 24 | rangeParts[1] << 16 | rangeParts[2] << 8 | rangeParts[3];
  const maskNum = ~((1 << 32 - mask) - 1);
  return (ipNum & maskNum) === (rangeNum & maskNum);
}
function shouldBypassProxy(url, bypass) {
  if (!bypass || bypass.length === 0)
    return false;
  let hostname = "";
  let port = "";
  try {
    const parsed = new URL(url);
    hostname = parsed.hostname;
    port = parsed.port;
  } catch {
    return false;
  }
  for (const rule of bypass) {
    if (rule === "*")
      return true;
    if (rule.includes("/")) {
      if (matchesCIDR(hostname, rule))
        return true;
      continue;
    }
    if (rule.includes(":") && !rule.includes("/")) {
      const [hostRule, portRule] = rule.split(":");
      if (hostname === hostRule && (!portRule || port === portRule))
        return true;
      continue;
    }
    if (rule.startsWith("*.")) {
      const suffix = rule.slice(1);
      if (hostname.endsWith(suffix))
        return true;
      continue;
    }
    if (rule.startsWith(".")) {
      if (hostname.endsWith(rule))
        return true;
      continue;
    }
    if (hostname === rule) {
      return true;
    }
  }
  return false;
}
function parseContentLength$1(headers2) {
  if (!headers2)
    return void 0;
  if (typeof headers2.get === "function") {
    const raw2 = headers2.get("content-length");
    return raw2 ? parseInt(raw2, 10) : void 0;
  }
  const raw = headers2["content-length"] ?? headers2["Content-Length"];
  if (raw === void 0)
    return void 0;
  const parsed = parseInt(Array.isArray(raw) ? raw[0] : raw, 10);
  return Number.isFinite(parsed) ? parsed : void 0;
}
function wrapDownloadResponse$1(response2, onProgress) {
  if (!onProgress)
    return response2;
  if (typeof Response !== "undefined" && response2 instanceof Response) {
    if (!response2.body)
      return response2;
    const total2 = parseContentLength$1(response2.headers);
    const body2 = createProgressStream(response2.body, onProgress, {
      total: total2,
      direction: "download"
    });
    return new Response(body2, {
      status: response2.status,
      statusText: response2.statusText,
      headers: response2.headers
    });
  }
  const total = parseContentLength$1(response2.headers);
  const nodeBody = response2.body;
  if (!nodeBody)
    return response2;
  const webBody = createProgressStream(nodeToWebStream(nodeBody), onProgress, {
    total,
    direction: "download"
  });
  return new Response(webBody, {
    status: response2.statusCode,
    headers: response2.headers
  });
}
function wrapUploadBody$1(body2, onProgress, total) {
  if (body2 instanceof FormData) {
    return body2;
  }
  if (!onProgress || !body2)
    return body2;
  if (typeof ReadableStream !== "undefined" && body2 instanceof ReadableStream) {
    return createProgressStream(body2, onProgress, { total, direction: "upload" });
  }
  if (typeof Blob !== "undefined" && body2 instanceof Blob) {
    return createProgressStream(body2.stream(), onProgress, { total: body2.size, direction: "upload" });
  }
  if (isNodeReadable(body2)) {
    const webStream = nodeToWebStream(body2);
    return createProgressStream(webStream, onProgress, { total, direction: "upload" });
  }
  if (body2 instanceof ArrayBuffer || ArrayBuffer.isView(body2)) {
    const view = body2 instanceof ArrayBuffer ? new Uint8Array(body2) : new Uint8Array(body2.buffer, body2.byteOffset, body2.byteLength);
    return bufferToProgressStream(view, onProgress);
  }
  if (typeof body2 === "string") {
    const encoder = new TextEncoder();
    const view = encoder.encode(body2);
    return bufferToProgressStream(view, onProgress);
  }
  return body2;
}
function bufferToProgressStream(buffer, onProgress, chunkSize = 64 * 1024) {
  let offset = 0;
  const total = buffer.byteLength;
  const stream = new ReadableStream({
    pull(controller) {
      if (offset >= total) {
        controller.close();
        return;
      }
      const end = Math.min(offset + chunkSize, total);
      controller.enqueue(buffer.slice(offset, end));
      offset = end;
    }
  });
  return createProgressStream(stream, onProgress, { total, direction: "upload" });
}
function isNodeReadable(obj) {
  return obj && typeof obj.pipe === "function" && typeof obj.on === "function";
}
var undici = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  UndiciTransport
});
function parseContentLength(headers2) {
  const raw = headers2.get("content-length");
  if (!raw)
    return void 0;
  const parsed = parseInt(raw, 10);
  return Number.isFinite(parsed) ? parsed : void 0;
}
function wrapDownloadResponse(response2, onProgress) {
  if (!onProgress || !response2.body)
    return response2;
  const total = parseContentLength(response2.headers);
  const body2 = createProgressStream(response2.body, onProgress, {
    total,
    direction: "download"
  });
  return new Response(body2, {
    status: response2.status,
    statusText: response2.statusText,
    headers: response2.headers
  });
}
function bufferToStream(buffer) {
  return new ReadableStream({
    start(controller) {
      controller.enqueue(buffer);
      controller.close();
    }
  });
}
function wrapUploadBody(body2, onProgress, total) {
  if (!onProgress || !body2)
    return body2;
  if (typeof FormData !== "undefined" && body2 instanceof FormData) {
    return body2;
  }
  if (typeof ReadableStream !== "undefined" && body2 instanceof ReadableStream) {
    return createProgressStream(body2, onProgress, { total, direction: "upload" });
  }
  if (typeof Blob !== "undefined" && body2 instanceof Blob) {
    return createProgressStream(body2.stream(), onProgress, { total: body2.size, direction: "upload" });
  }
  if (body2 instanceof ArrayBuffer || ArrayBuffer.isView(body2)) {
    const view = body2 instanceof ArrayBuffer ? new Uint8Array(body2) : new Uint8Array(body2.buffer, body2.byteOffset, body2.byteLength);
    return createProgressStream(bufferToStream(view), onProgress, { total: view.byteLength, direction: "upload" });
  }
  if (typeof body2 === "string") {
    const encoder = new TextEncoder();
    const view = encoder.encode(body2);
    return createProgressStream(bufferToStream(view), onProgress, { total: view.byteLength, direction: "upload" });
  }
  return body2;
}
var FetchTransport = class {
  options;
  constructor(options = {}) {
    this.options = options;
  }
  async dispatch(req) {
    const start = performance.now();
    let timeoutId;
    let abortController;
    const timeoutMs = typeof req.timeout === "number" ? req.timeout : req.timeout?.request;
    let signal = req.signal;
    if (timeoutMs && !signal) {
      abortController = new AbortController();
      signal = abortController.signal;
      timeoutId = setTimeout(() => abortController.abort(), timeoutMs);
    }
    const followRedirects = req.followRedirects !== false;
    const maxRedirects = req.maxRedirects ?? 20;
    const handleRedirectsManually = Boolean(req.beforeRedirect) || req.followRedirects === false || req.maxRedirects !== void 0;
    let currentUrl = req.url;
    let currentMethod = req.method;
    let currentBody = req.body;
    let currentHeaders = new Headers(req.headers);
    const uploadTotal = parseContentLength(currentHeaders);
    let redirectCount = 0;
    try {
      while (true) {
        const bodyWithProgress = redirectCount === 0 ? wrapUploadBody(currentBody, req.onUploadProgress, uploadTotal) : currentBody;
        const requestInit = {
          method: currentMethod,
          headers: currentHeaders,
          body: bodyWithProgress,
          signal,
          credentials: this.options.credentials,
          cache: this.options.cache,
          keepalive: this.options.keepalive ?? true,
          redirect: handleRedirectsManually ? "manual" : "follow",
          duplex: bodyWithProgress ? "half" : void 0
        };
        const response2 = await globalThis.fetch(currentUrl, requestInit);
        if (handleRedirectsManually) {
          const status = response2.status;
          const isRedirect = status >= 300 && status < 400;
          if (isRedirect && followRedirects && redirectCount < maxRedirects) {
            const location = response2.headers.get("location");
            if (!location || response2.type === "opaqueredirect") {
              const finalResponse2 = wrapDownloadResponse(response2, req.onDownloadProgress);
              const totalTime2 = performance.now() - start;
              return new FetchResponseWrapper(finalResponse2, { total: totalTime2, firstByte: totalTime2 });
            }
            const nextUrl = new URL(location, currentUrl).toString();
            let resolvedUrl = nextUrl;
            if (req.beforeRedirect) {
              const redirectInfo = {
                from: currentUrl,
                to: nextUrl,
                status,
                headers: response2.headers
              };
              const hookResult = await req.beforeRedirect(redirectInfo);
              if (hookResult === false) {
                const finalResponse2 = wrapDownloadResponse(response2, req.onDownloadProgress);
                const totalTime2 = performance.now() - start;
                return new FetchResponseWrapper(finalResponse2, { total: totalTime2, firstByte: totalTime2 });
              }
              if (typeof hookResult === "string") {
                resolvedUrl = hookResult;
              }
            }
            if (status === 303 || (status === 301 || status === 302) && currentMethod !== "GET" && currentMethod !== "HEAD") {
              currentMethod = "GET";
              currentBody = null;
              currentHeaders.delete("content-type");
              currentHeaders.delete("content-length");
            }
            await response2.body?.cancel();
            currentUrl = resolvedUrl;
            redirectCount++;
            continue;
          }
        }
        const finalResponse = wrapDownloadResponse(response2, req.onDownloadProgress);
        const totalTime = performance.now() - start;
        const timings = {
          total: totalTime,
          firstByte: totalTime
        };
        return new FetchResponseWrapper(finalResponse, timings);
      }
    } catch (error2) {
      if (error2.name === "AbortError" && abortController) {
        const timeoutError = new Error(`Request timeout after ${timeoutMs}ms`);
        timeoutError.name = "TimeoutError";
        throw timeoutError;
      }
      throw error2;
    } finally {
      if (timeoutId)
        clearTimeout(timeoutId);
    }
  }
};
var FetchResponseWrapper = class _FetchResponseWrapper {
  raw;
  timings;
  constructor(raw, timings) {
    this.raw = raw;
    this.timings = timings;
  }
  get status() {
    return this.raw.status;
  }
  get statusText() {
    return this.raw.statusText;
  }
  get headers() {
    return this.raw.headers;
  }
  get ok() {
    return this.raw.ok;
  }
  get url() {
    return this.raw.url;
  }
  get connection() {
    return {};
  }
  json() {
    return this.raw.json();
  }
  text() {
    return this.raw.text();
  }
  blob() {
    return this.raw.blob();
  }
  async cleanText() {
    return (await this.text()).replace(/<[^>]*>?/gm, "");
  }
  read() {
    return this.raw.body;
  }
  clone() {
    return new _FetchResponseWrapper(this.raw.clone(), this.timings);
  }
  async *sse() {
    if (!this.raw.body)
      return;
    const stream = this.raw.body.pipeThrough(new TextDecoderStream());
    const reader = stream.getReader();
    let buffer = "";
    while (true) {
      const { done, value } = await reader.read();
      if (done)
        break;
      buffer += value;
      const events2 = buffer.split("\n\n");
      buffer = events2.pop() || "";
      for (const event of events2) {
        if (!event.trim())
          continue;
        let data2 = "";
        let eventType;
        let id2;
        let retry2;
        const lines = event.split("\n");
        for (const line of lines) {
          if (line.startsWith("data: ")) {
            data2 = data2 ? data2 + "\n" + line.slice(6) : line.slice(6);
          } else if (line.startsWith("event: ")) {
            eventType = line.slice(7);
          } else if (line.startsWith("id: ")) {
            id2 = line.slice(4);
          } else if (line.startsWith("retry: ")) {
            retry2 = parseInt(line.slice(7), 10);
          }
        }
        if (data2) {
          yield { data: data2, event: eventType, id: id2, retry: retry2 };
        }
      }
    }
  }
  async *download() {
    if (!this.raw.body)
      return;
    const reader = this.raw.body.getReader();
    let loaded = 0;
    const total = Number(this.raw.headers.get("content-length")) || void 0;
    while (true) {
      const { done, value } = await reader.read();
      if (done)
        break;
      loaded += value.length;
      yield {
        loaded,
        transferred: loaded,
        total,
        percent: total ? loaded / total * 100 : void 0,
        direction: "download"
      };
    }
  }
  async *[Symbol.asyncIterator]() {
    if (!this.raw.body)
      return;
    const reader = this.raw.body.getReader();
    while (true) {
      const { done, value } = await reader.read();
      if (done)
        break;
      yield value;
    }
  }
};
var consoleLogger = {
  debug: (msgOrObj, ...args) => {
    if (typeof msgOrObj === "object") {
      console.debug(msgOrObj, ...args);
    } else {
      console.debug(msgOrObj, ...args);
    }
  },
  info: (msgOrObj, ...args) => {
    if (typeof msgOrObj === "object") {
      console.info(msgOrObj, ...args);
    } else {
      console.info(msgOrObj, ...args);
    }
  },
  warn: (msgOrObj, ...args) => {
    if (typeof msgOrObj === "object") {
      console.warn(msgOrObj, ...args);
    } else {
      console.warn(msgOrObj, ...args);
    }
  },
  error: (msgOrObj, ...args) => {
    if (typeof msgOrObj === "object") {
      console.error(msgOrObj, ...args);
    } else {
      console.error(msgOrObj, ...args);
    }
  }
};
var HTTP2_PRESETS = {
  balanced: {
    maxConcurrentStreams: 100,
    initialWindowSize: 65535,
    maxHeaderListSize: 16384,
    enablePush: 0
  },
  performance: {
    maxConcurrentStreams: 128,
    initialWindowSize: 1048576,
    maxHeaderListSize: 32768,
    enablePush: 0
  },
  "low-latency": {
    maxConcurrentStreams: 250,
    initialWindowSize: 65535,
    maxHeaderListSize: 16384,
    enablePush: 0
  },
  "low-memory": {
    maxConcurrentStreams: 50,
    initialWindowSize: 32768,
    maxHeaderListSize: 8192,
    enablePush: 0
  }
};
var DEFAULT_MAX_PAIRS = 12;
var ConversationMemory = class _ConversationMemory {
  config;
  systemMessage = null;
  messages = [];
  constructor(config = {}) {
    this.config = {
      maxPairs: config.maxPairs ?? DEFAULT_MAX_PAIRS,
      systemPrompt: config.systemPrompt ?? ""
    };
    if (this.config.systemPrompt) {
      this.systemMessage = {
        role: "system",
        content: this.config.systemPrompt
      };
    }
  }
  setSystemPrompt(prompt) {
    this.config.systemPrompt = prompt;
    if (prompt) {
      this.systemMessage = {
        role: "system",
        content: prompt
      };
    } else {
      this.systemMessage = null;
    }
  }
  getSystemPrompt() {
    return this.config.systemPrompt;
  }
  addUserMessage(content) {
    this.messages.push({
      role: "user",
      content
    });
    this.prune();
  }
  addAssistantMessage(content) {
    this.messages.push({
      role: "assistant",
      content
    });
    this.prune();
  }
  addMessage(message) {
    if (message.role === "system") {
      this.setSystemPrompt(typeof message.content === "string" ? message.content : "");
      return;
    }
    this.messages.push(message);
    this.prune();
  }
  buildMessages(userPrompt) {
    this.addUserMessage(userPrompt);
    return this.getMessages();
  }
  recordResponse(content) {
    this.addAssistantMessage(content);
  }
  getMessages() {
    const result = [];
    if (this.systemMessage) {
      result.push(this.systemMessage);
    }
    result.push(...this.messages);
    return result;
  }
  getConversation() {
    return this.messages;
  }
  getPairCount() {
    let pairs = 0;
    for (let i4 = 0; i4 < this.messages.length - 1; i4 += 2) {
      if (this.messages[i4].role === "user" && this.messages[i4 + 1]?.role === "assistant") {
        pairs++;
      }
    }
    return pairs;
  }
  clear() {
    this.messages = [];
  }
  reset() {
    this.messages = [];
    this.systemMessage = null;
    this.config.systemPrompt = "";
  }
  setConfig(config) {
    if (config.maxPairs !== void 0) {
      this.config.maxPairs = config.maxPairs;
      this.prune();
    }
    if (config.systemPrompt !== void 0) {
      this.setSystemPrompt(config.systemPrompt);
    }
  }
  getConfig() {
    return { ...this.config };
  }
  prune() {
    const maxMessages = this.config.maxPairs * 2;
    if (this.messages.length > maxMessages) {
      const excess = this.messages.length - maxMessages;
      const toRemove = Math.ceil(excess / 2) * 2;
      this.messages = this.messages.slice(toRemove);
    }
  }
  isEmpty() {
    return this.messages.length === 0;
  }
  getMessageCount() {
    return this.messages.length;
  }
  toJSON() {
    return {
      config: this.config,
      systemPrompt: this.systemMessage?.content,
      messages: [...this.messages]
    };
  }
  static fromJSON(data2) {
    const memory = new _ConversationMemory(data2.config);
    if (data2.systemPrompt) {
      memory.setSystemPrompt(data2.systemPrompt);
    }
    if (data2.messages) {
      for (const msg of data2.messages) {
        memory.addMessage(msg);
      }
    }
    return memory;
  }
};
var PROVIDER_ENDPOINTS = {
  openai: "/chat/completions",
  anthropic: "/messages",
  google: "/models/{model}:generateContent",
  groq: "/chat/completions",
  mistral: "/chat/completions",
  cohere: "/chat",
  together: "/chat/completions",
  perplexity: "/chat/completions",
  deepseek: "/chat/completions",
  fireworks: "/chat/completions",
  xai: "/chat/completions",
  replicate: "/predictions",
  huggingface: "/models/{model}/v1/chat/completions",
  ollama: "/api/chat",
  "azure-openai": "/chat/completions",
  "cloudflare-workers-ai": "/ai/run/@cf/meta/llama-2-7b-chat-int8",
  custom: "/chat/completions"
};
var ClientAIImpl = class {
  client;
  config;
  memory;
  constructor(client2, config) {
    this.client = client2;
    this.config = config;
    this.memory = new ConversationMemory(config.memory);
  }
  get provider() {
    return this.config.provider;
  }
  get model() {
    return this.config.model;
  }
  async chat(prompt) {
    const messages = this.memory.buildMessages(prompt);
    const response2 = await this.makeRequest(messages, false);
    this.memory.recordResponse(response2.content);
    return response2;
  }
  async chatStream(prompt) {
    const messages = this.memory.buildMessages(prompt);
    const stream = await this.makeStreamRequest(messages);
    return this.wrapStreamWithMemory(stream);
  }
  async prompt(prompt) {
    const messages = [{ role: "user", content: prompt }];
    return this.makeRequest(messages, false);
  }
  async promptStream(prompt) {
    const messages = [{ role: "user", content: prompt }];
    return this.makeStreamRequest(messages);
  }
  clearMemory() {
    this.memory.clear();
  }
  getMemory() {
    return this.memory.getConversation();
  }
  setMemoryConfig(config) {
    this.memory.setConfig(config);
  }
  getMemoryConfig() {
    return this.memory.getConfig();
  }
  async makeRequest(messages, stream) {
    const startTime = performance.now();
    const body2 = this.buildRequestBody(messages, stream);
    const endpoint = this.getEndpoint();
    const response2 = await this.client.post(endpoint, {
      json: body2,
      headers: this.getExtraHeaders()
    });
    const data2 = await response2.json();
    return this.parseResponse(data2, startTime);
  }
  async makeStreamRequest(messages) {
    const body2 = this.buildRequestBody(messages, true);
    const endpoint = this.getEndpoint();
    const response2 = await this.client.post(endpoint, {
      json: body2,
      headers: this.getExtraHeaders()
    });
    return this.parseSSEStream(response2.raw);
  }
  buildRequestBody(messages, stream) {
    const provider = this.config.provider;
    if (provider === "anthropic") {
      return this.buildAnthropicBody(messages, stream);
    }
    if (provider === "google") {
      return this.buildGoogleBody(messages, stream);
    }
    if (provider === "cohere") {
      return this.buildCohereBody(messages, stream);
    }
    return {
      model: this.config.model,
      messages: messages.map((m4) => ({
        role: m4.role,
        content: m4.content
      })),
      stream,
      ...stream && { stream_options: { include_usage: true } }
    };
  }
  buildAnthropicBody(messages, stream) {
    const systemMessages = messages.filter((m4) => m4.role === "system");
    const otherMessages = messages.filter((m4) => m4.role !== "system");
    return {
      model: this.config.model,
      max_tokens: 4096,
      system: systemMessages.map((m4) => m4.content).join("\n") || void 0,
      messages: otherMessages.map((m4) => ({
        role: m4.role === "assistant" ? "assistant" : "user",
        content: m4.content
      })),
      stream
    };
  }
  buildGoogleBody(messages, stream) {
    const contents = messages.filter((m4) => m4.role !== "system").map((m4) => ({
      role: m4.role === "assistant" ? "model" : "user",
      parts: [{ text: m4.content }]
    }));
    const systemInstruction = messages.filter((m4) => m4.role === "system").map((m4) => m4.content).join("\n");
    return {
      contents,
      ...systemInstruction && {
        systemInstruction: { parts: [{ text: systemInstruction }] }
      },
      generationConfig: {
        maxOutputTokens: 4096
      }
    };
  }
  buildCohereBody(messages, stream) {
    const chatHistory = messages.slice(0, -1).map((m4) => ({
      role: m4.role === "assistant" ? "CHATBOT" : "USER",
      message: m4.content
    }));
    const lastMessage = messages[messages.length - 1];
    return {
      model: this.config.model,
      message: typeof lastMessage.content === "string" ? lastMessage.content : "",
      chat_history: chatHistory.length > 0 ? chatHistory : void 0,
      stream
    };
  }
  getEndpoint() {
    let endpoint = PROVIDER_ENDPOINTS[this.config.provider] || "/chat/completions";
    endpoint = endpoint.replace("{model}", this.config.model);
    return endpoint;
  }
  getExtraHeaders() {
    const headers2 = {};
    if (this.config.headers) {
      Object.assign(headers2, this.config.headers);
    }
    return headers2;
  }
  parseResponse(data2, startTime) {
    const provider = this.config.provider;
    const endTime = performance.now();
    if (provider === "anthropic") {
      return this.parseAnthropicResponse(data2, startTime, endTime);
    }
    if (provider === "google") {
      return this.parseGoogleResponse(data2, startTime, endTime);
    }
    if (provider === "cohere") {
      return this.parseCohereResponse(data2, startTime, endTime);
    }
    return this.parseOpenAIResponse(data2, startTime, endTime);
  }
  parseOpenAIResponse(data2, startTime, endTime) {
    const d4 = data2;
    const content = d4.choices?.[0]?.message?.content || "";
    const usage = {
      inputTokens: d4.usage?.prompt_tokens || 0,
      outputTokens: d4.usage?.completion_tokens || 0,
      totalTokens: d4.usage?.total_tokens || 0
    };
    return {
      content,
      usage,
      latency: this.buildLatency(startTime, endTime, usage.outputTokens),
      model: d4.model || this.config.model,
      provider: this.config.provider,
      cached: false,
      finishReason: d4.choices?.[0]?.finish_reason,
      raw: data2
    };
  }
  parseAnthropicResponse(data2, startTime, endTime) {
    const d4 = data2;
    const textContent2 = d4.content?.find((c4) => c4.type === "text");
    const content = textContent2?.text || "";
    const usage = {
      inputTokens: d4.usage?.input_tokens || 0,
      outputTokens: d4.usage?.output_tokens || 0,
      totalTokens: (d4.usage?.input_tokens || 0) + (d4.usage?.output_tokens || 0)
    };
    return {
      content,
      usage,
      latency: this.buildLatency(startTime, endTime, usage.outputTokens),
      model: d4.model || this.config.model,
      provider: "anthropic",
      cached: false,
      finishReason: d4.stop_reason === "end_turn" ? "stop" : void 0,
      raw: data2
    };
  }
  parseGoogleResponse(data2, startTime, endTime) {
    const d4 = data2;
    const content = d4.candidates?.[0]?.content?.parts?.[0]?.text || "";
    const usage = {
      inputTokens: d4.usageMetadata?.promptTokenCount || 0,
      outputTokens: d4.usageMetadata?.candidatesTokenCount || 0,
      totalTokens: d4.usageMetadata?.totalTokenCount || 0
    };
    return {
      content,
      usage,
      latency: this.buildLatency(startTime, endTime, usage.outputTokens),
      model: this.config.model,
      provider: "google",
      cached: false,
      finishReason: d4.candidates?.[0]?.finishReason === "STOP" ? "stop" : void 0,
      raw: data2
    };
  }
  parseCohereResponse(data2, startTime, endTime) {
    const d4 = data2;
    const content = d4.text || "";
    const usage = {
      inputTokens: d4.meta?.tokens?.input_tokens || 0,
      outputTokens: d4.meta?.tokens?.output_tokens || 0,
      totalTokens: (d4.meta?.tokens?.input_tokens || 0) + (d4.meta?.tokens?.output_tokens || 0)
    };
    return {
      content,
      usage,
      latency: this.buildLatency(startTime, endTime, usage.outputTokens),
      model: this.config.model,
      provider: "cohere",
      cached: false,
      finishReason: d4.finish_reason === "COMPLETE" ? "stop" : void 0,
      raw: data2
    };
  }
  buildLatency(startTime, endTime, outputTokens) {
    const total = endTime - startTime;
    return {
      ttft: total,
      tps: outputTokens > 0 ? outputTokens / (total / 1e3) : 0,
      total
    };
  }
  async *parseSSEStream(response2) {
    const reader = response2.body?.getReader();
    if (!reader) {
      throw new Error("No response body");
    }
    const decoder = new TextDecoder();
    let buffer = "";
    let firstChunkTime;
    performance.now();
    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done) {
          break;
        }
        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split("\n");
        buffer = lines.pop() || "";
        for (const line of lines) {
          const trimmed = line.trim();
          if (!trimmed || trimmed === "data: [DONE]") {
            continue;
          }
          if (trimmed.startsWith("data: ")) {
            const jsonStr = trimmed.slice(6);
            try {
              const event = this.parseStreamChunk(jsonStr);
              if (event) {
                if (!firstChunkTime && event.type === "text") {
                  firstChunkTime = performance.now();
                }
                yield event;
              }
            } catch {
            }
          }
        }
      }
    } finally {
      reader.releaseLock();
    }
  }
  parseStreamChunk(jsonStr) {
    const data2 = JSON.parse(jsonStr);
    const provider = this.config.provider;
    if (provider === "anthropic") {
      return this.parseAnthropicStreamChunk(data2);
    }
    return this.parseOpenAIStreamChunk(data2);
  }
  parseOpenAIStreamChunk(data2) {
    const choice = data2.choices?.[0];
    if (!choice) {
      if (data2.usage) {
        return {
          type: "usage",
          usage: {
            inputTokens: data2.usage.prompt_tokens || 0,
            outputTokens: data2.usage.completion_tokens || 0,
            totalTokens: data2.usage.total_tokens || 0
          }
        };
      }
      return null;
    }
    if (choice.delta?.content) {
      return {
        type: "text",
        content: choice.delta.content
      };
    }
    if (choice.finish_reason) {
      return {
        type: "done",
        finishReason: choice.finish_reason
      };
    }
    return null;
  }
  parseAnthropicStreamChunk(data2) {
    if (data2.type === "content_block_delta" && data2.delta?.type === "text_delta") {
      return {
        type: "text",
        content: data2.delta.text || ""
      };
    }
    if (data2.type === "message_stop") {
      return {
        type: "done",
        finishReason: "stop"
      };
    }
    if (data2.type === "message_delta" && data2.message?.usage) {
      return {
        type: "usage",
        usage: {
          inputTokens: data2.message.usage.input_tokens || 0,
          outputTokens: data2.message.usage.output_tokens || 0,
          totalTokens: (data2.message.usage.input_tokens || 0) + (data2.message.usage.output_tokens || 0)
        }
      };
    }
    return null;
  }
  async *wrapStreamWithMemory(stream) {
    let fullContent = "";
    for await (const event of stream) {
      if (event.type === "text") {
        fullContent += event.content;
      }
      yield event;
    }
    if (fullContent) {
      this.memory.recordResponse(fullContent);
    }
  }
};
function normalizeTimeout(timeout) {
  if (timeout === void 0)
    return void 0;
  if (typeof timeout === "number") {
    return { request: timeout };
  }
  return timeout;
}
var HttpRequest10 = class _HttpRequest {
  url;
  method;
  headers;
  body;
  signal;
  throwHttpErrors;
  timeout;
  onUploadProgress;
  onDownloadProgress;
  maxResponseSize;
  beforeRedirect;
  maxRedirects;
  followRedirects;
  http2;
  useCurl;
  constructor(url, options = {}) {
    this.url = url;
    this.method = options.method || "GET";
    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers);
    this.body = options.body || null;
    this.signal = options.signal;
    this.throwHttpErrors = options.throwHttpErrors !== void 0 ? options.throwHttpErrors : true;
    this.timeout = normalizeTimeout(options.timeout);
    this.onUploadProgress = options.onUploadProgress;
    this.onDownloadProgress = options.onDownloadProgress;
    this.maxResponseSize = options.maxResponseSize;
    this.beforeRedirect = options.beforeRedirect;
    this.maxRedirects = options.maxRedirects;
    this.followRedirects = options.followRedirects;
    this.http2 = options.http2;
    this.useCurl = options.useCurl;
  }
  withHeader(name, value) {
    const newHeaders = new Headers(this.headers);
    newHeaders.set(name, value);
    return new _HttpRequest(this.url, {
      method: this.method,
      headers: newHeaders,
      body: this.body,
      signal: this.signal,
      throwHttpErrors: this.throwHttpErrors,
      timeout: this.timeout,
      onUploadProgress: this.onUploadProgress,
      onDownloadProgress: this.onDownloadProgress,
      maxResponseSize: this.maxResponseSize,
      beforeRedirect: this.beforeRedirect,
      maxRedirects: this.maxRedirects,
      followRedirects: this.followRedirects,
      http2: this.http2,
      useCurl: this.useCurl
    });
  }
  withBody(body2) {
    return new _HttpRequest(this.url, {
      method: this.method,
      headers: this.headers,
      body: body2,
      signal: this.signal,
      throwHttpErrors: this.throwHttpErrors,
      timeout: this.timeout,
      onUploadProgress: this.onUploadProgress,
      onDownloadProgress: this.onDownloadProgress,
      maxResponseSize: this.maxResponseSize,
      beforeRedirect: this.beforeRedirect,
      maxRedirects: this.maxRedirects,
      followRedirects: this.followRedirects,
      http2: this.http2,
      useCurl: this.useCurl
    });
  }
};
function isPlainObject2(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  if (value instanceof Blob || value instanceof FormData || value instanceof URLSearchParams || value instanceof ArrayBuffer || value instanceof ReadableStream) {
    return false;
  }
  if (typeof File !== "undefined") {
    try {
      if (value instanceof File) {
        return false;
      }
    } catch {
    }
  }
  return true;
}
function processBody(body2) {
  if (body2 === null || body2 === void 0) {
    return { body: void 0 };
  }
  if (typeof body2 === "string") {
    return {
      body: body2,
      contentType: "text/plain; charset=utf-8"
    };
  }
  if (body2 instanceof FormData) {
    return {
      body: body2,
      contentType: void 0
    };
  }
  if (body2 instanceof URLSearchParams) {
    return {
      body: body2.toString(),
      contentType: "application/x-www-form-urlencoded"
    };
  }
  if (body2 instanceof Blob || isFile(body2)) {
    return {
      body: body2,
      contentType: body2.type || "application/octet-stream"
    };
  }
  if (body2 instanceof ArrayBuffer) {
    return {
      body: body2,
      contentType: "application/octet-stream"
    };
  }
  if (body2 instanceof ReadableStream) {
    return {
      body: body2,
      contentType: "application/octet-stream"
    };
  }
  if (isPlainObject2(body2)) {
    if (isFileUpload(body2)) {
      return {
        body: createFormData(body2),
        contentType: void 0
      };
    }
    return {
      body: JSON.stringify(body2),
      contentType: "application/json"
    };
  }
  if (Array.isArray(body2)) {
    return {
      body: JSON.stringify(body2),
      contentType: "application/json"
    };
  }
  return {
    body: String(body2),
    contentType: "text/plain; charset=utf-8"
  };
}
function createFormData(data2) {
  const formData = new FormData();
  for (const [key, value] of Object.entries(data2)) {
    if (value === null || value === void 0) {
      continue;
    }
    if (Array.isArray(value)) {
      value.forEach((item) => {
        if (item instanceof Blob || isFile(item)) {
          formData.append(key, item);
        } else {
          formData.append(key, String(item));
        }
      });
      continue;
    }
    if (value instanceof Blob || isFile(value)) {
      formData.append(key, value);
      continue;
    }
    if (typeof value === "object") {
      formData.append(key, JSON.stringify(value));
      continue;
    }
    formData.append(key, String(value));
  }
  return formData;
}
function isFile(value) {
  if (typeof File === "undefined") {
    return false;
  }
  return value instanceof File;
}
function isFileUpload(body2) {
  if (!body2)
    return false;
  if (body2 instanceof Blob || isFile(body2)) {
    return true;
  }
  if (body2 instanceof FormData) {
    for (const value of body2.values()) {
      if (value instanceof Blob || isFile(value)) {
        return true;
      }
    }
  }
  if (isPlainObject2(body2)) {
    for (const value of Object.values(body2)) {
      if (value instanceof Blob || isFile(value)) {
        return true;
      }
      if (Array.isArray(value) && value.some((v4) => v4 instanceof Blob || isFile(v4))) {
        return true;
      }
    }
  }
  return false;
}
var RequestPool = class {
  concurrency;
  requestsPerInterval;
  interval;
  queue = [];
  active = 0;
  windowStart = 0;
  startedInWindow = 0;
  waitingTimer;
  constructor(options = {}) {
    this.concurrency = options.concurrency ?? Number.POSITIVE_INFINITY;
    this.requestsPerInterval = options.requestsPerInterval;
    this.interval = options.interval;
  }
  run(fn, signal) {
    if (signal?.aborted) {
      return Promise.reject(signal.reason ?? new ReckerError("Request aborted before enqueue", void 0, void 0, ["Ensure the AbortSignal is not already aborted when calling the request.", "Remove or reset the signal before enqueueing."]));
    }
    return new Promise((resolve, reject) => {
      const request2 = { fn, resolve, reject, signal };
      if (signal) {
        const onAbort = () => {
          this._removeFromQueue(request2);
          reject(signal.reason ?? new ReckerError("Request aborted while queued", void 0, void 0, ["Avoid aborting immediately after queuing.", "Increase timeouts or adjust rate limits if cancellations are unintended."]));
          this._schedule();
        };
        signal.addEventListener("abort", onAbort, { once: true });
        request2.abortCleanup = () => signal.removeEventListener("abort", onAbort);
      }
      this.queue.push(request2);
      this._schedule();
    });
  }
  _removeFromQueue(request2) {
    const index = this.queue.indexOf(request2);
    if (index >= 0) {
      this.queue.splice(index, 1);
    }
  }
  _canStart(now) {
    if (this.active >= this.concurrency) {
      return false;
    }
    if (this.requestsPerInterval == null || this.interval == null) {
      return true;
    }
    if (now - this.windowStart >= this.interval) {
      this.windowStart = now;
      this.startedInWindow = 0;
    }
    if (this.startedInWindow < this.requestsPerInterval) {
      return true;
    }
    return false;
  }
  _schedule() {
    if (this.waitingTimer) {
      return;
    }
    while (this.queue.length > 0 && this._canStart(Date.now())) {
      const request2 = this.queue.shift();
      if (request2.signal?.aborted) {
        request2.abortCleanup?.();
        request2.reject(request2.signal.reason ?? new ReckerError("Request aborted while queued", void 0, void 0, ["Avoid aborting immediately after queuing.", "Increase timeouts or adjust rate limits if cancellations are unintended."]));
        continue;
      }
      this.active++;
      this.startedInWindow++;
      const clearAbort = request2.abortCleanup;
      if (clearAbort) {
        clearAbort();
        request2.abortCleanup = void 0;
      }
      Promise.resolve().then(() => request2.fn()).then((result) => request2.resolve(result)).catch((error2) => request2.reject(error2)).finally(() => {
        this.active--;
        this._schedule();
      });
    }
    if (this.queue.length > 0 && this.requestsPerInterval != null && this.interval != null && !this._canStart(Date.now())) {
      const wait = Math.max(0, this.windowStart + this.interval - Date.now());
      this.waitingTimer = setTimeout(() => {
        this.waitingTimer = void 0;
        this._schedule();
      }, wait);
    }
  }
  asMiddleware() {
    return async (req, next) => {
      return this.run(() => next(req), req.signal);
    };
  }
};
var DEFAULT_INTERVAL = 1 * 1e3;
function normalizeConcurrency(options) {
  let config;
  if (typeof options.concurrency === "number") {
    config = { max: options.concurrency };
  } else if (options.concurrency && typeof options.concurrency === "object") {
    config = options.concurrency;
  } else {
    config = {};
  }
  const max = config.max ?? Infinity;
  const requestsPerInterval = config.requestsPerInterval ?? Infinity;
  const interval = config.interval ?? DEFAULT_INTERVAL;
  const http2Options = parseHTTP2Options(options.http2);
  const http2Enabled = http2Options.enabled ?? false;
  const agentConfig = normalizeAgentConfig(config.agent, max, http2Enabled, http2Options.maxConcurrentStreams);
  const http2Streams = normalizeHTTP2Streams(config.http2?.maxConcurrentStreams, max, http2Enabled);
  let runnerConcurrency;
  if (config.runner?.concurrency !== void 0) {
    runnerConcurrency = config.runner.concurrency;
  } else if (max !== Infinity) {
    runnerConcurrency = max;
  } else {
    runnerConcurrency = Infinity;
  }
  return {
    max,
    requestsPerInterval,
    interval,
    runner: {
      concurrency: runnerConcurrency,
      retries: config.runner?.retries,
      retryDelay: config.runner?.retryDelay
    },
    agent: {
      ...agentConfig,
      connections: agentConfig.connections
    },
    http2: {
      maxConcurrentStreams: http2Streams
    }
  };
}
function parseHTTP2Options(http2) {
  if (!http2)
    return {};
  if (typeof http2 === "boolean") {
    return { enabled: http2, preset: "balanced" };
  }
  if (typeof http2 === "string") {
    return { enabled: true, preset: http2 };
  }
  return {
    ...http2,
    enabled: http2.enabled ?? true,
    preset: http2.preset ?? "balanced"
  };
}
function expandHTTP2Options(http2) {
  const parsed = parseHTTP2Options(http2);
  if (!parsed.enabled) {
    return {
      enabled: false,
      resolvedSettings: HTTP2_PRESETS.balanced
    };
  }
  const presetName = parsed.preset ?? "balanced";
  const presetSettings = HTTP2_PRESETS[presetName] ?? HTTP2_PRESETS.balanced;
  const resolvedSettings = {
    ...presetSettings,
    ...parsed.settings,
    maxConcurrentStreams: parsed.maxConcurrentStreams ?? presetSettings.maxConcurrentStreams
  };
  return {
    enabled: true,
    preset: presetName,
    maxConcurrentStreams: resolvedSettings.maxConcurrentStreams,
    pipelining: parsed.pipelining,
    settings: resolvedSettings,
    resolvedSettings
  };
}
function normalizeAgentConfig(agentConfig, maxConcurrent, http2Enabled, http2MaxStreams) {
  const defaults = {
    pipelining: 1,
    keepAlive: true,
    keepAliveTimeout: 4 * 1e3,
    keepAliveMaxTimeout: 10 * 60 * 1e3,
    keepAliveTimeoutThreshold: 1 * 1e3,
    connectTimeout: 10 * 1e3,
    perDomainPooling: true,
    maxCachedSessions: 100,
    maxRequestsPerClient: 0,
    clientTtl: null
  };
  const merged = { ...defaults, ...agentConfig };
  let connections;
  if (agentConfig?.connections === "auto" || agentConfig?.connections === void 0) {
    connections = calculateOptimalConnections(maxConcurrent, http2Enabled, http2MaxStreams, merged.pipelining ?? 1);
  } else {
    connections = agentConfig.connections;
  }
  return {
    ...merged,
    connections
  };
}
function calculateOptimalConnections(maxConcurrent, http2Enabled, http2MaxStreams, pipelining = 1) {
  if (http2Enabled) {
    const streams = http2MaxStreams ?? 100;
    return Math.max(1, Math.ceil(maxConcurrent / streams));
  } else {
    const requestsPerConnection = pipelining > 1 ? pipelining : 2;
    return Math.max(1, Math.min(Math.ceil(maxConcurrent / requestsPerConnection), 50));
  }
}
function normalizeHTTP2Streams(configuredStreams, maxConcurrent, http2Enabled) {
  if (!http2Enabled) {
    return 100;
  }
  if (configuredStreams === "auto" || configuredStreams === void 0) {
    return Math.min(Math.max(maxConcurrent, 100), 200);
  }
  return configuredStreams;
}
var VERSION$1 = "0.0.0-dev";
function getDefaultUserAgent() {
  return `recker/${VERSION$1}`;
}
var VERSION = "1.0.66";
var _version = null;
async function getVersion() {
  if (_version)
    return _version;
  {
    _version = VERSION;
    return _version;
  }
}
function getVersionSync() {
  if (_version)
    return _version;
  return VERSION;
}
async function getVersionInfo() {
  const version = await getVersion();
  return {
    version,
    name: "recker",
    nodeVersion: process.version,
    platform: process.platform,
    arch: process.arch
  };
}
async function* streamPages(client2, url, requestOptions = {}, paginationOptions = {}) {
  let currentUrl = url;
  let pageCount = 1;
  const maxPages = paginationOptions.maxPages || Infinity;
  while (currentUrl && pageCount <= maxPages) {
    const response2 = await client2.request(currentUrl, { ...requestOptions, method: "GET" });
    const data2 = await response2.json();
    yield {
      data: data2,
      response: response2,
      pageNumber: pageCount
    };
    pageCount++;
    if (paginationOptions.getNextUrl) {
      currentUrl = paginationOptions.getNextUrl(response2, data2, currentUrl);
      continue;
    }
    if (paginationOptions.nextCursorPath) {
      const parts = paginationOptions.nextCursorPath.split(".");
      let cursor2 = data2;
      for (const part of parts) {
        if (cursor2 && typeof cursor2 === "object") {
          cursor2 = cursor2[part];
        } else {
          cursor2 = void 0;
          break;
        }
      }
      if (cursor2) {
        const cursorParamName = paginationOptions.pageParam || "cursor";
        const isAbsolute = currentUrl.startsWith("http");
        const urlObj = new URL(isAbsolute ? currentUrl : `http://dummy-base${currentUrl.startsWith("/") ? "" : "/"}${currentUrl}`);
        urlObj.searchParams.set(cursorParamName, String(cursor2));
        if (isAbsolute) {
          currentUrl = urlObj.toString();
        } else {
          currentUrl = urlObj.pathname + urlObj.search;
        }
      } else {
        currentUrl = null;
      }
      continue;
    }
    if (paginationOptions.pageParam) {
      const isAbsolute = currentUrl.startsWith("http");
      const urlObj = new URL(isAbsolute ? currentUrl : `http://dummy-base${currentUrl.startsWith("/") ? "" : "/"}${currentUrl}`);
      const paramName = paginationOptions.pageParam;
      const currentVal = parseInt(urlObj.searchParams.get(paramName) || String(pageCount - 1), 10);
      let isEmpty2 = false;
      if (Array.isArray(data2) && data2.length === 0)
        isEmpty2 = true;
      if (data2 && Array.isArray(data2.data) && data2.data.length === 0)
        isEmpty2 = true;
      if (data2 && Array.isArray(data2.items) && data2.items.length === 0)
        isEmpty2 = true;
      if (isEmpty2) {
        currentUrl = null;
      } else {
        const nextPage = (isNaN(currentVal) ? 1 : currentVal) + 1;
        urlObj.searchParams.set(paramName, String(nextPage));
        currentUrl = isAbsolute ? urlObj.toString() : urlObj.pathname + urlObj.search;
      }
      continue;
    }
    const linkHeader = response2.headers.get("link");
    if (linkHeader) {
      const match = linkHeader.match(/<([^>]+)>;\s*rel="next"/);
      currentUrl = match ? match[1] : null;
    } else {
      currentUrl = null;
    }
  }
}
async function* paginate(client2, url, requestOptions = {}, paginationOptions = {}) {
  for await (const page of streamPages(client2, url, requestOptions, paginationOptions)) {
    const data2 = page.data;
    let items = [];
    if (paginationOptions.getItems) {
      items = paginationOptions.getItems(data2);
    } else if (paginationOptions.resultsPath) {
      items = paginationOptions.resultsPath.split(".").reduce((o4, i4) => o4?.[i4], data2) || [];
    } else if (Array.isArray(data2)) {
      items = data2;
    } else if (data2 && Array.isArray(data2.data)) {
      items = data2.data;
    } else if (data2 && Array.isArray(data2.items)) {
      items = data2.items;
    } else {
      items = [data2];
    }
    for (const item of items) {
      yield item;
    }
  }
}
function calculateDelay(attempt, baseDelay, maxDelay, strategy, useJitter) {
  let calculatedDelay;
  switch (strategy) {
    case "linear":
      calculatedDelay = baseDelay * attempt;
      break;
    case "exponential":
      calculatedDelay = Math.pow(2, attempt - 1) * baseDelay;
      break;
    case "decorrelated":
      const prevDelay = attempt === 1 ? baseDelay : Math.pow(2, attempt - 2) * baseDelay;
      calculatedDelay = Math.random() * (prevDelay * 3 - baseDelay) + baseDelay;
      break;
    default:
      calculatedDelay = baseDelay * attempt;
  }
  calculatedDelay = Math.min(calculatedDelay, maxDelay);
  if (useJitter) {
    const jitterRange = calculatedDelay * 0.25;
    const jitterAmount = Math.random() * jitterRange * 2 - jitterRange;
    calculatedDelay += jitterAmount;
  }
  return Math.max(0, Math.floor(calculatedDelay));
}
function parseRetryAfter$1(headerValue) {
  if (!headerValue)
    return void 0;
  const seconds = parseInt(headerValue, 10);
  if (!isNaN(seconds) && seconds >= 0) {
    return seconds * 1e3;
  }
  const date3 = Date.parse(headerValue);
  if (!isNaN(date3)) {
    const delay = date3 - Date.now();
    return delay > 0 ? delay : void 0;
  }
  return void 0;
}
function retryPlugin(options = {}) {
  const maxAttempts = options.maxAttempts || 3;
  const baseDelay = options.delay || 1e3;
  const maxDelay = options.maxDelay || 3e4;
  const backoffStrategy = options.backoff || "exponential";
  const useJitter = options.jitter !== false;
  const statusCodes = options.statusCodes || [408, 429, 500, 502, 503, 504];
  const onRetry = options.onRetry;
  const respectRetryAfter = options.respectRetryAfter !== false;
  const defaultShouldRetry = (error2) => {
    if (error2 instanceof NetworkError)
      return true;
    if (error2 instanceof TimeoutError)
      return true;
    if (error2 instanceof HttpError) {
      return statusCodes.includes(error2.status);
    }
    if (error2 && typeof error2 === "object" && "code" in error2) {
      const code = error2.code;
      return code === "ECONNRESET" || code === "ETIMEDOUT" || code === "ENOTFOUND";
    }
    return false;
  };
  const shouldRetry = options.shouldRetry || defaultShouldRetry;
  return (client2) => {
    const middleware = async (req, next) => {
      let attempt = 0;
      while (true) {
        try {
          attempt++;
          const res = await next(req);
          if (attempt < maxAttempts && !res.ok && statusCodes.includes(res.status)) {
            let delayMs;
            if (respectRetryAfter) {
              const retryAfterDelay = parseRetryAfter$1(res.headers.get("Retry-After"));
              delayMs = retryAfterDelay !== void 0 ? Math.min(retryAfterDelay, maxDelay) : calculateDelay(attempt, baseDelay, maxDelay, backoffStrategy, useJitter);
            } else {
              delayMs = calculateDelay(attempt, baseDelay, maxDelay, backoffStrategy, useJitter);
            }
            const err = new HttpError(res, req);
            if (onRetry) {
              onRetry(attempt, err, delayMs);
            }
            if (client2.hooks?.onRetry) {
              for (const hook of client2.hooks.onRetry) {
                await hook(err, attempt, delayMs, req);
              }
            }
            await new Promise((resolve) => setTimeout(resolve, delayMs));
            continue;
          }
          return res;
        } catch (error2) {
          if (attempt < maxAttempts && shouldRetry(error2)) {
            const delayMs = calculateDelay(attempt, baseDelay, maxDelay, backoffStrategy, useJitter);
            if (onRetry) {
              onRetry(attempt, error2, delayMs);
            }
            if (client2.hooks?.onRetry) {
              for (const hook of client2.hooks.onRetry) {
                await hook(error2, attempt, delayMs, req);
              }
            }
            await new Promise((resolve) => setTimeout(resolve, delayMs));
            continue;
          }
          throw error2;
        }
      }
    };
    client2.use(middleware);
  };
}
var SimpleMemoryStorage = class {
  store = /* @__PURE__ */ new Map();
  async get(key) {
    const entry = this.store.get(key);
    if (!entry)
      return null;
    if (entry.expiresAt > 0 && entry.expiresAt <= Date.now()) {
      this.store.delete(key);
      return null;
    }
    return entry.value;
  }
  async set(key, value, ttl) {
    if (!Number.isFinite(ttl) || ttl <= 0) {
      this.store.delete(key);
      return;
    }
    this.store.set(key, {
      value,
      expiresAt: Date.now() + ttl
    });
  }
  async delete(key) {
    this.store.delete(key);
  }
};
var textEncoder$1 = typeof TextEncoder !== "undefined" ? new TextEncoder() : null;
var BufferCtor$1 = globalThis.Buffer;
function isNodeRuntime$4() {
  return typeof globalThis !== "undefined" && Boolean(globalThis.process?.versions?.node);
}
var LazyCacheStorage$1 = class LazyCacheStorage {
  factory;
  storage;
  resolving;
  constructor(factory) {
    this.factory = factory;
  }
  async getStorage() {
    if (!this.storage) {
      if (!this.resolving) {
        this.resolving = this.factory().then((instance) => {
          this.storage = instance;
          return instance;
        });
      }
      this.storage = await this.resolving;
    }
    return this.storage;
  }
  async get(key) {
    return (await this.getStorage()).get(key);
  }
  async set(key, value, ttl) {
    return (await this.getStorage()).set(key, value, ttl);
  }
  async delete(key) {
    return (await this.getStorage()).delete(key);
  }
};
function createDefaultStorage() {
  if (!isNodeRuntime$4()) {
    return new SimpleMemoryStorage();
  }
  return new LazyCacheStorage$1(async () => {
    const { MemoryStorage: MemoryStorage3 } = await Promise.resolve().then(function() {
      return memoryStorage;
    });
    return new MemoryStorage3();
  });
}
function toBytes$1(value) {
  if (value === null || value === void 0)
    return null;
  if (typeof value === "string") {
    if (textEncoder$1)
      return textEncoder$1.encode(value);
    if (BufferCtor$1)
      return BufferCtor$1.from(value, "utf8");
    return null;
  }
  if (typeof URLSearchParams !== "undefined" && value instanceof URLSearchParams) {
    const encoded = value.toString();
    if (textEncoder$1)
      return textEncoder$1.encode(encoded);
    if (BufferCtor$1)
      return BufferCtor$1.from(encoded, "utf8");
    return null;
  }
  if (value instanceof ArrayBuffer) {
    return new Uint8Array(value);
  }
  if (ArrayBuffer.isView(value)) {
    return new Uint8Array(value.buffer, value.byteOffset, value.byteLength);
  }
  if (typeof Blob !== "undefined" && value instanceof Blob) {
    return null;
  }
  if (typeof value === "object") {
    try {
      const json = JSON.stringify(value);
      if (textEncoder$1)
        return textEncoder$1.encode(json);
      if (BufferCtor$1)
        return BufferCtor$1.from(json, "utf8");
      return null;
    } catch {
      return null;
    }
  }
  return null;
}
function hashBytes(bytes) {
  let hash = 0xcbf29ce484222325n;
  const prime = 0x100000001b3n;
  for (const byte of bytes) {
    hash ^= BigInt(byte);
    hash = hash * prime & 0xffffffffffffffffn;
  }
  return hash.toString(16).padStart(16, "0");
}
function isTextContentType(contentType) {
  if (!contentType)
    return true;
  const value = contentType.toLowerCase();
  if (value.startsWith("text/"))
    return true;
  if (value.includes("json") || value.includes("xml"))
    return true;
  if (value.includes("yaml") || value.includes("csv"))
    return true;
  if (value.includes("javascript") || value.includes("ecmascript"))
    return true;
  if (value.includes("x-www-form-urlencoded"))
    return true;
  if (value.includes("graphql"))
    return true;
  if (value.includes("event-stream"))
    return true;
  if (value.includes("+json") || value.includes("+xml"))
    return true;
  return false;
}
function encodeBase64(bytes) {
  if (BufferCtor$1) {
    return BufferCtor$1.from(bytes).toString("base64");
  }
  if (typeof btoa !== "undefined") {
    let binary = "";
    const chunkSize = 32768;
    for (let i4 = 0; i4 < bytes.length; i4 += chunkSize) {
      const chunk2 = bytes.subarray(i4, i4 + chunkSize);
      binary += String.fromCharCode(...chunk2);
    }
    return btoa(binary);
  }
  return null;
}
function decodeBase64(value) {
  if (BufferCtor$1) {
    return BufferCtor$1.from(value, "base64");
  }
  if (typeof atob !== "undefined") {
    const binary = atob(value);
    const bytes = new Uint8Array(binary.length);
    for (let i4 = 0; i4 < binary.length; i4++) {
      bytes[i4] = binary.charCodeAt(i4);
    }
    return bytes;
  }
  return null;
}
async function readResponseBody(response2) {
  const contentType = response2.headers.get("content-type");
  if (isTextContentType(contentType)) {
    return { body: await response2.text(), bodyEncoding: "utf8" };
  }
  const buffer = await response2.arrayBuffer();
  const bytes = new Uint8Array(buffer);
  const encoded = encodeBase64(bytes);
  if (encoded === null)
    return null;
  return { body: encoded, bodyEncoding: "base64" };
}
var CacheResponse = class _CacheResponse {
  raw;
  timings;
  constructor(raw, timings) {
    this.raw = raw;
    this.timings = timings;
  }
  get status() {
    return this.raw.status;
  }
  get statusText() {
    return this.raw.statusText;
  }
  get headers() {
    return this.raw.headers;
  }
  get ok() {
    return this.raw.ok;
  }
  get url() {
    return this.raw.url;
  }
  get connection() {
    return {};
  }
  get cache() {
    return parseHeaders(this.headers, this.status).cache;
  }
  get rateLimit() {
    return parseHeaders(this.headers, this.status).rateLimit;
  }
  links() {
    return parseLinkHeader(this.headers);
  }
  get headerInfo() {
    return parseHeaders(this.headers, this.status);
  }
  json() {
    return this.raw.json();
  }
  text() {
    return this.raw.text();
  }
  async cleanText() {
    return cleanHtml(await this.text());
  }
  blob() {
    return this.raw.blob();
  }
  read() {
    return this.raw.body;
  }
  clone() {
    return new _CacheResponse(this.raw.clone(), this.timings);
  }
  sse() {
    return parseSSE(this.raw);
  }
  async *download() {
    if (!this.raw.body)
      return;
    const reader = this.raw.body.getReader();
    let loaded = 0;
    const total = Number(this.raw.headers.get("content-length")) || void 0;
    while (true) {
      const { done, value } = await reader.read();
      if (done)
        break;
      loaded += value.length;
      yield {
        loaded,
        transferred: loaded,
        total,
        percent: total ? loaded / total * 100 : void 0,
        direction: "download"
      };
    }
  }
  async *[Symbol.asyncIterator]() {
    if (!this.raw.body)
      return;
    const reader = this.raw.body.getReader();
    while (true) {
      const { done, value } = await reader.read();
      if (done)
        break;
      yield value;
    }
  }
};
function parseRequestCacheControl(header) {
  if (!header)
    return {};
  const result = {};
  const directives = header.toLowerCase().split(",").map((d4) => d4.trim());
  for (const directive of directives) {
    if (directive.startsWith("max-age=")) {
      result.maxAge = parseInt(directive.slice(8), 10);
    } else if (directive.startsWith("min-fresh=")) {
      result.minFresh = parseInt(directive.slice(10), 10);
    } else if (directive.startsWith("max-stale")) {
      const equals = directive.indexOf("=");
      if (equals !== -1) {
        result.maxStale = parseInt(directive.slice(equals + 1), 10);
      } else {
        result.maxStale = Infinity;
      }
    } else if (directive === "only-if-cached") {
      result.onlyIfCached = true;
    } else if (directive === "no-cache") {
      result.noCache = true;
    } else if (directive === "no-store") {
      result.noStore = true;
    }
  }
  return result;
}
function parseCacheControl(header) {
  if (!header)
    return {};
  const result = {};
  const directives = header.toLowerCase().split(",").map((d4) => d4.trim());
  for (const directive of directives) {
    if (directive.startsWith("max-age=")) {
      result.maxAge = parseInt(directive.slice(8), 10);
    } else if (directive.startsWith("s-maxage=")) {
      result.sMaxAge = parseInt(directive.slice(9), 10);
    } else if (directive.startsWith("stale-while-revalidate=")) {
      result.staleWhileRevalidate = parseInt(directive.slice(23), 10);
    } else if (directive.startsWith("stale-if-error=")) {
      result.staleIfError = parseInt(directive.slice(15), 10);
    } else if (directive === "no-cache") {
      result.noCache = true;
    } else if (directive === "no-store") {
      result.noStore = true;
    } else if (directive === "must-revalidate") {
      result.mustRevalidate = true;
    } else if (directive === "private") {
      result.isPrivate = true;
    } else if (directive === "public") {
      result.isPublic = true;
    }
  }
  return result;
}
function isFresh(entry, now) {
  const age = (now - entry.timestamp) / 1e3;
  if (entry.sMaxAge !== void 0) {
    return age < entry.sMaxAge;
  }
  if (entry.maxAge !== void 0) {
    return age < entry.maxAge;
  }
  if (entry.expires !== void 0) {
    return now < entry.expires;
  }
  if (entry.lastModified) {
    const lastModifiedTime = new Date(entry.lastModified).getTime();
    if (!isNaN(lastModifiedTime)) {
      const dateTime = entry.headers["date"] ? new Date(entry.headers["date"]).getTime() : entry.timestamp;
      if (!isNaN(dateTime) && dateTime > lastModifiedTime) {
        const timeSinceModified = (dateTime - lastModifiedTime) / 1e3;
        const heuristicFreshness = timeSinceModified * 0.1;
        return age < heuristicFreshness;
      }
    }
  }
  return false;
}
function satisfiesRequestDirectives(entry, now, reqDirectives) {
  const age = (now - entry.timestamp) / 1e3;
  const responseMaxAge = entry.sMaxAge ?? entry.maxAge ?? Infinity;
  const currentFreshness = responseMaxAge - age;
  const fresh = isFresh(entry, now);
  if (reqDirectives.maxAge !== void 0 && age > reqDirectives.maxAge) {
    return { allowed: false, reason: "exceeds-request-max-age" };
  }
  if (reqDirectives.minFresh !== void 0) {
    if (!fresh || currentFreshness < reqDirectives.minFresh) {
      return { allowed: false, reason: "insufficient-freshness" };
    }
  }
  if (reqDirectives.onlyIfCached) {
    return { allowed: true };
  }
  if (!fresh && reqDirectives.maxStale === void 0) {
    return { allowed: false, reason: "stale-not-acceptable" };
  }
  if (!fresh && reqDirectives.maxStale !== void 0) {
    const staleness = age - responseMaxAge;
    if (reqDirectives.maxStale !== Infinity && staleness > reqDirectives.maxStale) {
      return { allowed: false, reason: "exceeds-max-stale" };
    }
  }
  return { allowed: true };
}
function canServeStale(entry, now) {
  if (!entry.staleWhileRevalidate)
    return false;
  const age = (now - entry.timestamp) / 1e3;
  const maxAge = entry.sMaxAge ?? entry.maxAge ?? 0;
  const staleTime = age - maxAge;
  return staleTime < entry.staleWhileRevalidate;
}
function createConditionalRequest(req, entry) {
  const conditionalHeaders = new Headers(req.headers);
  if (entry.etag) {
    conditionalHeaders.set("If-None-Match", entry.etag);
  }
  if (entry.lastModified) {
    conditionalHeaders.set("If-Modified-Since", entry.lastModified);
  }
  return new HttpRequest10(req.url, {
    method: req.method,
    headers: conditionalHeaders,
    body: req.body,
    signal: req.signal,
    throwHttpErrors: false,
    timeout: req.timeout,
    onUploadProgress: req.onUploadProgress,
    onDownloadProgress: req.onDownloadProgress,
    maxResponseSize: req.maxResponseSize
  });
}
async function storeCacheEntry(storage, baseKey, req, entry, ttl, keyGenerator) {
  if (entry.vary) {
    const varyKey = keyGenerator(req, entry.vary);
    await storage.set(varyKey, entry, ttl);
    const varyMarker = {
      ...entry,
      body: ""
    };
    await storage.set(baseKey, varyMarker, ttl);
  } else {
    await storage.set(baseKey, entry, ttl);
  }
}
async function createCacheEntry(response2, cachedBody, now) {
  const headers2 = {};
  response2.headers.forEach((v4, k4) => {
    headers2[k4] = v4;
  });
  const cacheControl = parseCacheControl(response2.headers.get("Cache-Control"));
  let expires;
  const expiresHeader = response2.headers.get("Expires");
  if (expiresHeader) {
    const expiresDate = new Date(expiresHeader);
    if (!isNaN(expiresDate.getTime())) {
      expires = expiresDate.getTime();
    }
  }
  return {
    status: response2.status,
    statusText: response2.statusText,
    headers: headers2,
    body: cachedBody.body,
    bodyEncoding: cachedBody.bodyEncoding,
    timestamp: now,
    etag: response2.headers.get("ETag") || void 0,
    lastModified: response2.headers.get("Last-Modified") || void 0,
    vary: response2.headers.get("Vary") || void 0,
    expires,
    ...cacheControl
  };
}
function createCachedResponse(entry, cacheStatus) {
  const headers2 = new Headers(entry.headers);
  headers2.set("X-Cache", cacheStatus);
  headers2.set("X-Cache-Age", String(Math.floor((Date.now() - entry.timestamp) / 1e3)));
  if (cacheStatus === "stale" || cacheStatus === "stale-error") {
    const warningCode = cacheStatus === "stale" ? 110 : 111;
    const warningText = cacheStatus === "stale" ? "Response is Stale" : "Revalidation Failed";
    const existingWarning = headers2.get("Warning");
    if (existingWarning) {
      headers2.set("Warning", `${existingWarning}, ${warningCode} - "${warningText}"`);
    } else {
      headers2.set("Warning", `${warningCode} - "${warningText}"`);
    }
  }
  const responseBody = entry.bodyEncoding === "base64" ? decodeBase64(entry.body) ?? entry.body : entry.body;
  const response2 = new Response(responseBody, {
    status: entry.status,
    statusText: entry.statusText,
    headers: headers2
  });
  return new CacheResponse(response2);
}
function cachePlugin(options = {}) {
  const storage = options.storage || createDefaultStorage();
  const strategy = options.strategy || "cache-first";
  const ttl = options.ttl || 60 * 1e3;
  const methods = options.methods || ["GET"];
  const respectCacheControl = options.respectCacheControl !== false;
  const forceRevalidate = options.forceRevalidate === true;
  const generateKey = options.keyGenerator || ((req, varyHeaders) => {
    let key = `${req.method}:${req.url}`;
    if (req.method !== "GET" && req.method !== "HEAD" && req.body) {
      try {
        const bytes = toBytes$1(req.body);
        if (bytes && bytes.length > 0) {
          key += `:${hashBytes(bytes)}`;
        }
      } catch {
      }
    }
    if (varyHeaders && options.respectVary !== false) {
      const varyHeaderNames = varyHeaders.split(",").map((h4) => h4.trim().toLowerCase());
      const varyParts = [];
      for (const headerName of varyHeaderNames) {
        if (headerName === "*") {
          return `${key}:vary-*:${Date.now()}`;
        }
        const headerValue = req.headers.get(headerName);
        if (headerValue) {
          varyParts.push(`${headerName}=${headerValue}`);
        }
      }
      if (varyParts.length > 0) {
        key += `:vary:${varyParts.join("|")}`;
      }
    }
    return key;
  });
  const cacheMiddleware = async (req, next) => {
    const unsafeMethods = [
      "POST",
      "PUT",
      "PATCH",
      "DELETE",
      "PROPPATCH",
      "MKCOL",
      "COPY",
      "MOVE",
      "LOCK",
      "UNLOCK",
      "LINK",
      "UNLINK",
      "PURGE"
    ];
    if (unsafeMethods.includes(req.method)) {
      const response2 = await next(req);
      if (response2.ok) {
        await storage.delete(`GET:${req.url}`);
        await storage.delete(`HEAD:${req.url}`);
      }
      return response2;
    }
    if (!methods.includes(req.method)) {
      return next(req);
    }
    const reqCacheControl = respectCacheControl ? parseRequestCacheControl(req.headers.get("Cache-Control")) : {};
    if (respectCacheControl && reqCacheControl.noStore) {
      return next(req);
    }
    if (respectCacheControl) {
      const reqPragma = req.headers.get("Pragma");
      if (reqPragma?.includes("no-cache")) {
        return next(req);
      }
    }
    const baseKey = generateKey(req);
    let key = baseKey;
    const now = Date.now();
    let cachedEntry;
    if (options.respectVary !== false) {
      const baseEntry = await storage.get(baseKey);
      if (baseEntry?.vary) {
        key = generateKey(req, baseEntry.vary);
        cachedEntry = await storage.get(key);
      } else if (baseEntry?.body) {
        cachedEntry = baseEntry;
      } else {
        cachedEntry = void 0;
      }
    } else {
      cachedEntry = await storage.get(key);
    }
    if (reqCacheControl.onlyIfCached) {
      if (!cachedEntry) {
        const response2 = new Response(null, {
          status: 504,
          statusText: "Gateway Timeout"
        });
        return new CacheResponse(response2);
      }
      const satisfaction = satisfiesRequestDirectives(cachedEntry, now, reqCacheControl);
      if (!satisfaction.allowed) {
        const response2 = new Response(null, {
          status: 504,
          statusText: "Gateway Timeout"
        });
        return new CacheResponse(response2);
      }
      return createCachedResponse(cachedEntry, isFresh(cachedEntry, now) ? "hit" : "stale");
    }
    const hasRequestDirectives = Object.keys(reqCacheControl).length > 0;
    if (cachedEntry && respectCacheControl && hasRequestDirectives && strategy === "network-first") {
      const satisfaction = satisfiesRequestDirectives(cachedEntry, now, reqCacheControl);
      if (!satisfaction.allowed) {
        cachedEntry = void 0;
      }
    }
    if (strategy === "network-only") {
      const response2 = await next(req);
      if (response2.ok && respectCacheControl) {
        const cacheControl = parseCacheControl(response2.headers.get("Cache-Control"));
        if (!cacheControl.noStore) {
          const clonedResponse = response2.raw.clone();
          const cachedBody = await readResponseBody(clonedResponse);
          if (!cachedBody) {
            return response2;
          }
          const entry = await createCacheEntry(response2, cachedBody, now);
          const entryTtl = (entry.sMaxAge ?? entry.maxAge ?? ttl / 1e3) * 1e3;
          await storeCacheEntry(storage, baseKey, req, entry, entryTtl, generateKey);
        }
      }
      return response2;
    }
    if (strategy === "rfc-compliant" || strategy === "revalidate") {
      if (cachedEntry) {
        const fresh = isFresh(cachedEntry, now);
        const satisfaction = satisfiesRequestDirectives(cachedEntry, now, reqCacheControl);
        const hasValidators = cachedEntry.etag || cachedEntry.lastModified;
        if (!satisfaction.allowed && !hasValidators) {
          cachedEntry = void 0;
        } else if (fresh && !forceRevalidate && !cachedEntry.noCache && !reqCacheControl.noCache) {
          return createCachedResponse(cachedEntry, "hit");
        } else if (!fresh && reqCacheControl.maxStale !== void 0 && !forceRevalidate && !reqCacheControl.noCache) {
          return createCachedResponse(cachedEntry, "stale");
        }
      }
      if (cachedEntry) {
        const conditionalReq = createConditionalRequest(req, cachedEntry);
        try {
          const response3 = await next(conditionalReq);
          if (response3.status === 304) {
            const updatedEntry = {
              ...cachedEntry,
              timestamp: now,
              etag: response3.headers.get("ETag") || cachedEntry.etag,
              lastModified: response3.headers.get("Last-Modified") || cachedEntry.lastModified
            };
            const freshnessTtl = (updatedEntry.sMaxAge ?? updatedEntry.maxAge ?? ttl / 1e3) * 1e3;
            const storageTtl = Math.max(freshnessTtl, ttl);
            await storage.set(key, updatedEntry, storageTtl);
            return createCachedResponse(updatedEntry, "revalidated");
          }
          if (response3.ok) {
            const cacheControl = parseCacheControl(response3.headers.get("Cache-Control"));
            if (!cacheControl.noStore) {
              const clonedResponse = response3.raw.clone();
              const cachedBody = await readResponseBody(clonedResponse);
              if (!cachedBody) {
                return response3;
              }
              const entry = await createCacheEntry(response3, cachedBody, now);
              const freshnessTtl = (entry.sMaxAge ?? entry.maxAge ?? ttl / 1e3) * 1e3;
              const storageTtl = Math.max(freshnessTtl, ttl);
              await storeCacheEntry(storage, baseKey, req, entry, storageTtl, generateKey);
            }
          }
          return response3;
        } catch (error2) {
          if (cachedEntry.staleIfError && canServeStale(cachedEntry, now)) {
            return createCachedResponse(cachedEntry, "stale-error");
          }
          throw error2;
        }
      }
      const response2 = await next(req);
      if (response2.ok) {
        const cacheControl = parseCacheControl(response2.headers.get("Cache-Control"));
        if (!cacheControl.noStore) {
          const clonedResponse = response2.raw.clone();
          const cachedBody = await readResponseBody(clonedResponse);
          if (!cachedBody) {
            return response2;
          }
          const entry = await createCacheEntry(response2, cachedBody, now);
          const freshnessTtl = (entry.sMaxAge ?? entry.maxAge ?? ttl / 1e3) * 1e3;
          const storageTtl = Math.max(freshnessTtl, ttl);
          await storeCacheEntry(storage, baseKey, req, entry, storageTtl, generateKey);
        }
      }
      return response2;
    }
    if (strategy === "cache-first") {
      if (cachedEntry) {
        return createCachedResponse(cachedEntry, "hit");
      }
      const response2 = await next(req);
      if (response2.ok) {
        const clonedResponse = response2.raw.clone();
        const cachedBody = await readResponseBody(clonedResponse);
        if (!cachedBody) {
          return response2;
        }
        const entry = await createCacheEntry(response2, cachedBody, now);
        await storeCacheEntry(storage, baseKey, req, entry, ttl, generateKey);
      }
      return response2;
    }
    if (strategy === "stale-while-revalidate") {
      if (cachedEntry) {
        const cachedResponse = createCachedResponse(cachedEntry, "stale");
        (async () => {
          try {
            const conditionalReq = createConditionalRequest(req, cachedEntry);
            const freshResponse = await next(conditionalReq);
            if (freshResponse.status === 304) {
              const updatedEntry = {
                ...cachedEntry,
                timestamp: Date.now()
              };
              await storage.set(key, updatedEntry, ttl);
            } else if (freshResponse.ok) {
              const clonedResponse = freshResponse.raw.clone();
              const cachedBody = await readResponseBody(clonedResponse);
              if (!cachedBody) {
                return;
              }
              const entry = await createCacheEntry(freshResponse, cachedBody, Date.now());
              const freshnessTtl = (entry.sMaxAge ?? entry.maxAge ?? ttl / 1e3) * 1e3;
              const storageTtl = Math.max(freshnessTtl, ttl);
              await storeCacheEntry(storage, baseKey, req, entry, storageTtl, generateKey);
            }
          } catch {
          }
        })();
        return cachedResponse;
      }
      const response2 = await next(req);
      if (response2.ok) {
        const clonedResponse = response2.raw.clone();
        const cachedBody = await readResponseBody(clonedResponse);
        if (!cachedBody) {
          return response2;
        }
        const entry = await createCacheEntry(response2, cachedBody, now);
        await storeCacheEntry(storage, baseKey, req, entry, ttl, generateKey);
      }
      return response2;
    }
    if (strategy === "network-first") {
      try {
        const response2 = await next(req);
        if (response2.ok) {
          const clonedResponse = response2.raw.clone();
          const cachedBody = await readResponseBody(clonedResponse);
          if (!cachedBody) {
            return response2;
          }
          const entry = await createCacheEntry(response2, cachedBody, now);
          const freshnessTtl = (entry.sMaxAge ?? entry.maxAge ?? ttl / 1e3) * 1e3;
          const storageTtl = Math.max(freshnessTtl, ttl);
          await storeCacheEntry(storage, baseKey, req, entry, storageTtl, generateKey);
        }
        return response2;
      } catch (error2) {
        if (cachedEntry) {
          return createCachedResponse(cachedEntry, "stale-error");
        }
        throw error2;
      }
    }
    return next(req);
  };
  return (client2) => {
    client2.use(cacheMiddleware);
  };
}
function dedupPlugin(options = {}) {
  const pendingRequests = /* @__PURE__ */ new Map();
  const generateKey = options.keyGenerator || ((req) => {
    return req.method + ":" + req.url;
  });
  const dedupMiddleware = async (req, next) => {
    if (req.method !== "GET" && req.method !== "HEAD") {
      return next(req);
    }
    const key = generateKey(req);
    if (pendingRequests.has(key)) {
      const response2 = await pendingRequests.get(key);
      return response2.clone();
    }
    const promise2 = next(req).then((res) => {
      return res;
    }).finally(() => {
      pendingRequests.delete(key);
    });
    pendingRequests.set(key, promise2);
    try {
      const response2 = await promise2;
      return response2.clone ? response2.clone() : response2;
    } catch (err) {
      throw err;
    }
  };
  return (client2) => {
    client2.use(dedupMiddleware);
  };
}
function parseCookies(cookieString) {
  const cookies2 = {};
  if (!cookieString) {
    return cookies2;
  }
  const pairs = cookieString.split(";");
  for (const pair of pairs) {
    const [key, ...valueParts] = pair.split("=");
    const trimmedKey = key?.trim();
    const value = valueParts.join("=").trim();
    if (trimmedKey) {
      cookies2[trimmedKey] = decodeURIComponent(value || "");
    }
  }
  return cookies2;
}
function getXSRFToken(cookieName, cookies2) {
  if (cookies2) {
    const parsed = parseCookies(cookies2);
    return parsed[cookieName] || null;
  }
  if (typeof document !== "undefined" && document.cookie) {
    const parsed = parseCookies(document.cookie);
    return parsed[cookieName] || null;
  }
  return null;
}
function xsrfPlugin(options = {}) {
  const { cookieName = "XSRF-TOKEN", headerName = "X-XSRF-TOKEN", token: manualToken, cookies: cookies2 } = options;
  return async (req, next) => {
    const token = manualToken || getXSRFToken(cookieName, cookies2);
    if (token) {
      if (!req.headers.has(headerName)) {
        req.headers.set(headerName, token);
      }
    }
    return next(req);
  };
}
function createXSRFMiddleware(config) {
  if (!config) {
    return null;
  }
  if (config === true) {
    return xsrfPlugin();
  }
  return xsrfPlugin(config);
}
var textEncoder = typeof TextEncoder !== "undefined" ? new TextEncoder() : null;
var BufferCtor = globalThis.Buffer;
function isNodeRuntime$3() {
  return typeof globalThis !== "undefined" && Boolean(globalThis.process?.versions?.node);
}
var nodeCompressorsPromise = null;
async function loadNodeCompressors() {
  if (!nodeCompressorsPromise) {
    nodeCompressorsPromise = (async () => {
      const zlibModuleName = "node:zlib";
      const utilModuleName = "node:util";
      const zlibModule = await import(zlibModuleName);
      const utilModule = await import(utilModuleName);
      const gzipAsync = utilModule.promisify(zlibModule.gzip);
      const deflateAsync = utilModule.promisify(zlibModule.deflate);
      const brotliAsync = utilModule.promisify(zlibModule.brotliCompress);
      return {
        gzip: async (input) => gzipAsync(BufferCtor ? BufferCtor.from(input) : input),
        deflate: async (input) => deflateAsync(BufferCtor ? BufferCtor.from(input) : input),
        brotli: async (input) => brotliAsync(BufferCtor ? BufferCtor.from(input) : input)
      };
    })();
  }
  return nodeCompressorsPromise;
}
function isCompressible(contentType) {
  if (!contentType)
    return true;
  const compressibleTypes = [
    "text/",
    "application/json",
    "application/xml",
    "application/javascript",
    "application/x-www-form-urlencoded"
  ];
  return compressibleTypes.some((type) => contentType.includes(type));
}
function getBodySize(body2) {
  if (!body2)
    return 0;
  if (typeof body2 === "string") {
    if (textEncoder)
      return textEncoder.encode(body2).length;
    if (BufferCtor)
      return BufferCtor.from(body2, "utf8").length;
    return body2.length;
  }
  if (body2 instanceof ArrayBuffer) {
    return body2.byteLength;
  }
  if (ArrayBuffer.isView(body2)) {
    return body2.byteLength;
  }
  if (typeof Blob !== "undefined" && body2 instanceof Blob) {
    return body2.size;
  }
  if (typeof body2 === "object") {
    try {
      const json = JSON.stringify(body2);
      if (textEncoder)
        return textEncoder.encode(json).length;
      if (BufferCtor)
        return BufferCtor.from(json, "utf8").length;
      return json.length;
    } catch {
      return 0;
    }
  }
  return 0;
}
function toBytes(body2) {
  if (!body2)
    return null;
  if (typeof body2 === "string") {
    if (textEncoder)
      return textEncoder.encode(body2);
    if (BufferCtor)
      return BufferCtor.from(body2, "utf8");
    return null;
  }
  if (typeof URLSearchParams !== "undefined" && body2 instanceof URLSearchParams) {
    const encoded = body2.toString();
    if (textEncoder)
      return textEncoder.encode(encoded);
    if (BufferCtor)
      return BufferCtor.from(encoded, "utf8");
    return null;
  }
  if (body2 instanceof ArrayBuffer) {
    return new Uint8Array(body2);
  }
  if (ArrayBuffer.isView(body2)) {
    return new Uint8Array(body2.buffer, body2.byteOffset, body2.byteLength);
  }
  if (typeof Blob !== "undefined" && body2 instanceof Blob) {
    return null;
  }
  if (typeof body2 === "object") {
    try {
      const json = JSON.stringify(body2);
      if (textEncoder)
        return textEncoder.encode(json);
      if (BufferCtor)
        return BufferCtor.from(json, "utf8");
      return null;
    } catch {
      return null;
    }
  }
  return null;
}
async function compress(data2, algorithm) {
  if (isNodeRuntime$3()) {
    const compressors = await loadNodeCompressors();
    switch (algorithm) {
      case "gzip":
        return compressors.gzip(data2);
      case "deflate":
        return compressors.deflate(data2);
      case "br":
        return compressors.brotli(data2);
    }
  }
  if (typeof CompressionStream !== "undefined") {
    if (algorithm === "br") {
      throw new UnsupportedError("Brotli compression is not available in browser environments.", { feature: algorithm });
    }
    const stream = new CompressionStream(algorithm);
    const writer = stream.writable.getWriter();
    const payload2 = data2.buffer instanceof ArrayBuffer ? data2 : new Uint8Array(data2);
    await writer.write(payload2);
    await writer.close();
    const buffer = await new Response(stream.readable).arrayBuffer();
    return new Uint8Array(buffer);
  }
  throw new UnsupportedError(`Unsupported compression algorithm: ${algorithm}`, {
    feature: algorithm
  });
}
function compression(options = {}) {
  const { algorithm = "gzip", threshold = 1024, force = false, methods = ["POST", "PUT", "PATCH"] } = options;
  return async (req, next) => {
    const shouldCompress = methods.includes(req.method);
    if (!shouldCompress || !req.body) {
      return next(req);
    }
    if (req.headers.has("Content-Encoding")) {
      return next(req);
    }
    const contentType = req.headers.get("Content-Type");
    if (!isCompressible(contentType)) {
      return next(req);
    }
    const bodySize = getBodySize(req.body);
    if (!force && bodySize < threshold) {
      return next(req);
    }
    const bytes = toBytes(req.body);
    if (!bytes) {
      return next(req);
    }
    try {
      const compressed = await compress(bytes, algorithm);
      if (!force && compressed.length >= bytes.length) {
        return next(req);
      }
      const newHeaders = new Headers(req.headers);
      newHeaders.set("Content-Encoding", algorithm);
      newHeaders.set("Content-Length", compressed.length.toString());
      const compressedReq = {
        ...req,
        body: compressed,
        headers: newHeaders
      };
      return next(compressedReq);
    } catch {
      return next(req);
    }
  };
}
function createCompressionMiddleware(config) {
  if (!config) {
    return null;
  }
  if (config === true) {
    return compression();
  }
  return compression(config);
}
function serializeXML(obj, rootName) {
  if (obj === null || obj === void 0) {
    return rootName ? `<${rootName}/>` : "";
  }
  if (typeof obj !== "object") {
    return rootName ? `<${rootName}>${encodeXMLEntities(String(obj))}</${rootName}>` : encodeXMLEntities(String(obj));
  }
  const keys2 = Object.keys(obj);
  if (keys2.length === 1 && !rootName) {
    const key = keys2[0];
    return serializeXML(obj[key], key);
  }
  let xml = "";
  let attributes = "";
  let textContent2 = "";
  for (const key of keys2) {
    const value = obj[key];
    if (key === "@attributes") {
      for (const [attrName, attrValue] of Object.entries(value)) {
        attributes += ` ${attrName}="${encodeXMLEntities(String(attrValue))}"`;
      }
    } else if (key === "#text") {
      textContent2 = encodeXMLEntities(String(value));
    } else if (Array.isArray(value)) {
      for (const item of value) {
        xml += serializeXML(item, key);
      }
    } else {
      xml += serializeXML(value, key);
    }
  }
  if (rootName) {
    if (xml || textContent2) {
      return `<${rootName}${attributes}>${textContent2}${xml}</${rootName}>`;
    }
    return `<${rootName}${attributes}/>`;
  }
  return xml;
}
function encodeXMLEntities(str) {
  return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}
var SimpleEmitter$1 = class SimpleEmitter {
  listeners = /* @__PURE__ */ new Map();
  on(event, listener) {
    const set2 = this.listeners.get(event) ?? /* @__PURE__ */ new Set();
    set2.add(listener);
    this.listeners.set(event, set2);
    return this;
  }
  once(event, listener) {
    const wrapped = (...args) => {
      this.off(event, wrapped);
      listener(...args);
    };
    return this.on(event, wrapped);
  }
  off(event, listener) {
    const set2 = this.listeners.get(event);
    if (set2) {
      set2.delete(listener);
      if (set2.size === 0) {
        this.listeners.delete(event);
      }
    }
    return this;
  }
  removeListener(event, listener) {
    return this.off(event, listener);
  }
  emit(event, ...args) {
    const set2 = this.listeners.get(event);
    if (!set2)
      return false;
    for (const listener of [...set2]) {
      listener(...args);
    }
    return true;
  }
};
var RequestRunner = class extends SimpleEmitter$1 {
  concurrency;
  retries;
  retryDelay;
  queue = [];
  activeCount = 0;
  paused = false;
  results = /* @__PURE__ */ new Map();
  stats = { total: 0, successful: 0, failed: 0 };
  startTime = 0;
  pendingRetries = 0;
  constructor(options = {}) {
    super();
    this.concurrency = options.concurrency || 5;
    this.retries = options.retries ?? 0;
    this.retryDelay = options.retryDelay ?? 0;
  }
  add(fn, options = {}) {
    this.queueTask({
      id: options.id || Math.random().toString(36).slice(2),
      fn,
      priority: options.priority || 0,
      retries: options.retries ?? this.retries,
      resolve: options.resolve
    });
    if (options.trackTotal !== false) {
      this.stats.total++;
    }
    this.processNext();
  }
  async run(items, processor, options = {}) {
    this.startTime = Date.now();
    this.stats = { total: items.length, successful: 0, failed: 0 };
    this.results.clear();
    const promises2 = items.map((item, index) => {
      return new Promise((resolve) => {
        this.add(() => processor(item, index), {
          priority: options.priority,
          id: String(index),
          retries: options.retries,
          resolve,
          trackTotal: false
        });
      });
    });
    const results = await Promise.all(promises2);
    return {
      results,
      stats: {
        ...this.stats,
        duration: Date.now() - this.startTime
      }
    };
  }
  queueTask(task) {
    this.queue.push(task);
    this.queue.sort((a4, b4) => b4.priority - a4.priority);
  }
  scheduleRetry(task, delay) {
    this.pendingRetries++;
    if (delay > 0) {
      setTimeout(() => {
        this.pendingRetries--;
        this.queueTask(task);
        this.processNext();
      }, delay);
      return;
    }
    this.pendingRetries--;
    this.queueTask(task);
    this.processNext();
  }
  async processNext() {
    if (this.paused || this.activeCount >= this.concurrency || this.queue.length === 0) {
      return;
    }
    const task = this.queue.shift();
    if (!task)
      return;
    this.activeCount++;
    this.emit("taskStart", task);
    try {
      const result = await task.fn();
      this.stats.successful++;
      task.resolve?.(result);
      this.emit("taskComplete", { task, result });
    } catch (error2) {
      const remaining = task.retries ?? 0;
      if (remaining > 0) {
        task.retries = remaining - 1;
        this.emit("taskRetry", { task, error: error2, remaining: task.retries, delay: this.retryDelay });
        this.scheduleRetry(task, this.retryDelay);
      } else {
        this.stats.failed++;
        task.resolve?.(error2);
        this.emit("taskError", { task, error: error2 });
      }
    } finally {
      this.activeCount--;
      this.emit("progress", this.getProgress());
      if (this.activeCount === 0 && this.queue.length === 0 && this.pendingRetries === 0) {
        this.emit("drained");
      }
      this.processNext();
    }
  }
  getProgress() {
    const completed = this.stats.successful + this.stats.failed;
    return {
      total: this.stats.total,
      completed,
      pending: this.queue.length,
      active: this.activeCount,
      percent: this.stats.total > 0 ? completed / this.stats.total * 100 : 0
    };
  }
};
var SimpleEmitter2 = class {
  listeners = /* @__PURE__ */ new Map();
  on(event, listener) {
    const set2 = this.listeners.get(event) ?? /* @__PURE__ */ new Set();
    set2.add(listener);
    this.listeners.set(event, set2);
    return this;
  }
  once(event, listener) {
    const wrapped = (...args) => {
      this.off(event, wrapped);
      listener(...args);
    };
    return this.on(event, wrapped);
  }
  off(event, listener) {
    const set2 = this.listeners.get(event);
    if (set2) {
      set2.delete(listener);
      if (set2.size === 0) {
        this.listeners.delete(event);
      }
    }
    return this;
  }
  removeListener(event, listener) {
    return this.off(event, listener);
  }
  emit(event, ...args) {
    const set2 = this.listeners.get(event);
    if (!set2)
      return false;
    for (const listener of [...set2]) {
      listener(...args);
    }
    return true;
  }
};
var READY_STATE = {
  OPEN: 1,
  CLOSED: 3
};
function isNodeRuntime$2() {
  return typeof globalThis !== "undefined" && Boolean(globalThis.process?.versions?.node);
}
var undiciModulePromise = null;
async function loadUndici() {
  if (!undiciModulePromise) {
    const moduleName = "undici";
    undiciModulePromise = import(moduleName);
  }
  return undiciModulePromise;
}
async function getWebSocketConstructor() {
  if (isNodeRuntime$2()) {
    const undici2 = await loadUndici();
    return undici2.WebSocket;
  }
  const ws = globalThis.WebSocket;
  if (!ws) {
    throw new UnsupportedError("WebSocket is not available in this environment.", { feature: "websocket" });
  }
  return ws;
}
function isReadableStream(value) {
  return Boolean(value && typeof value.getReader === "function");
}
var ReckerWebSocket = class extends SimpleEmitter2 {
  ws = null;
  url;
  options;
  reconnectAttempts = 0;
  reconnectTimer;
  heartbeatTimer;
  isClosed = false;
  isReconnecting = false;
  pongWatchdog;
  backoff;
  closedByUser = false;
  constructor(url, options = {}) {
    super();
    this.url = url;
    this.options = {
      protocols: options.protocols || [],
      headers: options.headers || {},
      reconnect: options.reconnect ?? false,
      reconnectDelay: options.reconnectDelay ?? 1e3,
      maxReconnectAttempts: options.maxReconnectAttempts ?? 5,
      heartbeatInterval: options.heartbeatInterval ?? 3e4,
      heartbeatTimeout: options.heartbeatTimeout ?? 1e4,
      dispatcher: options.dispatcher,
      proxy: options.proxy,
      tls: options.tls,
      perMessageDeflate: options.perMessageDeflate ?? false
    };
    this.backoff = {
      base: this.options.reconnectDelay,
      factor: 2,
      jitter: true,
      max: 3e4
    };
  }
  async connect() {
    const WebSocketCtor = await getWebSocketConstructor();
    const nodeEnv = isNodeRuntime$2();
    const wsOptions = nodeEnv ? {
      headers: this.options.headers,
      dispatcher: this.options.dispatcher,
      perMessageDeflate: this.options.perMessageDeflate
    } : void 0;
    if (nodeEnv && this.options.proxy) {
      const proxyConfig = typeof this.options.proxy === "string" ? { url: this.options.proxy } : this.options.proxy;
      const undici2 = await loadUndici();
      wsOptions.dispatcher = new undici2.ProxyAgent(proxyConfig.url);
    }
    if (nodeEnv && this.options.tls) {
      wsOptions.tls = this.options.tls;
    }
    return new Promise((resolve, reject) => {
      try {
        this.ws = nodeEnv ? new WebSocketCtor(this.url, this.options.protocols, wsOptions) : new WebSocketCtor(this.url, this.options.protocols);
        this.ws.addEventListener("open", () => {
          this.reconnectAttempts = 0;
          this.isReconnecting = false;
          this.startHeartbeat();
          this.emit("open");
          resolve();
        });
        this.ws.addEventListener("message", (event) => {
          const data2 = event.data;
          const message = {
            data: data2,
            isBinary: typeof data2 !== "string"
          };
          this.emit("message", message);
          this.stopPongWatchdog();
        });
        this.ws.addEventListener("close", (event) => {
          this.stopHeartbeat();
          this.stopPongWatchdog();
          this.emit("close", event.code, event.reason);
          if (!this.closedByUser && !this.isClosed && this.options.reconnect) {
            this.attemptReconnect();
          }
        });
        this.ws.addEventListener("error", (event) => {
          const err = event?.error instanceof Error ? event.error : new ConnectionError("WebSocket connection error", {
            host: this.url,
            retriable: true
          });
          this.emit("error", err);
          reject(err);
        });
      } catch (error2) {
        reject(error2);
      }
    });
  }
  async send(data2, options) {
    if (!this.ws || this.ws.readyState !== READY_STATE.OPEN) {
      throw new StateError("WebSocket is not connected", {
        expectedState: "open",
        actualState: this.ws ? "closed" : "not-created"
      });
    }
    const awaitDrain = options?.awaitDrain ?? false;
    const highWaterMark = options?.highWaterMark ?? 16 * 1024;
    this.ws.send(data2);
    if (awaitDrain) {
      await this.waitForDrain(highWaterMark);
    }
  }
  async sendStream(stream, options) {
    if (isReadableStream(stream)) {
      const reader = stream.getReader();
      while (true) {
        const { done, value } = await reader.read();
        if (done)
          break;
        await this.send(value, options);
      }
      return;
    }
    for await (const chunk2 of stream) {
      await this.send(chunk2, options);
    }
  }
  sendJSON(data2) {
    void this.send(JSON.stringify(data2));
  }
  close(code = 1e3, reason = "") {
    this.isClosed = true;
    this.closedByUser = true;
    this.stopHeartbeat();
    this.clearReconnectTimer();
    if (this.ws) {
      this.ws.close(code, reason);
      this.ws = null;
    }
  }
  ping() {
    if (!this.ws || this.ws.readyState !== READY_STATE.OPEN)
      return;
    const anyWs = this.ws;
    if (typeof anyWs.ping === "function") {
      try {
        anyWs.ping();
        return;
      } catch {
      }
    }
    try {
      this.ws.send("__heartbeat__");
    } catch {
    }
  }
  get readyState() {
    return this.ws?.readyState ?? READY_STATE.CLOSED;
  }
  get isConnected() {
    return this.ws?.readyState === READY_STATE.OPEN;
  }
  toReadable() {
    if (!this.ws)
      return null;
    const wsAny = this.ws;
    if (wsAny.readable && typeof wsAny.readable.getReader === "function") {
      return wsAny.readable;
    }
    return null;
  }
  async pipeFrom(source, options) {
    await this.sendStream(source, options);
  }
  async pipeTo(destination) {
    const readable2 = this.toReadable();
    if (!readable2) {
      throw new StreamError$1("WebSocket has no readable stream", {
        streamType: "websocket",
        retriable: false
      });
    }
    if (destination && typeof destination.getWriter === "function") {
      await readable2.pipeTo(destination);
      return;
    }
    if (isNodeRuntime$2()) {
      const streamModuleName = "node:stream";
      const pipelineModuleName = "node:stream/promises";
      const streamModule = await import(streamModuleName);
      const pipelineModule = await import(pipelineModuleName);
      const nodeReadable = typeof streamModule.Readable?.fromWeb === "function" ? streamModule.Readable.fromWeb(readable2) : streamModule.Readable.from(readable2);
      await pipelineModule.pipeline(nodeReadable, destination);
      return;
    }
    throw new StreamError$1("Destination stream is not supported in this environment", {
      streamType: "websocket",
      retriable: false
    });
  }
  async *[Symbol.asyncIterator]() {
    const queue = [];
    let resolveNext = null;
    let closed = false;
    const messageHandler = (msg) => {
      if (resolveNext) {
        resolveNext(msg);
        resolveNext = null;
      } else {
        queue.push(msg);
      }
    };
    const closeHandler = () => {
      closed = true;
      if (resolveNext) {
        resolveNext(null);
        resolveNext = null;
      }
    };
    this.on("message", messageHandler);
    this.on("close", closeHandler);
    try {
      while (true) {
        if (queue.length > 0) {
          yield queue.shift();
        } else {
          if (closed)
            break;
          const msg = await new Promise((resolve) => {
            resolveNext = resolve;
          });
          if (msg) {
            yield msg;
          } else {
            break;
          }
        }
      }
    } finally {
      this.off("message", messageHandler);
      this.off("close", closeHandler);
    }
  }
  attemptReconnect() {
    if (this.isReconnecting)
      return;
    if (this.options.maxReconnectAttempts > 0 && this.reconnectAttempts >= this.options.maxReconnectAttempts) {
      this.emit("max-reconnect-attempts");
      return;
    }
    this.isReconnecting = true;
    this.reconnectAttempts++;
    const baseDelay = this.backoff.base * Math.pow(this.backoff.factor, this.reconnectAttempts - 1);
    const capped = this.backoff.max ? Math.min(baseDelay, this.backoff.max) : baseDelay;
    const jittered = this.backoff.jitter ? randomJitter(capped) : capped;
    this.emit("reconnecting", this.reconnectAttempts, jittered);
    this.reconnectTimer = setTimeout(() => {
      this.connect().catch((error2) => {
        this.emit("reconnect-error", error2);
      });
    }, jittered);
  }
  clearReconnectTimer() {
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = void 0;
    }
  }
  startHeartbeat() {
    if (this.options.heartbeatInterval <= 0)
      return;
    this.heartbeatTimer = setInterval(() => {
      if (this.isConnected) {
        this.ping();
        this.startPongWatchdog();
      }
    }, this.options.heartbeatInterval);
  }
  stopHeartbeat() {
    if (this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer);
      this.heartbeatTimer = void 0;
    }
    this.stopPongWatchdog();
  }
  startPongWatchdog() {
    this.stopPongWatchdog();
    if (this.options.heartbeatTimeout <= 0)
      return;
    this.pongWatchdog = setTimeout(() => {
      this.emit("heartbeat-timeout");
      if (!this.closedByUser && this.options.reconnect) {
        this.ws?.close(4e3, "heartbeat timeout");
      }
    }, this.options.heartbeatTimeout);
  }
  stopPongWatchdog() {
    if (this.pongWatchdog) {
      clearTimeout(this.pongWatchdog);
      this.pongWatchdog = void 0;
    }
  }
  getBufferedAmount() {
    return this.ws?.bufferedAmount ?? 0;
  }
  async waitForDrain(highWaterMark) {
    const buffered = this.getBufferedAmount();
    if (buffered <= highWaterMark)
      return;
    await new Promise((resolve) => {
      const check = () => {
        if (this.getBufferedAmount() <= highWaterMark || !this.isConnected) {
          resolve();
        } else {
          setTimeout(check, 10);
        }
      };
      setTimeout(check, 10);
    });
  }
};
function randomJitter(value) {
  const jitter = 0.2 * value;
  return value - jitter + Math.random() * (2 * jitter);
}
function isNodeRuntime$1() {
  return typeof globalThis !== "undefined" && Boolean(globalThis.process?.versions?.node);
}
var netModulePromise = null;
async function getNetModule() {
  if (!isNodeRuntime$1()) {
    throw new UnsupportedError("WHOIS is only available in Node.js environments.", { feature: "whois" });
  }
  if (!netModulePromise) {
    const moduleName = "node:net";
    netModulePromise = import(moduleName);
  }
  return netModulePromise;
}
var DEFAULT_SERVERS = {
  "com": "whois.verisign-grs.com",
  "net": "whois.verisign-grs.com",
  "org": "whois.pir.org",
  "info": "whois.afilias.net",
  "biz": "whois.biz",
  "us": "whois.nic.us",
  "uk": "whois.nic.uk",
  "ca": "whois.cira.ca",
  "de": "whois.denic.de",
  "fr": "whois.afnic.fr",
  "au": "whois.aunic.net",
  "jp": "whois.jprs.jp",
  "cn": "whois.cnnic.cn",
  "ru": "whois.tcinet.ru",
  "br": "whois.registro.br",
  "eu": "whois.eu",
  "io": "whois.nic.io",
  "co": "whois.nic.co",
  "me": "whois.nic.me",
  "tv": "whois.nic.tv",
  "cc": "whois.nic.cc",
  "ws": "whois.website.ws",
  "mobi": "whois.dotmobiregistry.net",
  "asia": "whois.nic.asia",
  "tel": "whois.nic.tel",
  "pro": "whois.registrypro.pro",
  "aero": "whois.aero",
  "cat": "whois.cat",
  "coop": "whois.nic.coop",
  "jobs": "whois.nic.jobs",
  "museum": "whois.museum",
  "travel": "whois.nic.travel",
  "xxx": "whois.nic.xxx",
  "app": "whois.nic.google",
  "dev": "whois.nic.google",
  "ai": "whois.nic.ai"
};
function extractTLD(domain) {
  const parts = domain.toLowerCase().split(".");
  return parts[parts.length - 1];
}
function getWhoisServer(query, customServer) {
  if (customServer) {
    return customServer;
  }
  const ipv4Pattern = /^(\d{1,3}\.){3}\d{1,3}$/;
  const ipv6Pattern = /^([0-9a-fA-F]{0,4}:){2,7}[0-9a-fA-F]{0,4}$/;
  if (ipv4Pattern.test(query) || ipv6Pattern.test(query)) {
    return "whois.arin.net";
  }
  const tld = extractTLD(query);
  return DEFAULT_SERVERS[tld] || "whois.iana.org";
}
function parseWhoisData(raw) {
  const data2 = {};
  const lines = raw.split("\n");
  for (const line of lines) {
    if (line.startsWith("%") || line.startsWith("#") || !line.trim()) {
      continue;
    }
    const colonIndex = line.indexOf(":");
    if (colonIndex === -1) {
      continue;
    }
    const key = line.substring(0, colonIndex).trim().toLowerCase();
    const value = line.substring(colonIndex + 1).trim();
    if (!key || !value) {
      continue;
    }
    if (data2[key]) {
      if (Array.isArray(data2[key])) {
        data2[key].push(value);
      } else {
        data2[key] = [data2[key], value];
      }
    } else {
      data2[key] = value;
    }
  }
  return data2;
}
function extractReferralServer(raw) {
  const lines = raw.toLowerCase().split("\n");
  for (const line of lines) {
    if (line.includes("whois server:") || line.includes("referral url:")) {
      const match = line.match(/whois\.[\w.-]+/);
      if (match) {
        return match[0];
      }
    }
  }
  return null;
}
async function queryWhoisServer(server, query, port, timeout) {
  const { createConnection } = await getNetModule();
  return new Promise((resolve, reject) => {
    let response2 = "";
    let socket = null;
    const timeoutId = setTimeout(() => {
      socket?.destroy();
      reject(new ReckerError(`WHOIS query timed out after ${timeout}ms`, void 0, void 0, [
        "Increase the WHOIS timeout for slower registries.",
        "Check network connectivity to the WHOIS server.",
        "Retry the query; some registries respond slowly under load."
      ]));
    }, timeout);
    socket = createConnection({ host: server, port }, () => {
      socket.write(query + "\r\n");
    });
    socket.on("data", (chunk2) => {
      response2 += chunk2.toString("utf-8");
    });
    socket.on("end", () => {
      clearTimeout(timeoutId);
      resolve(response2);
    });
    socket.on("error", (error2) => {
      clearTimeout(timeoutId);
      const errorDetail = error2?.message || error2?.code || "Connection failed";
      const err = new ReckerError(`WHOIS query failed: ${errorDetail}`, void 0, void 0, [
        "Verify the WHOIS server is reachable and correct.",
        "Check network/firewall settings blocking WHOIS port 43.",
        "Retry the query; transient network issues can occur."
      ]);
      err.code = error2?.code;
      reject(err);
    });
    socket.on("close", (hadError) => {
      clearTimeout(timeoutId);
      if (hadError && !response2) {
        const err = new ReckerError("WHOIS connection closed unexpectedly", void 0, void 0, [
          "The WHOIS server may be rate limiting requests.",
          "Try again in a few seconds.",
          "Some TLDs have unreliable WHOIS servers."
        ]);
        err.code = "ECONNRESET";
        reject(err);
      }
    });
  });
}
async function whois(query, options = {}) {
  const { server: customServer, port = 43, timeout = 1e4, follow = true } = options;
  const cleanQuery = query.trim().toLowerCase();
  let server = getWhoisServer(cleanQuery, customServer);
  let raw = await queryWhoisServer(server, cleanQuery, port, timeout);
  if (follow && !customServer) {
    const referralServer = extractReferralServer(raw);
    if (referralServer && referralServer !== server) {
      server = referralServer;
      raw = await queryWhoisServer(server, cleanQuery, port, timeout);
    }
  }
  const data2 = parseWhoisData(raw);
  return {
    raw,
    query: cleanQuery,
    server,
    data: data2
  };
}
async function isDomainAvailable(domain, options) {
  try {
    const result = await whois(domain, options);
    const rawLower = result.raw.toLowerCase();
    const notFoundIndicators = [
      "no match",
      "not found",
      "no entries found",
      "no data found",
      "status: available",
      "status: free"
    ];
    return notFoundIndicators.some((indicator) => rawLower.includes(indicator));
  } catch (error2) {
    return false;
  }
}
var domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
var pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
var MemoryCookieJar = class {
  cookies = /* @__PURE__ */ new Map();
  getCookieString(url) {
    const parsedUrl = new URL(url);
    const hostname = parsedUrl.hostname;
    const pathname = parsedUrl.pathname || "/";
    const isSecure = parsedUrl.protocol === "https:";
    const now = Date.now();
    const matchingCookies = [];
    for (const [domain, pathMap] of this.cookies.entries()) {
      if (!this.domainMatches(hostname, domain))
        continue;
      for (const [path3, nameMap] of pathMap.entries()) {
        if (!this.pathMatches(pathname, path3))
          continue;
        for (const cookie of nameMap.values()) {
          if (this.isExpired(cookie, now)) {
            nameMap.delete(cookie.name);
            continue;
          }
          if (cookie.secure && !isSecure)
            continue;
          matchingCookies.push(cookie);
        }
      }
    }
    matchingCookies.sort((a4, b4) => {
      const pathDiff = b4.path.length - a4.path.length;
      if (pathDiff !== 0)
        return pathDiff;
      return a4.createdAt - b4.createdAt;
    });
    return matchingCookies.map((c4) => `${c4.name}=${c4.value}`).join("; ");
  }
  setCookie(rawCookie, url) {
    const parsedUrl = new URL(url);
    const hostname = parsedUrl.hostname;
    const pathname = parsedUrl.pathname || "/";
    const cookie = this.parseCookie(rawCookie, hostname, pathname);
    if (!cookie)
      return;
    if (!this.domainMatches(hostname, cookie.domain)) {
      return;
    }
    if (!this.cookies.has(cookie.domain)) {
      this.cookies.set(cookie.domain, /* @__PURE__ */ new Map());
    }
    const domainMap = this.cookies.get(cookie.domain);
    if (!domainMap.has(cookie.path)) {
      domainMap.set(cookie.path, /* @__PURE__ */ new Map());
    }
    const pathMap = domainMap.get(cookie.path);
    pathMap.set(cookie.name, cookie);
  }
  clear() {
    this.cookies.clear();
  }
  clearDomain(domain) {
    this.cookies.delete(domain);
  }
  getAllCookies() {
    const all = [];
    for (const domainMap of this.cookies.values()) {
      for (const pathMap of domainMap.values()) {
        for (const cookie of pathMap.values()) {
          all.push(cookie);
        }
      }
    }
    return all;
  }
  parseCookie(setCookieStr, requestDomain, requestPath) {
    const parts = setCookieStr.split(";").map((p4) => p4.trim());
    if (parts.length === 0 || !parts[0])
      return null;
    const [nameValue, ...attributes] = parts;
    const eqIndex = nameValue.indexOf("=");
    if (eqIndex === -1)
      return null;
    const name = nameValue.substring(0, eqIndex).trim();
    const rawValue = nameValue.substring(eqIndex + 1).trim();
    if (!name)
      return null;
    const value = this.decode(rawValue);
    const cookie = {
      name,
      value,
      domain: requestDomain,
      path: this.defaultPath(requestPath),
      secure: false,
      httpOnly: false,
      createdAt: Date.now()
    };
    for (const attr of attributes) {
      const lowerAttr = attr.toLowerCase();
      if (lowerAttr === "secure") {
        cookie.secure = true;
      } else if (lowerAttr === "httponly") {
        cookie.httpOnly = true;
      } else if (lowerAttr === "partitioned") {
        cookie.partitioned = true;
      } else if (lowerAttr.startsWith("domain=")) {
        let domain = attr.substring(7).trim();
        if (domain.startsWith(".")) {
          domain = domain.substring(1);
        }
        if (domainValueRegExp.test(domain)) {
          cookie.domain = domain.toLowerCase();
        }
      } else if (lowerAttr.startsWith("path=")) {
        const path3 = attr.substring(5).trim();
        if (!path3 || pathValueRegExp.test(path3)) {
          cookie.path = path3 || "/";
        }
      } else if (lowerAttr.startsWith("expires=")) {
        const expiresStr = attr.substring(8).trim();
        const expires = new Date(expiresStr);
        if (Number.isFinite(expires.valueOf())) {
          cookie.expires = expires;
        }
      } else if (lowerAttr.startsWith("max-age=")) {
        const maxAgeStr = attr.substring(8).trim();
        if (/^-?\d+$/.test(maxAgeStr)) {
          cookie.maxAge = parseInt(maxAgeStr, 10);
        }
      } else if (lowerAttr.startsWith("samesite=")) {
        const samesite = attr.substring(9).trim().toLowerCase();
        if (samesite === "strict")
          cookie.sameSite = "Strict";
        else if (samesite === "lax")
          cookie.sameSite = "Lax";
        else if (samesite === "none")
          cookie.sameSite = "None";
      } else if (lowerAttr.startsWith("priority=")) {
        const priority = attr.substring(9).trim().toLowerCase();
        if (priority === "low")
          cookie.priority = "Low";
        else if (priority === "medium")
          cookie.priority = "Medium";
        else if (priority === "high")
          cookie.priority = "High";
      }
    }
    return cookie;
  }
  decode(str) {
    if (str.indexOf("%") === -1)
      return str;
    try {
      return decodeURIComponent(str);
    } catch {
      return str;
    }
  }
  domainMatches(requestDomain, cookieDomain) {
    const reqLower = requestDomain.toLowerCase();
    const cookieLower = cookieDomain.toLowerCase();
    if (reqLower === cookieLower)
      return true;
    if (reqLower.endsWith("." + cookieLower))
      return true;
    return false;
  }
  pathMatches(requestPath, cookiePath) {
    if (requestPath === cookiePath)
      return true;
    if (requestPath.startsWith(cookiePath)) {
      if (cookiePath.endsWith("/"))
        return true;
      if (requestPath[cookiePath.length] === "/")
        return true;
    }
    return false;
  }
  defaultPath(requestPath) {
    if (!requestPath || !requestPath.startsWith("/")) {
      return "/";
    }
    const lastSlash = requestPath.lastIndexOf("/");
    if (lastSlash === 0) {
      return "/";
    }
    return requestPath.substring(0, lastSlash);
  }
  isExpired(cookie, now) {
    if (cookie.maxAge !== void 0) {
      if (cookie.maxAge <= 0)
        return true;
      const expiresAt = cookie.createdAt + cookie.maxAge * 1e3;
      return now >= expiresAt;
    }
    if (cookie.expires) {
      return now >= cookie.expires.getTime();
    }
    return false;
  }
};
var ScrapeDocumentClass = null;
async function getScrapeDocumentClass() {
  if (!ScrapeDocumentClass) {
    const module2 = await Promise.resolve().then(function() {
      return document$1;
    });
    ScrapeDocumentClass = module2.ScrapeDocument;
  }
  return ScrapeDocumentClass;
}
function scrape(promise2) {
  const basePromise = Promise.resolve(promise2);
  const getDocument = async (options) => {
    const ScrapeDoc = await getScrapeDocumentClass();
    const response2 = await basePromise;
    const html = await response2.text();
    return ScrapeDoc.create(html, {
      baseUrl: options?.baseUrl || response2.url,
      ...options
    });
  };
  const enhanced = basePromise;
  enhanced.scrape = async (options) => {
    return getDocument(options);
  };
  enhanced.links = async (options) => {
    const doc = await getDocument();
    return doc.links(options);
  };
  enhanced.images = async (options) => {
    const doc = await getDocument();
    return doc.images(options);
  };
  enhanced.meta = async () => {
    const doc = await getDocument();
    return doc.meta();
  };
  enhanced.openGraph = async () => {
    const doc = await getDocument();
    return doc.openGraph();
  };
  enhanced.twitterCard = async () => {
    const doc = await getDocument();
    return doc.twitterCard();
  };
  enhanced.jsonLd = async () => {
    const doc = await getDocument();
    return doc.jsonLd();
  };
  enhanced.forms = async (selector) => {
    const doc = await getDocument();
    return doc.forms(selector);
  };
  enhanced.tables = async (selector) => {
    const doc = await getDocument();
    return doc.tables(selector);
  };
  enhanced.scripts = async () => {
    const doc = await getDocument();
    return doc.scripts();
  };
  enhanced.styles = async () => {
    const doc = await getDocument();
    return doc.styles();
  };
  enhanced.extract = async (schema) => {
    const doc = await getDocument();
    return doc.extract(schema);
  };
  return enhanced;
}
function isNodeRuntime() {
  return typeof globalThis !== "undefined" && Boolean(globalThis.process?.versions?.node);
}
var LazyTransport = class {
  factory;
  transport;
  resolving;
  dispatchFn;
  constructor(factory) {
    this.factory = factory;
    this.dispatchFn = this.initialDispatch.bind(this);
  }
  async initialDispatch(req) {
    if (!this.transport) {
      if (!this.resolving) {
        this.resolving = this.factory().then((instance) => {
          this.transport = instance;
          this.dispatchFn = (r4) => this.transport.dispatch(r4);
          return instance;
        });
      }
      this.transport = await this.resolving;
    }
    return this.transport.dispatch(req);
  }
  dispatch(req) {
    return this.dispatchFn(req);
  }
  async warmup() {
    if (!this.transport && !this.resolving) {
      this.resolving = this.factory().then((instance) => {
        this.transport = instance;
        this.dispatchFn = (r4) => this.transport.dispatch(r4);
        return instance;
      });
    }
    await this.resolving;
  }
};
function createLazyCurlTransport() {
  if (!isNodeRuntime()) {
    return {
      async dispatch(req) {
        throw new ConfigurationError("Curl transport is only available in Node.js environments.", { configKey: "useCurl", request: req });
      }
    };
  }
  return new LazyTransport(async () => {
    const { CurlTransport: CurlTransport2 } = await Promise.resolve().then(function() {
      return curl;
    });
    return new CurlTransport2();
  });
}
var LazyCacheStorage2 = class {
  factory;
  storage;
  resolving;
  constructor(factory) {
    this.factory = factory;
  }
  async getStorage() {
    if (!this.storage) {
      if (!this.resolving) {
        this.resolving = this.factory().then((instance) => {
          this.storage = instance;
          return instance;
        });
      }
      this.storage = await this.resolving;
    }
    return this.storage;
  }
  async get(key) {
    return (await this.getStorage()).get(key);
  }
  async set(key, value, ttl) {
    return (await this.getStorage()).set(key, value, ttl);
  }
  async delete(key) {
    return (await this.getStorage()).delete(key);
  }
};
function createLazyFileStorage(path3) {
  if (!isNodeRuntime()) {
    throw new ConfigurationError("File cache storage is only available in Node.js environments.", { configKey: "cache.driver" });
  }
  return new LazyCacheStorage2(async () => {
    const { FileStorage: FileStorage2 } = await Promise.resolve().then(function() {
      return basicFileStorage;
    });
    return new FileStorage2(path3);
  });
}
function createDefaultCacheStorage() {
  if (!isNodeRuntime()) {
    return new SimpleMemoryStorage();
  }
  return new LazyCacheStorage2(async () => {
    const { MemoryStorage: MemoryStorage3 } = await Promise.resolve().then(function() {
      return memoryStorage;
    });
    return new MemoryStorage3();
  });
}
var LazyHlsPromise = class {
  instancePromise;
  constructor(factory) {
    this.instancePromise = factory();
  }
  get [Symbol.toStringTag]() {
    return "HlsPromise";
  }
  then(onfulfilled, onrejected) {
    return this.instancePromise.then(({ instance }) => instance.then(onfulfilled, onrejected));
  }
  catch(onrejected) {
    return this.then(null, onrejected);
  }
  finally(onfinally) {
    return this.instancePromise.then(({ instance }) => instance.finally(onfinally));
  }
  cancel() {
    this.instancePromise.then(({ instance }) => instance.cancel()).catch(() => {
    });
  }
  async download(dest) {
    const { instance } = await this.instancePromise;
    return instance.download(dest);
  }
  async *stream() {
    const { instance } = await this.instancePromise;
    yield* instance.stream();
  }
  async pipe(writable) {
    const { instance } = await this.instancePromise;
    return instance.pipe(writable);
  }
  async info() {
    const { instance } = await this.instancePromise;
    return instance.info();
  }
};
var Client = class {
  static get version() {
    return getVersionSync();
  }
  static getVersion() {
    return getVersion();
  }
  static getVersionInfo() {
    return getVersionInfo();
  }
  baseUrl;
  middlewares;
  hooks;
  transport;
  curlTransport;
  defaultHeaders;
  defaultHeadersObj;
  defaultParams;
  paginationConfig;
  handler;
  fastHandler;
  logger;
  debugEnabled;
  agentManager;
  concurrencyConfig;
  requestPool;
  maxResponseSize;
  cookieJar;
  cookieIgnoreInvalid = false;
  defaultTimeout;
  http2Enabled = false;
  transportKind = "custom";
  canFastPath = false;
  _aiConfig;
  _ai;
  constructor(options = {}) {
    this.baseUrl = options.baseUrl || "";
    this.middlewares = options.middlewares || [];
    this.defaultTimeout = options.timeout;
    this.hooks = {
      beforeRequest: options.hooks?.beforeRequest || [],
      afterResponse: options.hooks?.afterResponse || [],
      onError: options.hooks?.onError || [],
      onRetry: options.hooks?.onRetry || [],
      onUrlResolved: options.hooks?.onUrlResolved || []
    };
    this.defaultHeaders = {
      "User-Agent": getDefaultUserAgent(),
      ...options.headers || {}
    };
    this.defaultHeadersObj = new Headers(this.defaultHeaders);
    this.defaultParams = options.defaults?.params || {};
    this.paginationConfig = options.pagination;
    this.maxResponseSize = options.maxResponseSize;
    this.debugEnabled = options.debug === true;
    if (this.debugEnabled) {
      this.logger = options.logger ?? consoleLogger;
    } else if (options.logger) {
      this.logger = options.logger;
    }
    this.concurrencyConfig = normalizeConcurrency({
      concurrency: options.concurrency,
      http2: options.http2
    });
    const expandedHttp2 = expandHTTP2Options(options.http2);
    this.http2Enabled = expandedHttp2.enabled ?? false;
    if (options.transport) {
      this.transport = options.transport;
      this.transportKind = "custom";
    } else if (options.useCurl) {
      if (this.debugEnabled)
        console.log("[DEBUG] Using Curl Transport");
      this.transport = createLazyCurlTransport();
      this.transportKind = "curl";
    } else if (isNodeRuntime()) {
      if (this.debugEnabled)
        console.log("[DEBUG] Using Undici Transport");
      const agentOptions = {
        ...this.concurrencyConfig.agent,
        allowH2: expandedHttp2.enabled,
        maxConcurrentStreams: expandedHttp2.resolvedSettings?.maxConcurrentStreams
      };
      const transportOptions = {
        proxy: options.proxy,
        http2: expandedHttp2.enabled ? expandedHttp2 : void 0,
        dns: options.dns,
        socketPath: options.socketPath,
        tls: options.tls,
        observability: options.observability,
        expectContinue: options.expectContinue,
        protocolCache: true
      };
      this.transport = new LazyTransport(async () => {
        if (!this.agentManager) {
          const protocolCache = getGlobalProtocolCache();
          const { AgentManager: AgentManager2 } = await Promise.resolve().then(function() {
            return agentManager;
          });
          this.agentManager = new AgentManager2(agentOptions, protocolCache);
        }
        const { UndiciTransport: UndiciTransport2 } = await Promise.resolve().then(function() {
          return undici;
        });
        return new UndiciTransport2(this.baseUrl || void 0, {
          ...transportOptions,
          agent: this.agentManager
        });
      });
      this.transportKind = "undici";
    } else {
      if (this.debugEnabled)
        console.log("[DEBUG] Using Fetch Transport");
      this.transport = new FetchTransport();
      this.transportKind = "fetch";
    }
    if (options.retry) {
      retryPlugin(options.retry)(this);
    }
    if (this.concurrencyConfig.max < Infinity || this.concurrencyConfig.requestsPerInterval < Infinity) {
      this.requestPool = new RequestPool({
        concurrency: this.concurrencyConfig.max,
        requestsPerInterval: this.concurrencyConfig.requestsPerInterval,
        interval: this.concurrencyConfig.interval
      });
      this.middlewares.unshift(this.requestPool.asMiddleware());
      if (this.debugEnabled && this.logger) {
        this.logger.debug(`Global concurrency limit: ${this.concurrencyConfig.max} concurrent requests`);
      }
    } else {
      if (this.debugEnabled && this.logger) {
        this.logger.debug("No global concurrency limit (allows unlimited parallel batches)");
      }
    }
    if (options.dedup) {
      dedupPlugin(options.dedup)(this);
    }
    if (options.cache) {
      let storage;
      if (options.cache.storage) {
        storage = options.cache.storage;
      } else if (options.cache.driver === "file") {
        storage = createLazyFileStorage(options.cache.fileStoragePath);
      } else {
        storage = createDefaultCacheStorage();
      }
      cachePlugin({
        ...options.cache,
        storage
      })(this);
    }
    if (options.plugins) {
      options.plugins.forEach((plugin) => plugin(this));
    }
    if (options.compression) {
      const compressionMiddleware = createCompressionMiddleware(options.compression);
      if (compressionMiddleware) {
        this.middlewares.push(compressionMiddleware);
      }
    }
    if (options.xsrf) {
      const xsrfMiddleware = createXSRFMiddleware(options.xsrf);
      if (xsrfMiddleware) {
        this.middlewares.push(xsrfMiddleware);
      }
    }
    if (options.cookies) {
      this.setupCookieJar(options.cookies);
    }
    if (options._aiConfig) {
      this._aiConfig = options._aiConfig;
    }
    if (this.maxResponseSize !== void 0) {
      this.middlewares.push(this.createMaxSizeMiddleware(this.maxResponseSize));
    }
    if (this.debugEnabled && this.logger) {
      this.middlewares.unshift(this.createLoggingMiddleware(this.logger));
    }
    this.handler = this.composeMiddlewares();
    this.fastHandler = this.composeFastHandler();
    const hasHooks = (this.hooks.beforeRequest?.length ?? 0) > 0 || (this.hooks.afterResponse?.length ?? 0) > 0 || (this.hooks.onError?.length ?? 0) > 0;
    const hasComplexConfig = !!this.cookieJar || !!this.defaultTimeout || this.maxResponseSize !== void 0 || this.debugEnabled;
    const hasUserMiddlewares = this.middlewares.length > 0;
    this.canFastPath = !hasHooks && !hasComplexConfig && !hasUserMiddlewares;
  }
  createLoggingMiddleware(logger3) {
    return async (req, next) => {
      const startTime = Date.now();
      logger3.debug({ type: "request", method: req.method, url: req.url }, `\u2192 ${req.method} ${req.url}`);
      try {
        const response2 = await next(req);
        const duration = Date.now() - startTime;
        logger3.debug({
          type: "response",
          method: req.method,
          url: req.url,
          status: response2.status,
          duration,
          timings: response2.timings
        }, `\u2190 ${response2.status} ${req.method} ${req.url} (${duration}ms)`);
        return response2;
      } catch (error2) {
        const duration = Date.now() - startTime;
        const err = error2;
        logger3.error({
          type: "error",
          method: req.method,
          url: req.url,
          error: err.message,
          errorName: err.name,
          duration
        }, `\u2716 ${req.method} ${req.url} - ${err.message}`);
        throw error2;
      }
    };
  }
  createMaxSizeMiddleware(globalMaxSize) {
    return async (req, next) => {
      const response2 = await next(req);
      const limit = req.maxResponseSize ?? globalMaxSize;
      if (limit === void 0)
        return response2;
      const contentLength = response2.headers.get("Content-Length");
      if (contentLength) {
        const size = parseInt(contentLength, 10);
        if (!isNaN(size) && size > limit) {
          throw new MaxSizeExceededError(limit, size, req);
        }
      }
      return response2;
    };
  }
  setupCookieJar(options) {
    if (options === true) {
      this.cookieJar = new MemoryCookieJar();
    } else if (typeof options === "object") {
      if (options.jar === true) {
        this.cookieJar = new MemoryCookieJar();
      } else if (options.jar && typeof options.jar === "object") {
        this.cookieJar = options.jar;
      }
      this.cookieIgnoreInvalid = options.ignoreInvalid ?? false;
    }
    if (this.cookieJar) {
      this.middlewares.push(this.createCookieMiddleware());
    }
  }
  createCookieMiddleware() {
    return async (req, next) => {
      const jar = this.cookieJar;
      try {
        const cookieString = await jar.getCookieString(req.url);
        if (cookieString) {
          const existingCookie = req.headers.get("cookie");
          const newCookie = existingCookie ? `${existingCookie}; ${cookieString}` : cookieString;
          req.headers.set("cookie", newCookie);
        }
      } catch (error2) {
        if (!this.cookieIgnoreInvalid) {
          throw error2;
        }
      }
      const response2 = await next(req);
      const setCookieHeader = response2.headers.get("set-cookie");
      if (setCookieHeader) {
        const cookies2 = this.splitSetCookieHeader(setCookieHeader);
        for (const cookie of cookies2) {
          try {
            await jar.setCookie(cookie, req.url);
          } catch (error2) {
            if (!this.cookieIgnoreInvalid) {
              throw error2;
            }
          }
        }
      }
      return response2;
    };
  }
  splitSetCookieHeader(header) {
    return header.split(/,(?=\s*[a-zA-Z0-9_-]+=)/g).map((s4) => s4.trim());
  }
  async dispatch(req) {
    if (req.useCurl && this.transportKind !== "curl") {
      if (!this.curlTransport) {
        this.curlTransport = createLazyCurlTransport();
      }
      return this.curlTransport.dispatch(req);
    }
    return this.transport.dispatch(req);
  }
  composeMiddlewares() {
    const chain = [...this.middlewares];
    const self2 = this;
    const transportWithErrorCheck = async (req) => {
      const response2 = await self2.dispatch(req);
      if (req.throwHttpErrors !== false && !response2.ok && response2.status !== 304) {
        throw new HttpError(response2, req);
      }
      return response2;
    };
    if (this.hooks.beforeRequest?.length || this.hooks.afterResponse?.length) {
      chain.unshift(this.hooksMiddleware);
    }
    if (chain.length === 0) {
      return transportWithErrorCheck;
    }
    return chain.reduceRight((next, middleware) => {
      return (req) => middleware(req, next);
    }, transportWithErrorCheck);
  }
  composeFastHandler() {
    const self2 = this;
    return async (req) => {
      const response2 = await self2.dispatch(req);
      if (req.throwHttpErrors !== false && !response2.ok && response2.status !== 304) {
        throw new HttpError(response2, req);
      }
      return response2;
    };
  }
  hooksMiddleware = async (req, next) => {
    let modifiedReq = req;
    if (this.hooks.beforeRequest && this.hooks.beforeRequest.length > 0) {
      for (const hook of this.hooks.beforeRequest) {
        const result = await hook(modifiedReq);
        if (result) {
          modifiedReq = result;
        }
      }
    }
    try {
      let response2 = await next(modifiedReq);
      if (this.hooks.afterResponse && this.hooks.afterResponse.length > 0) {
        for (const hook of this.hooks.afterResponse) {
          const result = await hook(modifiedReq, response2);
          if (result) {
            response2 = result;
          }
        }
      }
      return response2;
    } catch (error2) {
      if (this.hooks.onError && this.hooks.onError.length > 0) {
        for (const hook of this.hooks.onError) {
          const result = await hook(error2, modifiedReq);
          if (result) {
            return result;
          }
        }
      }
      throw error2;
    }
  };
  use(middleware) {
    this.middlewares.push(middleware);
    this.handler = this.composeMiddlewares();
    this.canFastPath = false;
    return this;
  }
  beforeRequest(hook) {
    if (!this.hooks.beforeRequest) {
      this.hooks.beforeRequest = [];
    }
    this.hooks.beforeRequest.push(hook);
    this.handler = this.composeMiddlewares();
    this.canFastPath = false;
    return this;
  }
  afterResponse(hook) {
    if (!this.hooks.afterResponse) {
      this.hooks.afterResponse = [];
    }
    this.hooks.afterResponse.push(hook);
    this.handler = this.composeMiddlewares();
    this.canFastPath = false;
    return this;
  }
  onError(hook) {
    if (!this.hooks.onError) {
      this.hooks.onError = [];
    }
    this.hooks.onError.push(hook);
    this.handler = this.composeMiddlewares();
    this.canFastPath = false;
    return this;
  }
  buildUrl(path3, requestParams) {
    const hasRequestParams = requestParams && Object.keys(requestParams).length > 0;
    const hasDefaultParams = Object.keys(this.defaultParams).length > 0;
    if (!hasRequestParams && !hasDefaultParams) {
      if (path3.startsWith("http://") || path3.startsWith("https://")) {
        return path3;
      }
      if (this.baseUrl) {
        const base2 = this.baseUrl.endsWith("/") ? this.baseUrl.slice(0, -1) : this.baseUrl;
        const p4 = path3.startsWith("/") ? path3 : "/" + path3;
        return base2 + p4;
      }
      return path3;
    }
    let finalPath = path3;
    const mergedParams = { ...this.defaultParams, ...requestParams };
    const usedParams = /* @__PURE__ */ new Set();
    if (finalPath.includes(":")) {
      finalPath = finalPath.replace(/:([a-zA-Z0-9_]+)/g, (match, paramName) => {
        if (mergedParams && paramName in mergedParams) {
          usedParams.add(paramName);
          return encodeURIComponent(String(mergedParams[paramName]));
        }
        throw new ValidationError$1(`Missing required path parameter: ${paramName}`, {
          field: paramName,
          value: void 0
        });
      });
    }
    let finalUrl;
    if (finalPath.startsWith("http://") || finalPath.startsWith("https://")) {
      finalUrl = finalPath;
    } else if (this.baseUrl) {
      const base2 = this.baseUrl.endsWith("/") ? this.baseUrl.slice(0, -1) : this.baseUrl;
      const p4 = finalPath.startsWith("/") ? finalPath : "/" + finalPath;
      finalUrl = base2 + p4;
    } else {
      throw new ConfigurationError("Relative path provided without a baseUrl or explicit transport.", {
        configKey: "baseUrl"
      });
    }
    const remainingKeys = Object.keys(mergedParams).filter((k4) => !usedParams.has(k4));
    if (remainingKeys.length > 0) {
      const queryParts = remainingKeys.map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(String(mergedParams[key]))}`);
      const separator = finalUrl.includes("?") ? "&" : "?";
      return finalUrl + separator + queryParts.join("&");
    }
    return finalUrl;
  }
  request(path3, options = {}) {
    const url = this.buildUrl(path3, options.params);
    const usesFastPath = this.canFastPath && !options.headers && !options.timeout && !options.signal && options.maxResponseSize === void 0;
    if (usesFastPath) {
      const req2 = new HttpRequest10(url, {
        method: options.method || "GET",
        body: options.body,
        headers: this.defaultHeadersObj,
        throwHttpErrors: options.throwHttpErrors
      });
      const responsePromise2 = this.fastHandler(req2);
      return new RequestPromise(responsePromise2);
    }
    let mergedHeaders;
    if (options.headers) {
      mergedHeaders = new Headers(this.defaultHeadersObj);
      const optHeaders = options.headers instanceof Headers ? options.headers : new Headers(options.headers);
      optHeaders.forEach((value, key) => mergedHeaders.set(key, value));
    } else {
      mergedHeaders = this.defaultHeadersObj;
    }
    const needsController = options.timeout || options.signal || this.defaultTimeout;
    let controller;
    let signal = options.signal;
    let timeoutId;
    let externalAbortCleanup;
    if (needsController) {
      controller = new AbortController();
      signal = controller.signal;
      if (options.signal) {
        const externalSignal = options.signal;
        const abortHandler = () => controller.abort(externalSignal.reason);
        if (externalSignal.aborted) {
          abortHandler();
        } else {
          externalSignal.addEventListener("abort", abortHandler, { once: true });
          externalAbortCleanup = () => externalSignal.removeEventListener("abort", abortHandler);
        }
      }
      const timeout = options.timeout ?? this.defaultTimeout;
      if (timeout) {
        const totalTimeout = typeof timeout === "number" ? timeout : timeout.request;
        if (totalTimeout) {
          timeoutId = setTimeout(() => controller.abort(new TimeoutError(req, {
            phase: "request",
            timeout: totalTimeout
          })), totalTimeout);
        }
      }
    }
    const req = new HttpRequest10(url, {
      ...options,
      headers: mergedHeaders,
      signal,
      maxResponseSize: options.maxResponseSize ?? this.maxResponseSize
    });
    const responsePromise = this.handler(req);
    if (timeoutId || externalAbortCleanup) {
      responsePromise.finally(() => {
        if (timeoutId)
          clearTimeout(timeoutId);
        externalAbortCleanup?.();
      }).catch(() => {
      });
    }
    return new RequestPromise(responsePromise, controller);
  }
  get(path3, options = {}) {
    return this.request(path3, { ...options, method: "GET" });
  }
  async warmup() {
    if (this.transport && "warmup" in this.transport && typeof this.transport.warmup === "function") {
      await this.transport.warmup();
    }
  }
  async batch(requests, options = {}) {
    const mapResponse = options.mapResponse ?? ((res) => res);
    const batchConcurrency = options.concurrency ?? this.concurrencyConfig.runner.concurrency;
    const runner = new RequestRunner({
      concurrency: batchConcurrency,
      retries: this.concurrencyConfig.runner.retries,
      retryDelay: this.concurrencyConfig.runner.retryDelay
    });
    const runnerResult = await runner.run(requests, async (item) => {
      const res = await this.request(item.path, item.options);
      return mapResponse(res);
    });
    return runnerResult;
  }
  multi(requests, options = {}) {
    return this.batch(requests, options);
  }
  requestWithBody(method, path3, bodyOrOptions, options) {
    let actualBody = bodyOrOptions;
    let actualOptions = options;
    const isOptionsEmpty = actualOptions === void 0 || typeof actualOptions === "object" && actualOptions !== null && Object.keys(actualOptions).length === 0;
    if (isOptionsEmpty && isPlainObject2(bodyOrOptions)) {
      const potentialOptions = bodyOrOptions;
      if (potentialOptions.json !== void 0 || potentialOptions.form !== void 0 || potentialOptions.xml !== void 0 || potentialOptions.yaml !== void 0 || potentialOptions.csv !== void 0 || potentialOptions.body !== void 0 || potentialOptions.headers !== void 0 || potentialOptions.timeout !== void 0 || potentialOptions.retry !== void 0 || potentialOptions.hooks !== void 0 || potentialOptions.searchParams !== void 0 || potentialOptions.params !== void 0) {
        actualOptions = bodyOrOptions;
        actualBody = void 0;
      }
    }
    actualOptions = actualOptions || {};
    const { json, form, xml, yaml, csv, ...restOptions } = actualOptions;
    let finalBody = actualBody;
    let explicitContentType;
    if (form !== void 0) {
      finalBody = createFormData(form);
      explicitContentType = void 0;
    } else if (json !== void 0) {
      finalBody = JSON.stringify(json);
      explicitContentType = "application/json";
    } else if (xml !== void 0) {
      finalBody = '<?xml version="1.0" encoding="UTF-8"?>\n' + serializeXML(xml);
      explicitContentType = "application/xml";
    } else if (yaml !== void 0) {
      finalBody = serializeYaml(yaml);
      explicitContentType = "application/yaml";
    } else if (csv !== void 0) {
      finalBody = serializeCsv(csv);
      explicitContentType = "text/csv";
    } else if (restOptions.body !== void 0) {
      finalBody = restOptions.body;
    }
    const { body: processedBody, contentType } = processBody(finalBody);
    const headers2 = new Headers(restOptions.headers);
    const finalContentType = explicitContentType ?? contentType;
    if (finalContentType && !headers2.has("Content-Type")) {
      headers2.set("Content-Type", finalContentType);
    }
    return this.request(path3, { ...restOptions, method, body: processedBody, headers: headers2 });
  }
  post(path3, body2, options = {}) {
    return this.requestWithBody("POST", path3, body2, options);
  }
  put(path3, body2, options = {}) {
    return this.requestWithBody("PUT", path3, body2, options);
  }
  patch(path3, body2, options = {}) {
    return this.requestWithBody("PATCH", path3, body2, options);
  }
  delete(path3, options = {}) {
    return this.request(path3, { ...options, method: "DELETE" });
  }
  head(path3, options = {}) {
    return this.request(path3, { ...options, method: "HEAD" });
  }
  options(path3, options = {}) {
    return this.request(path3, { ...options, method: "OPTIONS" });
  }
  trace(path3, options = {}) {
    return this.request(path3, { ...options, method: "TRACE" });
  }
  connect(path3, options = {}) {
    return this.request(path3, { ...options, method: "CONNECT" });
  }
  purge(path3, options = {}) {
    return this.request(path3, { ...options, method: "PURGE" });
  }
  propfind(path3, body2, options = {}) {
    return this.requestWithBody("PROPFIND", path3, body2, options);
  }
  proppatch(path3, body2, options = {}) {
    return this.requestWithBody("PROPPATCH", path3, body2, options);
  }
  mkcol(path3, options = {}) {
    return this.request(path3, { ...options, method: "MKCOL" });
  }
  copy(path3, options = {}) {
    return this.request(path3, { ...options, method: "COPY" });
  }
  move(path3, options = {}) {
    return this.request(path3, { ...options, method: "MOVE" });
  }
  lock(path3, body2, options = {}) {
    return this.requestWithBody("LOCK", path3, body2, options);
  }
  unlock(path3, options = {}) {
    return this.request(path3, { ...options, method: "UNLOCK" });
  }
  link(path3, body2, options = {}) {
    return this.requestWithBody("LINK", path3, body2, options);
  }
  unlink(path3, body2, options = {}) {
    return this.requestWithBody("UNLINK", path3, body2, options);
  }
  scrape(path3, options = {}) {
    const method = options.method || "GET";
    const requestPromise = this.request(path3, { ...options, method });
    return scrape(requestPromise);
  }
  paginate(path3, options = {}) {
    const { getItems, getNextUrl, maxPages, pageParam, limitParam, resultsPath, nextCursorPath, ...reqOptions } = options;
    const paginationOpts = {
      getItems,
      getNextUrl,
      maxPages,
      pageParam: pageParam || this.paginationConfig?.pageParam,
      limitParam: limitParam || this.paginationConfig?.limitParam,
      resultsPath: resultsPath || this.paginationConfig?.resultsPath,
      nextCursorPath: nextCursorPath || this.paginationConfig?.nextCursorPath
    };
    return paginate(this, path3, reqOptions, paginationOpts);
  }
  pages(path3, options = {}) {
    const { getNextUrl, maxPages, pageParam, limitParam, resultsPath, nextCursorPath, ...reqOptions } = options;
    const paginationOpts = {
      getNextUrl,
      maxPages,
      pageParam: pageParam || this.paginationConfig?.pageParam,
      limitParam: limitParam || this.paginationConfig?.limitParam,
      nextCursorPath: nextCursorPath || this.paginationConfig?.nextCursorPath
    };
    return streamPages(this, path3, reqOptions, paginationOpts);
  }
  page(path3, pageNumber, options = {}) {
    const pageParam = options.pageParam || this.paginationConfig?.pageParam || "page";
    new URL(path3.startsWith("http") ? path3 : `http://base${path3}`);
    const params = { ...options.params, [pageParam]: pageNumber };
    return this.request(path3, { ...options, params });
  }
  async getAll(path3, options = {}) {
    const items = [];
    for await (const item of this.paginate(path3, options)) {
      items.push(item);
    }
    return items;
  }
  websocket(path3, options = {}) {
    let wsUrl;
    if (path3.startsWith("ws://") || path3.startsWith("wss://")) {
      wsUrl = path3;
    } else if (this.baseUrl) {
      const base2 = this.baseUrl.replace(/^http/, "ws");
      wsUrl = new URL(path3, base2).toString();
    } else {
      throw new ConfigurationError("WebSocket requires either a full ws:// URL or a baseUrl", {
        configKey: "baseUrl"
      });
    }
    const headersObj = {};
    if (this.defaultHeaders) {
      const headers2 = new Headers(this.defaultHeaders);
      headers2.forEach((value, key) => {
        headersObj[key] = value;
      });
    }
    const finalHeaders = { ...headersObj, ...options.headers };
    return new ReckerWebSocket(wsUrl, { ...options, headers: finalHeaders });
  }
  ws(path3, options = {}) {
    return this.websocket(path3, options);
  }
  async whois(query, options) {
    return whois(query, options);
  }
  async isDomainAvailable(domain, options) {
    return isDomainAvailable(domain, options);
  }
  hls(manifestUrl, options = {}) {
    if (!isNodeRuntime()) {
      throw new UnsupportedError("HLS is only available in Node.js environments.", { feature: "hls" });
    }
    const factory = async () => {
      const { HlsPromise: HlsPromise2 } = await Promise.resolve().then(function() {
        return hls;
      });
      return { instance: new HlsPromise2(this, manifestUrl, options) };
    };
    return new LazyHlsPromise(factory);
  }
  get metadata() {
    return { handlerProtocol: "http/1.1" };
  }
  async handle(request2, options) {
    const protocol = request2.protocol || "https:";
    const hostname = request2.hostname;
    const port = request2.port;
    const path3 = request2.path || "/";
    let url = `${protocol}//${hostname}`;
    if (port && !(protocol === "https:" && port === 443 || protocol === "http:" && port === 80)) {
      url += `:${port}`;
    }
    url += path3;
    if (request2.query) {
      const searchParams = new URLSearchParams();
      for (const [key, value] of Object.entries(request2.query)) {
        if (value === null || value === void 0)
          continue;
        if (Array.isArray(value)) {
          for (const v4 of value) {
            searchParams.append(key, v4);
          }
        } else {
          searchParams.set(key, value);
        }
      }
      const qs = searchParams.toString();
      if (qs) {
        url += (url.includes("?") ? "&" : "?") + qs;
      }
    }
    const headers2 = {};
    if (request2.headers) {
      for (const [key, value] of Object.entries(request2.headers)) {
        if (value === void 0)
          continue;
        if (key.startsWith(":"))
          continue;
        headers2[key] = Array.isArray(value) ? value.join(", ") : value;
      }
    }
    const response2 = await this.request(url, {
      method: request2.method || "GET",
      headers: headers2,
      body: request2.body,
      signal: options?.abortSignal,
      timeout: options?.requestTimeout,
      throwHttpErrors: false
    });
    const responseHeaders = {};
    response2.headers.forEach((value, key) => {
      responseHeaders[key] = value;
    });
    let body2;
    if (response2.raw.body) {
      const { Readable: Readable2 } = await import("stream");
      body2 = Readable2.fromWeb(response2.raw.body);
    }
    return {
      response: {
        statusCode: response2.status,
        reason: response2.statusText,
        headers: responseHeaders,
        body: body2
      }
    };
  }
  updateHttpClientConfig(_key, _value) {
  }
  httpHandlerConfigs() {
    return {
      http2: this.http2Enabled,
      maxSockets: this.concurrencyConfig.agent.connections,
      keepAlive: true
    };
  }
  async destroy() {
    if (this.agentManager) {
      await this.agentManager.destroy();
    }
    this.requestPool = void 0;
  }
  get ai() {
    if (!this._ai) {
      if (!this._aiConfig) {
        throw new ConfigurationError("AI features require an AI-enabled preset. Use createClient(openai({...})), createClient(anthropic({...})), etc.", { configKey: "_aiConfig" });
      }
      this._ai = new ClientAIImpl(this, this._aiConfig);
    }
    return this._ai;
  }
  get hasAI() {
    return this._aiConfig !== void 0;
  }
};
function createClient(options = {}) {
  return new Client(options);
}
var DEFAULT_TOTAL_PERCENT = 0.5;
var DEFAULT_HEAP_PERCENT = 0.6;
function readCgroupLimit() {
  const candidates = [
    "/sys/fs/cgroup/memory.max",
    "/sys/fs/cgroup/memory/memory.limit_in_bytes"
  ];
  for (const file of candidates) {
    try {
      if (import_node_fs.default.existsSync(file)) {
        const raw = import_node_fs.default.readFileSync(file, "utf8").trim();
        if (!raw || raw === "max")
          continue;
        const value = Number.parseInt(raw, 10);
        if (Number.isFinite(value) && value > 0) {
          return value;
        }
      }
    } catch {
    }
  }
  return null;
}
function getEffectiveTotalMemoryBytes() {
  const cgroupLimit = readCgroupLimit();
  if (cgroupLimit && Number.isFinite(cgroupLimit) && cgroupLimit > 0) {
    return cgroupLimit;
  }
  return import_node_os.default.totalmem();
}
function resolveCacheMemoryLimit(options = {}) {
  const { maxMemoryBytes, maxMemoryPercent, safetyPercent } = options;
  const heapStats = import_node_v8.default.getHeapStatistics();
  const heapLimit = heapStats?.heap_size_limit ?? 0;
  const effectiveTotal = getEffectiveTotalMemoryBytes();
  let resolvedBytes = 0;
  let derivedFromPercent = false;
  if (typeof maxMemoryBytes === "number" && maxMemoryBytes > 0) {
    resolvedBytes = maxMemoryBytes;
  } else if (typeof maxMemoryPercent === "number" && maxMemoryPercent > 0) {
    const percent = Math.max(0, Math.min(maxMemoryPercent, 1));
    resolvedBytes = Math.floor(effectiveTotal * percent);
    derivedFromPercent = true;
  }
  const safeTotalPercent = typeof safetyPercent === "number" && safetyPercent > 0 && safetyPercent <= 1 ? safetyPercent : DEFAULT_TOTAL_PERCENT;
  const totalCap = Math.floor(effectiveTotal * safeTotalPercent);
  if (resolvedBytes === 0 || totalCap < resolvedBytes) {
    resolvedBytes = totalCap;
    derivedFromPercent = derivedFromPercent || (maxMemoryPercent ?? 0) > 0;
  }
  if (heapLimit > 0) {
    const heapCap = Math.floor(heapLimit * DEFAULT_HEAP_PERCENT);
    if (resolvedBytes === 0 || heapCap < resolvedBytes) {
      resolvedBytes = heapCap;
      derivedFromPercent = derivedFromPercent || (maxMemoryPercent ?? 0) > 0;
    }
  }
  if (!Number.isFinite(resolvedBytes) || resolvedBytes <= 0) {
    resolvedBytes = Math.floor(effectiveTotal * DEFAULT_TOTAL_PERCENT);
    derivedFromPercent = true;
  }
  const inferredPercent = effectiveTotal > 0 ? resolvedBytes / effectiveTotal : null;
  return {
    maxMemoryBytes: resolvedBytes,
    derivedFromPercent,
    effectiveTotal,
    heapLimit,
    inferredPercent
  };
}
function formatBytes(bytes) {
  if (bytes === 0)
    return "0 B";
  const k4 = 1024;
  const sizes = ["B", "KB", "MB", "GB", "TB"];
  const i4 = Math.floor(Math.log(bytes) / Math.log(k4));
  return `${(bytes / Math.pow(k4, i4)).toFixed(2)} ${sizes[i4]}`;
}
function getHeapStats() {
  const heapStats = import_node_v8.default.getHeapStatistics();
  const { heapUsed } = process.memoryUsage();
  const heapLimit = heapStats?.heap_size_limit ?? 0;
  const heapRatio = heapLimit > 0 ? heapUsed / heapLimit : 0;
  return {
    heapUsed,
    heapLimit,
    heapRatio
  };
}
var MemoryStorage$1 = class MemoryStorage {
  storage = /* @__PURE__ */ new Map();
  meta = /* @__PURE__ */ new Map();
  maxSize;
  maxMemoryBytes;
  maxMemoryPercent;
  defaultTtl;
  evictionPolicy;
  compressionEnabled;
  compressionThreshold;
  enableStats;
  heapUsageThreshold;
  onEvict;
  onPressure;
  currentMemoryBytes = 0;
  evictedDueToMemory = 0;
  memoryPressureEvents = 0;
  accessCounter = 0;
  monitorHandle = null;
  cleanupHandle = null;
  stats = {
    hits: 0,
    misses: 0,
    sets: 0,
    deletes: 0,
    evictions: 0
  };
  compressionStats = {
    totalCompressed: 0,
    totalOriginalSize: 0,
    totalCompressedSize: 0
  };
  constructor(options = {}) {
    if (options.maxMemoryBytes && options.maxMemoryBytes > 0 && options.maxMemoryPercent && options.maxMemoryPercent > 0) {
      throw new ConfigurationError("[MemoryStorage] Cannot use both maxMemoryBytes and maxMemoryPercent", { configKey: "maxMemoryBytes|maxMemoryPercent" });
    }
    if (options.maxMemoryPercent !== void 0 && (options.maxMemoryPercent < 0 || options.maxMemoryPercent > 1)) {
      throw new ConfigurationError("[MemoryStorage] maxMemoryPercent must be between 0 and 1", { configKey: "maxMemoryPercent" });
    }
    this.maxSize = options.maxSize ?? 1e3;
    this.defaultTtl = options.ttl ?? 3e5;
    this.evictionPolicy = options.evictionPolicy ?? "lru";
    this.enableStats = options.enableStats ?? false;
    this.heapUsageThreshold = options.heapUsageThreshold ?? 0.6;
    if (options.maxMemoryBytes && options.maxMemoryBytes > 0) {
      this.maxMemoryBytes = options.maxMemoryBytes;
      this.maxMemoryPercent = 0;
    } else if (options.maxMemoryPercent && options.maxMemoryPercent > 0) {
      const effectiveTotal = getEffectiveTotalMemoryBytes();
      this.maxMemoryBytes = Math.floor(effectiveTotal * options.maxMemoryPercent);
      this.maxMemoryPercent = options.maxMemoryPercent;
    } else {
      const resolved = resolveCacheMemoryLimit({});
      this.maxMemoryBytes = resolved.maxMemoryBytes;
      this.maxMemoryPercent = resolved.inferredPercent ?? 0;
    }
    if (options.compression === true) {
      this.compressionEnabled = true;
      this.compressionThreshold = 1024;
    } else if (typeof options.compression === "object" && options.compression.enabled) {
      this.compressionEnabled = true;
      this.compressionThreshold = options.compression.threshold ?? 1024;
    } else {
      this.compressionEnabled = false;
      this.compressionThreshold = 1024;
    }
    this.onEvict = options.onEvict;
    this.onPressure = options.onPressure;
    const monitorInterval = options.monitorInterval ?? 15e3;
    if (monitorInterval > 0) {
      this.monitorHandle = setInterval(() => this.memoryHealthCheck(), monitorInterval);
      this.monitorHandle.unref();
    }
    const cleanupInterval = options.cleanupInterval ?? 6e4;
    if (cleanupInterval > 0) {
      this.cleanupHandle = setInterval(() => this.cleanupExpired(), cleanupInterval);
      this.cleanupHandle.unref();
    }
  }
  async get(key) {
    const data2 = this.storage.get(key);
    const metadata = this.meta.get(key);
    if (!data2 || !metadata) {
      this.recordStat("misses");
      return void 0;
    }
    const now = Date.now();
    if (now > metadata.expiresAt) {
      this.deleteInternal(key);
      this.recordStat("misses");
      return void 0;
    }
    if (this.evictionPolicy === "lru") {
      metadata.lastAccess = now;
      metadata.accessOrder = ++this.accessCounter;
    }
    this.recordStat("hits");
    if (this.isCompressed(data2)) {
      try {
        const decompressed = this.decompress(data2);
        return JSON.parse(decompressed);
      } catch {
        this.deleteInternal(key);
        return void 0;
      }
    }
    return JSON.parse(data2);
  }
  async set(key, entry, ttl) {
    const effectiveTtl = ttl ?? this.defaultTtl;
    const now = Date.now();
    const serialized = JSON.stringify(entry);
    const originalSize = Buffer.byteLength(serialized, "utf8");
    let finalData = serialized;
    let compressedSize = originalSize;
    let compressed = false;
    if (this.compressionEnabled && originalSize >= this.compressionThreshold) {
      try {
        const result = this.compress(serialized);
        finalData = result;
        compressedSize = Buffer.byteLength(result.__data, "utf8");
        compressed = true;
        this.compressionStats.totalCompressed++;
        this.compressionStats.totalOriginalSize += originalSize;
        this.compressionStats.totalCompressedSize += compressedSize;
      } catch {
      }
    }
    const existingMeta = this.meta.get(key);
    if (existingMeta) {
      this.currentMemoryBytes -= existingMeta.compressedSize;
    }
    if (!this.enforceMemoryLimit(compressedSize)) {
      this.evictedDueToMemory++;
      return;
    }
    if (!existingMeta && this.storage.size >= this.maxSize) {
      this.evictOne("size");
    }
    this.storage.set(key, finalData);
    this.meta.set(key, {
      createdAt: now,
      expiresAt: now + effectiveTtl,
      lastAccess: now,
      insertOrder: ++this.accessCounter,
      accessOrder: this.accessCounter,
      compressed,
      originalSize,
      compressedSize
    });
    this.currentMemoryBytes += compressedSize;
    this.recordStat("sets");
  }
  async delete(key) {
    this.deleteInternal(key);
    this.recordStat("deletes");
  }
  clear(prefix) {
    if (!prefix) {
      this.storage.clear();
      this.meta.clear();
      this.currentMemoryBytes = 0;
      this.evictedDueToMemory = 0;
      if (this.enableStats) {
        this.stats = { hits: 0, misses: 0, sets: 0, deletes: 0, evictions: 0 };
      }
      return;
    }
    for (const key of this.storage.keys()) {
      if (key.startsWith(prefix)) {
        this.deleteInternal(key);
      }
    }
  }
  size() {
    return this.storage.size;
  }
  keys() {
    return Array.from(this.storage.keys());
  }
  has(key) {
    const meta = this.meta.get(key);
    if (!meta)
      return false;
    if (Date.now() > meta.expiresAt) {
      this.deleteInternal(key);
      return false;
    }
    return true;
  }
  getStats() {
    const total = this.stats.hits + this.stats.misses;
    const hitRate = total > 0 ? this.stats.hits / total : 0;
    return {
      enabled: this.enableStats,
      ...this.stats,
      hitRate,
      totalItems: this.storage.size,
      memoryUsageBytes: this.currentMemoryBytes,
      maxMemoryBytes: this.maxMemoryBytes,
      evictedDueToMemory: this.evictedDueToMemory
    };
  }
  getMemoryStats() {
    const totalItems = this.storage.size;
    const memoryUsagePercent = this.maxMemoryBytes > 0 ? this.currentMemoryBytes / this.maxMemoryBytes * 100 : 0;
    const systemTotal = import_node_os.default.totalmem();
    const systemFree = import_node_os.default.freemem();
    const systemUsed = systemTotal - systemFree;
    const cachePercentOfSystem = systemTotal > 0 ? this.currentMemoryBytes / systemTotal * 100 : 0;
    return {
      currentMemoryBytes: this.currentMemoryBytes,
      maxMemoryBytes: this.maxMemoryBytes,
      maxMemoryPercent: this.maxMemoryPercent,
      memoryUsagePercent: parseFloat(memoryUsagePercent.toFixed(2)),
      cachePercentOfSystemMemory: parseFloat(cachePercentOfSystem.toFixed(2)),
      totalItems,
      maxSize: this.maxSize,
      evictedDueToMemory: this.evictedDueToMemory,
      memoryPressureEvents: this.memoryPressureEvents,
      averageItemSize: totalItems > 0 ? Math.round(this.currentMemoryBytes / totalItems) : 0,
      memoryUsage: {
        current: formatBytes(this.currentMemoryBytes),
        max: formatBytes(this.maxMemoryBytes),
        available: formatBytes(Math.max(0, this.maxMemoryBytes - this.currentMemoryBytes))
      },
      systemMemory: {
        total: formatBytes(systemTotal),
        free: formatBytes(systemFree),
        used: formatBytes(systemUsed),
        cachePercent: `${cachePercentOfSystem.toFixed(2)}%`
      }
    };
  }
  getCompressionStats() {
    if (!this.compressionEnabled) {
      return {
        enabled: false,
        totalItems: this.storage.size,
        compressedItems: 0,
        compressionThreshold: this.compressionThreshold,
        totalOriginalSize: 0,
        totalCompressedSize: 0,
        averageCompressionRatio: "0",
        spaceSavingsPercent: "0",
        memoryUsage: {
          uncompressed: "0 B",
          compressed: "0 B",
          saved: "0 B"
        }
      };
    }
    const ratio = this.compressionStats.totalOriginalSize > 0 ? (this.compressionStats.totalCompressedSize / this.compressionStats.totalOriginalSize).toFixed(2) : "0";
    const savings = this.compressionStats.totalOriginalSize > 0 ? ((this.compressionStats.totalOriginalSize - this.compressionStats.totalCompressedSize) / this.compressionStats.totalOriginalSize * 100).toFixed(2) : "0";
    const saved = this.compressionStats.totalOriginalSize - this.compressionStats.totalCompressedSize;
    return {
      enabled: true,
      totalItems: this.storage.size,
      compressedItems: this.compressionStats.totalCompressed,
      compressionThreshold: this.compressionThreshold,
      totalOriginalSize: this.compressionStats.totalOriginalSize,
      totalCompressedSize: this.compressionStats.totalCompressedSize,
      averageCompressionRatio: ratio,
      spaceSavingsPercent: savings,
      memoryUsage: {
        uncompressed: formatBytes(this.compressionStats.totalOriginalSize),
        compressed: formatBytes(this.compressionStats.totalCompressedSize),
        saved: formatBytes(saved)
      }
    };
  }
  shutdown() {
    if (this.monitorHandle) {
      clearInterval(this.monitorHandle);
      this.monitorHandle = null;
    }
    if (this.cleanupHandle) {
      clearInterval(this.cleanupHandle);
      this.cleanupHandle = null;
    }
  }
  deleteInternal(key) {
    const meta = this.meta.get(key);
    if (meta) {
      this.currentMemoryBytes -= meta.compressedSize;
    }
    this.storage.delete(key);
    this.meta.delete(key);
  }
  recordStat(type) {
    if (this.enableStats) {
      this.stats[type]++;
    }
  }
  isCompressed(data2) {
    return typeof data2 === "object" && data2 !== null && "__compressed" in data2;
  }
  compress(data2) {
    const buffer = Buffer.from(data2, "utf8");
    const compressed = import_node_zlib.default.gzipSync(buffer);
    return {
      __compressed: true,
      __data: compressed.toString("base64"),
      __originalSize: buffer.length
    };
  }
  decompress(data2) {
    const buffer = Buffer.from(data2.__data, "base64");
    const decompressed = import_node_zlib.default.gunzipSync(buffer);
    return decompressed.toString("utf8");
  }
  selectEvictionCandidate() {
    if (this.meta.size === 0)
      return null;
    let candidate = null;
    let candidateValue = this.evictionPolicy === "lru" ? Infinity : Infinity;
    for (const [key, meta] of this.meta) {
      const value = this.evictionPolicy === "lru" ? meta.accessOrder : meta.insertOrder;
      if (value < candidateValue) {
        candidateValue = value;
        candidate = key;
      }
    }
    return candidate;
  }
  evictOne(reason) {
    const candidate = this.selectEvictionCandidate();
    if (!candidate)
      return null;
    const meta = this.meta.get(candidate);
    const freedBytes = meta?.compressedSize ?? 0;
    this.deleteInternal(candidate);
    this.stats.evictions++;
    if (reason === "memory" || reason === "heap") {
      this.evictedDueToMemory++;
    }
    this.onEvict?.({
      reason,
      key: candidate,
      freedBytes,
      currentBytes: this.currentMemoryBytes,
      maxMemoryBytes: this.maxMemoryBytes
    });
    return { key: candidate, freedBytes };
  }
  enforceMemoryLimit(incomingSize) {
    if (incomingSize > this.maxMemoryBytes) {
      return false;
    }
    while (this.currentMemoryBytes + incomingSize > this.maxMemoryBytes && this.storage.size > 0) {
      const result = this.evictOne("memory");
      if (!result)
        break;
    }
    return this.currentMemoryBytes + incomingSize <= this.maxMemoryBytes;
  }
  reduceMemoryTo(targetBytes) {
    targetBytes = Math.max(0, targetBytes);
    let freedBytes = 0;
    while (this.currentMemoryBytes > targetBytes && this.storage.size > 0) {
      const result = this.evictOne("memory");
      if (!result)
        break;
      freedBytes += result.freedBytes;
    }
    return freedBytes;
  }
  memoryHealthCheck() {
    let totalFreed = 0;
    if (this.currentMemoryBytes > this.maxMemoryBytes) {
      const before = this.currentMemoryBytes;
      this.enforceMemoryLimit(0);
      const freed = before - this.currentMemoryBytes;
      if (freed > 0) {
        totalFreed += freed;
        this.memoryPressureEvents++;
        this.onPressure?.({
          reason: "limit",
          heapLimit: getHeapStats().heapLimit,
          heapUsed: getHeapStats().heapUsed,
          currentBytes: this.currentMemoryBytes,
          maxMemoryBytes: this.maxMemoryBytes,
          freedBytes: freed
        });
      }
    }
    const { heapUsed, heapLimit, heapRatio } = getHeapStats();
    if (heapLimit > 0 && heapRatio >= this.heapUsageThreshold) {
      const before = this.currentMemoryBytes;
      const target = Math.floor(this.currentMemoryBytes * 0.5);
      this.reduceMemoryTo(target);
      const freed = before - this.currentMemoryBytes;
      if (freed > 0) {
        totalFreed += freed;
        this.memoryPressureEvents++;
        this.onPressure?.({
          reason: "heap",
          heapLimit,
          heapUsed,
          heapRatio,
          currentBytes: this.currentMemoryBytes,
          maxMemoryBytes: this.maxMemoryBytes,
          freedBytes: freed
        });
      }
    }
    return totalFreed;
  }
  cleanupExpired() {
    const now = Date.now();
    let cleaned = 0;
    for (const [key, meta] of this.meta) {
      if (now > meta.expiresAt) {
        this.deleteInternal(key);
        cleaned++;
        this.onEvict?.({
          reason: "expired",
          key,
          freedBytes: meta.compressedSize,
          currentBytes: this.currentMemoryBytes,
          maxMemoryBytes: this.maxMemoryBytes
        });
      }
    }
    return cleaned;
  }
};
var memoryStorage = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  MemoryStorage: MemoryStorage$1
});
var he$2 = { exports: {} };
var he$1 = he$2.exports;
var hasRequiredHe;
function requireHe() {
  if (hasRequiredHe) return he$2.exports;
  hasRequiredHe = 1;
  (function(module2, exports$1) {
    (function(root2) {
      var freeExports4 = exports$1;
      var freeModule4 = module2 && module2.exports == freeExports4 && module2;
      var freeGlobal2 = typeof commonjsGlobal == "object" && commonjsGlobal;
      if (freeGlobal2.global === freeGlobal2 || freeGlobal2.window === freeGlobal2) {
        root2 = freeGlobal2;
      }
      var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
      var regexAsciiWhitelist = /[\x01-\x7F]/g;
      var regexBmpWhitelist = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;
      var regexEncodeNonAscii = /<\u20D2|=\u20E5|>\u20D2|\u205F\u200A|\u219D\u0338|\u2202\u0338|\u2220\u20D2|\u2229\uFE00|\u222A\uFE00|\u223C\u20D2|\u223D\u0331|\u223E\u0333|\u2242\u0338|\u224B\u0338|\u224D\u20D2|\u224E\u0338|\u224F\u0338|\u2250\u0338|\u2261\u20E5|\u2264\u20D2|\u2265\u20D2|\u2266\u0338|\u2267\u0338|\u2268\uFE00|\u2269\uFE00|\u226A\u0338|\u226A\u20D2|\u226B\u0338|\u226B\u20D2|\u227F\u0338|\u2282\u20D2|\u2283\u20D2|\u228A\uFE00|\u228B\uFE00|\u228F\u0338|\u2290\u0338|\u2293\uFE00|\u2294\uFE00|\u22B4\u20D2|\u22B5\u20D2|\u22D8\u0338|\u22D9\u0338|\u22DA\uFE00|\u22DB\uFE00|\u22F5\u0338|\u22F9\u0338|\u2933\u0338|\u29CF\u0338|\u29D0\u0338|\u2A6D\u0338|\u2A70\u0338|\u2A7D\u0338|\u2A7E\u0338|\u2AA1\u0338|\u2AA2\u0338|\u2AAC\uFE00|\u2AAD\uFE00|\u2AAF\u0338|\u2AB0\u0338|\u2AC5\u0338|\u2AC6\u0338|\u2ACB\uFE00|\u2ACC\uFE00|\u2AFD\u20E5|[\xA0-\u0113\u0116-\u0122\u0124-\u012B\u012E-\u014D\u0150-\u017E\u0192\u01B5\u01F5\u0237\u02C6\u02C7\u02D8-\u02DD\u0311\u0391-\u03A1\u03A3-\u03A9\u03B1-\u03C9\u03D1\u03D2\u03D5\u03D6\u03DC\u03DD\u03F0\u03F1\u03F5\u03F6\u0401-\u040C\u040E-\u044F\u0451-\u045C\u045E\u045F\u2002-\u2005\u2007-\u2010\u2013-\u2016\u2018-\u201A\u201C-\u201E\u2020-\u2022\u2025\u2026\u2030-\u2035\u2039\u203A\u203E\u2041\u2043\u2044\u204F\u2057\u205F-\u2063\u20AC\u20DB\u20DC\u2102\u2105\u210A-\u2113\u2115-\u211E\u2122\u2124\u2127-\u2129\u212C\u212D\u212F-\u2131\u2133-\u2138\u2145-\u2148\u2153-\u215E\u2190-\u219B\u219D-\u21A7\u21A9-\u21AE\u21B0-\u21B3\u21B5-\u21B7\u21BA-\u21DB\u21DD\u21E4\u21E5\u21F5\u21FD-\u2205\u2207-\u2209\u220B\u220C\u220F-\u2214\u2216-\u2218\u221A\u221D-\u2238\u223A-\u2257\u2259\u225A\u225C\u225F-\u2262\u2264-\u228B\u228D-\u229B\u229D-\u22A5\u22A7-\u22B0\u22B2-\u22BB\u22BD-\u22DB\u22DE-\u22E3\u22E6-\u22F7\u22F9-\u22FE\u2305\u2306\u2308-\u2310\u2312\u2313\u2315\u2316\u231C-\u231F\u2322\u2323\u232D\u232E\u2336\u233D\u233F\u237C\u23B0\u23B1\u23B4-\u23B6\u23DC-\u23DF\u23E2\u23E7\u2423\u24C8\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2550-\u256C\u2580\u2584\u2588\u2591-\u2593\u25A1\u25AA\u25AB\u25AD\u25AE\u25B1\u25B3-\u25B5\u25B8\u25B9\u25BD-\u25BF\u25C2\u25C3\u25CA\u25CB\u25EC\u25EF\u25F8-\u25FC\u2605\u2606\u260E\u2640\u2642\u2660\u2663\u2665\u2666\u266A\u266D-\u266F\u2713\u2717\u2720\u2736\u2758\u2772\u2773\u27C8\u27C9\u27E6-\u27ED\u27F5-\u27FA\u27FC\u27FF\u2902-\u2905\u290C-\u2913\u2916\u2919-\u2920\u2923-\u292A\u2933\u2935-\u2939\u293C\u293D\u2945\u2948-\u294B\u294E-\u2976\u2978\u2979\u297B-\u297F\u2985\u2986\u298B-\u2996\u299A\u299C\u299D\u29A4-\u29B7\u29B9\u29BB\u29BC\u29BE-\u29C5\u29C9\u29CD-\u29D0\u29DC-\u29DE\u29E3-\u29E5\u29EB\u29F4\u29F6\u2A00-\u2A02\u2A04\u2A06\u2A0C\u2A0D\u2A10-\u2A17\u2A22-\u2A27\u2A29\u2A2A\u2A2D-\u2A31\u2A33-\u2A3C\u2A3F\u2A40\u2A42-\u2A4D\u2A50\u2A53-\u2A58\u2A5A-\u2A5D\u2A5F\u2A66\u2A6A\u2A6D-\u2A75\u2A77-\u2A9A\u2A9D-\u2AA2\u2AA4-\u2AB0\u2AB3-\u2AC8\u2ACB\u2ACC\u2ACF-\u2ADB\u2AE4\u2AE6-\u2AE9\u2AEB-\u2AF3\u2AFD\uFB00-\uFB04]|\uD835[\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDD6B]/g;
      var encodeMap = { "\xAD": "shy", "\u200C": "zwnj", "\u200D": "zwj", "\u200E": "lrm", "\u2063": "ic", "\u2062": "it", "\u2061": "af", "\u200F": "rlm", "\u200B": "ZeroWidthSpace", "\u2060": "NoBreak", "\u0311": "DownBreve", "\u20DB": "tdot", "\u20DC": "DotDot", "	": "Tab", "\n": "NewLine", "\u2008": "puncsp", "\u205F": "MediumSpace", "\u2009": "thinsp", "\u200A": "hairsp", "\u2004": "emsp13", "\u2002": "ensp", "\u2005": "emsp14", "\u2003": "emsp", "\u2007": "numsp", "\xA0": "nbsp", "\u205F\u200A": "ThickSpace", "\u203E": "oline", "_": "lowbar", "\u2010": "dash", "\u2013": "ndash", "\u2014": "mdash", "\u2015": "horbar", ",": "comma", ";": "semi", "\u204F": "bsemi", ":": "colon", "\u2A74": "Colone", "!": "excl", "\xA1": "iexcl", "?": "quest", "\xBF": "iquest", ".": "period", "\u2025": "nldr", "\u2026": "mldr", "\xB7": "middot", "'": "apos", "\u2018": "lsquo", "\u2019": "rsquo", "\u201A": "sbquo", "\u2039": "lsaquo", "\u203A": "rsaquo", '"': "quot", "\u201C": "ldquo", "\u201D": "rdquo", "\u201E": "bdquo", "\xAB": "laquo", "\xBB": "raquo", "(": "lpar", ")": "rpar", "[": "lsqb", "]": "rsqb", "{": "lcub", "}": "rcub", "\u2308": "lceil", "\u2309": "rceil", "\u230A": "lfloor", "\u230B": "rfloor", "\u2985": "lopar", "\u2986": "ropar", "\u298B": "lbrke", "\u298C": "rbrke", "\u298D": "lbrkslu", "\u298E": "rbrksld", "\u298F": "lbrksld", "\u2990": "rbrkslu", "\u2991": "langd", "\u2992": "rangd", "\u2993": "lparlt", "\u2994": "rpargt", "\u2995": "gtlPar", "\u2996": "ltrPar", "\u27E6": "lobrk", "\u27E7": "robrk", "\u27E8": "lang", "\u27E9": "rang", "\u27EA": "Lang", "\u27EB": "Rang", "\u27EC": "loang", "\u27ED": "roang", "\u2772": "lbbrk", "\u2773": "rbbrk", "\u2016": "Vert", "\xA7": "sect", "\xB6": "para", "@": "commat", "*": "ast", "/": "sol", "undefined": null, "&": "amp", "#": "num", "%": "percnt", "\u2030": "permil", "\u2031": "pertenk", "\u2020": "dagger", "\u2021": "Dagger", "\u2022": "bull", "\u2043": "hybull", "\u2032": "prime", "\u2033": "Prime", "\u2034": "tprime", "\u2057": "qprime", "\u2035": "bprime", "\u2041": "caret", "`": "grave", "\xB4": "acute", "\u02DC": "tilde", "^": "Hat", "\xAF": "macr", "\u02D8": "breve", "\u02D9": "dot", "\xA8": "die", "\u02DA": "ring", "\u02DD": "dblac", "\xB8": "cedil", "\u02DB": "ogon", "\u02C6": "circ", "\u02C7": "caron", "\xB0": "deg", "\xA9": "copy", "\xAE": "reg", "\u2117": "copysr", "\u2118": "wp", "\u211E": "rx", "\u2127": "mho", "\u2129": "iiota", "\u2190": "larr", "\u219A": "nlarr", "\u2192": "rarr", "\u219B": "nrarr", "\u2191": "uarr", "\u2193": "darr", "\u2194": "harr", "\u21AE": "nharr", "\u2195": "varr", "\u2196": "nwarr", "\u2197": "nearr", "\u2198": "searr", "\u2199": "swarr", "\u219D": "rarrw", "\u219D\u0338": "nrarrw", "\u219E": "Larr", "\u219F": "Uarr", "\u21A0": "Rarr", "\u21A1": "Darr", "\u21A2": "larrtl", "\u21A3": "rarrtl", "\u21A4": "mapstoleft", "\u21A5": "mapstoup", "\u21A6": "map", "\u21A7": "mapstodown", "\u21A9": "larrhk", "\u21AA": "rarrhk", "\u21AB": "larrlp", "\u21AC": "rarrlp", "\u21AD": "harrw", "\u21B0": "lsh", "\u21B1": "rsh", "\u21B2": "ldsh", "\u21B3": "rdsh", "\u21B5": "crarr", "\u21B6": "cularr", "\u21B7": "curarr", "\u21BA": "olarr", "\u21BB": "orarr", "\u21BC": "lharu", "\u21BD": "lhard", "\u21BE": "uharr", "\u21BF": "uharl", "\u21C0": "rharu", "\u21C1": "rhard", "\u21C2": "dharr", "\u21C3": "dharl", "\u21C4": "rlarr", "\u21C5": "udarr", "\u21C6": "lrarr", "\u21C7": "llarr", "\u21C8": "uuarr", "\u21C9": "rrarr", "\u21CA": "ddarr", "\u21CB": "lrhar", "\u21CC": "rlhar", "\u21D0": "lArr", "\u21CD": "nlArr", "\u21D1": "uArr", "\u21D2": "rArr", "\u21CF": "nrArr", "\u21D3": "dArr", "\u21D4": "iff", "\u21CE": "nhArr", "\u21D5": "vArr", "\u21D6": "nwArr", "\u21D7": "neArr", "\u21D8": "seArr", "\u21D9": "swArr", "\u21DA": "lAarr", "\u21DB": "rAarr", "\u21DD": "zigrarr", "\u21E4": "larrb", "\u21E5": "rarrb", "\u21F5": "duarr", "\u21FD": "loarr", "\u21FE": "roarr", "\u21FF": "hoarr", "\u2200": "forall", "\u2201": "comp", "\u2202": "part", "\u2202\u0338": "npart", "\u2203": "exist", "\u2204": "nexist", "\u2205": "empty", "\u2207": "Del", "\u2208": "in", "\u2209": "notin", "\u220B": "ni", "\u220C": "notni", "\u03F6": "bepsi", "\u220F": "prod", "\u2210": "coprod", "\u2211": "sum", "+": "plus", "\xB1": "pm", "\xF7": "div", "\xD7": "times", "<": "lt", "\u226E": "nlt", "<\u20D2": "nvlt", "=": "equals", "\u2260": "ne", "=\u20E5": "bne", "\u2A75": "Equal", ">": "gt", "\u226F": "ngt", ">\u20D2": "nvgt", "\xAC": "not", "|": "vert", "\xA6": "brvbar", "\u2212": "minus", "\u2213": "mp", "\u2214": "plusdo", "\u2044": "frasl", "\u2216": "setmn", "\u2217": "lowast", "\u2218": "compfn", "\u221A": "Sqrt", "\u221D": "prop", "\u221E": "infin", "\u221F": "angrt", "\u2220": "ang", "\u2220\u20D2": "nang", "\u2221": "angmsd", "\u2222": "angsph", "\u2223": "mid", "\u2224": "nmid", "\u2225": "par", "\u2226": "npar", "\u2227": "and", "\u2228": "or", "\u2229": "cap", "\u2229\uFE00": "caps", "\u222A": "cup", "\u222A\uFE00": "cups", "\u222B": "int", "\u222C": "Int", "\u222D": "tint", "\u2A0C": "qint", "\u222E": "oint", "\u222F": "Conint", "\u2230": "Cconint", "\u2231": "cwint", "\u2232": "cwconint", "\u2233": "awconint", "\u2234": "there4", "\u2235": "becaus", "\u2236": "ratio", "\u2237": "Colon", "\u2238": "minusd", "\u223A": "mDDot", "\u223B": "homtht", "\u223C": "sim", "\u2241": "nsim", "\u223C\u20D2": "nvsim", "\u223D": "bsim", "\u223D\u0331": "race", "\u223E": "ac", "\u223E\u0333": "acE", "\u223F": "acd", "\u2240": "wr", "\u2242": "esim", "\u2242\u0338": "nesim", "\u2243": "sime", "\u2244": "nsime", "\u2245": "cong", "\u2247": "ncong", "\u2246": "simne", "\u2248": "ap", "\u2249": "nap", "\u224A": "ape", "\u224B": "apid", "\u224B\u0338": "napid", "\u224C": "bcong", "\u224D": "CupCap", "\u226D": "NotCupCap", "\u224D\u20D2": "nvap", "\u224E": "bump", "\u224E\u0338": "nbump", "\u224F": "bumpe", "\u224F\u0338": "nbumpe", "\u2250": "doteq", "\u2250\u0338": "nedot", "\u2251": "eDot", "\u2252": "efDot", "\u2253": "erDot", "\u2254": "colone", "\u2255": "ecolon", "\u2256": "ecir", "\u2257": "cire", "\u2259": "wedgeq", "\u225A": "veeeq", "\u225C": "trie", "\u225F": "equest", "\u2261": "equiv", "\u2262": "nequiv", "\u2261\u20E5": "bnequiv", "\u2264": "le", "\u2270": "nle", "\u2264\u20D2": "nvle", "\u2265": "ge", "\u2271": "nge", "\u2265\u20D2": "nvge", "\u2266": "lE", "\u2266\u0338": "nlE", "\u2267": "gE", "\u2267\u0338": "ngE", "\u2268\uFE00": "lvnE", "\u2268": "lnE", "\u2269": "gnE", "\u2269\uFE00": "gvnE", "\u226A": "ll", "\u226A\u0338": "nLtv", "\u226A\u20D2": "nLt", "\u226B": "gg", "\u226B\u0338": "nGtv", "\u226B\u20D2": "nGt", "\u226C": "twixt", "\u2272": "lsim", "\u2274": "nlsim", "\u2273": "gsim", "\u2275": "ngsim", "\u2276": "lg", "\u2278": "ntlg", "\u2277": "gl", "\u2279": "ntgl", "\u227A": "pr", "\u2280": "npr", "\u227B": "sc", "\u2281": "nsc", "\u227C": "prcue", "\u22E0": "nprcue", "\u227D": "sccue", "\u22E1": "nsccue", "\u227E": "prsim", "\u227F": "scsim", "\u227F\u0338": "NotSucceedsTilde", "\u2282": "sub", "\u2284": "nsub", "\u2282\u20D2": "vnsub", "\u2283": "sup", "\u2285": "nsup", "\u2283\u20D2": "vnsup", "\u2286": "sube", "\u2288": "nsube", "\u2287": "supe", "\u2289": "nsupe", "\u228A\uFE00": "vsubne", "\u228A": "subne", "\u228B\uFE00": "vsupne", "\u228B": "supne", "\u228D": "cupdot", "\u228E": "uplus", "\u228F": "sqsub", "\u228F\u0338": "NotSquareSubset", "\u2290": "sqsup", "\u2290\u0338": "NotSquareSuperset", "\u2291": "sqsube", "\u22E2": "nsqsube", "\u2292": "sqsupe", "\u22E3": "nsqsupe", "\u2293": "sqcap", "\u2293\uFE00": "sqcaps", "\u2294": "sqcup", "\u2294\uFE00": "sqcups", "\u2295": "oplus", "\u2296": "ominus", "\u2297": "otimes", "\u2298": "osol", "\u2299": "odot", "\u229A": "ocir", "\u229B": "oast", "\u229D": "odash", "\u229E": "plusb", "\u229F": "minusb", "\u22A0": "timesb", "\u22A1": "sdotb", "\u22A2": "vdash", "\u22AC": "nvdash", "\u22A3": "dashv", "\u22A4": "top", "\u22A5": "bot", "\u22A7": "models", "\u22A8": "vDash", "\u22AD": "nvDash", "\u22A9": "Vdash", "\u22AE": "nVdash", "\u22AA": "Vvdash", "\u22AB": "VDash", "\u22AF": "nVDash", "\u22B0": "prurel", "\u22B2": "vltri", "\u22EA": "nltri", "\u22B3": "vrtri", "\u22EB": "nrtri", "\u22B4": "ltrie", "\u22EC": "nltrie", "\u22B4\u20D2": "nvltrie", "\u22B5": "rtrie", "\u22ED": "nrtrie", "\u22B5\u20D2": "nvrtrie", "\u22B6": "origof", "\u22B7": "imof", "\u22B8": "mumap", "\u22B9": "hercon", "\u22BA": "intcal", "\u22BB": "veebar", "\u22BD": "barvee", "\u22BE": "angrtvb", "\u22BF": "lrtri", "\u22C0": "Wedge", "\u22C1": "Vee", "\u22C2": "xcap", "\u22C3": "xcup", "\u22C4": "diam", "\u22C5": "sdot", "\u22C6": "Star", "\u22C7": "divonx", "\u22C8": "bowtie", "\u22C9": "ltimes", "\u22CA": "rtimes", "\u22CB": "lthree", "\u22CC": "rthree", "\u22CD": "bsime", "\u22CE": "cuvee", "\u22CF": "cuwed", "\u22D0": "Sub", "\u22D1": "Sup", "\u22D2": "Cap", "\u22D3": "Cup", "\u22D4": "fork", "\u22D5": "epar", "\u22D6": "ltdot", "\u22D7": "gtdot", "\u22D8": "Ll", "\u22D8\u0338": "nLl", "\u22D9": "Gg", "\u22D9\u0338": "nGg", "\u22DA\uFE00": "lesg", "\u22DA": "leg", "\u22DB": "gel", "\u22DB\uFE00": "gesl", "\u22DE": "cuepr", "\u22DF": "cuesc", "\u22E6": "lnsim", "\u22E7": "gnsim", "\u22E8": "prnsim", "\u22E9": "scnsim", "\u22EE": "vellip", "\u22EF": "ctdot", "\u22F0": "utdot", "\u22F1": "dtdot", "\u22F2": "disin", "\u22F3": "isinsv", "\u22F4": "isins", "\u22F5": "isindot", "\u22F5\u0338": "notindot", "\u22F6": "notinvc", "\u22F7": "notinvb", "\u22F9": "isinE", "\u22F9\u0338": "notinE", "\u22FA": "nisd", "\u22FB": "xnis", "\u22FC": "nis", "\u22FD": "notnivc", "\u22FE": "notnivb", "\u2305": "barwed", "\u2306": "Barwed", "\u230C": "drcrop", "\u230D": "dlcrop", "\u230E": "urcrop", "\u230F": "ulcrop", "\u2310": "bnot", "\u2312": "profline", "\u2313": "profsurf", "\u2315": "telrec", "\u2316": "target", "\u231C": "ulcorn", "\u231D": "urcorn", "\u231E": "dlcorn", "\u231F": "drcorn", "\u2322": "frown", "\u2323": "smile", "\u232D": "cylcty", "\u232E": "profalar", "\u2336": "topbot", "\u233D": "ovbar", "\u233F": "solbar", "\u237C": "angzarr", "\u23B0": "lmoust", "\u23B1": "rmoust", "\u23B4": "tbrk", "\u23B5": "bbrk", "\u23B6": "bbrktbrk", "\u23DC": "OverParenthesis", "\u23DD": "UnderParenthesis", "\u23DE": "OverBrace", "\u23DF": "UnderBrace", "\u23E2": "trpezium", "\u23E7": "elinters", "\u2423": "blank", "\u2500": "boxh", "\u2502": "boxv", "\u250C": "boxdr", "\u2510": "boxdl", "\u2514": "boxur", "\u2518": "boxul", "\u251C": "boxvr", "\u2524": "boxvl", "\u252C": "boxhd", "\u2534": "boxhu", "\u253C": "boxvh", "\u2550": "boxH", "\u2551": "boxV", "\u2552": "boxdR", "\u2553": "boxDr", "\u2554": "boxDR", "\u2555": "boxdL", "\u2556": "boxDl", "\u2557": "boxDL", "\u2558": "boxuR", "\u2559": "boxUr", "\u255A": "boxUR", "\u255B": "boxuL", "\u255C": "boxUl", "\u255D": "boxUL", "\u255E": "boxvR", "\u255F": "boxVr", "\u2560": "boxVR", "\u2561": "boxvL", "\u2562": "boxVl", "\u2563": "boxVL", "\u2564": "boxHd", "\u2565": "boxhD", "\u2566": "boxHD", "\u2567": "boxHu", "\u2568": "boxhU", "\u2569": "boxHU", "\u256A": "boxvH", "\u256B": "boxVh", "\u256C": "boxVH", "\u2580": "uhblk", "\u2584": "lhblk", "\u2588": "block", "\u2591": "blk14", "\u2592": "blk12", "\u2593": "blk34", "\u25A1": "squ", "\u25AA": "squf", "\u25AB": "EmptyVerySmallSquare", "\u25AD": "rect", "\u25AE": "marker", "\u25B1": "fltns", "\u25B3": "xutri", "\u25B4": "utrif", "\u25B5": "utri", "\u25B8": "rtrif", "\u25B9": "rtri", "\u25BD": "xdtri", "\u25BE": "dtrif", "\u25BF": "dtri", "\u25C2": "ltrif", "\u25C3": "ltri", "\u25CA": "loz", "\u25CB": "cir", "\u25EC": "tridot", "\u25EF": "xcirc", "\u25F8": "ultri", "\u25F9": "urtri", "\u25FA": "lltri", "\u25FB": "EmptySmallSquare", "\u25FC": "FilledSmallSquare", "\u2605": "starf", "\u2606": "star", "\u260E": "phone", "\u2640": "female", "\u2642": "male", "\u2660": "spades", "\u2663": "clubs", "\u2665": "hearts", "\u2666": "diams", "\u266A": "sung", "\u2713": "check", "\u2717": "cross", "\u2720": "malt", "\u2736": "sext", "\u2758": "VerticalSeparator", "\u27C8": "bsolhsub", "\u27C9": "suphsol", "\u27F5": "xlarr", "\u27F6": "xrarr", "\u27F7": "xharr", "\u27F8": "xlArr", "\u27F9": "xrArr", "\u27FA": "xhArr", "\u27FC": "xmap", "\u27FF": "dzigrarr", "\u2902": "nvlArr", "\u2903": "nvrArr", "\u2904": "nvHarr", "\u2905": "Map", "\u290C": "lbarr", "\u290D": "rbarr", "\u290E": "lBarr", "\u290F": "rBarr", "\u2910": "RBarr", "\u2911": "DDotrahd", "\u2912": "UpArrowBar", "\u2913": "DownArrowBar", "\u2916": "Rarrtl", "\u2919": "latail", "\u291A": "ratail", "\u291B": "lAtail", "\u291C": "rAtail", "\u291D": "larrfs", "\u291E": "rarrfs", "\u291F": "larrbfs", "\u2920": "rarrbfs", "\u2923": "nwarhk", "\u2924": "nearhk", "\u2925": "searhk", "\u2926": "swarhk", "\u2927": "nwnear", "\u2928": "toea", "\u2929": "tosa", "\u292A": "swnwar", "\u2933": "rarrc", "\u2933\u0338": "nrarrc", "\u2935": "cudarrr", "\u2936": "ldca", "\u2937": "rdca", "\u2938": "cudarrl", "\u2939": "larrpl", "\u293C": "curarrm", "\u293D": "cularrp", "\u2945": "rarrpl", "\u2948": "harrcir", "\u2949": "Uarrocir", "\u294A": "lurdshar", "\u294B": "ldrushar", "\u294E": "LeftRightVector", "\u294F": "RightUpDownVector", "\u2950": "DownLeftRightVector", "\u2951": "LeftUpDownVector", "\u2952": "LeftVectorBar", "\u2953": "RightVectorBar", "\u2954": "RightUpVectorBar", "\u2955": "RightDownVectorBar", "\u2956": "DownLeftVectorBar", "\u2957": "DownRightVectorBar", "\u2958": "LeftUpVectorBar", "\u2959": "LeftDownVectorBar", "\u295A": "LeftTeeVector", "\u295B": "RightTeeVector", "\u295C": "RightUpTeeVector", "\u295D": "RightDownTeeVector", "\u295E": "DownLeftTeeVector", "\u295F": "DownRightTeeVector", "\u2960": "LeftUpTeeVector", "\u2961": "LeftDownTeeVector", "\u2962": "lHar", "\u2963": "uHar", "\u2964": "rHar", "\u2965": "dHar", "\u2966": "luruhar", "\u2967": "ldrdhar", "\u2968": "ruluhar", "\u2969": "rdldhar", "\u296A": "lharul", "\u296B": "llhard", "\u296C": "rharul", "\u296D": "lrhard", "\u296E": "udhar", "\u296F": "duhar", "\u2970": "RoundImplies", "\u2971": "erarr", "\u2972": "simrarr", "\u2973": "larrsim", "\u2974": "rarrsim", "\u2975": "rarrap", "\u2976": "ltlarr", "\u2978": "gtrarr", "\u2979": "subrarr", "\u297B": "suplarr", "\u297C": "lfisht", "\u297D": "rfisht", "\u297E": "ufisht", "\u297F": "dfisht", "\u299A": "vzigzag", "\u299C": "vangrt", "\u299D": "angrtvbd", "\u29A4": "ange", "\u29A5": "range", "\u29A6": "dwangle", "\u29A7": "uwangle", "\u29A8": "angmsdaa", "\u29A9": "angmsdab", "\u29AA": "angmsdac", "\u29AB": "angmsdad", "\u29AC": "angmsdae", "\u29AD": "angmsdaf", "\u29AE": "angmsdag", "\u29AF": "angmsdah", "\u29B0": "bemptyv", "\u29B1": "demptyv", "\u29B2": "cemptyv", "\u29B3": "raemptyv", "\u29B4": "laemptyv", "\u29B5": "ohbar", "\u29B6": "omid", "\u29B7": "opar", "\u29B9": "operp", "\u29BB": "olcross", "\u29BC": "odsold", "\u29BE": "olcir", "\u29BF": "ofcir", "\u29C0": "olt", "\u29C1": "ogt", "\u29C2": "cirscir", "\u29C3": "cirE", "\u29C4": "solb", "\u29C5": "bsolb", "\u29C9": "boxbox", "\u29CD": "trisb", "\u29CE": "rtriltri", "\u29CF": "LeftTriangleBar", "\u29CF\u0338": "NotLeftTriangleBar", "\u29D0": "RightTriangleBar", "\u29D0\u0338": "NotRightTriangleBar", "\u29DC": "iinfin", "\u29DD": "infintie", "\u29DE": "nvinfin", "\u29E3": "eparsl", "\u29E4": "smeparsl", "\u29E5": "eqvparsl", "\u29EB": "lozf", "\u29F4": "RuleDelayed", "\u29F6": "dsol", "\u2A00": "xodot", "\u2A01": "xoplus", "\u2A02": "xotime", "\u2A04": "xuplus", "\u2A06": "xsqcup", "\u2A0D": "fpartint", "\u2A10": "cirfnint", "\u2A11": "awint", "\u2A12": "rppolint", "\u2A13": "scpolint", "\u2A14": "npolint", "\u2A15": "pointint", "\u2A16": "quatint", "\u2A17": "intlarhk", "\u2A22": "pluscir", "\u2A23": "plusacir", "\u2A24": "simplus", "\u2A25": "plusdu", "\u2A26": "plussim", "\u2A27": "plustwo", "\u2A29": "mcomma", "\u2A2A": "minusdu", "\u2A2D": "loplus", "\u2A2E": "roplus", "\u2A2F": "Cross", "\u2A30": "timesd", "\u2A31": "timesbar", "\u2A33": "smashp", "\u2A34": "lotimes", "\u2A35": "rotimes", "\u2A36": "otimesas", "\u2A37": "Otimes", "\u2A38": "odiv", "\u2A39": "triplus", "\u2A3A": "triminus", "\u2A3B": "tritime", "\u2A3C": "iprod", "\u2A3F": "amalg", "\u2A40": "capdot", "\u2A42": "ncup", "\u2A43": "ncap", "\u2A44": "capand", "\u2A45": "cupor", "\u2A46": "cupcap", "\u2A47": "capcup", "\u2A48": "cupbrcap", "\u2A49": "capbrcup", "\u2A4A": "cupcup", "\u2A4B": "capcap", "\u2A4C": "ccups", "\u2A4D": "ccaps", "\u2A50": "ccupssm", "\u2A53": "And", "\u2A54": "Or", "\u2A55": "andand", "\u2A56": "oror", "\u2A57": "orslope", "\u2A58": "andslope", "\u2A5A": "andv", "\u2A5B": "orv", "\u2A5C": "andd", "\u2A5D": "ord", "\u2A5F": "wedbar", "\u2A66": "sdote", "\u2A6A": "simdot", "\u2A6D": "congdot", "\u2A6D\u0338": "ncongdot", "\u2A6E": "easter", "\u2A6F": "apacir", "\u2A70": "apE", "\u2A70\u0338": "napE", "\u2A71": "eplus", "\u2A72": "pluse", "\u2A73": "Esim", "\u2A77": "eDDot", "\u2A78": "equivDD", "\u2A79": "ltcir", "\u2A7A": "gtcir", "\u2A7B": "ltquest", "\u2A7C": "gtquest", "\u2A7D": "les", "\u2A7D\u0338": "nles", "\u2A7E": "ges", "\u2A7E\u0338": "nges", "\u2A7F": "lesdot", "\u2A80": "gesdot", "\u2A81": "lesdoto", "\u2A82": "gesdoto", "\u2A83": "lesdotor", "\u2A84": "gesdotol", "\u2A85": "lap", "\u2A86": "gap", "\u2A87": "lne", "\u2A88": "gne", "\u2A89": "lnap", "\u2A8A": "gnap", "\u2A8B": "lEg", "\u2A8C": "gEl", "\u2A8D": "lsime", "\u2A8E": "gsime", "\u2A8F": "lsimg", "\u2A90": "gsiml", "\u2A91": "lgE", "\u2A92": "glE", "\u2A93": "lesges", "\u2A94": "gesles", "\u2A95": "els", "\u2A96": "egs", "\u2A97": "elsdot", "\u2A98": "egsdot", "\u2A99": "el", "\u2A9A": "eg", "\u2A9D": "siml", "\u2A9E": "simg", "\u2A9F": "simlE", "\u2AA0": "simgE", "\u2AA1": "LessLess", "\u2AA1\u0338": "NotNestedLessLess", "\u2AA2": "GreaterGreater", "\u2AA2\u0338": "NotNestedGreaterGreater", "\u2AA4": "glj", "\u2AA5": "gla", "\u2AA6": "ltcc", "\u2AA7": "gtcc", "\u2AA8": "lescc", "\u2AA9": "gescc", "\u2AAA": "smt", "\u2AAB": "lat", "\u2AAC": "smte", "\u2AAC\uFE00": "smtes", "\u2AAD": "late", "\u2AAD\uFE00": "lates", "\u2AAE": "bumpE", "\u2AAF": "pre", "\u2AAF\u0338": "npre", "\u2AB0": "sce", "\u2AB0\u0338": "nsce", "\u2AB3": "prE", "\u2AB4": "scE", "\u2AB5": "prnE", "\u2AB6": "scnE", "\u2AB7": "prap", "\u2AB8": "scap", "\u2AB9": "prnap", "\u2ABA": "scnap", "\u2ABB": "Pr", "\u2ABC": "Sc", "\u2ABD": "subdot", "\u2ABE": "supdot", "\u2ABF": "subplus", "\u2AC0": "supplus", "\u2AC1": "submult", "\u2AC2": "supmult", "\u2AC3": "subedot", "\u2AC4": "supedot", "\u2AC5": "subE", "\u2AC5\u0338": "nsubE", "\u2AC6": "supE", "\u2AC6\u0338": "nsupE", "\u2AC7": "subsim", "\u2AC8": "supsim", "\u2ACB\uFE00": "vsubnE", "\u2ACB": "subnE", "\u2ACC\uFE00": "vsupnE", "\u2ACC": "supnE", "\u2ACF": "csub", "\u2AD0": "csup", "\u2AD1": "csube", "\u2AD2": "csupe", "\u2AD3": "subsup", "\u2AD4": "supsub", "\u2AD5": "subsub", "\u2AD6": "supsup", "\u2AD7": "suphsub", "\u2AD8": "supdsub", "\u2AD9": "forkv", "\u2ADA": "topfork", "\u2ADB": "mlcp", "\u2AE4": "Dashv", "\u2AE6": "Vdashl", "\u2AE7": "Barv", "\u2AE8": "vBar", "\u2AE9": "vBarv", "\u2AEB": "Vbar", "\u2AEC": "Not", "\u2AED": "bNot", "\u2AEE": "rnmid", "\u2AEF": "cirmid", "\u2AF0": "midcir", "\u2AF1": "topcir", "\u2AF2": "nhpar", "\u2AF3": "parsim", "\u2AFD": "parsl", "\u2AFD\u20E5": "nparsl", "\u266D": "flat", "\u266E": "natur", "\u266F": "sharp", "\xA4": "curren", "\xA2": "cent", "$": "dollar", "\xA3": "pound", "\xA5": "yen", "\u20AC": "euro", "\xB9": "sup1", "\xBD": "half", "\u2153": "frac13", "\xBC": "frac14", "\u2155": "frac15", "\u2159": "frac16", "\u215B": "frac18", "\xB2": "sup2", "\u2154": "frac23", "\u2156": "frac25", "\xB3": "sup3", "\xBE": "frac34", "\u2157": "frac35", "\u215C": "frac38", "\u2158": "frac45", "\u215A": "frac56", "\u215D": "frac58", "\u215E": "frac78", "\u{1D4B6}": "ascr", "\u{1D552}": "aopf", "\u{1D51E}": "afr", "\u{1D538}": "Aopf", "\u{1D504}": "Afr", "\u{1D49C}": "Ascr", "\xAA": "ordf", "\xE1": "aacute", "\xC1": "Aacute", "\xE0": "agrave", "\xC0": "Agrave", "\u0103": "abreve", "\u0102": "Abreve", "\xE2": "acirc", "\xC2": "Acirc", "\xE5": "aring", "\xC5": "angst", "\xE4": "auml", "\xC4": "Auml", "\xE3": "atilde", "\xC3": "Atilde", "\u0105": "aogon", "\u0104": "Aogon", "\u0101": "amacr", "\u0100": "Amacr", "\xE6": "aelig", "\xC6": "AElig", "\u{1D4B7}": "bscr", "\u{1D553}": "bopf", "\u{1D51F}": "bfr", "\u{1D539}": "Bopf", "\u212C": "Bscr", "\u{1D505}": "Bfr", "\u{1D520}": "cfr", "\u{1D4B8}": "cscr", "\u{1D554}": "copf", "\u212D": "Cfr", "\u{1D49E}": "Cscr", "\u2102": "Copf", "\u0107": "cacute", "\u0106": "Cacute", "\u0109": "ccirc", "\u0108": "Ccirc", "\u010D": "ccaron", "\u010C": "Ccaron", "\u010B": "cdot", "\u010A": "Cdot", "\xE7": "ccedil", "\xC7": "Ccedil", "\u2105": "incare", "\u{1D521}": "dfr", "\u2146": "dd", "\u{1D555}": "dopf", "\u{1D4B9}": "dscr", "\u{1D49F}": "Dscr", "\u{1D507}": "Dfr", "\u2145": "DD", "\u{1D53B}": "Dopf", "\u010F": "dcaron", "\u010E": "Dcaron", "\u0111": "dstrok", "\u0110": "Dstrok", "\xF0": "eth", "\xD0": "ETH", "\u2147": "ee", "\u212F": "escr", "\u{1D522}": "efr", "\u{1D556}": "eopf", "\u2130": "Escr", "\u{1D508}": "Efr", "\u{1D53C}": "Eopf", "\xE9": "eacute", "\xC9": "Eacute", "\xE8": "egrave", "\xC8": "Egrave", "\xEA": "ecirc", "\xCA": "Ecirc", "\u011B": "ecaron", "\u011A": "Ecaron", "\xEB": "euml", "\xCB": "Euml", "\u0117": "edot", "\u0116": "Edot", "\u0119": "eogon", "\u0118": "Eogon", "\u0113": "emacr", "\u0112": "Emacr", "\u{1D523}": "ffr", "\u{1D557}": "fopf", "\u{1D4BB}": "fscr", "\u{1D509}": "Ffr", "\u{1D53D}": "Fopf", "\u2131": "Fscr", "\uFB00": "fflig", "\uFB03": "ffilig", "\uFB04": "ffllig", "\uFB01": "filig", "fj": "fjlig", "\uFB02": "fllig", "\u0192": "fnof", "\u210A": "gscr", "\u{1D558}": "gopf", "\u{1D524}": "gfr", "\u{1D4A2}": "Gscr", "\u{1D53E}": "Gopf", "\u{1D50A}": "Gfr", "\u01F5": "gacute", "\u011F": "gbreve", "\u011E": "Gbreve", "\u011D": "gcirc", "\u011C": "Gcirc", "\u0121": "gdot", "\u0120": "Gdot", "\u0122": "Gcedil", "\u{1D525}": "hfr", "\u210E": "planckh", "\u{1D4BD}": "hscr", "\u{1D559}": "hopf", "\u210B": "Hscr", "\u210C": "Hfr", "\u210D": "Hopf", "\u0125": "hcirc", "\u0124": "Hcirc", "\u210F": "hbar", "\u0127": "hstrok", "\u0126": "Hstrok", "\u{1D55A}": "iopf", "\u{1D526}": "ifr", "\u{1D4BE}": "iscr", "\u2148": "ii", "\u{1D540}": "Iopf", "\u2110": "Iscr", "\u2111": "Im", "\xED": "iacute", "\xCD": "Iacute", "\xEC": "igrave", "\xCC": "Igrave", "\xEE": "icirc", "\xCE": "Icirc", "\xEF": "iuml", "\xCF": "Iuml", "\u0129": "itilde", "\u0128": "Itilde", "\u0130": "Idot", "\u012F": "iogon", "\u012E": "Iogon", "\u012B": "imacr", "\u012A": "Imacr", "\u0133": "ijlig", "\u0132": "IJlig", "\u0131": "imath", "\u{1D4BF}": "jscr", "\u{1D55B}": "jopf", "\u{1D527}": "jfr", "\u{1D4A5}": "Jscr", "\u{1D50D}": "Jfr", "\u{1D541}": "Jopf", "\u0135": "jcirc", "\u0134": "Jcirc", "\u0237": "jmath", "\u{1D55C}": "kopf", "\u{1D4C0}": "kscr", "\u{1D528}": "kfr", "\u{1D4A6}": "Kscr", "\u{1D542}": "Kopf", "\u{1D50E}": "Kfr", "\u0137": "kcedil", "\u0136": "Kcedil", "\u{1D529}": "lfr", "\u{1D4C1}": "lscr", "\u2113": "ell", "\u{1D55D}": "lopf", "\u2112": "Lscr", "\u{1D50F}": "Lfr", "\u{1D543}": "Lopf", "\u013A": "lacute", "\u0139": "Lacute", "\u013E": "lcaron", "\u013D": "Lcaron", "\u013C": "lcedil", "\u013B": "Lcedil", "\u0142": "lstrok", "\u0141": "Lstrok", "\u0140": "lmidot", "\u013F": "Lmidot", "\u{1D52A}": "mfr", "\u{1D55E}": "mopf", "\u{1D4C2}": "mscr", "\u{1D510}": "Mfr", "\u{1D544}": "Mopf", "\u2133": "Mscr", "\u{1D52B}": "nfr", "\u{1D55F}": "nopf", "\u{1D4C3}": "nscr", "\u2115": "Nopf", "\u{1D4A9}": "Nscr", "\u{1D511}": "Nfr", "\u0144": "nacute", "\u0143": "Nacute", "\u0148": "ncaron", "\u0147": "Ncaron", "\xF1": "ntilde", "\xD1": "Ntilde", "\u0146": "ncedil", "\u0145": "Ncedil", "\u2116": "numero", "\u014B": "eng", "\u014A": "ENG", "\u{1D560}": "oopf", "\u{1D52C}": "ofr", "\u2134": "oscr", "\u{1D4AA}": "Oscr", "\u{1D512}": "Ofr", "\u{1D546}": "Oopf", "\xBA": "ordm", "\xF3": "oacute", "\xD3": "Oacute", "\xF2": "ograve", "\xD2": "Ograve", "\xF4": "ocirc", "\xD4": "Ocirc", "\xF6": "ouml", "\xD6": "Ouml", "\u0151": "odblac", "\u0150": "Odblac", "\xF5": "otilde", "\xD5": "Otilde", "\xF8": "oslash", "\xD8": "Oslash", "\u014D": "omacr", "\u014C": "Omacr", "\u0153": "oelig", "\u0152": "OElig", "\u{1D52D}": "pfr", "\u{1D4C5}": "pscr", "\u{1D561}": "popf", "\u2119": "Popf", "\u{1D513}": "Pfr", "\u{1D4AB}": "Pscr", "\u{1D562}": "qopf", "\u{1D52E}": "qfr", "\u{1D4C6}": "qscr", "\u{1D4AC}": "Qscr", "\u{1D514}": "Qfr", "\u211A": "Qopf", "\u0138": "kgreen", "\u{1D52F}": "rfr", "\u{1D563}": "ropf", "\u{1D4C7}": "rscr", "\u211B": "Rscr", "\u211C": "Re", "\u211D": "Ropf", "\u0155": "racute", "\u0154": "Racute", "\u0159": "rcaron", "\u0158": "Rcaron", "\u0157": "rcedil", "\u0156": "Rcedil", "\u{1D564}": "sopf", "\u{1D4C8}": "sscr", "\u{1D530}": "sfr", "\u{1D54A}": "Sopf", "\u{1D516}": "Sfr", "\u{1D4AE}": "Sscr", "\u24C8": "oS", "\u015B": "sacute", "\u015A": "Sacute", "\u015D": "scirc", "\u015C": "Scirc", "\u0161": "scaron", "\u0160": "Scaron", "\u015F": "scedil", "\u015E": "Scedil", "\xDF": "szlig", "\u{1D531}": "tfr", "\u{1D4C9}": "tscr", "\u{1D565}": "topf", "\u{1D4AF}": "Tscr", "\u{1D517}": "Tfr", "\u{1D54B}": "Topf", "\u0165": "tcaron", "\u0164": "Tcaron", "\u0163": "tcedil", "\u0162": "Tcedil", "\u2122": "trade", "\u0167": "tstrok", "\u0166": "Tstrok", "\u{1D4CA}": "uscr", "\u{1D566}": "uopf", "\u{1D532}": "ufr", "\u{1D54C}": "Uopf", "\u{1D518}": "Ufr", "\u{1D4B0}": "Uscr", "\xFA": "uacute", "\xDA": "Uacute", "\xF9": "ugrave", "\xD9": "Ugrave", "\u016D": "ubreve", "\u016C": "Ubreve", "\xFB": "ucirc", "\xDB": "Ucirc", "\u016F": "uring", "\u016E": "Uring", "\xFC": "uuml", "\xDC": "Uuml", "\u0171": "udblac", "\u0170": "Udblac", "\u0169": "utilde", "\u0168": "Utilde", "\u0173": "uogon", "\u0172": "Uogon", "\u016B": "umacr", "\u016A": "Umacr", "\u{1D533}": "vfr", "\u{1D567}": "vopf", "\u{1D4CB}": "vscr", "\u{1D519}": "Vfr", "\u{1D54D}": "Vopf", "\u{1D4B1}": "Vscr", "\u{1D568}": "wopf", "\u{1D4CC}": "wscr", "\u{1D534}": "wfr", "\u{1D4B2}": "Wscr", "\u{1D54E}": "Wopf", "\u{1D51A}": "Wfr", "\u0175": "wcirc", "\u0174": "Wcirc", "\u{1D535}": "xfr", "\u{1D4CD}": "xscr", "\u{1D569}": "xopf", "\u{1D54F}": "Xopf", "\u{1D51B}": "Xfr", "\u{1D4B3}": "Xscr", "\u{1D536}": "yfr", "\u{1D4CE}": "yscr", "\u{1D56A}": "yopf", "\u{1D4B4}": "Yscr", "\u{1D51C}": "Yfr", "\u{1D550}": "Yopf", "\xFD": "yacute", "\xDD": "Yacute", "\u0177": "ycirc", "\u0176": "Ycirc", "\xFF": "yuml", "\u0178": "Yuml", "\u{1D4CF}": "zscr", "\u{1D537}": "zfr", "\u{1D56B}": "zopf", "\u2128": "Zfr", "\u2124": "Zopf", "\u{1D4B5}": "Zscr", "\u017A": "zacute", "\u0179": "Zacute", "\u017E": "zcaron", "\u017D": "Zcaron", "\u017C": "zdot", "\u017B": "Zdot", "\u01B5": "imped", "\xFE": "thorn", "\xDE": "THORN", "\u0149": "napos", "\u03B1": "alpha", "\u0391": "Alpha", "\u03B2": "beta", "\u0392": "Beta", "\u03B3": "gamma", "\u0393": "Gamma", "\u03B4": "delta", "\u0394": "Delta", "\u03B5": "epsi", "\u03F5": "epsiv", "\u0395": "Epsilon", "\u03DD": "gammad", "\u03DC": "Gammad", "\u03B6": "zeta", "\u0396": "Zeta", "\u03B7": "eta", "\u0397": "Eta", "\u03B8": "theta", "\u03D1": "thetav", "\u0398": "Theta", "\u03B9": "iota", "\u0399": "Iota", "\u03BA": "kappa", "\u03F0": "kappav", "\u039A": "Kappa", "\u03BB": "lambda", "\u039B": "Lambda", "\u03BC": "mu", "\xB5": "micro", "\u039C": "Mu", "\u03BD": "nu", "\u039D": "Nu", "\u03BE": "xi", "\u039E": "Xi", "\u03BF": "omicron", "\u039F": "Omicron", "\u03C0": "pi", "\u03D6": "piv", "\u03A0": "Pi", "\u03C1": "rho", "\u03F1": "rhov", "\u03A1": "Rho", "\u03C3": "sigma", "\u03A3": "Sigma", "\u03C2": "sigmaf", "\u03C4": "tau", "\u03A4": "Tau", "\u03C5": "upsi", "\u03A5": "Upsilon", "\u03D2": "Upsi", "\u03C6": "phi", "\u03D5": "phiv", "\u03A6": "Phi", "\u03C7": "chi", "\u03A7": "Chi", "\u03C8": "psi", "\u03A8": "Psi", "\u03C9": "omega", "\u03A9": "ohm", "\u0430": "acy", "\u0410": "Acy", "\u0431": "bcy", "\u0411": "Bcy", "\u0432": "vcy", "\u0412": "Vcy", "\u0433": "gcy", "\u0413": "Gcy", "\u0453": "gjcy", "\u0403": "GJcy", "\u0434": "dcy", "\u0414": "Dcy", "\u0452": "djcy", "\u0402": "DJcy", "\u0435": "iecy", "\u0415": "IEcy", "\u0451": "iocy", "\u0401": "IOcy", "\u0454": "jukcy", "\u0404": "Jukcy", "\u0436": "zhcy", "\u0416": "ZHcy", "\u0437": "zcy", "\u0417": "Zcy", "\u0455": "dscy", "\u0405": "DScy", "\u0438": "icy", "\u0418": "Icy", "\u0456": "iukcy", "\u0406": "Iukcy", "\u0457": "yicy", "\u0407": "YIcy", "\u0439": "jcy", "\u0419": "Jcy", "\u0458": "jsercy", "\u0408": "Jsercy", "\u043A": "kcy", "\u041A": "Kcy", "\u045C": "kjcy", "\u040C": "KJcy", "\u043B": "lcy", "\u041B": "Lcy", "\u0459": "ljcy", "\u0409": "LJcy", "\u043C": "mcy", "\u041C": "Mcy", "\u043D": "ncy", "\u041D": "Ncy", "\u045A": "njcy", "\u040A": "NJcy", "\u043E": "ocy", "\u041E": "Ocy", "\u043F": "pcy", "\u041F": "Pcy", "\u0440": "rcy", "\u0420": "Rcy", "\u0441": "scy", "\u0421": "Scy", "\u0442": "tcy", "\u0422": "Tcy", "\u045B": "tshcy", "\u040B": "TSHcy", "\u0443": "ucy", "\u0423": "Ucy", "\u045E": "ubrcy", "\u040E": "Ubrcy", "\u0444": "fcy", "\u0424": "Fcy", "\u0445": "khcy", "\u0425": "KHcy", "\u0446": "tscy", "\u0426": "TScy", "\u0447": "chcy", "\u0427": "CHcy", "\u045F": "dzcy", "\u040F": "DZcy", "\u0448": "shcy", "\u0428": "SHcy", "\u0449": "shchcy", "\u0429": "SHCHcy", "\u044A": "hardcy", "\u042A": "HARDcy", "\u044B": "ycy", "\u042B": "Ycy", "\u044C": "softcy", "\u042C": "SOFTcy", "\u044D": "ecy", "\u042D": "Ecy", "\u044E": "yucy", "\u042E": "YUcy", "\u044F": "yacy", "\u042F": "YAcy", "\u2135": "aleph", "\u2136": "beth", "\u2137": "gimel", "\u2138": "daleth" };
      var regexEscape = /["&'<>`]/g;
      var escapeMap = {
        '"': "&quot;",
        "&": "&amp;",
        "'": "&#x27;",
        "<": "&lt;",
        // See https://mathiasbynens.be/notes/ambiguous-ampersands: in HTML, the
        // following is not strictly necessary unless its part of a tag or an
        // unquoted attribute value. Were only escaping it to support those
        // situations, and for XML support.
        ">": "&gt;",
        // In Internet Explorer  8, the backtick character can be used
        // to break out of (un)quoted attribute values or HTML comments.
        // See http://html5sec.org/#102, http://html5sec.org/#108, and
        // http://html5sec.org/#133.
        "`": "&#x60;"
      };
      var regexInvalidEntity = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/;
      var regexInvalidRawCodePoint = /[\0-\x08\x0B\x0E-\x1F\x7F-\x9F\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
      var regexDecode = /&(CounterClockwiseContourIntegral|DoubleLongLeftRightArrow|ClockwiseContourIntegral|NotNestedGreaterGreater|NotSquareSupersetEqual|DiacriticalDoubleAcute|NotRightTriangleEqual|NotSucceedsSlantEqual|NotPrecedesSlantEqual|CloseCurlyDoubleQuote|NegativeVeryThinSpace|DoubleContourIntegral|FilledVerySmallSquare|CapitalDifferentialD|OpenCurlyDoubleQuote|EmptyVerySmallSquare|NestedGreaterGreater|DoubleLongRightArrow|NotLeftTriangleEqual|NotGreaterSlantEqual|ReverseUpEquilibrium|DoubleLeftRightArrow|NotSquareSubsetEqual|NotDoubleVerticalBar|RightArrowLeftArrow|NotGreaterFullEqual|NotRightTriangleBar|SquareSupersetEqual|DownLeftRightVector|DoubleLongLeftArrow|leftrightsquigarrow|LeftArrowRightArrow|NegativeMediumSpace|blacktriangleright|RightDownVectorBar|PrecedesSlantEqual|RightDoubleBracket|SucceedsSlantEqual|NotLeftTriangleBar|RightTriangleEqual|SquareIntersection|RightDownTeeVector|ReverseEquilibrium|NegativeThickSpace|longleftrightarrow|Longleftrightarrow|LongLeftRightArrow|DownRightTeeVector|DownRightVectorBar|GreaterSlantEqual|SquareSubsetEqual|LeftDownVectorBar|LeftDoubleBracket|VerticalSeparator|rightleftharpoons|NotGreaterGreater|NotSquareSuperset|blacktriangleleft|blacktriangledown|NegativeThinSpace|LeftDownTeeVector|NotLessSlantEqual|leftrightharpoons|DoubleUpDownArrow|DoubleVerticalBar|LeftTriangleEqual|FilledSmallSquare|twoheadrightarrow|NotNestedLessLess|DownLeftTeeVector|DownLeftVectorBar|RightAngleBracket|NotTildeFullEqual|NotReverseElement|RightUpDownVector|DiacriticalTilde|NotSucceedsTilde|circlearrowright|NotPrecedesEqual|rightharpoondown|DoubleRightArrow|NotSucceedsEqual|NonBreakingSpace|NotRightTriangle|LessEqualGreater|RightUpTeeVector|LeftAngleBracket|GreaterFullEqual|DownArrowUpArrow|RightUpVectorBar|twoheadleftarrow|GreaterEqualLess|downharpoonright|RightTriangleBar|ntrianglerighteq|NotSupersetEqual|LeftUpDownVector|DiacriticalAcute|rightrightarrows|vartriangleright|UpArrowDownArrow|DiacriticalGrave|UnderParenthesis|EmptySmallSquare|LeftUpVectorBar|leftrightarrows|DownRightVector|downharpoonleft|trianglerighteq|ShortRightArrow|OverParenthesis|DoubleLeftArrow|DoubleDownArrow|NotSquareSubset|bigtriangledown|ntrianglelefteq|UpperRightArrow|curvearrowright|vartriangleleft|NotLeftTriangle|nleftrightarrow|LowerRightArrow|NotHumpDownHump|NotGreaterTilde|rightthreetimes|LeftUpTeeVector|NotGreaterEqual|straightepsilon|LeftTriangleBar|rightsquigarrow|ContourIntegral|rightleftarrows|CloseCurlyQuote|RightDownVector|LeftRightVector|nLeftrightarrow|leftharpoondown|circlearrowleft|SquareSuperset|OpenCurlyQuote|hookrightarrow|HorizontalLine|DiacriticalDot|NotLessGreater|ntriangleright|DoubleRightTee|InvisibleComma|InvisibleTimes|LowerLeftArrow|DownLeftVector|NotSubsetEqual|curvearrowleft|trianglelefteq|NotVerticalBar|TildeFullEqual|downdownarrows|NotGreaterLess|RightTeeVector|ZeroWidthSpace|looparrowright|LongRightArrow|doublebarwedge|ShortLeftArrow|ShortDownArrow|RightVectorBar|GreaterGreater|ReverseElement|rightharpoonup|LessSlantEqual|leftthreetimes|upharpoonright|rightarrowtail|LeftDownVector|Longrightarrow|NestedLessLess|UpperLeftArrow|nshortparallel|leftleftarrows|leftrightarrow|Leftrightarrow|LeftRightArrow|longrightarrow|upharpoonleft|RightArrowBar|ApplyFunction|LeftTeeVector|leftarrowtail|NotEqualTilde|varsubsetneqq|varsupsetneqq|RightTeeArrow|SucceedsEqual|SucceedsTilde|LeftVectorBar|SupersetEqual|hookleftarrow|DifferentialD|VerticalTilde|VeryThinSpace|blacktriangle|bigtriangleup|LessFullEqual|divideontimes|leftharpoonup|UpEquilibrium|ntriangleleft|RightTriangle|measuredangle|shortparallel|longleftarrow|Longleftarrow|LongLeftArrow|DoubleLeftTee|Poincareplane|PrecedesEqual|triangleright|DoubleUpArrow|RightUpVector|fallingdotseq|looparrowleft|PrecedesTilde|NotTildeEqual|NotTildeTilde|smallsetminus|Proportional|triangleleft|triangledown|UnderBracket|NotHumpEqual|exponentiale|ExponentialE|NotLessTilde|HilbertSpace|RightCeiling|blacklozenge|varsupsetneq|HumpDownHump|GreaterEqual|VerticalLine|LeftTeeArrow|NotLessEqual|DownTeeArrow|LeftTriangle|varsubsetneq|Intersection|NotCongruent|DownArrowBar|LeftUpVector|LeftArrowBar|risingdotseq|GreaterTilde|RoundImplies|SquareSubset|ShortUpArrow|NotSuperset|quaternions|precnapprox|backepsilon|preccurlyeq|OverBracket|blacksquare|MediumSpace|VerticalBar|circledcirc|circleddash|CircleMinus|CircleTimes|LessGreater|curlyeqprec|curlyeqsucc|diamondsuit|UpDownArrow|Updownarrow|RuleDelayed|Rrightarrow|updownarrow|RightVector|nRightarrow|nrightarrow|eqslantless|LeftCeiling|Equilibrium|SmallCircle|expectation|NotSucceeds|thickapprox|GreaterLess|SquareUnion|NotPrecedes|NotLessLess|straightphi|succnapprox|succcurlyeq|SubsetEqual|sqsupseteq|Proportion|Laplacetrf|ImaginaryI|supsetneqq|NotGreater|gtreqqless|NotElement|ThickSpace|TildeEqual|TildeTilde|Fouriertrf|rmoustache|EqualTilde|eqslantgtr|UnderBrace|LeftVector|UpArrowBar|nLeftarrow|nsubseteqq|subsetneqq|nsupseteqq|nleftarrow|succapprox|lessapprox|UpTeeArrow|upuparrows|curlywedge|lesseqqgtr|varepsilon|varnothing|RightFloor|complement|CirclePlus|sqsubseteq|Lleftarrow|circledast|RightArrow|Rightarrow|rightarrow|lmoustache|Bernoullis|precapprox|mapstoleft|mapstodown|longmapsto|dotsquare|downarrow|DoubleDot|nsubseteq|supsetneq|leftarrow|nsupseteq|subsetneq|ThinSpace|ngeqslant|subseteqq|HumpEqual|NotSubset|triangleq|NotCupCap|lesseqgtr|heartsuit|TripleDot|Leftarrow|Coproduct|Congruent|varpropto|complexes|gvertneqq|LeftArrow|LessTilde|supseteqq|MinusPlus|CircleDot|nleqslant|NotExists|gtreqless|nparallel|UnionPlus|LeftFloor|checkmark|CenterDot|centerdot|Mellintrf|gtrapprox|bigotimes|OverBrace|spadesuit|therefore|pitchfork|rationals|PlusMinus|Backslash|Therefore|DownBreve|backsimeq|backprime|DownArrow|nshortmid|Downarrow|lvertneqq|eqvparsl|imagline|imagpart|infintie|integers|Integral|intercal|LessLess|Uarrocir|intlarhk|sqsupset|angmsdaf|sqsubset|llcorner|vartheta|cupbrcap|lnapprox|Superset|SuchThat|succnsim|succneqq|angmsdag|biguplus|curlyvee|trpezium|Succeeds|NotTilde|bigwedge|angmsdah|angrtvbd|triminus|cwconint|fpartint|lrcorner|smeparsl|subseteq|urcorner|lurdshar|laemptyv|DDotrahd|approxeq|ldrushar|awconint|mapstoup|backcong|shortmid|triangle|geqslant|gesdotol|timesbar|circledR|circledS|setminus|multimap|naturals|scpolint|ncongdot|RightTee|boxminus|gnapprox|boxtimes|andslope|thicksim|angmsdaa|varsigma|cirfnint|rtriltri|angmsdab|rppolint|angmsdac|barwedge|drbkarow|clubsuit|thetasym|bsolhsub|capbrcup|dzigrarr|doteqdot|DotEqual|dotminus|UnderBar|NotEqual|realpart|otimesas|ulcorner|hksearow|hkswarow|parallel|PartialD|elinters|emptyset|plusacir|bbrktbrk|angmsdad|pointint|bigoplus|angmsdae|Precedes|bigsqcup|varkappa|notindot|supseteq|precneqq|precnsim|profalar|profline|profsurf|leqslant|lesdotor|raemptyv|subplus|notnivb|notnivc|subrarr|zigrarr|vzigzag|submult|subedot|Element|between|cirscir|larrbfs|larrsim|lotimes|lbrksld|lbrkslu|lozenge|ldrdhar|dbkarow|bigcirc|epsilon|simrarr|simplus|ltquest|Epsilon|luruhar|gtquest|maltese|npolint|eqcolon|npreceq|bigodot|ddagger|gtrless|bnequiv|harrcir|ddotseq|equivDD|backsim|demptyv|nsqsube|nsqsupe|Upsilon|nsubset|upsilon|minusdu|nsucceq|swarrow|nsupset|coloneq|searrow|boxplus|napprox|natural|asympeq|alefsym|congdot|nearrow|bigstar|diamond|supplus|tritime|LeftTee|nvinfin|triplus|NewLine|nvltrie|nvrtrie|nwarrow|nexists|Diamond|ruluhar|Implies|supmult|angzarr|suplarr|suphsub|questeq|because|digamma|Because|olcross|bemptyv|omicron|Omicron|rotimes|NoBreak|intprod|angrtvb|orderof|uwangle|suphsol|lesdoto|orslope|DownTee|realine|cudarrl|rdldhar|OverBar|supedot|lessdot|supdsub|topfork|succsim|rbrkslu|rbrksld|pertenk|cudarrr|isindot|planckh|lessgtr|pluscir|gesdoto|plussim|plustwo|lesssim|cularrp|rarrsim|Cayleys|notinva|notinvb|notinvc|UpArrow|Uparrow|uparrow|NotLess|dwangle|precsim|Product|curarrm|Cconint|dotplus|rarrbfs|ccupssm|Cedilla|cemptyv|notniva|quatint|frac35|frac38|frac45|frac56|frac58|frac78|tridot|xoplus|gacute|gammad|Gammad|lfisht|lfloor|bigcup|sqsupe|gbreve|Gbreve|lharul|sqsube|sqcups|Gcedil|apacir|llhard|lmidot|Lmidot|lmoust|andand|sqcaps|approx|Abreve|spades|circeq|tprime|divide|topcir|Assign|topbot|gesdot|divonx|xuplus|timesd|gesles|atilde|solbar|SOFTcy|loplus|timesb|lowast|lowbar|dlcorn|dlcrop|softcy|dollar|lparlt|thksim|lrhard|Atilde|lsaquo|smashp|bigvee|thinsp|wreath|bkarow|lsquor|lstrok|Lstrok|lthree|ltimes|ltlarr|DotDot|simdot|ltrPar|weierp|xsqcup|angmsd|sigmav|sigmaf|zeetrf|Zcaron|zcaron|mapsto|vsupne|thetav|cirmid|marker|mcomma|Zacute|vsubnE|there4|gtlPar|vsubne|bottom|gtrarr|SHCHcy|shchcy|midast|midcir|middot|minusb|minusd|gtrdot|bowtie|sfrown|mnplus|models|colone|seswar|Colone|mstpos|searhk|gtrsim|nacute|Nacute|boxbox|telrec|hairsp|Tcedil|nbumpe|scnsim|ncaron|Ncaron|ncedil|Ncedil|hamilt|Scedil|nearhk|hardcy|HARDcy|tcedil|Tcaron|commat|nequiv|nesear|tcaron|target|hearts|nexist|varrho|scedil|Scaron|scaron|hellip|Sacute|sacute|hercon|swnwar|compfn|rtimes|rthree|rsquor|rsaquo|zacute|wedgeq|homtht|barvee|barwed|Barwed|rpargt|horbar|conint|swarhk|roplus|nltrie|hslash|hstrok|Hstrok|rmoust|Conint|bprime|hybull|hyphen|iacute|Iacute|supsup|supsub|supsim|varphi|coprod|brvbar|agrave|Supset|supset|igrave|Igrave|notinE|Agrave|iiiint|iinfin|copysr|wedbar|Verbar|vangrt|becaus|incare|verbar|inodot|bullet|drcorn|intcal|drcrop|cularr|vellip|Utilde|bumpeq|cupcap|dstrok|Dstrok|CupCap|cupcup|cupdot|eacute|Eacute|supdot|iquest|easter|ecaron|Ecaron|ecolon|isinsv|utilde|itilde|Itilde|curarr|succeq|Bumpeq|cacute|ulcrop|nparsl|Cacute|nprcue|egrave|Egrave|nrarrc|nrarrw|subsup|subsub|nrtrie|jsercy|nsccue|Jsercy|kappav|kcedil|Kcedil|subsim|ulcorn|nsimeq|egsdot|veebar|kgreen|capand|elsdot|Subset|subset|curren|aacute|lacute|Lacute|emptyv|ntilde|Ntilde|lagran|lambda|Lambda|capcap|Ugrave|langle|subdot|emsp13|numero|emsp14|nvdash|nvDash|nVdash|nVDash|ugrave|ufisht|nvHarr|larrfs|nvlArr|larrhk|larrlp|larrpl|nvrArr|Udblac|nwarhk|larrtl|nwnear|oacute|Oacute|latail|lAtail|sstarf|lbrace|odblac|Odblac|lbrack|udblac|odsold|eparsl|lcaron|Lcaron|ograve|Ograve|lcedil|Lcedil|Aacute|ssmile|ssetmn|squarf|ldquor|capcup|ominus|cylcty|rharul|eqcirc|dagger|rfloor|rfisht|Dagger|daleth|equals|origof|capdot|equest|dcaron|Dcaron|rdquor|oslash|Oslash|otilde|Otilde|otimes|Otimes|urcrop|Ubreve|ubreve|Yacute|Uacute|uacute|Rcedil|rcedil|urcorn|parsim|Rcaron|Vdashl|rcaron|Tstrok|percnt|period|permil|Exists|yacute|rbrack|rbrace|phmmat|ccaron|Ccaron|planck|ccedil|plankv|tstrok|female|plusdo|plusdu|ffilig|plusmn|ffllig|Ccedil|rAtail|dfisht|bernou|ratail|Rarrtl|rarrtl|angsph|rarrpl|rarrlp|rarrhk|xwedge|xotime|forall|ForAll|Vvdash|vsupnE|preceq|bigcap|frac12|frac13|frac14|primes|rarrfs|prnsim|frac15|Square|frac16|square|lesdot|frac18|frac23|propto|prurel|rarrap|rangle|puncsp|frac25|Racute|qprime|racute|lesges|frac34|abreve|AElig|eqsim|utdot|setmn|urtri|Equal|Uring|seArr|uring|searr|dashv|Dashv|mumap|nabla|iogon|Iogon|sdote|sdotb|scsim|napid|napos|equiv|natur|Acirc|dblac|erarr|nbump|iprod|erDot|ucirc|awint|esdot|angrt|ncong|isinE|scnap|Scirc|scirc|ndash|isins|Ubrcy|nearr|neArr|isinv|nedot|ubrcy|acute|Ycirc|iukcy|Iukcy|xutri|nesim|caret|jcirc|Jcirc|caron|twixt|ddarr|sccue|exist|jmath|sbquo|ngeqq|angst|ccaps|lceil|ngsim|UpTee|delta|Delta|rtrif|nharr|nhArr|nhpar|rtrie|jukcy|Jukcy|kappa|rsquo|Kappa|nlarr|nlArr|TSHcy|rrarr|aogon|Aogon|fflig|xrarr|tshcy|ccirc|nleqq|filig|upsih|nless|dharl|nlsim|fjlig|ropar|nltri|dharr|robrk|roarr|fllig|fltns|roang|rnmid|subnE|subne|lAarr|trisb|Ccirc|acirc|ccups|blank|VDash|forkv|Vdash|langd|cedil|blk12|blk14|laquo|strns|diams|notin|vDash|larrb|blk34|block|disin|uplus|vdash|vBarv|aelig|starf|Wedge|check|xrArr|lates|lbarr|lBarr|notni|lbbrk|bcong|frasl|lbrke|frown|vrtri|vprop|vnsup|gamma|Gamma|wedge|xodot|bdquo|srarr|doteq|ldquo|boxdl|boxdL|gcirc|Gcirc|boxDl|boxDL|boxdr|boxdR|boxDr|TRADE|trade|rlhar|boxDR|vnsub|npart|vltri|rlarr|boxhd|boxhD|nprec|gescc|nrarr|nrArr|boxHd|boxHD|boxhu|boxhU|nrtri|boxHu|clubs|boxHU|times|colon|Colon|gimel|xlArr|Tilde|nsime|tilde|nsmid|nspar|THORN|thorn|xlarr|nsube|nsubE|thkap|xhArr|comma|nsucc|boxul|boxuL|nsupe|nsupE|gneqq|gnsim|boxUl|boxUL|grave|boxur|boxuR|boxUr|boxUR|lescc|angle|bepsi|boxvh|varpi|boxvH|numsp|Theta|gsime|gsiml|theta|boxVh|boxVH|boxvl|gtcir|gtdot|boxvL|boxVl|boxVL|crarr|cross|Cross|nvsim|boxvr|nwarr|nwArr|sqsup|dtdot|Uogon|lhard|lharu|dtrif|ocirc|Ocirc|lhblk|duarr|odash|sqsub|Hacek|sqcup|llarr|duhar|oelig|OElig|ofcir|boxvR|uogon|lltri|boxVr|csube|uuarr|ohbar|csupe|ctdot|olarr|olcir|harrw|oline|sqcap|omacr|Omacr|omega|Omega|boxVR|aleph|lneqq|lnsim|loang|loarr|rharu|lobrk|hcirc|operp|oplus|rhard|Hcirc|orarr|Union|order|ecirc|Ecirc|cuepr|szlig|cuesc|breve|reals|eDDot|Breve|hoarr|lopar|utrif|rdquo|Umacr|umacr|efDot|swArr|ultri|alpha|rceil|ovbar|swarr|Wcirc|wcirc|smtes|smile|bsemi|lrarr|aring|parsl|lrhar|bsime|uhblk|lrtri|cupor|Aring|uharr|uharl|slarr|rbrke|bsolb|lsime|rbbrk|RBarr|lsimg|phone|rBarr|rbarr|icirc|lsquo|Icirc|emacr|Emacr|ratio|simne|plusb|simlE|simgE|simeq|pluse|ltcir|ltdot|empty|xharr|xdtri|iexcl|Alpha|ltrie|rarrw|pound|ltrif|xcirc|bumpe|prcue|bumpE|asymp|amacr|cuvee|Sigma|sigma|iiint|udhar|iiota|ijlig|IJlig|supnE|imacr|Imacr|prime|Prime|image|prnap|eogon|Eogon|rarrc|mdash|mDDot|cuwed|imath|supne|imped|Amacr|udarr|prsim|micro|rarrb|cwint|raquo|infin|eplus|range|rangd|Ucirc|radic|minus|amalg|veeeq|rAarr|epsiv|ycirc|quest|sharp|quot|zwnj|Qscr|race|qscr|Qopf|qopf|qint|rang|Rang|Zscr|zscr|Zopf|zopf|rarr|rArr|Rarr|Pscr|pscr|prop|prod|prnE|prec|ZHcy|zhcy|prap|Zeta|zeta|Popf|popf|Zdot|plus|zdot|Yuml|yuml|phiv|YUcy|yucy|Yscr|yscr|perp|Yopf|yopf|part|para|YIcy|Ouml|rcub|yicy|YAcy|rdca|ouml|osol|Oscr|rdsh|yacy|real|oscr|xvee|andd|rect|andv|Xscr|oror|ordm|ordf|xscr|ange|aopf|Aopf|rHar|Xopf|opar|Oopf|xopf|xnis|rhov|oopf|omid|xmap|oint|apid|apos|ogon|ascr|Ascr|odot|odiv|xcup|xcap|ocir|oast|nvlt|nvle|nvgt|nvge|nvap|Wscr|wscr|auml|ntlg|ntgl|nsup|nsub|nsim|Nscr|nscr|nsce|Wopf|ring|npre|wopf|npar|Auml|Barv|bbrk|Nopf|nopf|nmid|nLtv|beta|ropf|Ropf|Beta|beth|nles|rpar|nleq|bnot|bNot|nldr|NJcy|rscr|Rscr|Vscr|vscr|rsqb|njcy|bopf|nisd|Bopf|rtri|Vopf|nGtv|ngtr|vopf|boxh|boxH|boxv|nges|ngeq|boxV|bscr|scap|Bscr|bsim|Vert|vert|bsol|bull|bump|caps|cdot|ncup|scnE|ncap|nbsp|napE|Cdot|cent|sdot|Vbar|nang|vBar|chcy|Mscr|mscr|sect|semi|CHcy|Mopf|mopf|sext|circ|cire|mldr|mlcp|cirE|comp|shcy|SHcy|vArr|varr|cong|copf|Copf|copy|COPY|malt|male|macr|lvnE|cscr|ltri|sime|ltcc|simg|Cscr|siml|csub|Uuml|lsqb|lsim|uuml|csup|Lscr|lscr|utri|smid|lpar|cups|smte|lozf|darr|Lopf|Uscr|solb|lopf|sopf|Sopf|lneq|uscr|spar|dArr|lnap|Darr|dash|Sqrt|LJcy|ljcy|lHar|dHar|Upsi|upsi|diam|lesg|djcy|DJcy|leqq|dopf|Dopf|dscr|Dscr|dscy|ldsh|ldca|squf|DScy|sscr|Sscr|dsol|lcub|late|star|Star|Uopf|Larr|lArr|larr|uopf|dtri|dzcy|sube|subE|Lang|lang|Kscr|kscr|Kopf|kopf|KJcy|kjcy|KHcy|khcy|DZcy|ecir|edot|eDot|Jscr|jscr|succ|Jopf|jopf|Edot|uHar|emsp|ensp|Iuml|iuml|eopf|isin|Iscr|iscr|Eopf|epar|sung|epsi|escr|sup1|sup2|sup3|Iota|iota|supe|supE|Iopf|iopf|IOcy|iocy|Escr|esim|Esim|imof|Uarr|QUOT|uArr|uarr|euml|IEcy|iecy|Idot|Euml|euro|excl|Hscr|hscr|Hopf|hopf|TScy|tscy|Tscr|hbar|tscr|flat|tbrk|fnof|hArr|harr|half|fopf|Fopf|tdot|gvnE|fork|trie|gtcc|fscr|Fscr|gdot|gsim|Gscr|gscr|Gopf|gopf|gneq|Gdot|tosa|gnap|Topf|topf|geqq|toea|GJcy|gjcy|tint|gesl|mid|Sfr|ggg|top|ges|gla|glE|glj|geq|gne|gEl|gel|gnE|Gcy|gcy|gap|Tfr|tfr|Tcy|tcy|Hat|Tau|Ffr|tau|Tab|hfr|Hfr|ffr|Fcy|fcy|icy|Icy|iff|ETH|eth|ifr|Ifr|Eta|eta|int|Int|Sup|sup|ucy|Ucy|Sum|sum|jcy|ENG|ufr|Ufr|eng|Jcy|jfr|els|ell|egs|Efr|efr|Jfr|uml|kcy|Kcy|Ecy|ecy|kfr|Kfr|lap|Sub|sub|lat|lcy|Lcy|leg|Dot|dot|lEg|leq|les|squ|div|die|lfr|Lfr|lgE|Dfr|dfr|Del|deg|Dcy|dcy|lne|lnE|sol|loz|smt|Cup|lrm|cup|lsh|Lsh|sim|shy|map|Map|mcy|Mcy|mfr|Mfr|mho|gfr|Gfr|sfr|cir|Chi|chi|nap|Cfr|vcy|Vcy|cfr|Scy|scy|ncy|Ncy|vee|Vee|Cap|cap|nfr|scE|sce|Nfr|nge|ngE|nGg|vfr|Vfr|ngt|bot|nGt|nis|niv|Rsh|rsh|nle|nlE|bne|Bfr|bfr|nLl|nlt|nLt|Bcy|bcy|not|Not|rlm|wfr|Wfr|npr|nsc|num|ocy|ast|Ocy|ofr|xfr|Xfr|Ofr|ogt|ohm|apE|olt|Rho|ape|rho|Rfr|rfr|ord|REG|ang|reg|orv|And|and|AMP|Rcy|amp|Afr|ycy|Ycy|yen|yfr|Yfr|rcy|par|pcy|Pcy|pfr|Pfr|phi|Phi|afr|Acy|acy|zcy|Zcy|piv|acE|acd|zfr|Zfr|pre|prE|psi|Psi|qfr|Qfr|zwj|Or|ge|Gg|gt|gg|el|oS|lt|Lt|LT|Re|lg|gl|eg|ne|Im|it|le|DD|wp|wr|nu|Nu|dd|lE|Sc|sc|pi|Pi|ee|af|ll|Ll|rx|gE|xi|pm|Xi|ic|pr|Pr|in|ni|mp|mu|ac|Mu|or|ap|Gt|GT|ii);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)(?!;)([=a-zA-Z0-9]?)|&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+)/g;
      var decodeMap2 = { "aacute": "\xE1", "Aacute": "\xC1", "abreve": "\u0103", "Abreve": "\u0102", "ac": "\u223E", "acd": "\u223F", "acE": "\u223E\u0333", "acirc": "\xE2", "Acirc": "\xC2", "acute": "\xB4", "acy": "\u0430", "Acy": "\u0410", "aelig": "\xE6", "AElig": "\xC6", "af": "\u2061", "afr": "\u{1D51E}", "Afr": "\u{1D504}", "agrave": "\xE0", "Agrave": "\xC0", "alefsym": "\u2135", "aleph": "\u2135", "alpha": "\u03B1", "Alpha": "\u0391", "amacr": "\u0101", "Amacr": "\u0100", "amalg": "\u2A3F", "amp": "&", "AMP": "&", "and": "\u2227", "And": "\u2A53", "andand": "\u2A55", "andd": "\u2A5C", "andslope": "\u2A58", "andv": "\u2A5A", "ang": "\u2220", "ange": "\u29A4", "angle": "\u2220", "angmsd": "\u2221", "angmsdaa": "\u29A8", "angmsdab": "\u29A9", "angmsdac": "\u29AA", "angmsdad": "\u29AB", "angmsdae": "\u29AC", "angmsdaf": "\u29AD", "angmsdag": "\u29AE", "angmsdah": "\u29AF", "angrt": "\u221F", "angrtvb": "\u22BE", "angrtvbd": "\u299D", "angsph": "\u2222", "angst": "\xC5", "angzarr": "\u237C", "aogon": "\u0105", "Aogon": "\u0104", "aopf": "\u{1D552}", "Aopf": "\u{1D538}", "ap": "\u2248", "apacir": "\u2A6F", "ape": "\u224A", "apE": "\u2A70", "apid": "\u224B", "apos": "'", "ApplyFunction": "\u2061", "approx": "\u2248", "approxeq": "\u224A", "aring": "\xE5", "Aring": "\xC5", "ascr": "\u{1D4B6}", "Ascr": "\u{1D49C}", "Assign": "\u2254", "ast": "*", "asymp": "\u2248", "asympeq": "\u224D", "atilde": "\xE3", "Atilde": "\xC3", "auml": "\xE4", "Auml": "\xC4", "awconint": "\u2233", "awint": "\u2A11", "backcong": "\u224C", "backepsilon": "\u03F6", "backprime": "\u2035", "backsim": "\u223D", "backsimeq": "\u22CD", "Backslash": "\u2216", "Barv": "\u2AE7", "barvee": "\u22BD", "barwed": "\u2305", "Barwed": "\u2306", "barwedge": "\u2305", "bbrk": "\u23B5", "bbrktbrk": "\u23B6", "bcong": "\u224C", "bcy": "\u0431", "Bcy": "\u0411", "bdquo": "\u201E", "becaus": "\u2235", "because": "\u2235", "Because": "\u2235", "bemptyv": "\u29B0", "bepsi": "\u03F6", "bernou": "\u212C", "Bernoullis": "\u212C", "beta": "\u03B2", "Beta": "\u0392", "beth": "\u2136", "between": "\u226C", "bfr": "\u{1D51F}", "Bfr": "\u{1D505}", "bigcap": "\u22C2", "bigcirc": "\u25EF", "bigcup": "\u22C3", "bigodot": "\u2A00", "bigoplus": "\u2A01", "bigotimes": "\u2A02", "bigsqcup": "\u2A06", "bigstar": "\u2605", "bigtriangledown": "\u25BD", "bigtriangleup": "\u25B3", "biguplus": "\u2A04", "bigvee": "\u22C1", "bigwedge": "\u22C0", "bkarow": "\u290D", "blacklozenge": "\u29EB", "blacksquare": "\u25AA", "blacktriangle": "\u25B4", "blacktriangledown": "\u25BE", "blacktriangleleft": "\u25C2", "blacktriangleright": "\u25B8", "blank": "\u2423", "blk12": "\u2592", "blk14": "\u2591", "blk34": "\u2593", "block": "\u2588", "bne": "=\u20E5", "bnequiv": "\u2261\u20E5", "bnot": "\u2310", "bNot": "\u2AED", "bopf": "\u{1D553}", "Bopf": "\u{1D539}", "bot": "\u22A5", "bottom": "\u22A5", "bowtie": "\u22C8", "boxbox": "\u29C9", "boxdl": "\u2510", "boxdL": "\u2555", "boxDl": "\u2556", "boxDL": "\u2557", "boxdr": "\u250C", "boxdR": "\u2552", "boxDr": "\u2553", "boxDR": "\u2554", "boxh": "\u2500", "boxH": "\u2550", "boxhd": "\u252C", "boxhD": "\u2565", "boxHd": "\u2564", "boxHD": "\u2566", "boxhu": "\u2534", "boxhU": "\u2568", "boxHu": "\u2567", "boxHU": "\u2569", "boxminus": "\u229F", "boxplus": "\u229E", "boxtimes": "\u22A0", "boxul": "\u2518", "boxuL": "\u255B", "boxUl": "\u255C", "boxUL": "\u255D", "boxur": "\u2514", "boxuR": "\u2558", "boxUr": "\u2559", "boxUR": "\u255A", "boxv": "\u2502", "boxV": "\u2551", "boxvh": "\u253C", "boxvH": "\u256A", "boxVh": "\u256B", "boxVH": "\u256C", "boxvl": "\u2524", "boxvL": "\u2561", "boxVl": "\u2562", "boxVL": "\u2563", "boxvr": "\u251C", "boxvR": "\u255E", "boxVr": "\u255F", "boxVR": "\u2560", "bprime": "\u2035", "breve": "\u02D8", "Breve": "\u02D8", "brvbar": "\xA6", "bscr": "\u{1D4B7}", "Bscr": "\u212C", "bsemi": "\u204F", "bsim": "\u223D", "bsime": "\u22CD", "bsol": "\\", "bsolb": "\u29C5", "bsolhsub": "\u27C8", "bull": "\u2022", "bullet": "\u2022", "bump": "\u224E", "bumpe": "\u224F", "bumpE": "\u2AAE", "bumpeq": "\u224F", "Bumpeq": "\u224E", "cacute": "\u0107", "Cacute": "\u0106", "cap": "\u2229", "Cap": "\u22D2", "capand": "\u2A44", "capbrcup": "\u2A49", "capcap": "\u2A4B", "capcup": "\u2A47", "capdot": "\u2A40", "CapitalDifferentialD": "\u2145", "caps": "\u2229\uFE00", "caret": "\u2041", "caron": "\u02C7", "Cayleys": "\u212D", "ccaps": "\u2A4D", "ccaron": "\u010D", "Ccaron": "\u010C", "ccedil": "\xE7", "Ccedil": "\xC7", "ccirc": "\u0109", "Ccirc": "\u0108", "Cconint": "\u2230", "ccups": "\u2A4C", "ccupssm": "\u2A50", "cdot": "\u010B", "Cdot": "\u010A", "cedil": "\xB8", "Cedilla": "\xB8", "cemptyv": "\u29B2", "cent": "\xA2", "centerdot": "\xB7", "CenterDot": "\xB7", "cfr": "\u{1D520}", "Cfr": "\u212D", "chcy": "\u0447", "CHcy": "\u0427", "check": "\u2713", "checkmark": "\u2713", "chi": "\u03C7", "Chi": "\u03A7", "cir": "\u25CB", "circ": "\u02C6", "circeq": "\u2257", "circlearrowleft": "\u21BA", "circlearrowright": "\u21BB", "circledast": "\u229B", "circledcirc": "\u229A", "circleddash": "\u229D", "CircleDot": "\u2299", "circledR": "\xAE", "circledS": "\u24C8", "CircleMinus": "\u2296", "CirclePlus": "\u2295", "CircleTimes": "\u2297", "cire": "\u2257", "cirE": "\u29C3", "cirfnint": "\u2A10", "cirmid": "\u2AEF", "cirscir": "\u29C2", "ClockwiseContourIntegral": "\u2232", "CloseCurlyDoubleQuote": "\u201D", "CloseCurlyQuote": "\u2019", "clubs": "\u2663", "clubsuit": "\u2663", "colon": ":", "Colon": "\u2237", "colone": "\u2254", "Colone": "\u2A74", "coloneq": "\u2254", "comma": ",", "commat": "@", "comp": "\u2201", "compfn": "\u2218", "complement": "\u2201", "complexes": "\u2102", "cong": "\u2245", "congdot": "\u2A6D", "Congruent": "\u2261", "conint": "\u222E", "Conint": "\u222F", "ContourIntegral": "\u222E", "copf": "\u{1D554}", "Copf": "\u2102", "coprod": "\u2210", "Coproduct": "\u2210", "copy": "\xA9", "COPY": "\xA9", "copysr": "\u2117", "CounterClockwiseContourIntegral": "\u2233", "crarr": "\u21B5", "cross": "\u2717", "Cross": "\u2A2F", "cscr": "\u{1D4B8}", "Cscr": "\u{1D49E}", "csub": "\u2ACF", "csube": "\u2AD1", "csup": "\u2AD0", "csupe": "\u2AD2", "ctdot": "\u22EF", "cudarrl": "\u2938", "cudarrr": "\u2935", "cuepr": "\u22DE", "cuesc": "\u22DF", "cularr": "\u21B6", "cularrp": "\u293D", "cup": "\u222A", "Cup": "\u22D3", "cupbrcap": "\u2A48", "cupcap": "\u2A46", "CupCap": "\u224D", "cupcup": "\u2A4A", "cupdot": "\u228D", "cupor": "\u2A45", "cups": "\u222A\uFE00", "curarr": "\u21B7", "curarrm": "\u293C", "curlyeqprec": "\u22DE", "curlyeqsucc": "\u22DF", "curlyvee": "\u22CE", "curlywedge": "\u22CF", "curren": "\xA4", "curvearrowleft": "\u21B6", "curvearrowright": "\u21B7", "cuvee": "\u22CE", "cuwed": "\u22CF", "cwconint": "\u2232", "cwint": "\u2231", "cylcty": "\u232D", "dagger": "\u2020", "Dagger": "\u2021", "daleth": "\u2138", "darr": "\u2193", "dArr": "\u21D3", "Darr": "\u21A1", "dash": "\u2010", "dashv": "\u22A3", "Dashv": "\u2AE4", "dbkarow": "\u290F", "dblac": "\u02DD", "dcaron": "\u010F", "Dcaron": "\u010E", "dcy": "\u0434", "Dcy": "\u0414", "dd": "\u2146", "DD": "\u2145", "ddagger": "\u2021", "ddarr": "\u21CA", "DDotrahd": "\u2911", "ddotseq": "\u2A77", "deg": "\xB0", "Del": "\u2207", "delta": "\u03B4", "Delta": "\u0394", "demptyv": "\u29B1", "dfisht": "\u297F", "dfr": "\u{1D521}", "Dfr": "\u{1D507}", "dHar": "\u2965", "dharl": "\u21C3", "dharr": "\u21C2", "DiacriticalAcute": "\xB4", "DiacriticalDot": "\u02D9", "DiacriticalDoubleAcute": "\u02DD", "DiacriticalGrave": "`", "DiacriticalTilde": "\u02DC", "diam": "\u22C4", "diamond": "\u22C4", "Diamond": "\u22C4", "diamondsuit": "\u2666", "diams": "\u2666", "die": "\xA8", "DifferentialD": "\u2146", "digamma": "\u03DD", "disin": "\u22F2", "div": "\xF7", "divide": "\xF7", "divideontimes": "\u22C7", "divonx": "\u22C7", "djcy": "\u0452", "DJcy": "\u0402", "dlcorn": "\u231E", "dlcrop": "\u230D", "dollar": "$", "dopf": "\u{1D555}", "Dopf": "\u{1D53B}", "dot": "\u02D9", "Dot": "\xA8", "DotDot": "\u20DC", "doteq": "\u2250", "doteqdot": "\u2251", "DotEqual": "\u2250", "dotminus": "\u2238", "dotplus": "\u2214", "dotsquare": "\u22A1", "doublebarwedge": "\u2306", "DoubleContourIntegral": "\u222F", "DoubleDot": "\xA8", "DoubleDownArrow": "\u21D3", "DoubleLeftArrow": "\u21D0", "DoubleLeftRightArrow": "\u21D4", "DoubleLeftTee": "\u2AE4", "DoubleLongLeftArrow": "\u27F8", "DoubleLongLeftRightArrow": "\u27FA", "DoubleLongRightArrow": "\u27F9", "DoubleRightArrow": "\u21D2", "DoubleRightTee": "\u22A8", "DoubleUpArrow": "\u21D1", "DoubleUpDownArrow": "\u21D5", "DoubleVerticalBar": "\u2225", "downarrow": "\u2193", "Downarrow": "\u21D3", "DownArrow": "\u2193", "DownArrowBar": "\u2913", "DownArrowUpArrow": "\u21F5", "DownBreve": "\u0311", "downdownarrows": "\u21CA", "downharpoonleft": "\u21C3", "downharpoonright": "\u21C2", "DownLeftRightVector": "\u2950", "DownLeftTeeVector": "\u295E", "DownLeftVector": "\u21BD", "DownLeftVectorBar": "\u2956", "DownRightTeeVector": "\u295F", "DownRightVector": "\u21C1", "DownRightVectorBar": "\u2957", "DownTee": "\u22A4", "DownTeeArrow": "\u21A7", "drbkarow": "\u2910", "drcorn": "\u231F", "drcrop": "\u230C", "dscr": "\u{1D4B9}", "Dscr": "\u{1D49F}", "dscy": "\u0455", "DScy": "\u0405", "dsol": "\u29F6", "dstrok": "\u0111", "Dstrok": "\u0110", "dtdot": "\u22F1", "dtri": "\u25BF", "dtrif": "\u25BE", "duarr": "\u21F5", "duhar": "\u296F", "dwangle": "\u29A6", "dzcy": "\u045F", "DZcy": "\u040F", "dzigrarr": "\u27FF", "eacute": "\xE9", "Eacute": "\xC9", "easter": "\u2A6E", "ecaron": "\u011B", "Ecaron": "\u011A", "ecir": "\u2256", "ecirc": "\xEA", "Ecirc": "\xCA", "ecolon": "\u2255", "ecy": "\u044D", "Ecy": "\u042D", "eDDot": "\u2A77", "edot": "\u0117", "eDot": "\u2251", "Edot": "\u0116", "ee": "\u2147", "efDot": "\u2252", "efr": "\u{1D522}", "Efr": "\u{1D508}", "eg": "\u2A9A", "egrave": "\xE8", "Egrave": "\xC8", "egs": "\u2A96", "egsdot": "\u2A98", "el": "\u2A99", "Element": "\u2208", "elinters": "\u23E7", "ell": "\u2113", "els": "\u2A95", "elsdot": "\u2A97", "emacr": "\u0113", "Emacr": "\u0112", "empty": "\u2205", "emptyset": "\u2205", "EmptySmallSquare": "\u25FB", "emptyv": "\u2205", "EmptyVerySmallSquare": "\u25AB", "emsp": "\u2003", "emsp13": "\u2004", "emsp14": "\u2005", "eng": "\u014B", "ENG": "\u014A", "ensp": "\u2002", "eogon": "\u0119", "Eogon": "\u0118", "eopf": "\u{1D556}", "Eopf": "\u{1D53C}", "epar": "\u22D5", "eparsl": "\u29E3", "eplus": "\u2A71", "epsi": "\u03B5", "epsilon": "\u03B5", "Epsilon": "\u0395", "epsiv": "\u03F5", "eqcirc": "\u2256", "eqcolon": "\u2255", "eqsim": "\u2242", "eqslantgtr": "\u2A96", "eqslantless": "\u2A95", "Equal": "\u2A75", "equals": "=", "EqualTilde": "\u2242", "equest": "\u225F", "Equilibrium": "\u21CC", "equiv": "\u2261", "equivDD": "\u2A78", "eqvparsl": "\u29E5", "erarr": "\u2971", "erDot": "\u2253", "escr": "\u212F", "Escr": "\u2130", "esdot": "\u2250", "esim": "\u2242", "Esim": "\u2A73", "eta": "\u03B7", "Eta": "\u0397", "eth": "\xF0", "ETH": "\xD0", "euml": "\xEB", "Euml": "\xCB", "euro": "\u20AC", "excl": "!", "exist": "\u2203", "Exists": "\u2203", "expectation": "\u2130", "exponentiale": "\u2147", "ExponentialE": "\u2147", "fallingdotseq": "\u2252", "fcy": "\u0444", "Fcy": "\u0424", "female": "\u2640", "ffilig": "\uFB03", "fflig": "\uFB00", "ffllig": "\uFB04", "ffr": "\u{1D523}", "Ffr": "\u{1D509}", "filig": "\uFB01", "FilledSmallSquare": "\u25FC", "FilledVerySmallSquare": "\u25AA", "fjlig": "fj", "flat": "\u266D", "fllig": "\uFB02", "fltns": "\u25B1", "fnof": "\u0192", "fopf": "\u{1D557}", "Fopf": "\u{1D53D}", "forall": "\u2200", "ForAll": "\u2200", "fork": "\u22D4", "forkv": "\u2AD9", "Fouriertrf": "\u2131", "fpartint": "\u2A0D", "frac12": "\xBD", "frac13": "\u2153", "frac14": "\xBC", "frac15": "\u2155", "frac16": "\u2159", "frac18": "\u215B", "frac23": "\u2154", "frac25": "\u2156", "frac34": "\xBE", "frac35": "\u2157", "frac38": "\u215C", "frac45": "\u2158", "frac56": "\u215A", "frac58": "\u215D", "frac78": "\u215E", "frasl": "\u2044", "frown": "\u2322", "fscr": "\u{1D4BB}", "Fscr": "\u2131", "gacute": "\u01F5", "gamma": "\u03B3", "Gamma": "\u0393", "gammad": "\u03DD", "Gammad": "\u03DC", "gap": "\u2A86", "gbreve": "\u011F", "Gbreve": "\u011E", "Gcedil": "\u0122", "gcirc": "\u011D", "Gcirc": "\u011C", "gcy": "\u0433", "Gcy": "\u0413", "gdot": "\u0121", "Gdot": "\u0120", "ge": "\u2265", "gE": "\u2267", "gel": "\u22DB", "gEl": "\u2A8C", "geq": "\u2265", "geqq": "\u2267", "geqslant": "\u2A7E", "ges": "\u2A7E", "gescc": "\u2AA9", "gesdot": "\u2A80", "gesdoto": "\u2A82", "gesdotol": "\u2A84", "gesl": "\u22DB\uFE00", "gesles": "\u2A94", "gfr": "\u{1D524}", "Gfr": "\u{1D50A}", "gg": "\u226B", "Gg": "\u22D9", "ggg": "\u22D9", "gimel": "\u2137", "gjcy": "\u0453", "GJcy": "\u0403", "gl": "\u2277", "gla": "\u2AA5", "glE": "\u2A92", "glj": "\u2AA4", "gnap": "\u2A8A", "gnapprox": "\u2A8A", "gne": "\u2A88", "gnE": "\u2269", "gneq": "\u2A88", "gneqq": "\u2269", "gnsim": "\u22E7", "gopf": "\u{1D558}", "Gopf": "\u{1D53E}", "grave": "`", "GreaterEqual": "\u2265", "GreaterEqualLess": "\u22DB", "GreaterFullEqual": "\u2267", "GreaterGreater": "\u2AA2", "GreaterLess": "\u2277", "GreaterSlantEqual": "\u2A7E", "GreaterTilde": "\u2273", "gscr": "\u210A", "Gscr": "\u{1D4A2}", "gsim": "\u2273", "gsime": "\u2A8E", "gsiml": "\u2A90", "gt": ">", "Gt": "\u226B", "GT": ">", "gtcc": "\u2AA7", "gtcir": "\u2A7A", "gtdot": "\u22D7", "gtlPar": "\u2995", "gtquest": "\u2A7C", "gtrapprox": "\u2A86", "gtrarr": "\u2978", "gtrdot": "\u22D7", "gtreqless": "\u22DB", "gtreqqless": "\u2A8C", "gtrless": "\u2277", "gtrsim": "\u2273", "gvertneqq": "\u2269\uFE00", "gvnE": "\u2269\uFE00", "Hacek": "\u02C7", "hairsp": "\u200A", "half": "\xBD", "hamilt": "\u210B", "hardcy": "\u044A", "HARDcy": "\u042A", "harr": "\u2194", "hArr": "\u21D4", "harrcir": "\u2948", "harrw": "\u21AD", "Hat": "^", "hbar": "\u210F", "hcirc": "\u0125", "Hcirc": "\u0124", "hearts": "\u2665", "heartsuit": "\u2665", "hellip": "\u2026", "hercon": "\u22B9", "hfr": "\u{1D525}", "Hfr": "\u210C", "HilbertSpace": "\u210B", "hksearow": "\u2925", "hkswarow": "\u2926", "hoarr": "\u21FF", "homtht": "\u223B", "hookleftarrow": "\u21A9", "hookrightarrow": "\u21AA", "hopf": "\u{1D559}", "Hopf": "\u210D", "horbar": "\u2015", "HorizontalLine": "\u2500", "hscr": "\u{1D4BD}", "Hscr": "\u210B", "hslash": "\u210F", "hstrok": "\u0127", "Hstrok": "\u0126", "HumpDownHump": "\u224E", "HumpEqual": "\u224F", "hybull": "\u2043", "hyphen": "\u2010", "iacute": "\xED", "Iacute": "\xCD", "ic": "\u2063", "icirc": "\xEE", "Icirc": "\xCE", "icy": "\u0438", "Icy": "\u0418", "Idot": "\u0130", "iecy": "\u0435", "IEcy": "\u0415", "iexcl": "\xA1", "iff": "\u21D4", "ifr": "\u{1D526}", "Ifr": "\u2111", "igrave": "\xEC", "Igrave": "\xCC", "ii": "\u2148", "iiiint": "\u2A0C", "iiint": "\u222D", "iinfin": "\u29DC", "iiota": "\u2129", "ijlig": "\u0133", "IJlig": "\u0132", "Im": "\u2111", "imacr": "\u012B", "Imacr": "\u012A", "image": "\u2111", "ImaginaryI": "\u2148", "imagline": "\u2110", "imagpart": "\u2111", "imath": "\u0131", "imof": "\u22B7", "imped": "\u01B5", "Implies": "\u21D2", "in": "\u2208", "incare": "\u2105", "infin": "\u221E", "infintie": "\u29DD", "inodot": "\u0131", "int": "\u222B", "Int": "\u222C", "intcal": "\u22BA", "integers": "\u2124", "Integral": "\u222B", "intercal": "\u22BA", "Intersection": "\u22C2", "intlarhk": "\u2A17", "intprod": "\u2A3C", "InvisibleComma": "\u2063", "InvisibleTimes": "\u2062", "iocy": "\u0451", "IOcy": "\u0401", "iogon": "\u012F", "Iogon": "\u012E", "iopf": "\u{1D55A}", "Iopf": "\u{1D540}", "iota": "\u03B9", "Iota": "\u0399", "iprod": "\u2A3C", "iquest": "\xBF", "iscr": "\u{1D4BE}", "Iscr": "\u2110", "isin": "\u2208", "isindot": "\u22F5", "isinE": "\u22F9", "isins": "\u22F4", "isinsv": "\u22F3", "isinv": "\u2208", "it": "\u2062", "itilde": "\u0129", "Itilde": "\u0128", "iukcy": "\u0456", "Iukcy": "\u0406", "iuml": "\xEF", "Iuml": "\xCF", "jcirc": "\u0135", "Jcirc": "\u0134", "jcy": "\u0439", "Jcy": "\u0419", "jfr": "\u{1D527}", "Jfr": "\u{1D50D}", "jmath": "\u0237", "jopf": "\u{1D55B}", "Jopf": "\u{1D541}", "jscr": "\u{1D4BF}", "Jscr": "\u{1D4A5}", "jsercy": "\u0458", "Jsercy": "\u0408", "jukcy": "\u0454", "Jukcy": "\u0404", "kappa": "\u03BA", "Kappa": "\u039A", "kappav": "\u03F0", "kcedil": "\u0137", "Kcedil": "\u0136", "kcy": "\u043A", "Kcy": "\u041A", "kfr": "\u{1D528}", "Kfr": "\u{1D50E}", "kgreen": "\u0138", "khcy": "\u0445", "KHcy": "\u0425", "kjcy": "\u045C", "KJcy": "\u040C", "kopf": "\u{1D55C}", "Kopf": "\u{1D542}", "kscr": "\u{1D4C0}", "Kscr": "\u{1D4A6}", "lAarr": "\u21DA", "lacute": "\u013A", "Lacute": "\u0139", "laemptyv": "\u29B4", "lagran": "\u2112", "lambda": "\u03BB", "Lambda": "\u039B", "lang": "\u27E8", "Lang": "\u27EA", "langd": "\u2991", "langle": "\u27E8", "lap": "\u2A85", "Laplacetrf": "\u2112", "laquo": "\xAB", "larr": "\u2190", "lArr": "\u21D0", "Larr": "\u219E", "larrb": "\u21E4", "larrbfs": "\u291F", "larrfs": "\u291D", "larrhk": "\u21A9", "larrlp": "\u21AB", "larrpl": "\u2939", "larrsim": "\u2973", "larrtl": "\u21A2", "lat": "\u2AAB", "latail": "\u2919", "lAtail": "\u291B", "late": "\u2AAD", "lates": "\u2AAD\uFE00", "lbarr": "\u290C", "lBarr": "\u290E", "lbbrk": "\u2772", "lbrace": "{", "lbrack": "[", "lbrke": "\u298B", "lbrksld": "\u298F", "lbrkslu": "\u298D", "lcaron": "\u013E", "Lcaron": "\u013D", "lcedil": "\u013C", "Lcedil": "\u013B", "lceil": "\u2308", "lcub": "{", "lcy": "\u043B", "Lcy": "\u041B", "ldca": "\u2936", "ldquo": "\u201C", "ldquor": "\u201E", "ldrdhar": "\u2967", "ldrushar": "\u294B", "ldsh": "\u21B2", "le": "\u2264", "lE": "\u2266", "LeftAngleBracket": "\u27E8", "leftarrow": "\u2190", "Leftarrow": "\u21D0", "LeftArrow": "\u2190", "LeftArrowBar": "\u21E4", "LeftArrowRightArrow": "\u21C6", "leftarrowtail": "\u21A2", "LeftCeiling": "\u2308", "LeftDoubleBracket": "\u27E6", "LeftDownTeeVector": "\u2961", "LeftDownVector": "\u21C3", "LeftDownVectorBar": "\u2959", "LeftFloor": "\u230A", "leftharpoondown": "\u21BD", "leftharpoonup": "\u21BC", "leftleftarrows": "\u21C7", "leftrightarrow": "\u2194", "Leftrightarrow": "\u21D4", "LeftRightArrow": "\u2194", "leftrightarrows": "\u21C6", "leftrightharpoons": "\u21CB", "leftrightsquigarrow": "\u21AD", "LeftRightVector": "\u294E", "LeftTee": "\u22A3", "LeftTeeArrow": "\u21A4", "LeftTeeVector": "\u295A", "leftthreetimes": "\u22CB", "LeftTriangle": "\u22B2", "LeftTriangleBar": "\u29CF", "LeftTriangleEqual": "\u22B4", "LeftUpDownVector": "\u2951", "LeftUpTeeVector": "\u2960", "LeftUpVector": "\u21BF", "LeftUpVectorBar": "\u2958", "LeftVector": "\u21BC", "LeftVectorBar": "\u2952", "leg": "\u22DA", "lEg": "\u2A8B", "leq": "\u2264", "leqq": "\u2266", "leqslant": "\u2A7D", "les": "\u2A7D", "lescc": "\u2AA8", "lesdot": "\u2A7F", "lesdoto": "\u2A81", "lesdotor": "\u2A83", "lesg": "\u22DA\uFE00", "lesges": "\u2A93", "lessapprox": "\u2A85", "lessdot": "\u22D6", "lesseqgtr": "\u22DA", "lesseqqgtr": "\u2A8B", "LessEqualGreater": "\u22DA", "LessFullEqual": "\u2266", "LessGreater": "\u2276", "lessgtr": "\u2276", "LessLess": "\u2AA1", "lesssim": "\u2272", "LessSlantEqual": "\u2A7D", "LessTilde": "\u2272", "lfisht": "\u297C", "lfloor": "\u230A", "lfr": "\u{1D529}", "Lfr": "\u{1D50F}", "lg": "\u2276", "lgE": "\u2A91", "lHar": "\u2962", "lhard": "\u21BD", "lharu": "\u21BC", "lharul": "\u296A", "lhblk": "\u2584", "ljcy": "\u0459", "LJcy": "\u0409", "ll": "\u226A", "Ll": "\u22D8", "llarr": "\u21C7", "llcorner": "\u231E", "Lleftarrow": "\u21DA", "llhard": "\u296B", "lltri": "\u25FA", "lmidot": "\u0140", "Lmidot": "\u013F", "lmoust": "\u23B0", "lmoustache": "\u23B0", "lnap": "\u2A89", "lnapprox": "\u2A89", "lne": "\u2A87", "lnE": "\u2268", "lneq": "\u2A87", "lneqq": "\u2268", "lnsim": "\u22E6", "loang": "\u27EC", "loarr": "\u21FD", "lobrk": "\u27E6", "longleftarrow": "\u27F5", "Longleftarrow": "\u27F8", "LongLeftArrow": "\u27F5", "longleftrightarrow": "\u27F7", "Longleftrightarrow": "\u27FA", "LongLeftRightArrow": "\u27F7", "longmapsto": "\u27FC", "longrightarrow": "\u27F6", "Longrightarrow": "\u27F9", "LongRightArrow": "\u27F6", "looparrowleft": "\u21AB", "looparrowright": "\u21AC", "lopar": "\u2985", "lopf": "\u{1D55D}", "Lopf": "\u{1D543}", "loplus": "\u2A2D", "lotimes": "\u2A34", "lowast": "\u2217", "lowbar": "_", "LowerLeftArrow": "\u2199", "LowerRightArrow": "\u2198", "loz": "\u25CA", "lozenge": "\u25CA", "lozf": "\u29EB", "lpar": "(", "lparlt": "\u2993", "lrarr": "\u21C6", "lrcorner": "\u231F", "lrhar": "\u21CB", "lrhard": "\u296D", "lrm": "\u200E", "lrtri": "\u22BF", "lsaquo": "\u2039", "lscr": "\u{1D4C1}", "Lscr": "\u2112", "lsh": "\u21B0", "Lsh": "\u21B0", "lsim": "\u2272", "lsime": "\u2A8D", "lsimg": "\u2A8F", "lsqb": "[", "lsquo": "\u2018", "lsquor": "\u201A", "lstrok": "\u0142", "Lstrok": "\u0141", "lt": "<", "Lt": "\u226A", "LT": "<", "ltcc": "\u2AA6", "ltcir": "\u2A79", "ltdot": "\u22D6", "lthree": "\u22CB", "ltimes": "\u22C9", "ltlarr": "\u2976", "ltquest": "\u2A7B", "ltri": "\u25C3", "ltrie": "\u22B4", "ltrif": "\u25C2", "ltrPar": "\u2996", "lurdshar": "\u294A", "luruhar": "\u2966", "lvertneqq": "\u2268\uFE00", "lvnE": "\u2268\uFE00", "macr": "\xAF", "male": "\u2642", "malt": "\u2720", "maltese": "\u2720", "map": "\u21A6", "Map": "\u2905", "mapsto": "\u21A6", "mapstodown": "\u21A7", "mapstoleft": "\u21A4", "mapstoup": "\u21A5", "marker": "\u25AE", "mcomma": "\u2A29", "mcy": "\u043C", "Mcy": "\u041C", "mdash": "\u2014", "mDDot": "\u223A", "measuredangle": "\u2221", "MediumSpace": "\u205F", "Mellintrf": "\u2133", "mfr": "\u{1D52A}", "Mfr": "\u{1D510}", "mho": "\u2127", "micro": "\xB5", "mid": "\u2223", "midast": "*", "midcir": "\u2AF0", "middot": "\xB7", "minus": "\u2212", "minusb": "\u229F", "minusd": "\u2238", "minusdu": "\u2A2A", "MinusPlus": "\u2213", "mlcp": "\u2ADB", "mldr": "\u2026", "mnplus": "\u2213", "models": "\u22A7", "mopf": "\u{1D55E}", "Mopf": "\u{1D544}", "mp": "\u2213", "mscr": "\u{1D4C2}", "Mscr": "\u2133", "mstpos": "\u223E", "mu": "\u03BC", "Mu": "\u039C", "multimap": "\u22B8", "mumap": "\u22B8", "nabla": "\u2207", "nacute": "\u0144", "Nacute": "\u0143", "nang": "\u2220\u20D2", "nap": "\u2249", "napE": "\u2A70\u0338", "napid": "\u224B\u0338", "napos": "\u0149", "napprox": "\u2249", "natur": "\u266E", "natural": "\u266E", "naturals": "\u2115", "nbsp": "\xA0", "nbump": "\u224E\u0338", "nbumpe": "\u224F\u0338", "ncap": "\u2A43", "ncaron": "\u0148", "Ncaron": "\u0147", "ncedil": "\u0146", "Ncedil": "\u0145", "ncong": "\u2247", "ncongdot": "\u2A6D\u0338", "ncup": "\u2A42", "ncy": "\u043D", "Ncy": "\u041D", "ndash": "\u2013", "ne": "\u2260", "nearhk": "\u2924", "nearr": "\u2197", "neArr": "\u21D7", "nearrow": "\u2197", "nedot": "\u2250\u0338", "NegativeMediumSpace": "\u200B", "NegativeThickSpace": "\u200B", "NegativeThinSpace": "\u200B", "NegativeVeryThinSpace": "\u200B", "nequiv": "\u2262", "nesear": "\u2928", "nesim": "\u2242\u0338", "NestedGreaterGreater": "\u226B", "NestedLessLess": "\u226A", "NewLine": "\n", "nexist": "\u2204", "nexists": "\u2204", "nfr": "\u{1D52B}", "Nfr": "\u{1D511}", "nge": "\u2271", "ngE": "\u2267\u0338", "ngeq": "\u2271", "ngeqq": "\u2267\u0338", "ngeqslant": "\u2A7E\u0338", "nges": "\u2A7E\u0338", "nGg": "\u22D9\u0338", "ngsim": "\u2275", "ngt": "\u226F", "nGt": "\u226B\u20D2", "ngtr": "\u226F", "nGtv": "\u226B\u0338", "nharr": "\u21AE", "nhArr": "\u21CE", "nhpar": "\u2AF2", "ni": "\u220B", "nis": "\u22FC", "nisd": "\u22FA", "niv": "\u220B", "njcy": "\u045A", "NJcy": "\u040A", "nlarr": "\u219A", "nlArr": "\u21CD", "nldr": "\u2025", "nle": "\u2270", "nlE": "\u2266\u0338", "nleftarrow": "\u219A", "nLeftarrow": "\u21CD", "nleftrightarrow": "\u21AE", "nLeftrightarrow": "\u21CE", "nleq": "\u2270", "nleqq": "\u2266\u0338", "nleqslant": "\u2A7D\u0338", "nles": "\u2A7D\u0338", "nless": "\u226E", "nLl": "\u22D8\u0338", "nlsim": "\u2274", "nlt": "\u226E", "nLt": "\u226A\u20D2", "nltri": "\u22EA", "nltrie": "\u22EC", "nLtv": "\u226A\u0338", "nmid": "\u2224", "NoBreak": "\u2060", "NonBreakingSpace": "\xA0", "nopf": "\u{1D55F}", "Nopf": "\u2115", "not": "\xAC", "Not": "\u2AEC", "NotCongruent": "\u2262", "NotCupCap": "\u226D", "NotDoubleVerticalBar": "\u2226", "NotElement": "\u2209", "NotEqual": "\u2260", "NotEqualTilde": "\u2242\u0338", "NotExists": "\u2204", "NotGreater": "\u226F", "NotGreaterEqual": "\u2271", "NotGreaterFullEqual": "\u2267\u0338", "NotGreaterGreater": "\u226B\u0338", "NotGreaterLess": "\u2279", "NotGreaterSlantEqual": "\u2A7E\u0338", "NotGreaterTilde": "\u2275", "NotHumpDownHump": "\u224E\u0338", "NotHumpEqual": "\u224F\u0338", "notin": "\u2209", "notindot": "\u22F5\u0338", "notinE": "\u22F9\u0338", "notinva": "\u2209", "notinvb": "\u22F7", "notinvc": "\u22F6", "NotLeftTriangle": "\u22EA", "NotLeftTriangleBar": "\u29CF\u0338", "NotLeftTriangleEqual": "\u22EC", "NotLess": "\u226E", "NotLessEqual": "\u2270", "NotLessGreater": "\u2278", "NotLessLess": "\u226A\u0338", "NotLessSlantEqual": "\u2A7D\u0338", "NotLessTilde": "\u2274", "NotNestedGreaterGreater": "\u2AA2\u0338", "NotNestedLessLess": "\u2AA1\u0338", "notni": "\u220C", "notniva": "\u220C", "notnivb": "\u22FE", "notnivc": "\u22FD", "NotPrecedes": "\u2280", "NotPrecedesEqual": "\u2AAF\u0338", "NotPrecedesSlantEqual": "\u22E0", "NotReverseElement": "\u220C", "NotRightTriangle": "\u22EB", "NotRightTriangleBar": "\u29D0\u0338", "NotRightTriangleEqual": "\u22ED", "NotSquareSubset": "\u228F\u0338", "NotSquareSubsetEqual": "\u22E2", "NotSquareSuperset": "\u2290\u0338", "NotSquareSupersetEqual": "\u22E3", "NotSubset": "\u2282\u20D2", "NotSubsetEqual": "\u2288", "NotSucceeds": "\u2281", "NotSucceedsEqual": "\u2AB0\u0338", "NotSucceedsSlantEqual": "\u22E1", "NotSucceedsTilde": "\u227F\u0338", "NotSuperset": "\u2283\u20D2", "NotSupersetEqual": "\u2289", "NotTilde": "\u2241", "NotTildeEqual": "\u2244", "NotTildeFullEqual": "\u2247", "NotTildeTilde": "\u2249", "NotVerticalBar": "\u2224", "npar": "\u2226", "nparallel": "\u2226", "nparsl": "\u2AFD\u20E5", "npart": "\u2202\u0338", "npolint": "\u2A14", "npr": "\u2280", "nprcue": "\u22E0", "npre": "\u2AAF\u0338", "nprec": "\u2280", "npreceq": "\u2AAF\u0338", "nrarr": "\u219B", "nrArr": "\u21CF", "nrarrc": "\u2933\u0338", "nrarrw": "\u219D\u0338", "nrightarrow": "\u219B", "nRightarrow": "\u21CF", "nrtri": "\u22EB", "nrtrie": "\u22ED", "nsc": "\u2281", "nsccue": "\u22E1", "nsce": "\u2AB0\u0338", "nscr": "\u{1D4C3}", "Nscr": "\u{1D4A9}", "nshortmid": "\u2224", "nshortparallel": "\u2226", "nsim": "\u2241", "nsime": "\u2244", "nsimeq": "\u2244", "nsmid": "\u2224", "nspar": "\u2226", "nsqsube": "\u22E2", "nsqsupe": "\u22E3", "nsub": "\u2284", "nsube": "\u2288", "nsubE": "\u2AC5\u0338", "nsubset": "\u2282\u20D2", "nsubseteq": "\u2288", "nsubseteqq": "\u2AC5\u0338", "nsucc": "\u2281", "nsucceq": "\u2AB0\u0338", "nsup": "\u2285", "nsupe": "\u2289", "nsupE": "\u2AC6\u0338", "nsupset": "\u2283\u20D2", "nsupseteq": "\u2289", "nsupseteqq": "\u2AC6\u0338", "ntgl": "\u2279", "ntilde": "\xF1", "Ntilde": "\xD1", "ntlg": "\u2278", "ntriangleleft": "\u22EA", "ntrianglelefteq": "\u22EC", "ntriangleright": "\u22EB", "ntrianglerighteq": "\u22ED", "nu": "\u03BD", "Nu": "\u039D", "num": "#", "numero": "\u2116", "numsp": "\u2007", "nvap": "\u224D\u20D2", "nvdash": "\u22AC", "nvDash": "\u22AD", "nVdash": "\u22AE", "nVDash": "\u22AF", "nvge": "\u2265\u20D2", "nvgt": ">\u20D2", "nvHarr": "\u2904", "nvinfin": "\u29DE", "nvlArr": "\u2902", "nvle": "\u2264\u20D2", "nvlt": "<\u20D2", "nvltrie": "\u22B4\u20D2", "nvrArr": "\u2903", "nvrtrie": "\u22B5\u20D2", "nvsim": "\u223C\u20D2", "nwarhk": "\u2923", "nwarr": "\u2196", "nwArr": "\u21D6", "nwarrow": "\u2196", "nwnear": "\u2927", "oacute": "\xF3", "Oacute": "\xD3", "oast": "\u229B", "ocir": "\u229A", "ocirc": "\xF4", "Ocirc": "\xD4", "ocy": "\u043E", "Ocy": "\u041E", "odash": "\u229D", "odblac": "\u0151", "Odblac": "\u0150", "odiv": "\u2A38", "odot": "\u2299", "odsold": "\u29BC", "oelig": "\u0153", "OElig": "\u0152", "ofcir": "\u29BF", "ofr": "\u{1D52C}", "Ofr": "\u{1D512}", "ogon": "\u02DB", "ograve": "\xF2", "Ograve": "\xD2", "ogt": "\u29C1", "ohbar": "\u29B5", "ohm": "\u03A9", "oint": "\u222E", "olarr": "\u21BA", "olcir": "\u29BE", "olcross": "\u29BB", "oline": "\u203E", "olt": "\u29C0", "omacr": "\u014D", "Omacr": "\u014C", "omega": "\u03C9", "Omega": "\u03A9", "omicron": "\u03BF", "Omicron": "\u039F", "omid": "\u29B6", "ominus": "\u2296", "oopf": "\u{1D560}", "Oopf": "\u{1D546}", "opar": "\u29B7", "OpenCurlyDoubleQuote": "\u201C", "OpenCurlyQuote": "\u2018", "operp": "\u29B9", "oplus": "\u2295", "or": "\u2228", "Or": "\u2A54", "orarr": "\u21BB", "ord": "\u2A5D", "order": "\u2134", "orderof": "\u2134", "ordf": "\xAA", "ordm": "\xBA", "origof": "\u22B6", "oror": "\u2A56", "orslope": "\u2A57", "orv": "\u2A5B", "oS": "\u24C8", "oscr": "\u2134", "Oscr": "\u{1D4AA}", "oslash": "\xF8", "Oslash": "\xD8", "osol": "\u2298", "otilde": "\xF5", "Otilde": "\xD5", "otimes": "\u2297", "Otimes": "\u2A37", "otimesas": "\u2A36", "ouml": "\xF6", "Ouml": "\xD6", "ovbar": "\u233D", "OverBar": "\u203E", "OverBrace": "\u23DE", "OverBracket": "\u23B4", "OverParenthesis": "\u23DC", "par": "\u2225", "para": "\xB6", "parallel": "\u2225", "parsim": "\u2AF3", "parsl": "\u2AFD", "part": "\u2202", "PartialD": "\u2202", "pcy": "\u043F", "Pcy": "\u041F", "percnt": "%", "period": ".", "permil": "\u2030", "perp": "\u22A5", "pertenk": "\u2031", "pfr": "\u{1D52D}", "Pfr": "\u{1D513}", "phi": "\u03C6", "Phi": "\u03A6", "phiv": "\u03D5", "phmmat": "\u2133", "phone": "\u260E", "pi": "\u03C0", "Pi": "\u03A0", "pitchfork": "\u22D4", "piv": "\u03D6", "planck": "\u210F", "planckh": "\u210E", "plankv": "\u210F", "plus": "+", "plusacir": "\u2A23", "plusb": "\u229E", "pluscir": "\u2A22", "plusdo": "\u2214", "plusdu": "\u2A25", "pluse": "\u2A72", "PlusMinus": "\xB1", "plusmn": "\xB1", "plussim": "\u2A26", "plustwo": "\u2A27", "pm": "\xB1", "Poincareplane": "\u210C", "pointint": "\u2A15", "popf": "\u{1D561}", "Popf": "\u2119", "pound": "\xA3", "pr": "\u227A", "Pr": "\u2ABB", "prap": "\u2AB7", "prcue": "\u227C", "pre": "\u2AAF", "prE": "\u2AB3", "prec": "\u227A", "precapprox": "\u2AB7", "preccurlyeq": "\u227C", "Precedes": "\u227A", "PrecedesEqual": "\u2AAF", "PrecedesSlantEqual": "\u227C", "PrecedesTilde": "\u227E", "preceq": "\u2AAF", "precnapprox": "\u2AB9", "precneqq": "\u2AB5", "precnsim": "\u22E8", "precsim": "\u227E", "prime": "\u2032", "Prime": "\u2033", "primes": "\u2119", "prnap": "\u2AB9", "prnE": "\u2AB5", "prnsim": "\u22E8", "prod": "\u220F", "Product": "\u220F", "profalar": "\u232E", "profline": "\u2312", "profsurf": "\u2313", "prop": "\u221D", "Proportion": "\u2237", "Proportional": "\u221D", "propto": "\u221D", "prsim": "\u227E", "prurel": "\u22B0", "pscr": "\u{1D4C5}", "Pscr": "\u{1D4AB}", "psi": "\u03C8", "Psi": "\u03A8", "puncsp": "\u2008", "qfr": "\u{1D52E}", "Qfr": "\u{1D514}", "qint": "\u2A0C", "qopf": "\u{1D562}", "Qopf": "\u211A", "qprime": "\u2057", "qscr": "\u{1D4C6}", "Qscr": "\u{1D4AC}", "quaternions": "\u210D", "quatint": "\u2A16", "quest": "?", "questeq": "\u225F", "quot": '"', "QUOT": '"', "rAarr": "\u21DB", "race": "\u223D\u0331", "racute": "\u0155", "Racute": "\u0154", "radic": "\u221A", "raemptyv": "\u29B3", "rang": "\u27E9", "Rang": "\u27EB", "rangd": "\u2992", "range": "\u29A5", "rangle": "\u27E9", "raquo": "\xBB", "rarr": "\u2192", "rArr": "\u21D2", "Rarr": "\u21A0", "rarrap": "\u2975", "rarrb": "\u21E5", "rarrbfs": "\u2920", "rarrc": "\u2933", "rarrfs": "\u291E", "rarrhk": "\u21AA", "rarrlp": "\u21AC", "rarrpl": "\u2945", "rarrsim": "\u2974", "rarrtl": "\u21A3", "Rarrtl": "\u2916", "rarrw": "\u219D", "ratail": "\u291A", "rAtail": "\u291C", "ratio": "\u2236", "rationals": "\u211A", "rbarr": "\u290D", "rBarr": "\u290F", "RBarr": "\u2910", "rbbrk": "\u2773", "rbrace": "}", "rbrack": "]", "rbrke": "\u298C", "rbrksld": "\u298E", "rbrkslu": "\u2990", "rcaron": "\u0159", "Rcaron": "\u0158", "rcedil": "\u0157", "Rcedil": "\u0156", "rceil": "\u2309", "rcub": "}", "rcy": "\u0440", "Rcy": "\u0420", "rdca": "\u2937", "rdldhar": "\u2969", "rdquo": "\u201D", "rdquor": "\u201D", "rdsh": "\u21B3", "Re": "\u211C", "real": "\u211C", "realine": "\u211B", "realpart": "\u211C", "reals": "\u211D", "rect": "\u25AD", "reg": "\xAE", "REG": "\xAE", "ReverseElement": "\u220B", "ReverseEquilibrium": "\u21CB", "ReverseUpEquilibrium": "\u296F", "rfisht": "\u297D", "rfloor": "\u230B", "rfr": "\u{1D52F}", "Rfr": "\u211C", "rHar": "\u2964", "rhard": "\u21C1", "rharu": "\u21C0", "rharul": "\u296C", "rho": "\u03C1", "Rho": "\u03A1", "rhov": "\u03F1", "RightAngleBracket": "\u27E9", "rightarrow": "\u2192", "Rightarrow": "\u21D2", "RightArrow": "\u2192", "RightArrowBar": "\u21E5", "RightArrowLeftArrow": "\u21C4", "rightarrowtail": "\u21A3", "RightCeiling": "\u2309", "RightDoubleBracket": "\u27E7", "RightDownTeeVector": "\u295D", "RightDownVector": "\u21C2", "RightDownVectorBar": "\u2955", "RightFloor": "\u230B", "rightharpoondown": "\u21C1", "rightharpoonup": "\u21C0", "rightleftarrows": "\u21C4", "rightleftharpoons": "\u21CC", "rightrightarrows": "\u21C9", "rightsquigarrow": "\u219D", "RightTee": "\u22A2", "RightTeeArrow": "\u21A6", "RightTeeVector": "\u295B", "rightthreetimes": "\u22CC", "RightTriangle": "\u22B3", "RightTriangleBar": "\u29D0", "RightTriangleEqual": "\u22B5", "RightUpDownVector": "\u294F", "RightUpTeeVector": "\u295C", "RightUpVector": "\u21BE", "RightUpVectorBar": "\u2954", "RightVector": "\u21C0", "RightVectorBar": "\u2953", "ring": "\u02DA", "risingdotseq": "\u2253", "rlarr": "\u21C4", "rlhar": "\u21CC", "rlm": "\u200F", "rmoust": "\u23B1", "rmoustache": "\u23B1", "rnmid": "\u2AEE", "roang": "\u27ED", "roarr": "\u21FE", "robrk": "\u27E7", "ropar": "\u2986", "ropf": "\u{1D563}", "Ropf": "\u211D", "roplus": "\u2A2E", "rotimes": "\u2A35", "RoundImplies": "\u2970", "rpar": ")", "rpargt": "\u2994", "rppolint": "\u2A12", "rrarr": "\u21C9", "Rrightarrow": "\u21DB", "rsaquo": "\u203A", "rscr": "\u{1D4C7}", "Rscr": "\u211B", "rsh": "\u21B1", "Rsh": "\u21B1", "rsqb": "]", "rsquo": "\u2019", "rsquor": "\u2019", "rthree": "\u22CC", "rtimes": "\u22CA", "rtri": "\u25B9", "rtrie": "\u22B5", "rtrif": "\u25B8", "rtriltri": "\u29CE", "RuleDelayed": "\u29F4", "ruluhar": "\u2968", "rx": "\u211E", "sacute": "\u015B", "Sacute": "\u015A", "sbquo": "\u201A", "sc": "\u227B", "Sc": "\u2ABC", "scap": "\u2AB8", "scaron": "\u0161", "Scaron": "\u0160", "sccue": "\u227D", "sce": "\u2AB0", "scE": "\u2AB4", "scedil": "\u015F", "Scedil": "\u015E", "scirc": "\u015D", "Scirc": "\u015C", "scnap": "\u2ABA", "scnE": "\u2AB6", "scnsim": "\u22E9", "scpolint": "\u2A13", "scsim": "\u227F", "scy": "\u0441", "Scy": "\u0421", "sdot": "\u22C5", "sdotb": "\u22A1", "sdote": "\u2A66", "searhk": "\u2925", "searr": "\u2198", "seArr": "\u21D8", "searrow": "\u2198", "sect": "\xA7", "semi": ";", "seswar": "\u2929", "setminus": "\u2216", "setmn": "\u2216", "sext": "\u2736", "sfr": "\u{1D530}", "Sfr": "\u{1D516}", "sfrown": "\u2322", "sharp": "\u266F", "shchcy": "\u0449", "SHCHcy": "\u0429", "shcy": "\u0448", "SHcy": "\u0428", "ShortDownArrow": "\u2193", "ShortLeftArrow": "\u2190", "shortmid": "\u2223", "shortparallel": "\u2225", "ShortRightArrow": "\u2192", "ShortUpArrow": "\u2191", "shy": "\xAD", "sigma": "\u03C3", "Sigma": "\u03A3", "sigmaf": "\u03C2", "sigmav": "\u03C2", "sim": "\u223C", "simdot": "\u2A6A", "sime": "\u2243", "simeq": "\u2243", "simg": "\u2A9E", "simgE": "\u2AA0", "siml": "\u2A9D", "simlE": "\u2A9F", "simne": "\u2246", "simplus": "\u2A24", "simrarr": "\u2972", "slarr": "\u2190", "SmallCircle": "\u2218", "smallsetminus": "\u2216", "smashp": "\u2A33", "smeparsl": "\u29E4", "smid": "\u2223", "smile": "\u2323", "smt": "\u2AAA", "smte": "\u2AAC", "smtes": "\u2AAC\uFE00", "softcy": "\u044C", "SOFTcy": "\u042C", "sol": "/", "solb": "\u29C4", "solbar": "\u233F", "sopf": "\u{1D564}", "Sopf": "\u{1D54A}", "spades": "\u2660", "spadesuit": "\u2660", "spar": "\u2225", "sqcap": "\u2293", "sqcaps": "\u2293\uFE00", "sqcup": "\u2294", "sqcups": "\u2294\uFE00", "Sqrt": "\u221A", "sqsub": "\u228F", "sqsube": "\u2291", "sqsubset": "\u228F", "sqsubseteq": "\u2291", "sqsup": "\u2290", "sqsupe": "\u2292", "sqsupset": "\u2290", "sqsupseteq": "\u2292", "squ": "\u25A1", "square": "\u25A1", "Square": "\u25A1", "SquareIntersection": "\u2293", "SquareSubset": "\u228F", "SquareSubsetEqual": "\u2291", "SquareSuperset": "\u2290", "SquareSupersetEqual": "\u2292", "SquareUnion": "\u2294", "squarf": "\u25AA", "squf": "\u25AA", "srarr": "\u2192", "sscr": "\u{1D4C8}", "Sscr": "\u{1D4AE}", "ssetmn": "\u2216", "ssmile": "\u2323", "sstarf": "\u22C6", "star": "\u2606", "Star": "\u22C6", "starf": "\u2605", "straightepsilon": "\u03F5", "straightphi": "\u03D5", "strns": "\xAF", "sub": "\u2282", "Sub": "\u22D0", "subdot": "\u2ABD", "sube": "\u2286", "subE": "\u2AC5", "subedot": "\u2AC3", "submult": "\u2AC1", "subne": "\u228A", "subnE": "\u2ACB", "subplus": "\u2ABF", "subrarr": "\u2979", "subset": "\u2282", "Subset": "\u22D0", "subseteq": "\u2286", "subseteqq": "\u2AC5", "SubsetEqual": "\u2286", "subsetneq": "\u228A", "subsetneqq": "\u2ACB", "subsim": "\u2AC7", "subsub": "\u2AD5", "subsup": "\u2AD3", "succ": "\u227B", "succapprox": "\u2AB8", "succcurlyeq": "\u227D", "Succeeds": "\u227B", "SucceedsEqual": "\u2AB0", "SucceedsSlantEqual": "\u227D", "SucceedsTilde": "\u227F", "succeq": "\u2AB0", "succnapprox": "\u2ABA", "succneqq": "\u2AB6", "succnsim": "\u22E9", "succsim": "\u227F", "SuchThat": "\u220B", "sum": "\u2211", "Sum": "\u2211", "sung": "\u266A", "sup": "\u2283", "Sup": "\u22D1", "sup1": "\xB9", "sup2": "\xB2", "sup3": "\xB3", "supdot": "\u2ABE", "supdsub": "\u2AD8", "supe": "\u2287", "supE": "\u2AC6", "supedot": "\u2AC4", "Superset": "\u2283", "SupersetEqual": "\u2287", "suphsol": "\u27C9", "suphsub": "\u2AD7", "suplarr": "\u297B", "supmult": "\u2AC2", "supne": "\u228B", "supnE": "\u2ACC", "supplus": "\u2AC0", "supset": "\u2283", "Supset": "\u22D1", "supseteq": "\u2287", "supseteqq": "\u2AC6", "supsetneq": "\u228B", "supsetneqq": "\u2ACC", "supsim": "\u2AC8", "supsub": "\u2AD4", "supsup": "\u2AD6", "swarhk": "\u2926", "swarr": "\u2199", "swArr": "\u21D9", "swarrow": "\u2199", "swnwar": "\u292A", "szlig": "\xDF", "Tab": "	", "target": "\u2316", "tau": "\u03C4", "Tau": "\u03A4", "tbrk": "\u23B4", "tcaron": "\u0165", "Tcaron": "\u0164", "tcedil": "\u0163", "Tcedil": "\u0162", "tcy": "\u0442", "Tcy": "\u0422", "tdot": "\u20DB", "telrec": "\u2315", "tfr": "\u{1D531}", "Tfr": "\u{1D517}", "there4": "\u2234", "therefore": "\u2234", "Therefore": "\u2234", "theta": "\u03B8", "Theta": "\u0398", "thetasym": "\u03D1", "thetav": "\u03D1", "thickapprox": "\u2248", "thicksim": "\u223C", "ThickSpace": "\u205F\u200A", "thinsp": "\u2009", "ThinSpace": "\u2009", "thkap": "\u2248", "thksim": "\u223C", "thorn": "\xFE", "THORN": "\xDE", "tilde": "\u02DC", "Tilde": "\u223C", "TildeEqual": "\u2243", "TildeFullEqual": "\u2245", "TildeTilde": "\u2248", "times": "\xD7", "timesb": "\u22A0", "timesbar": "\u2A31", "timesd": "\u2A30", "tint": "\u222D", "toea": "\u2928", "top": "\u22A4", "topbot": "\u2336", "topcir": "\u2AF1", "topf": "\u{1D565}", "Topf": "\u{1D54B}", "topfork": "\u2ADA", "tosa": "\u2929", "tprime": "\u2034", "trade": "\u2122", "TRADE": "\u2122", "triangle": "\u25B5", "triangledown": "\u25BF", "triangleleft": "\u25C3", "trianglelefteq": "\u22B4", "triangleq": "\u225C", "triangleright": "\u25B9", "trianglerighteq": "\u22B5", "tridot": "\u25EC", "trie": "\u225C", "triminus": "\u2A3A", "TripleDot": "\u20DB", "triplus": "\u2A39", "trisb": "\u29CD", "tritime": "\u2A3B", "trpezium": "\u23E2", "tscr": "\u{1D4C9}", "Tscr": "\u{1D4AF}", "tscy": "\u0446", "TScy": "\u0426", "tshcy": "\u045B", "TSHcy": "\u040B", "tstrok": "\u0167", "Tstrok": "\u0166", "twixt": "\u226C", "twoheadleftarrow": "\u219E", "twoheadrightarrow": "\u21A0", "uacute": "\xFA", "Uacute": "\xDA", "uarr": "\u2191", "uArr": "\u21D1", "Uarr": "\u219F", "Uarrocir": "\u2949", "ubrcy": "\u045E", "Ubrcy": "\u040E", "ubreve": "\u016D", "Ubreve": "\u016C", "ucirc": "\xFB", "Ucirc": "\xDB", "ucy": "\u0443", "Ucy": "\u0423", "udarr": "\u21C5", "udblac": "\u0171", "Udblac": "\u0170", "udhar": "\u296E", "ufisht": "\u297E", "ufr": "\u{1D532}", "Ufr": "\u{1D518}", "ugrave": "\xF9", "Ugrave": "\xD9", "uHar": "\u2963", "uharl": "\u21BF", "uharr": "\u21BE", "uhblk": "\u2580", "ulcorn": "\u231C", "ulcorner": "\u231C", "ulcrop": "\u230F", "ultri": "\u25F8", "umacr": "\u016B", "Umacr": "\u016A", "uml": "\xA8", "UnderBar": "_", "UnderBrace": "\u23DF", "UnderBracket": "\u23B5", "UnderParenthesis": "\u23DD", "Union": "\u22C3", "UnionPlus": "\u228E", "uogon": "\u0173", "Uogon": "\u0172", "uopf": "\u{1D566}", "Uopf": "\u{1D54C}", "uparrow": "\u2191", "Uparrow": "\u21D1", "UpArrow": "\u2191", "UpArrowBar": "\u2912", "UpArrowDownArrow": "\u21C5", "updownarrow": "\u2195", "Updownarrow": "\u21D5", "UpDownArrow": "\u2195", "UpEquilibrium": "\u296E", "upharpoonleft": "\u21BF", "upharpoonright": "\u21BE", "uplus": "\u228E", "UpperLeftArrow": "\u2196", "UpperRightArrow": "\u2197", "upsi": "\u03C5", "Upsi": "\u03D2", "upsih": "\u03D2", "upsilon": "\u03C5", "Upsilon": "\u03A5", "UpTee": "\u22A5", "UpTeeArrow": "\u21A5", "upuparrows": "\u21C8", "urcorn": "\u231D", "urcorner": "\u231D", "urcrop": "\u230E", "uring": "\u016F", "Uring": "\u016E", "urtri": "\u25F9", "uscr": "\u{1D4CA}", "Uscr": "\u{1D4B0}", "utdot": "\u22F0", "utilde": "\u0169", "Utilde": "\u0168", "utri": "\u25B5", "utrif": "\u25B4", "uuarr": "\u21C8", "uuml": "\xFC", "Uuml": "\xDC", "uwangle": "\u29A7", "vangrt": "\u299C", "varepsilon": "\u03F5", "varkappa": "\u03F0", "varnothing": "\u2205", "varphi": "\u03D5", "varpi": "\u03D6", "varpropto": "\u221D", "varr": "\u2195", "vArr": "\u21D5", "varrho": "\u03F1", "varsigma": "\u03C2", "varsubsetneq": "\u228A\uFE00", "varsubsetneqq": "\u2ACB\uFE00", "varsupsetneq": "\u228B\uFE00", "varsupsetneqq": "\u2ACC\uFE00", "vartheta": "\u03D1", "vartriangleleft": "\u22B2", "vartriangleright": "\u22B3", "vBar": "\u2AE8", "Vbar": "\u2AEB", "vBarv": "\u2AE9", "vcy": "\u0432", "Vcy": "\u0412", "vdash": "\u22A2", "vDash": "\u22A8", "Vdash": "\u22A9", "VDash": "\u22AB", "Vdashl": "\u2AE6", "vee": "\u2228", "Vee": "\u22C1", "veebar": "\u22BB", "veeeq": "\u225A", "vellip": "\u22EE", "verbar": "|", "Verbar": "\u2016", "vert": "|", "Vert": "\u2016", "VerticalBar": "\u2223", "VerticalLine": "|", "VerticalSeparator": "\u2758", "VerticalTilde": "\u2240", "VeryThinSpace": "\u200A", "vfr": "\u{1D533}", "Vfr": "\u{1D519}", "vltri": "\u22B2", "vnsub": "\u2282\u20D2", "vnsup": "\u2283\u20D2", "vopf": "\u{1D567}", "Vopf": "\u{1D54D}", "vprop": "\u221D", "vrtri": "\u22B3", "vscr": "\u{1D4CB}", "Vscr": "\u{1D4B1}", "vsubne": "\u228A\uFE00", "vsubnE": "\u2ACB\uFE00", "vsupne": "\u228B\uFE00", "vsupnE": "\u2ACC\uFE00", "Vvdash": "\u22AA", "vzigzag": "\u299A", "wcirc": "\u0175", "Wcirc": "\u0174", "wedbar": "\u2A5F", "wedge": "\u2227", "Wedge": "\u22C0", "wedgeq": "\u2259", "weierp": "\u2118", "wfr": "\u{1D534}", "Wfr": "\u{1D51A}", "wopf": "\u{1D568}", "Wopf": "\u{1D54E}", "wp": "\u2118", "wr": "\u2240", "wreath": "\u2240", "wscr": "\u{1D4CC}", "Wscr": "\u{1D4B2}", "xcap": "\u22C2", "xcirc": "\u25EF", "xcup": "\u22C3", "xdtri": "\u25BD", "xfr": "\u{1D535}", "Xfr": "\u{1D51B}", "xharr": "\u27F7", "xhArr": "\u27FA", "xi": "\u03BE", "Xi": "\u039E", "xlarr": "\u27F5", "xlArr": "\u27F8", "xmap": "\u27FC", "xnis": "\u22FB", "xodot": "\u2A00", "xopf": "\u{1D569}", "Xopf": "\u{1D54F}", "xoplus": "\u2A01", "xotime": "\u2A02", "xrarr": "\u27F6", "xrArr": "\u27F9", "xscr": "\u{1D4CD}", "Xscr": "\u{1D4B3}", "xsqcup": "\u2A06", "xuplus": "\u2A04", "xutri": "\u25B3", "xvee": "\u22C1", "xwedge": "\u22C0", "yacute": "\xFD", "Yacute": "\xDD", "yacy": "\u044F", "YAcy": "\u042F", "ycirc": "\u0177", "Ycirc": "\u0176", "ycy": "\u044B", "Ycy": "\u042B", "yen": "\xA5", "yfr": "\u{1D536}", "Yfr": "\u{1D51C}", "yicy": "\u0457", "YIcy": "\u0407", "yopf": "\u{1D56A}", "Yopf": "\u{1D550}", "yscr": "\u{1D4CE}", "Yscr": "\u{1D4B4}", "yucy": "\u044E", "YUcy": "\u042E", "yuml": "\xFF", "Yuml": "\u0178", "zacute": "\u017A", "Zacute": "\u0179", "zcaron": "\u017E", "Zcaron": "\u017D", "zcy": "\u0437", "Zcy": "\u0417", "zdot": "\u017C", "Zdot": "\u017B", "zeetrf": "\u2128", "ZeroWidthSpace": "\u200B", "zeta": "\u03B6", "Zeta": "\u0396", "zfr": "\u{1D537}", "Zfr": "\u2128", "zhcy": "\u0436", "ZHcy": "\u0416", "zigrarr": "\u21DD", "zopf": "\u{1D56B}", "Zopf": "\u2124", "zscr": "\u{1D4CF}", "Zscr": "\u{1D4B5}", "zwj": "\u200D", "zwnj": "\u200C" };
      var decodeMapLegacy = { "aacute": "\xE1", "Aacute": "\xC1", "acirc": "\xE2", "Acirc": "\xC2", "acute": "\xB4", "aelig": "\xE6", "AElig": "\xC6", "agrave": "\xE0", "Agrave": "\xC0", "amp": "&", "AMP": "&", "aring": "\xE5", "Aring": "\xC5", "atilde": "\xE3", "Atilde": "\xC3", "auml": "\xE4", "Auml": "\xC4", "brvbar": "\xA6", "ccedil": "\xE7", "Ccedil": "\xC7", "cedil": "\xB8", "cent": "\xA2", "copy": "\xA9", "COPY": "\xA9", "curren": "\xA4", "deg": "\xB0", "divide": "\xF7", "eacute": "\xE9", "Eacute": "\xC9", "ecirc": "\xEA", "Ecirc": "\xCA", "egrave": "\xE8", "Egrave": "\xC8", "eth": "\xF0", "ETH": "\xD0", "euml": "\xEB", "Euml": "\xCB", "frac12": "\xBD", "frac14": "\xBC", "frac34": "\xBE", "gt": ">", "GT": ">", "iacute": "\xED", "Iacute": "\xCD", "icirc": "\xEE", "Icirc": "\xCE", "iexcl": "\xA1", "igrave": "\xEC", "Igrave": "\xCC", "iquest": "\xBF", "iuml": "\xEF", "Iuml": "\xCF", "laquo": "\xAB", "lt": "<", "LT": "<", "macr": "\xAF", "micro": "\xB5", "middot": "\xB7", "nbsp": "\xA0", "not": "\xAC", "ntilde": "\xF1", "Ntilde": "\xD1", "oacute": "\xF3", "Oacute": "\xD3", "ocirc": "\xF4", "Ocirc": "\xD4", "ograve": "\xF2", "Ograve": "\xD2", "ordf": "\xAA", "ordm": "\xBA", "oslash": "\xF8", "Oslash": "\xD8", "otilde": "\xF5", "Otilde": "\xD5", "ouml": "\xF6", "Ouml": "\xD6", "para": "\xB6", "plusmn": "\xB1", "pound": "\xA3", "quot": '"', "QUOT": '"', "raquo": "\xBB", "reg": "\xAE", "REG": "\xAE", "sect": "\xA7", "shy": "\xAD", "sup1": "\xB9", "sup2": "\xB2", "sup3": "\xB3", "szlig": "\xDF", "thorn": "\xFE", "THORN": "\xDE", "times": "\xD7", "uacute": "\xFA", "Uacute": "\xDA", "ucirc": "\xFB", "Ucirc": "\xDB", "ugrave": "\xF9", "Ugrave": "\xD9", "uml": "\xA8", "uuml": "\xFC", "Uuml": "\xDC", "yacute": "\xFD", "Yacute": "\xDD", "yen": "\xA5", "yuml": "\xFF" };
      var decodeMapNumeric = { "0": "\uFFFD", "128": "\u20AC", "130": "\u201A", "131": "\u0192", "132": "\u201E", "133": "\u2026", "134": "\u2020", "135": "\u2021", "136": "\u02C6", "137": "\u2030", "138": "\u0160", "139": "\u2039", "140": "\u0152", "142": "\u017D", "145": "\u2018", "146": "\u2019", "147": "\u201C", "148": "\u201D", "149": "\u2022", "150": "\u2013", "151": "\u2014", "152": "\u02DC", "153": "\u2122", "154": "\u0161", "155": "\u203A", "156": "\u0153", "158": "\u017E", "159": "\u0178" };
      var invalidReferenceCodePoints = [1, 2, 3, 4, 5, 6, 7, 8, 11, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 64976, 64977, 64978, 64979, 64980, 64981, 64982, 64983, 64984, 64985, 64986, 64987, 64988, 64989, 64990, 64991, 64992, 64993, 64994, 64995, 64996, 64997, 64998, 64999, 65e3, 65001, 65002, 65003, 65004, 65005, 65006, 65007, 65534, 65535, 131070, 131071, 196606, 196607, 262142, 262143, 327678, 327679, 393214, 393215, 458750, 458751, 524286, 524287, 589822, 589823, 655358, 655359, 720894, 720895, 786430, 786431, 851966, 851967, 917502, 917503, 983038, 983039, 1048574, 1048575, 1114110, 1114111];
      var stringFromCharCode = String.fromCharCode;
      var object = {};
      var hasOwnProperty13 = object.hasOwnProperty;
      var has = function(object2, propertyName) {
        return hasOwnProperty13.call(object2, propertyName);
      };
      var contains = function(array, value) {
        var index = -1;
        var length = array.length;
        while (++index < length) {
          if (array[index] == value) {
            return true;
          }
        }
        return false;
      };
      var merge2 = function(options, defaults) {
        if (!options) {
          return defaults;
        }
        var result = {};
        var key2;
        for (key2 in defaults) {
          result[key2] = has(options, key2) ? options[key2] : defaults[key2];
        }
        return result;
      };
      var codePointToSymbol = function(codePoint, strict) {
        var output = "";
        if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
          if (strict) {
            parseError("character reference outside the permissible Unicode range");
          }
          return "\uFFFD";
        }
        if (has(decodeMapNumeric, codePoint)) {
          if (strict) {
            parseError("disallowed character reference");
          }
          return decodeMapNumeric[codePoint];
        }
        if (strict && contains(invalidReferenceCodePoints, codePoint)) {
          parseError("disallowed character reference");
        }
        if (codePoint > 65535) {
          codePoint -= 65536;
          output += stringFromCharCode(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        output += stringFromCharCode(codePoint);
        return output;
      };
      var hexEscape = function(codePoint) {
        return "&#x" + codePoint.toString(16).toUpperCase() + ";";
      };
      var decEscape = function(codePoint) {
        return "&#" + codePoint + ";";
      };
      var parseError = function(message) {
        throw Error("Parse error: " + message);
      };
      var encode3 = function(string, options) {
        options = merge2(options, encode3.options);
        var strict = options.strict;
        if (strict && regexInvalidRawCodePoint.test(string)) {
          parseError("forbidden code point");
        }
        var encodeEverything = options.encodeEverything;
        var useNamedReferences = options.useNamedReferences;
        var allowUnsafeSymbols = options.allowUnsafeSymbols;
        var escapeCodePoint = options.decimal ? decEscape : hexEscape;
        var escapeBmpSymbol = function(symbol) {
          return escapeCodePoint(symbol.charCodeAt(0));
        };
        if (encodeEverything) {
          string = string.replace(regexAsciiWhitelist, function(symbol) {
            if (useNamedReferences && has(encodeMap, symbol)) {
              return "&" + encodeMap[symbol] + ";";
            }
            return escapeBmpSymbol(symbol);
          });
          if (useNamedReferences) {
            string = string.replace(/&gt;\u20D2/g, "&nvgt;").replace(/&lt;\u20D2/g, "&nvlt;").replace(/&#x66;&#x6A;/g, "&fjlig;");
          }
          if (useNamedReferences) {
            string = string.replace(regexEncodeNonAscii, function(string2) {
              return "&" + encodeMap[string2] + ";";
            });
          }
        } else if (useNamedReferences) {
          if (!allowUnsafeSymbols) {
            string = string.replace(regexEscape, function(string2) {
              return "&" + encodeMap[string2] + ";";
            });
          }
          string = string.replace(/&gt;\u20D2/g, "&nvgt;").replace(/&lt;\u20D2/g, "&nvlt;");
          string = string.replace(regexEncodeNonAscii, function(string2) {
            return "&" + encodeMap[string2] + ";";
          });
        } else if (!allowUnsafeSymbols) {
          string = string.replace(regexEscape, escapeBmpSymbol);
        }
        return string.replace(regexAstralSymbols, function($0) {
          var high = $0.charCodeAt(0);
          var low = $0.charCodeAt(1);
          var codePoint = (high - 55296) * 1024 + low - 56320 + 65536;
          return escapeCodePoint(codePoint);
        }).replace(regexBmpWhitelist, escapeBmpSymbol);
      };
      encode3.options = {
        "allowUnsafeSymbols": false,
        "encodeEverything": false,
        "strict": false,
        "useNamedReferences": false,
        "decimal": false
      };
      var decode3 = function(html, options) {
        options = merge2(options, decode3.options);
        var strict = options.strict;
        if (strict && regexInvalidEntity.test(html)) {
          parseError("malformed character reference");
        }
        return html.replace(regexDecode, function($0, $1, $2, $3, $4, $5, $6, $7, $8) {
          var codePoint;
          var semicolon;
          var decDigits;
          var hexDigits;
          var reference;
          var next;
          if ($1) {
            reference = $1;
            return decodeMap2[reference];
          }
          if ($2) {
            reference = $2;
            next = $3;
            if (next && options.isAttributeValue) {
              if (strict && next == "=") {
                parseError("`&` did not start a character reference");
              }
              return $0;
            } else {
              if (strict) {
                parseError(
                  "named character reference was not terminated by a semicolon"
                );
              }
              return decodeMapLegacy[reference] + (next || "");
            }
          }
          if ($4) {
            decDigits = $4;
            semicolon = $5;
            if (strict && !semicolon) {
              parseError("character reference was not terminated by a semicolon");
            }
            codePoint = parseInt(decDigits, 10);
            return codePointToSymbol(codePoint, strict);
          }
          if ($6) {
            hexDigits = $6;
            semicolon = $7;
            if (strict && !semicolon) {
              parseError("character reference was not terminated by a semicolon");
            }
            codePoint = parseInt(hexDigits, 16);
            return codePointToSymbol(codePoint, strict);
          }
          if (strict) {
            parseError(
              "named character reference was not terminated by a semicolon"
            );
          }
          return $0;
        });
      };
      decode3.options = {
        "isAttributeValue": false,
        "strict": false
      };
      var escape = function(string) {
        return string.replace(regexEscape, function($0) {
          return escapeMap[$0];
        });
      };
      var he2 = {
        "version": "1.2.0",
        "encode": encode3,
        "decode": decode3,
        "escape": escape,
        "unescape": decode3
      };
      if (freeExports4 && !freeExports4.nodeType) {
        if (freeModule4) {
          freeModule4.exports = he2;
        } else {
          for (var key in he2) {
            has(he2, key) && (freeExports4[key] = he2[key]);
          }
        }
      } else {
        root2.he = he2;
      }
    })(he$1);
  })(he$2, he$2.exports);
  return he$2.exports;
}
var heExports = requireHe();
var he = /* @__PURE__ */ getDefaultExportFromCjs(heExports);
var Node = class {
  parentNode;
  childNodes = [];
  range = [-1, -1];
  constructor(parentNode = null, range2) {
    this.parentNode = parentNode;
    if (range2) {
      this.range = range2;
    }
  }
  remove() {
    if (this.parentNode) {
      const children = this.parentNode.childNodes;
      this.parentNode.childNodes = children.filter((child) => {
        return this !== child;
      });
      this.parentNode = null;
    }
    return this;
  }
  get innerText() {
    return this.rawText;
  }
  get textContent() {
    return he.decode(this.rawText);
  }
  set textContent(val) {
    this.rawText = he.encode(val);
  }
};
var NodeType;
(function(NodeType2) {
  NodeType2[NodeType2["ELEMENT_NODE"] = 1] = "ELEMENT_NODE";
  NodeType2[NodeType2["TEXT_NODE"] = 3] = "TEXT_NODE";
  NodeType2[NodeType2["COMMENT_NODE"] = 8] = "COMMENT_NODE";
})(NodeType || (NodeType = {}));
var CommentNode = class _CommentNode extends Node {
  rawText;
  rawTagName;
  clone() {
    return new _CommentNode(this.rawText, null, void 0, this.rawTagName);
  }
  constructor(rawText, parentNode = null, range2, rawTagName = "!--") {
    super(parentNode, range2);
    this.rawText = rawText;
    this.rawTagName = rawTagName;
  }
  nodeType = NodeType.COMMENT_NODE;
  get text() {
    return this.rawText;
  }
  toString() {
    return `<!--${this.rawText}-->`;
  }
};
var boolbase$1;
var hasRequiredBoolbase;
function requireBoolbase() {
  if (hasRequiredBoolbase) return boolbase$1;
  hasRequiredBoolbase = 1;
  boolbase$1 = {
    trueFunc: function trueFunc() {
      return true;
    },
    falseFunc: function falseFunc() {
      return false;
    }
  };
  return boolbase$1;
}
var boolbaseExports = requireBoolbase();
var boolbase = /* @__PURE__ */ getDefaultExportFromCjs(boolbaseExports);
var SelectorType;
(function(SelectorType2) {
  SelectorType2["Attribute"] = "attribute";
  SelectorType2["Pseudo"] = "pseudo";
  SelectorType2["PseudoElement"] = "pseudo-element";
  SelectorType2["Tag"] = "tag";
  SelectorType2["Universal"] = "universal";
  SelectorType2["Adjacent"] = "adjacent";
  SelectorType2["Child"] = "child";
  SelectorType2["Descendant"] = "descendant";
  SelectorType2["Parent"] = "parent";
  SelectorType2["Sibling"] = "sibling";
  SelectorType2["ColumnCombinator"] = "column-combinator";
})(SelectorType || (SelectorType = {}));
var AttributeAction;
(function(AttributeAction2) {
  AttributeAction2["Any"] = "any";
  AttributeAction2["Element"] = "element";
  AttributeAction2["End"] = "end";
  AttributeAction2["Equals"] = "equals";
  AttributeAction2["Exists"] = "exists";
  AttributeAction2["Hyphen"] = "hyphen";
  AttributeAction2["Not"] = "not";
  AttributeAction2["Start"] = "start";
})(AttributeAction || (AttributeAction = {}));
var reName = /^[^#\\]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\u00B0-\uFFFF-])+/;
var reEscape = /\\([\da-f]{1,6}\s?|(\s)|.)/gi;
var CharCode;
(function(CharCode2) {
  CharCode2[CharCode2["LeftParenthesis"] = 40] = "LeftParenthesis";
  CharCode2[CharCode2["RightParenthesis"] = 41] = "RightParenthesis";
  CharCode2[CharCode2["LeftSquareBracket"] = 91] = "LeftSquareBracket";
  CharCode2[CharCode2["RightSquareBracket"] = 93] = "RightSquareBracket";
  CharCode2[CharCode2["Comma"] = 44] = "Comma";
  CharCode2[CharCode2["Period"] = 46] = "Period";
  CharCode2[CharCode2["Colon"] = 58] = "Colon";
  CharCode2[CharCode2["SingleQuote"] = 39] = "SingleQuote";
  CharCode2[CharCode2["DoubleQuote"] = 34] = "DoubleQuote";
  CharCode2[CharCode2["Plus"] = 43] = "Plus";
  CharCode2[CharCode2["Tilde"] = 126] = "Tilde";
  CharCode2[CharCode2["QuestionMark"] = 63] = "QuestionMark";
  CharCode2[CharCode2["ExclamationMark"] = 33] = "ExclamationMark";
  CharCode2[CharCode2["Slash"] = 47] = "Slash";
  CharCode2[CharCode2["Equal"] = 61] = "Equal";
  CharCode2[CharCode2["Dollar"] = 36] = "Dollar";
  CharCode2[CharCode2["Pipe"] = 124] = "Pipe";
  CharCode2[CharCode2["Circumflex"] = 94] = "Circumflex";
  CharCode2[CharCode2["Asterisk"] = 42] = "Asterisk";
  CharCode2[CharCode2["GreaterThan"] = 62] = "GreaterThan";
  CharCode2[CharCode2["LessThan"] = 60] = "LessThan";
  CharCode2[CharCode2["Hash"] = 35] = "Hash";
  CharCode2[CharCode2["LowerI"] = 105] = "LowerI";
  CharCode2[CharCode2["LowerS"] = 115] = "LowerS";
  CharCode2[CharCode2["BackSlash"] = 92] = "BackSlash";
  CharCode2[CharCode2["Space"] = 32] = "Space";
  CharCode2[CharCode2["Tab"] = 9] = "Tab";
  CharCode2[CharCode2["NewLine"] = 10] = "NewLine";
  CharCode2[CharCode2["FormFeed"] = 12] = "FormFeed";
  CharCode2[CharCode2["CarriageReturn"] = 13] = "CarriageReturn";
})(CharCode || (CharCode = {}));
var actionTypes = /* @__PURE__ */ new Map([
  [CharCode.Tilde, AttributeAction.Element],
  [CharCode.Circumflex, AttributeAction.Start],
  [CharCode.Dollar, AttributeAction.End],
  [CharCode.Asterisk, AttributeAction.Any],
  [CharCode.ExclamationMark, AttributeAction.Not],
  [CharCode.Pipe, AttributeAction.Hyphen]
]);
var unpackPseudos = /* @__PURE__ */ new Set([
  "has",
  "not",
  "matches",
  "is",
  "where",
  "host",
  "host-context"
]);
var pseudosToPseudoElements = /* @__PURE__ */ new Set([
  "before",
  "after",
  "first-line",
  "first-letter"
]);
function isTraversal$1(selector) {
  switch (selector.type) {
    case SelectorType.Adjacent:
    case SelectorType.Child:
    case SelectorType.Descendant:
    case SelectorType.Parent:
    case SelectorType.Sibling:
    case SelectorType.ColumnCombinator: {
      return true;
    }
    default: {
      return false;
    }
  }
}
var stripQuotesFromPseudos = /* @__PURE__ */ new Set(["contains", "icontains"]);
function funescape(_, escaped, escapedWhitespace) {
  const high = Number.parseInt(escaped, 16) - 65536;
  return high !== high || escapedWhitespace ? escaped : high < 0 ? (
    // BMP codepoint
    String.fromCharCode(high + 65536)
  ) : (
    // Supplemental Plane codepoint (surrogate pair)
    String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320)
  );
}
function unescapeCSS(cssString) {
  return cssString.replace(reEscape, funescape);
}
function isQuote(c4) {
  return c4 === CharCode.SingleQuote || c4 === CharCode.DoubleQuote;
}
function isWhitespace(c4) {
  return c4 === CharCode.Space || c4 === CharCode.Tab || c4 === CharCode.NewLine || c4 === CharCode.FormFeed || c4 === CharCode.CarriageReturn;
}
function parse$3(selector) {
  const subselects2 = [];
  const endIndex = parseSelector(subselects2, `${selector}`, 0);
  if (endIndex < selector.length) {
    throw new Error(`Unmatched selector: ${selector.slice(endIndex)}`);
  }
  return subselects2;
}
function parseSelector(subselects2, selector, selectorIndex) {
  let tokens = [];
  function getName2(offset) {
    const match = selector.slice(selectorIndex + offset).match(reName);
    if (!match) {
      throw new Error(`Expected name, found ${selector.slice(selectorIndex)}`);
    }
    const [name] = match;
    selectorIndex += offset + name.length;
    return unescapeCSS(name);
  }
  function stripWhitespace(offset) {
    selectorIndex += offset;
    while (selectorIndex < selector.length && isWhitespace(selector.charCodeAt(selectorIndex))) {
      selectorIndex++;
    }
  }
  function readValueWithParenthesis() {
    selectorIndex += 1;
    const start = selectorIndex;
    for (let counter = 1; selectorIndex < selector.length; selectorIndex++) {
      switch (selector.charCodeAt(selectorIndex)) {
        case CharCode.BackSlash: {
          selectorIndex += 1;
          break;
        }
        case CharCode.LeftParenthesis: {
          counter += 1;
          break;
        }
        case CharCode.RightParenthesis: {
          counter -= 1;
          if (counter === 0) {
            return unescapeCSS(selector.slice(start, selectorIndex++));
          }
          break;
        }
      }
    }
    throw new Error("Parenthesis not matched");
  }
  function ensureNotTraversal() {
    if (tokens.length > 0 && isTraversal$1(tokens[tokens.length - 1])) {
      throw new Error("Did not expect successive traversals.");
    }
  }
  function addTraversal(type) {
    if (tokens.length > 0 && tokens[tokens.length - 1].type === SelectorType.Descendant) {
      tokens[tokens.length - 1].type = type;
      return;
    }
    ensureNotTraversal();
    tokens.push({ type });
  }
  function addSpecialAttribute(name, action) {
    tokens.push({
      type: SelectorType.Attribute,
      name,
      action,
      value: getName2(1),
      namespace: null,
      ignoreCase: "quirks"
    });
  }
  function finalizeSubselector() {
    if (tokens.length > 0 && tokens[tokens.length - 1].type === SelectorType.Descendant) {
      tokens.pop();
    }
    if (tokens.length === 0) {
      throw new Error("Empty sub-selector");
    }
    subselects2.push(tokens);
  }
  stripWhitespace(0);
  if (selector.length === selectorIndex) {
    return selectorIndex;
  }
  loop: while (selectorIndex < selector.length) {
    const firstChar = selector.charCodeAt(selectorIndex);
    switch (firstChar) {
      // Whitespace
      case CharCode.Space:
      case CharCode.Tab:
      case CharCode.NewLine:
      case CharCode.FormFeed:
      case CharCode.CarriageReturn: {
        if (tokens.length === 0 || tokens[0].type !== SelectorType.Descendant) {
          ensureNotTraversal();
          tokens.push({ type: SelectorType.Descendant });
        }
        stripWhitespace(1);
        break;
      }
      // Traversals
      case CharCode.GreaterThan: {
        addTraversal(SelectorType.Child);
        stripWhitespace(1);
        break;
      }
      case CharCode.LessThan: {
        addTraversal(SelectorType.Parent);
        stripWhitespace(1);
        break;
      }
      case CharCode.Tilde: {
        addTraversal(SelectorType.Sibling);
        stripWhitespace(1);
        break;
      }
      case CharCode.Plus: {
        addTraversal(SelectorType.Adjacent);
        stripWhitespace(1);
        break;
      }
      // Special attribute selectors: .class, #id
      case CharCode.Period: {
        addSpecialAttribute("class", AttributeAction.Element);
        break;
      }
      case CharCode.Hash: {
        addSpecialAttribute("id", AttributeAction.Equals);
        break;
      }
      case CharCode.LeftSquareBracket: {
        stripWhitespace(1);
        let name;
        let namespace = null;
        if (selector.charCodeAt(selectorIndex) === CharCode.Pipe) {
          name = getName2(1);
        } else if (selector.startsWith("*|", selectorIndex)) {
          namespace = "*";
          name = getName2(2);
        } else {
          name = getName2(0);
          if (selector.charCodeAt(selectorIndex) === CharCode.Pipe && selector.charCodeAt(selectorIndex + 1) !== CharCode.Equal) {
            namespace = name;
            name = getName2(1);
          }
        }
        stripWhitespace(0);
        let action = AttributeAction.Exists;
        const possibleAction = actionTypes.get(selector.charCodeAt(selectorIndex));
        if (possibleAction) {
          action = possibleAction;
          if (selector.charCodeAt(selectorIndex + 1) !== CharCode.Equal) {
            throw new Error("Expected `=`");
          }
          stripWhitespace(2);
        } else if (selector.charCodeAt(selectorIndex) === CharCode.Equal) {
          action = AttributeAction.Equals;
          stripWhitespace(1);
        }
        let value = "";
        let ignoreCase = null;
        if (action !== "exists") {
          if (isQuote(selector.charCodeAt(selectorIndex))) {
            const quote = selector.charCodeAt(selectorIndex);
            selectorIndex += 1;
            const sectionStart = selectorIndex;
            while (selectorIndex < selector.length && selector.charCodeAt(selectorIndex) !== quote) {
              selectorIndex += // Skip next character if it is escaped
              selector.charCodeAt(selectorIndex) === CharCode.BackSlash ? 2 : 1;
            }
            if (selector.charCodeAt(selectorIndex) !== quote) {
              throw new Error("Attribute value didn't end");
            }
            value = unescapeCSS(selector.slice(sectionStart, selectorIndex));
            selectorIndex += 1;
          } else {
            const valueStart = selectorIndex;
            while (selectorIndex < selector.length && !isWhitespace(selector.charCodeAt(selectorIndex)) && selector.charCodeAt(selectorIndex) !== CharCode.RightSquareBracket) {
              selectorIndex += // Skip next character if it is escaped
              selector.charCodeAt(selectorIndex) === CharCode.BackSlash ? 2 : 1;
            }
            value = unescapeCSS(selector.slice(valueStart, selectorIndex));
          }
          stripWhitespace(0);
          switch (selector.charCodeAt(selectorIndex) | 32) {
            // If the forceIgnore flag is set (either `i` or `s`), use that value
            case CharCode.LowerI: {
              ignoreCase = true;
              stripWhitespace(1);
              break;
            }
            case CharCode.LowerS: {
              ignoreCase = false;
              stripWhitespace(1);
              break;
            }
          }
        }
        if (selector.charCodeAt(selectorIndex) !== CharCode.RightSquareBracket) {
          throw new Error("Attribute selector didn't terminate");
        }
        selectorIndex += 1;
        const attributeSelector = {
          type: SelectorType.Attribute,
          name,
          action,
          value,
          namespace,
          ignoreCase
        };
        tokens.push(attributeSelector);
        break;
      }
      case CharCode.Colon: {
        if (selector.charCodeAt(selectorIndex + 1) === CharCode.Colon) {
          tokens.push({
            type: SelectorType.PseudoElement,
            name: getName2(2).toLowerCase(),
            data: selector.charCodeAt(selectorIndex) === CharCode.LeftParenthesis ? readValueWithParenthesis() : null
          });
          break;
        }
        const name = getName2(1).toLowerCase();
        if (pseudosToPseudoElements.has(name)) {
          tokens.push({
            type: SelectorType.PseudoElement,
            name,
            data: null
          });
          break;
        }
        let data2 = null;
        if (selector.charCodeAt(selectorIndex) === CharCode.LeftParenthesis) {
          if (unpackPseudos.has(name)) {
            if (isQuote(selector.charCodeAt(selectorIndex + 1))) {
              throw new Error(`Pseudo-selector ${name} cannot be quoted`);
            }
            data2 = [];
            selectorIndex = parseSelector(data2, selector, selectorIndex + 1);
            if (selector.charCodeAt(selectorIndex) !== CharCode.RightParenthesis) {
              throw new Error(`Missing closing parenthesis in :${name} (${selector})`);
            }
            selectorIndex += 1;
          } else {
            data2 = readValueWithParenthesis();
            if (stripQuotesFromPseudos.has(name)) {
              const quot = data2.charCodeAt(0);
              if (quot === data2.charCodeAt(data2.length - 1) && isQuote(quot)) {
                data2 = data2.slice(1, -1);
              }
            }
            data2 = unescapeCSS(data2);
          }
        }
        tokens.push({ type: SelectorType.Pseudo, name, data: data2 });
        break;
      }
      case CharCode.Comma: {
        finalizeSubselector();
        tokens = [];
        stripWhitespace(1);
        break;
      }
      default: {
        if (selector.startsWith("/*", selectorIndex)) {
          const endIndex = selector.indexOf("*/", selectorIndex + 2);
          if (endIndex < 0) {
            throw new Error("Comment was not terminated");
          }
          selectorIndex = endIndex + 2;
          if (tokens.length === 0) {
            stripWhitespace(0);
          }
          break;
        }
        let namespace = null;
        let name;
        if (firstChar === CharCode.Asterisk) {
          selectorIndex += 1;
          name = "*";
        } else if (firstChar === CharCode.Pipe) {
          name = "";
          if (selector.charCodeAt(selectorIndex + 1) === CharCode.Pipe) {
            addTraversal(SelectorType.ColumnCombinator);
            stripWhitespace(2);
            break;
          }
        } else if (reName.test(selector.slice(selectorIndex))) {
          name = getName2(0);
        } else {
          break loop;
        }
        if (selector.charCodeAt(selectorIndex) === CharCode.Pipe && selector.charCodeAt(selectorIndex + 1) !== CharCode.Pipe) {
          namespace = name;
          if (selector.charCodeAt(selectorIndex + 1) === CharCode.Asterisk) {
            name = "*";
            selectorIndex += 2;
          } else {
            name = getName2(1);
          }
        }
        tokens.push(name === "*" ? { type: SelectorType.Universal, namespace } : { type: SelectorType.Tag, name, namespace });
      }
    }
  }
  finalizeSubselector();
  return selectorIndex;
}
var ElementType;
(function(ElementType2) {
  ElementType2["Root"] = "root";
  ElementType2["Text"] = "text";
  ElementType2["Directive"] = "directive";
  ElementType2["Comment"] = "comment";
  ElementType2["Script"] = "script";
  ElementType2["Style"] = "style";
  ElementType2["Tag"] = "tag";
  ElementType2["CDATA"] = "cdata";
  ElementType2["Doctype"] = "doctype";
})(ElementType || (ElementType = {}));
function isTag$2(elem) {
  return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
}
var Root = ElementType.Root;
var Text = ElementType.Text;
var Directive = ElementType.Directive;
var Comment = ElementType.Comment;
var Script = ElementType.Script;
var Style = ElementType.Style;
var Tag = ElementType.Tag;
var CDATA = ElementType.CDATA;
var Doctype = ElementType.Doctype;
function isTag$1(node) {
  return isTag$2(node);
}
function isCDATA(node) {
  return node.type === ElementType.CDATA;
}
function isText(node) {
  return node.type === ElementType.Text;
}
function isComment(node) {
  return node.type === ElementType.Comment;
}
function isDocument(node) {
  return node.type === ElementType.Root;
}
function hasChildren(node) {
  return Object.prototype.hasOwnProperty.call(node, "children");
}
var xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
var xmlCodeMap = /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [39, "&apos;"],
  [60, "&lt;"],
  [62, "&gt;"]
]);
var getCodePoint = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.prototype.codePointAt != null ? (str, index) => str.codePointAt(index) : (
    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
    (c4, index) => (c4.charCodeAt(index) & 64512) === 55296 ? (c4.charCodeAt(index) - 55296) * 1024 + c4.charCodeAt(index + 1) - 56320 + 65536 : c4.charCodeAt(index)
  )
);
function encodeXML(str) {
  let ret = "";
  let lastIdx = 0;
  let match;
  while ((match = xmlReplacer.exec(str)) !== null) {
    const i4 = match.index;
    const char = str.charCodeAt(i4);
    const next = xmlCodeMap.get(char);
    if (next !== void 0) {
      ret += str.substring(lastIdx, i4) + next;
      lastIdx = i4 + 1;
    } else {
      ret += `${str.substring(lastIdx, i4)}&#x${getCodePoint(str, i4).toString(16)};`;
      lastIdx = xmlReplacer.lastIndex += Number((char & 64512) === 55296);
    }
  }
  return ret + str.substr(lastIdx);
}
function getEscaper(regex, map2) {
  return function escape(data2) {
    let match;
    let lastIdx = 0;
    let result = "";
    while (match = regex.exec(data2)) {
      if (lastIdx !== match.index) {
        result += data2.substring(lastIdx, match.index);
      }
      result += map2.get(match[0].charCodeAt(0));
      lastIdx = match.index + 1;
    }
    return result + data2.substring(lastIdx);
  };
}
var escapeAttribute = getEscaper(/["&\u00A0]/g, /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [160, "&nbsp;"]
]));
var escapeText = getEscaper(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
  [38, "&amp;"],
  [60, "&lt;"],
  [62, "&gt;"],
  [160, "&nbsp;"]
]));
var elementNames = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((val) => [val.toLowerCase(), val]));
var attributeNames = new Map([
  "definitionURL",
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((val) => [val.toLowerCase(), val]));
var unencodedElements = /* @__PURE__ */ new Set([
  "style",
  "script",
  "xmp",
  "iframe",
  "noembed",
  "noframes",
  "plaintext",
  "noscript"
]);
function replaceQuotes(value) {
  return value.replace(/"/g, "&quot;");
}
function formatAttributes(attributes, opts) {
  var _a2;
  if (!attributes)
    return;
  const encode3 = ((_a2 = opts.encodeEntities) !== null && _a2 !== void 0 ? _a2 : opts.decodeEntities) === false ? replaceQuotes : opts.xmlMode || opts.encodeEntities !== "utf8" ? encodeXML : escapeAttribute;
  return Object.keys(attributes).map((key) => {
    var _a3, _b;
    const value = (_a3 = attributes[key]) !== null && _a3 !== void 0 ? _a3 : "";
    if (opts.xmlMode === "foreign") {
      key = (_b = attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
    }
    if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
      return key;
    }
    return `${key}="${encode3(value)}"`;
  }).join(" ");
}
var singleTag = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
function render(node, options = {}) {
  const nodes = "length" in node ? node : [node];
  let output = "";
  for (let i4 = 0; i4 < nodes.length; i4++) {
    output += renderNode(nodes[i4], options);
  }
  return output;
}
function renderNode(node, options) {
  switch (node.type) {
    case Root:
      return render(node.children, options);
    // @ts-expect-error We don't use `Doctype` yet
    case Doctype:
    case Directive:
      return renderDirective(node);
    case Comment:
      return renderComment(node);
    case CDATA:
      return renderCdata(node);
    case Script:
    case Style:
    case Tag:
      return renderTag(node, options);
    case Text:
      return renderText(node, options);
  }
}
var foreignModeIntegrationPoints = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignObject",
  "desc",
  "title"
]);
var foreignElements = /* @__PURE__ */ new Set(["svg", "math"]);
function renderTag(elem, opts) {
  var _a2;
  if (opts.xmlMode === "foreign") {
    elem.name = (_a2 = elementNames.get(elem.name)) !== null && _a2 !== void 0 ? _a2 : elem.name;
    if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
      opts = { ...opts, xmlMode: false };
    }
  }
  if (!opts.xmlMode && foreignElements.has(elem.name)) {
    opts = { ...opts, xmlMode: "foreign" };
  }
  let tag2 = `<${elem.name}`;
  const attribs = formatAttributes(elem.attribs, opts);
  if (attribs) {
    tag2 += ` ${attribs}`;
  }
  if (elem.children.length === 0 && (opts.xmlMode ? (
    // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
    opts.selfClosingTags !== false
  ) : (
    // User explicitly asked for self-closing tags, even in HTML mode
    opts.selfClosingTags && singleTag.has(elem.name)
  ))) {
    if (!opts.xmlMode)
      tag2 += " ";
    tag2 += "/>";
  } else {
    tag2 += ">";
    if (elem.children.length > 0) {
      tag2 += render(elem.children, opts);
    }
    if (opts.xmlMode || !singleTag.has(elem.name)) {
      tag2 += `</${elem.name}>`;
    }
  }
  return tag2;
}
function renderDirective(elem) {
  return `<${elem.data}>`;
}
function renderText(elem, opts) {
  var _a2;
  let data2 = elem.data || "";
  if (((_a2 = opts.encodeEntities) !== null && _a2 !== void 0 ? _a2 : opts.decodeEntities) !== false && !(!opts.xmlMode && elem.parent && unencodedElements.has(elem.parent.name))) {
    data2 = opts.xmlMode || opts.encodeEntities !== "utf8" ? encodeXML(data2) : escapeText(data2);
  }
  return data2;
}
function renderCdata(elem) {
  return `<![CDATA[${elem.children[0].data}]]>`;
}
function renderComment(elem) {
  return `<!--${elem.data}-->`;
}
function getOuterHTML(node, options) {
  return render(node, options);
}
function getInnerHTML(node, options) {
  return hasChildren(node) ? node.children.map((node2) => getOuterHTML(node2, options)).join("") : "";
}
function getText$1(node) {
  if (Array.isArray(node))
    return node.map(getText$1).join("");
  if (isTag$1(node))
    return node.name === "br" ? "\n" : getText$1(node.children);
  if (isCDATA(node))
    return getText$1(node.children);
  if (isText(node))
    return node.data;
  return "";
}
function textContent(node) {
  if (Array.isArray(node))
    return node.map(textContent).join("");
  if (hasChildren(node) && !isComment(node)) {
    return textContent(node.children);
  }
  if (isText(node))
    return node.data;
  return "";
}
function innerText(node) {
  if (Array.isArray(node))
    return node.map(innerText).join("");
  if (hasChildren(node) && (node.type === ElementType.Tag || isCDATA(node))) {
    return innerText(node.children);
  }
  if (isText(node))
    return node.data;
  return "";
}
function getChildren$1(elem) {
  return hasChildren(elem) ? elem.children : [];
}
function getParent$1(elem) {
  return elem.parent || null;
}
function getSiblings$1(elem) {
  const parent = getParent$1(elem);
  if (parent != null)
    return getChildren$1(parent);
  const siblings = [elem];
  let { prev, next } = elem;
  while (prev != null) {
    siblings.unshift(prev);
    ({ prev } = prev);
  }
  while (next != null) {
    siblings.push(next);
    ({ next } = next);
  }
  return siblings;
}
function getAttributeValue$1(elem, name) {
  var _a2;
  return (_a2 = elem.attribs) === null || _a2 === void 0 ? void 0 : _a2[name];
}
function hasAttrib$1(elem, name) {
  return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name) && elem.attribs[name] != null;
}
function getName$1(elem) {
  return elem.name;
}
function nextElementSibling(elem) {
  let { next } = elem;
  while (next !== null && !isTag$1(next))
    ({ next } = next);
  return next;
}
function prevElementSibling(elem) {
  let { prev } = elem;
  while (prev !== null && !isTag$1(prev))
    ({ prev } = prev);
  return prev;
}
function removeElement(elem) {
  if (elem.prev)
    elem.prev.next = elem.next;
  if (elem.next)
    elem.next.prev = elem.prev;
  if (elem.parent) {
    const childs = elem.parent.children;
    const childsIndex = childs.lastIndexOf(elem);
    if (childsIndex >= 0) {
      childs.splice(childsIndex, 1);
    }
  }
  elem.next = null;
  elem.prev = null;
  elem.parent = null;
}
function replaceElement(elem, replacement) {
  const prev = replacement.prev = elem.prev;
  if (prev) {
    prev.next = replacement;
  }
  const next = replacement.next = elem.next;
  if (next) {
    next.prev = replacement;
  }
  const parent = replacement.parent = elem.parent;
  if (parent) {
    const childs = parent.children;
    childs[childs.lastIndexOf(elem)] = replacement;
    elem.parent = null;
  }
}
function appendChild(parent, child) {
  removeElement(child);
  child.next = null;
  child.parent = parent;
  if (parent.children.push(child) > 1) {
    const sibling = parent.children[parent.children.length - 2];
    sibling.next = child;
    child.prev = sibling;
  } else {
    child.prev = null;
  }
}
function append(elem, next) {
  removeElement(next);
  const { parent } = elem;
  const currNext = elem.next;
  next.next = currNext;
  next.prev = elem;
  elem.next = next;
  next.parent = parent;
  if (currNext) {
    currNext.prev = next;
    if (parent) {
      const childs = parent.children;
      childs.splice(childs.lastIndexOf(currNext), 0, next);
    }
  } else if (parent) {
    parent.children.push(next);
  }
}
function prependChild(parent, child) {
  removeElement(child);
  child.parent = parent;
  child.prev = null;
  if (parent.children.unshift(child) !== 1) {
    const sibling = parent.children[1];
    sibling.prev = child;
    child.next = sibling;
  } else {
    child.next = null;
  }
}
function prepend(elem, prev) {
  removeElement(prev);
  const { parent } = elem;
  if (parent) {
    const childs = parent.children;
    childs.splice(childs.indexOf(elem), 0, prev);
  }
  if (elem.prev) {
    elem.prev.next = prev;
  }
  prev.parent = parent;
  prev.prev = elem.prev;
  prev.next = elem;
  elem.prev = prev;
}
function filter(test, node, recurse = true, limit = Infinity) {
  return find(test, Array.isArray(node) ? node : [node], recurse, limit);
}
function find(test, nodes, recurse, limit) {
  const result = [];
  const nodeStack = [Array.isArray(nodes) ? nodes : [nodes]];
  const indexStack = [0];
  for (; ; ) {
    if (indexStack[0] >= nodeStack[0].length) {
      if (indexStack.length === 1) {
        return result;
      }
      nodeStack.shift();
      indexStack.shift();
      continue;
    }
    const elem = nodeStack[0][indexStack[0]++];
    if (test(elem)) {
      result.push(elem);
      if (--limit <= 0)
        return result;
    }
    if (recurse && hasChildren(elem) && elem.children.length > 0) {
      indexStack.unshift(0);
      nodeStack.unshift(elem.children);
    }
  }
}
function findOneChild(test, nodes) {
  return nodes.find(test);
}
function findOne$2(test, nodes, recurse = true) {
  const searchedNodes = Array.isArray(nodes) ? nodes : [nodes];
  for (let i4 = 0; i4 < searchedNodes.length; i4++) {
    const node = searchedNodes[i4];
    if (isTag$1(node) && test(node)) {
      return node;
    }
    if (recurse && hasChildren(node) && node.children.length > 0) {
      const found = findOne$2(test, node.children, true);
      if (found)
        return found;
    }
  }
  return null;
}
function existsOne$1(test, nodes) {
  return (Array.isArray(nodes) ? nodes : [nodes]).some((node) => isTag$1(node) && test(node) || hasChildren(node) && existsOne$1(test, node.children));
}
function findAll$2(test, nodes) {
  const result = [];
  const nodeStack = [Array.isArray(nodes) ? nodes : [nodes]];
  const indexStack = [0];
  for (; ; ) {
    if (indexStack[0] >= nodeStack[0].length) {
      if (nodeStack.length === 1) {
        return result;
      }
      nodeStack.shift();
      indexStack.shift();
      continue;
    }
    const elem = nodeStack[0][indexStack[0]++];
    if (isTag$1(elem) && test(elem))
      result.push(elem);
    if (hasChildren(elem) && elem.children.length > 0) {
      indexStack.unshift(0);
      nodeStack.unshift(elem.children);
    }
  }
}
var Checks = {
  tag_name(name) {
    if (typeof name === "function") {
      return (elem) => isTag$1(elem) && name(elem.name);
    } else if (name === "*") {
      return isTag$1;
    }
    return (elem) => isTag$1(elem) && elem.name === name;
  },
  tag_type(type) {
    if (typeof type === "function") {
      return (elem) => type(elem.type);
    }
    return (elem) => elem.type === type;
  },
  tag_contains(data2) {
    if (typeof data2 === "function") {
      return (elem) => isText(elem) && data2(elem.data);
    }
    return (elem) => isText(elem) && elem.data === data2;
  }
};
function getAttribCheck(attrib, value) {
  if (typeof value === "function") {
    return (elem) => isTag$1(elem) && value(elem.attribs[attrib]);
  }
  return (elem) => isTag$1(elem) && elem.attribs[attrib] === value;
}
function combineFuncs(a4, b4) {
  return (elem) => a4(elem) || b4(elem);
}
function compileTest(options) {
  const funcs = Object.keys(options).map((key) => {
    const value = options[key];
    return Object.prototype.hasOwnProperty.call(Checks, key) ? Checks[key](value) : getAttribCheck(key, value);
  });
  return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
}
function testElement(options, node) {
  const test = compileTest(options);
  return test ? test(node) : true;
}
function getElements(options, nodes, recurse, limit = Infinity) {
  const test = compileTest(options);
  return test ? filter(test, nodes, recurse, limit) : [];
}
function getElementById(id2, nodes, recurse = true) {
  if (!Array.isArray(nodes))
    nodes = [nodes];
  return findOne$2(getAttribCheck("id", id2), nodes, recurse);
}
function getElementsByTagName(tagName, nodes, recurse = true, limit = Infinity) {
  return filter(Checks["tag_name"](tagName), nodes, recurse, limit);
}
function getElementsByClassName(className, nodes, recurse = true, limit = Infinity) {
  return filter(getAttribCheck("class", className), nodes, recurse, limit);
}
function getElementsByTagType(type, nodes, recurse = true, limit = Infinity) {
  return filter(Checks["tag_type"](type), nodes, recurse, limit);
}
function removeSubsets$1(nodes) {
  let idx = nodes.length;
  while (--idx >= 0) {
    const node = nodes[idx];
    if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
      nodes.splice(idx, 1);
      continue;
    }
    for (let ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
      if (nodes.includes(ancestor)) {
        nodes.splice(idx, 1);
        break;
      }
    }
  }
  return nodes;
}
var DocumentPosition;
(function(DocumentPosition2) {
  DocumentPosition2[DocumentPosition2["DISCONNECTED"] = 1] = "DISCONNECTED";
  DocumentPosition2[DocumentPosition2["PRECEDING"] = 2] = "PRECEDING";
  DocumentPosition2[DocumentPosition2["FOLLOWING"] = 4] = "FOLLOWING";
  DocumentPosition2[DocumentPosition2["CONTAINS"] = 8] = "CONTAINS";
  DocumentPosition2[DocumentPosition2["CONTAINED_BY"] = 16] = "CONTAINED_BY";
})(DocumentPosition || (DocumentPosition = {}));
function compareDocumentPosition(nodeA, nodeB) {
  const aParents = [];
  const bParents = [];
  if (nodeA === nodeB) {
    return 0;
  }
  let current = hasChildren(nodeA) ? nodeA : nodeA.parent;
  while (current) {
    aParents.unshift(current);
    current = current.parent;
  }
  current = hasChildren(nodeB) ? nodeB : nodeB.parent;
  while (current) {
    bParents.unshift(current);
    current = current.parent;
  }
  const maxIdx = Math.min(aParents.length, bParents.length);
  let idx = 0;
  while (idx < maxIdx && aParents[idx] === bParents[idx]) {
    idx++;
  }
  if (idx === 0) {
    return DocumentPosition.DISCONNECTED;
  }
  const sharedParent = aParents[idx - 1];
  const siblings = sharedParent.children;
  const aSibling = aParents[idx];
  const bSibling = bParents[idx];
  if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
    if (sharedParent === nodeB) {
      return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;
    }
    return DocumentPosition.FOLLOWING;
  }
  if (sharedParent === nodeA) {
    return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;
  }
  return DocumentPosition.PRECEDING;
}
function uniqueSort(nodes) {
  nodes = nodes.filter((node, i4, arr) => !arr.includes(node, i4 + 1));
  nodes.sort((a4, b4) => {
    const relative = compareDocumentPosition(a4, b4);
    if (relative & DocumentPosition.PRECEDING) {
      return -1;
    } else if (relative & DocumentPosition.FOLLOWING) {
      return 1;
    }
    return 0;
  });
  return nodes;
}
function getFeed(doc) {
  const feedRoot = getOneElement(isValidFeed, doc);
  return !feedRoot ? null : feedRoot.name === "feed" ? getAtomFeed(feedRoot) : getRssFeed(feedRoot);
}
function getAtomFeed(feedRoot) {
  var _a2;
  const childs = feedRoot.children;
  const feed = {
    type: "atom",
    items: getElementsByTagName("entry", childs).map((item) => {
      var _a3;
      const { children } = item;
      const entry = { media: getMediaElements(children) };
      addConditionally(entry, "id", "id", children);
      addConditionally(entry, "title", "title", children);
      const href2 = (_a3 = getOneElement("link", children)) === null || _a3 === void 0 ? void 0 : _a3.attribs["href"];
      if (href2) {
        entry.link = href2;
      }
      const description = fetch2("summary", children) || fetch2("content", children);
      if (description) {
        entry.description = description;
      }
      const pubDate = fetch2("updated", children);
      if (pubDate) {
        entry.pubDate = new Date(pubDate);
      }
      return entry;
    })
  };
  addConditionally(feed, "id", "id", childs);
  addConditionally(feed, "title", "title", childs);
  const href = (_a2 = getOneElement("link", childs)) === null || _a2 === void 0 ? void 0 : _a2.attribs["href"];
  if (href) {
    feed.link = href;
  }
  addConditionally(feed, "description", "subtitle", childs);
  const updated = fetch2("updated", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally(feed, "author", "email", childs, true);
  return feed;
}
function getRssFeed(feedRoot) {
  var _a2, _b;
  const childs = (_b = (_a2 = getOneElement("channel", feedRoot.children)) === null || _a2 === void 0 ? void 0 : _a2.children) !== null && _b !== void 0 ? _b : [];
  const feed = {
    type: feedRoot.name.substr(0, 3),
    id: "",
    items: getElementsByTagName("item", feedRoot.children).map((item) => {
      const { children } = item;
      const entry = { media: getMediaElements(children) };
      addConditionally(entry, "id", "guid", children);
      addConditionally(entry, "title", "title", children);
      addConditionally(entry, "link", "link", children);
      addConditionally(entry, "description", "description", children);
      const pubDate = fetch2("pubDate", children) || fetch2("dc:date", children);
      if (pubDate)
        entry.pubDate = new Date(pubDate);
      return entry;
    })
  };
  addConditionally(feed, "title", "title", childs);
  addConditionally(feed, "link", "link", childs);
  addConditionally(feed, "description", "description", childs);
  const updated = fetch2("lastBuildDate", childs);
  if (updated) {
    feed.updated = new Date(updated);
  }
  addConditionally(feed, "author", "managingEditor", childs, true);
  return feed;
}
var MEDIA_KEYS_STRING = ["url", "type", "lang"];
var MEDIA_KEYS_INT = [
  "fileSize",
  "bitrate",
  "framerate",
  "samplingrate",
  "channels",
  "duration",
  "height",
  "width"
];
function getMediaElements(where) {
  return getElementsByTagName("media:content", where).map((elem) => {
    const { attribs } = elem;
    const media = {
      medium: attribs["medium"],
      isDefault: !!attribs["isDefault"]
    };
    for (const attrib of MEDIA_KEYS_STRING) {
      if (attribs[attrib]) {
        media[attrib] = attribs[attrib];
      }
    }
    for (const attrib of MEDIA_KEYS_INT) {
      if (attribs[attrib]) {
        media[attrib] = parseInt(attribs[attrib], 10);
      }
    }
    if (attribs["expression"]) {
      media.expression = attribs["expression"];
    }
    return media;
  });
}
function getOneElement(tagName, node) {
  return getElementsByTagName(tagName, node, true, 1)[0];
}
function fetch2(tagName, where, recurse = false) {
  return textContent(getElementsByTagName(tagName, where, recurse, 1)).trim();
}
function addConditionally(obj, prop, tagName, where, recurse = false) {
  const val = fetch2(tagName, where, recurse);
  if (val)
    obj[prop] = val;
}
function isValidFeed(value) {
  return value === "rss" || value === "feed" || value === "rdf:RDF";
}
var DomUtils = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  get DocumentPosition() {
    return DocumentPosition;
  },
  append,
  appendChild,
  compareDocumentPosition,
  existsOne: existsOne$1,
  filter,
  find,
  findAll: findAll$2,
  findOne: findOne$2,
  findOneChild,
  getAttributeValue: getAttributeValue$1,
  getChildren: getChildren$1,
  getElementById,
  getElements,
  getElementsByClassName,
  getElementsByTagName,
  getElementsByTagType,
  getFeed,
  getInnerHTML,
  getName: getName$1,
  getOuterHTML,
  getParent: getParent$1,
  getSiblings: getSiblings$1,
  getText: getText$1,
  hasAttrib: hasAttrib$1,
  hasChildren,
  innerText,
  isCDATA,
  isComment,
  isDocument,
  isTag: isTag$1,
  isText,
  nextElementSibling,
  prepend,
  prependChild,
  prevElementSibling,
  removeElement,
  removeSubsets: removeSubsets$1,
  replaceElement,
  testElement,
  textContent,
  uniqueSort
});
var reChars = /[-[\]{}()*+?.,\\^$|#\s]/g;
function escapeRegex(value) {
  return value.replace(reChars, "\\$&");
}
var caseInsensitiveAttributes = /* @__PURE__ */ new Set([
  "accept",
  "accept-charset",
  "align",
  "alink",
  "axis",
  "bgcolor",
  "charset",
  "checked",
  "clear",
  "codetype",
  "color",
  "compact",
  "declare",
  "defer",
  "dir",
  "direction",
  "disabled",
  "enctype",
  "face",
  "frame",
  "hreflang",
  "http-equiv",
  "lang",
  "language",
  "link",
  "media",
  "method",
  "multiple",
  "nohref",
  "noresize",
  "noshade",
  "nowrap",
  "readonly",
  "rel",
  "rev",
  "rules",
  "scope",
  "scrolling",
  "selected",
  "shape",
  "target",
  "text",
  "type",
  "valign",
  "valuetype",
  "vlink"
]);
function shouldIgnoreCase(selector, options) {
  return typeof selector.ignoreCase === "boolean" ? selector.ignoreCase : selector.ignoreCase === "quirks" ? !!options.quirksMode : !options.xmlMode && caseInsensitiveAttributes.has(selector.name);
}
var attributeRules = {
  equals(next, data2, options) {
    const { adapter } = options;
    const { name } = data2;
    let { value } = data2;
    if (shouldIgnoreCase(data2, options)) {
      value = value.toLowerCase();
      return (elem) => {
        const attr = adapter.getAttributeValue(elem, name);
        return attr != null && attr.length === value.length && attr.toLowerCase() === value && next(elem);
      };
    }
    return (elem) => adapter.getAttributeValue(elem, name) === value && next(elem);
  },
  hyphen(next, data2, options) {
    const { adapter } = options;
    const { name } = data2;
    let { value } = data2;
    const len = value.length;
    if (shouldIgnoreCase(data2, options)) {
      value = value.toLowerCase();
      return function hyphenIC(elem) {
        const attr = adapter.getAttributeValue(elem, name);
        return attr != null && (attr.length === len || attr.charAt(len) === "-") && attr.substr(0, len).toLowerCase() === value && next(elem);
      };
    }
    return function hyphen(elem) {
      const attr = adapter.getAttributeValue(elem, name);
      return attr != null && (attr.length === len || attr.charAt(len) === "-") && attr.substr(0, len) === value && next(elem);
    };
  },
  element(next, data2, options) {
    const { adapter } = options;
    const { name, value } = data2;
    if (/\s/.test(value)) {
      return boolbaseExports.falseFunc;
    }
    const regex = new RegExp(`(?:^|\\s)${escapeRegex(value)}(?:$|\\s)`, shouldIgnoreCase(data2, options) ? "i" : "");
    return function element(elem) {
      const attr = adapter.getAttributeValue(elem, name);
      return attr != null && attr.length >= value.length && regex.test(attr) && next(elem);
    };
  },
  exists(next, { name }, { adapter }) {
    return (elem) => adapter.hasAttrib(elem, name) && next(elem);
  },
  start(next, data2, options) {
    const { adapter } = options;
    const { name } = data2;
    let { value } = data2;
    const len = value.length;
    if (len === 0) {
      return boolbaseExports.falseFunc;
    }
    if (shouldIgnoreCase(data2, options)) {
      value = value.toLowerCase();
      return (elem) => {
        const attr = adapter.getAttributeValue(elem, name);
        return attr != null && attr.length >= len && attr.substr(0, len).toLowerCase() === value && next(elem);
      };
    }
    return (elem) => !!adapter.getAttributeValue(elem, name)?.startsWith(value) && next(elem);
  },
  end(next, data2, options) {
    const { adapter } = options;
    const { name } = data2;
    let { value } = data2;
    const len = -value.length;
    if (len === 0) {
      return boolbaseExports.falseFunc;
    }
    if (shouldIgnoreCase(data2, options)) {
      value = value.toLowerCase();
      return (elem) => adapter.getAttributeValue(elem, name)?.substr(len).toLowerCase() === value && next(elem);
    }
    return (elem) => !!adapter.getAttributeValue(elem, name)?.endsWith(value) && next(elem);
  },
  any(next, data2, options) {
    const { adapter } = options;
    const { name, value } = data2;
    if (value === "") {
      return boolbaseExports.falseFunc;
    }
    if (shouldIgnoreCase(data2, options)) {
      const regex = new RegExp(escapeRegex(value), "i");
      return function anyIC(elem) {
        const attr = adapter.getAttributeValue(elem, name);
        return attr != null && attr.length >= value.length && regex.test(attr) && next(elem);
      };
    }
    return (elem) => !!adapter.getAttributeValue(elem, name)?.includes(value) && next(elem);
  },
  not(next, data2, options) {
    const { adapter } = options;
    const { name } = data2;
    let { value } = data2;
    if (value === "") {
      return (elem) => !!adapter.getAttributeValue(elem, name) && next(elem);
    }
    if (shouldIgnoreCase(data2, options)) {
      value = value.toLowerCase();
      return (elem) => {
        const attr = adapter.getAttributeValue(elem, name);
        return (attr == null || attr.length !== value.length || attr.toLowerCase() !== value) && next(elem);
      };
    }
    return (elem) => adapter.getAttributeValue(elem, name) !== value && next(elem);
  }
};
function findAll$1(query, elems, options) {
  const { adapter, xmlMode = false } = options;
  const result = [];
  const nodeStack = [elems];
  const indexStack = [0];
  for (; ; ) {
    if (indexStack[0] >= nodeStack[0].length) {
      if (nodeStack.length === 1) {
        return result;
      }
      nodeStack.shift();
      indexStack.shift();
      continue;
    }
    const elem = nodeStack[0][indexStack[0]++];
    if (!adapter.isTag(elem)) {
      continue;
    }
    if (query(elem)) {
      result.push(elem);
    }
    if (xmlMode || adapter.getName(elem) !== "template") {
      const children = adapter.getChildren(elem);
      if (children.length > 0) {
        nodeStack.unshift(children);
        indexStack.unshift(0);
      }
    }
  }
}
function findOne$1(query, elems, options) {
  const { adapter, xmlMode = false } = options;
  const nodeStack = [elems];
  const indexStack = [0];
  for (; ; ) {
    if (indexStack[0] >= nodeStack[0].length) {
      if (nodeStack.length === 1) {
        return null;
      }
      nodeStack.shift();
      indexStack.shift();
      continue;
    }
    const elem = nodeStack[0][indexStack[0]++];
    if (!adapter.isTag(elem)) {
      continue;
    }
    if (query(elem)) {
      return elem;
    }
    if (xmlMode || adapter.getName(elem) !== "template") {
      const children = adapter.getChildren(elem);
      if (children.length > 0) {
        nodeStack.unshift(children);
        indexStack.unshift(0);
      }
    }
  }
}
function getNextSiblings(elem, adapter) {
  const siblings = adapter.getSiblings(elem);
  if (siblings.length <= 1) {
    return [];
  }
  const elemIndex = siblings.indexOf(elem);
  if (elemIndex < 0 || elemIndex === siblings.length - 1) {
    return [];
  }
  return siblings.slice(elemIndex + 1).filter(adapter.isTag);
}
function getElementParent(node, adapter) {
  const parent = adapter.getParent(node);
  return parent != null && adapter.isTag(parent) ? parent : null;
}
var textControl = "input:is([type=text i],[type=search i],[type=url i],[type=tel i],[type=email i],[type=password i],[type=date i],[type=month i],[type=week i],[type=time i],[type=datetime-local i],[type=number i])";
var aliases = {
  // Links
  "any-link": ":is(a, area, link)[href]",
  link: ":any-link:not(:visited)",
  // Forms
  // https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
  disabled: `:is(
        :is(button, input, select, textarea, optgroup, option)[disabled],
        optgroup[disabled] > option,
        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)
    )`,
  enabled: ":not(:disabled)",
  checked: ":is(:is(input[type=radio], input[type=checkbox])[checked], :selected)",
  required: ":is(input, select, textarea)[required]",
  optional: ":is(input, select, textarea):not([required])",
  "read-only": `[readonly]:is(textarea, ${textControl})`,
  "read-write": `:not([readonly]):is(textarea, ${textControl})`,
  // JQuery extensions
  /**
   * `:selected` matches option elements that have the `selected` attribute,
   * or are the first option element in a select element that does not have
   * the `multiple` attribute and does not have any option elements with the
   * `selected` attribute.
   *
   * @see https://html.spec.whatwg.org/multipage/form-elements.html#concept-option-selectedness
   */
  selected: "option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)",
  checkbox: "[type=checkbox]",
  file: "[type=file]",
  password: "[type=password]",
  radio: "[type=radio]",
  reset: "[type=reset]",
  image: "[type=image]",
  submit: "[type=submit]",
  parent: ":not(:empty)",
  header: ":is(h1, h2, h3, h4, h5, h6)",
  button: ":is(button, input[type=button])",
  input: ":is(input, textarea, select, button)",
  text: "input:is(:not([type!='']), [type=text])"
};
var whitespace = /* @__PURE__ */ new Set([9, 10, 12, 13, 32]);
var ZERO = "0".charCodeAt(0);
var NINE = "9".charCodeAt(0);
function parse$2(formula) {
  formula = formula.trim().toLowerCase();
  if (formula === "even") {
    return [2, 0];
  } else if (formula === "odd") {
    return [2, 1];
  }
  let idx = 0;
  let a4 = 0;
  let sign = readSign();
  let number = readNumber();
  if (idx < formula.length && formula.charAt(idx) === "n") {
    idx++;
    a4 = sign * (number !== null && number !== void 0 ? number : 1);
    skipWhitespace();
    if (idx < formula.length) {
      sign = readSign();
      skipWhitespace();
      number = readNumber();
    } else {
      sign = number = 0;
    }
  }
  if (number === null || idx < formula.length) {
    throw new Error(`n-th rule couldn't be parsed ('${formula}')`);
  }
  return [a4, sign * number];
  function readSign() {
    if (formula.charAt(idx) === "-") {
      idx++;
      return -1;
    }
    if (formula.charAt(idx) === "+") {
      idx++;
    }
    return 1;
  }
  function readNumber() {
    const start = idx;
    let value = 0;
    while (idx < formula.length && formula.charCodeAt(idx) >= ZERO && formula.charCodeAt(idx) <= NINE) {
      value = value * 10 + (formula.charCodeAt(idx) - ZERO);
      idx++;
    }
    return idx === start ? null : value;
  }
  function skipWhitespace() {
    while (idx < formula.length && whitespace.has(formula.charCodeAt(idx))) {
      idx++;
    }
  }
}
function compile$1(parsed) {
  const a4 = parsed[0];
  const b4 = parsed[1] - 1;
  if (b4 < 0 && a4 <= 0)
    return boolbase.falseFunc;
  if (a4 === -1)
    return (index) => index <= b4;
  if (a4 === 0)
    return (index) => index === b4;
  if (a4 === 1)
    return b4 < 0 ? boolbase.trueFunc : (index) => index >= b4;
  const absA = Math.abs(a4);
  const bMod = (b4 % absA + absA) % absA;
  return a4 > 1 ? (index) => index >= b4 && index % absA === bMod : (index) => index <= b4 && index % absA === bMod;
}
function nthCheck(formula) {
  return compile$1(parse$2(formula));
}
function cacheParentResults(next, { adapter, cacheResults }, matches) {
  if (cacheResults === false || typeof WeakMap === "undefined") {
    return (elem) => next(elem) && matches(elem);
  }
  const resultCache = /* @__PURE__ */ new WeakMap();
  function addResultToCache(elem) {
    const result = matches(elem);
    resultCache.set(elem, result);
    return result;
  }
  return function cachedMatcher(elem) {
    if (!next(elem)) {
      return false;
    }
    if (resultCache.has(elem)) {
      return resultCache.get(elem);
    }
    let node = elem;
    do {
      const parent = getElementParent(node, adapter);
      if (parent === null) {
        return addResultToCache(elem);
      }
      node = parent;
    } while (!resultCache.has(node));
    return resultCache.get(node) && addResultToCache(elem);
  };
}
var filters = {
  contains(next, text, options) {
    const { getText: getText2 } = options.adapter;
    return cacheParentResults(next, options, (elem) => getText2(elem).includes(text));
  },
  icontains(next, text, options) {
    const itext = text.toLowerCase();
    const { getText: getText2 } = options.adapter;
    return cacheParentResults(next, options, (elem) => getText2(elem).toLowerCase().includes(itext));
  },
  // Location specific methods
  "nth-child"(next, rule, { adapter, equals }) {
    const func = nthCheck(rule);
    if (func === boolbaseExports.falseFunc) {
      return boolbaseExports.falseFunc;
    }
    if (func === boolbaseExports.trueFunc) {
      return (elem) => getElementParent(elem, adapter) !== null && next(elem);
    }
    return function nthChild(elem) {
      const siblings = adapter.getSiblings(elem);
      let pos = 0;
      for (let i4 = 0; i4 < siblings.length; i4++) {
        if (equals(elem, siblings[i4])) {
          break;
        }
        if (adapter.isTag(siblings[i4])) {
          pos++;
        }
      }
      return func(pos) && next(elem);
    };
  },
  "nth-last-child"(next, rule, { adapter, equals }) {
    const func = nthCheck(rule);
    if (func === boolbaseExports.falseFunc) {
      return boolbaseExports.falseFunc;
    }
    if (func === boolbaseExports.trueFunc) {
      return (elem) => getElementParent(elem, adapter) !== null && next(elem);
    }
    return function nthLastChild(elem) {
      const siblings = adapter.getSiblings(elem);
      let pos = 0;
      for (let i4 = siblings.length - 1; i4 >= 0; i4--) {
        if (equals(elem, siblings[i4])) {
          break;
        }
        if (adapter.isTag(siblings[i4])) {
          pos++;
        }
      }
      return func(pos) && next(elem);
    };
  },
  "nth-of-type"(next, rule, { adapter, equals }) {
    const func = nthCheck(rule);
    if (func === boolbaseExports.falseFunc) {
      return boolbaseExports.falseFunc;
    }
    if (func === boolbaseExports.trueFunc) {
      return (elem) => getElementParent(elem, adapter) !== null && next(elem);
    }
    return function nthOfType(elem) {
      const siblings = adapter.getSiblings(elem);
      let pos = 0;
      for (let i4 = 0; i4 < siblings.length; i4++) {
        const currentSibling = siblings[i4];
        if (equals(elem, currentSibling)) {
          break;
        }
        if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === adapter.getName(elem)) {
          pos++;
        }
      }
      return func(pos) && next(elem);
    };
  },
  "nth-last-of-type"(next, rule, { adapter, equals }) {
    const func = nthCheck(rule);
    if (func === boolbaseExports.falseFunc) {
      return boolbaseExports.falseFunc;
    }
    if (func === boolbaseExports.trueFunc) {
      return (elem) => getElementParent(elem, adapter) !== null && next(elem);
    }
    return function nthLastOfType(elem) {
      const siblings = adapter.getSiblings(elem);
      let pos = 0;
      for (let i4 = siblings.length - 1; i4 >= 0; i4--) {
        const currentSibling = siblings[i4];
        if (equals(elem, currentSibling)) {
          break;
        }
        if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === adapter.getName(elem)) {
          pos++;
        }
      }
      return func(pos) && next(elem);
    };
  },
  // TODO determine the actual root element
  root(next, _rule, { adapter }) {
    return (elem) => getElementParent(elem, adapter) === null && next(elem);
  },
  scope(next, rule, options, context) {
    const { equals } = options;
    if (!context || context.length === 0) {
      return filters["root"](next, rule, options);
    }
    if (context.length === 1) {
      return (elem) => equals(context[0], elem) && next(elem);
    }
    return (elem) => context.includes(elem) && next(elem);
  },
  hover: dynamicStatePseudo("isHovered"),
  visited: dynamicStatePseudo("isVisited"),
  active: dynamicStatePseudo("isActive")
};
function dynamicStatePseudo(name) {
  return function dynamicPseudo(next, _rule, { adapter }) {
    const func = adapter[name];
    if (typeof func !== "function") {
      return boolbaseExports.falseFunc;
    }
    return function active(elem) {
      return func(elem) && next(elem);
    };
  };
}
var isDocumentWhiteSpace = /^[ \t\r\n]*$/;
var pseudos = {
  empty(elem, { adapter }) {
    const children = adapter.getChildren(elem);
    return (
      // First, make sure the tag does not have any element children.
      children.every((elem2) => !adapter.isTag(elem2)) && // Then, check that the text content is only whitespace.
      children.every((elem2) => (
        // FIXME: `getText` call is potentially expensive.
        isDocumentWhiteSpace.test(adapter.getText(elem2))
      ))
    );
  },
  "first-child"(elem, { adapter, equals }) {
    if (adapter.prevElementSibling) {
      return adapter.prevElementSibling(elem) == null;
    }
    const firstChild = adapter.getSiblings(elem).find((elem2) => adapter.isTag(elem2));
    return firstChild != null && equals(elem, firstChild);
  },
  "last-child"(elem, { adapter, equals }) {
    const siblings = adapter.getSiblings(elem);
    for (let i4 = siblings.length - 1; i4 >= 0; i4--) {
      if (equals(elem, siblings[i4])) {
        return true;
      }
      if (adapter.isTag(siblings[i4])) {
        break;
      }
    }
    return false;
  },
  "first-of-type"(elem, { adapter, equals }) {
    const siblings = adapter.getSiblings(elem);
    const elemName = adapter.getName(elem);
    for (let i4 = 0; i4 < siblings.length; i4++) {
      const currentSibling = siblings[i4];
      if (equals(elem, currentSibling)) {
        return true;
      }
      if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === elemName) {
        break;
      }
    }
    return false;
  },
  "last-of-type"(elem, { adapter, equals }) {
    const siblings = adapter.getSiblings(elem);
    const elemName = adapter.getName(elem);
    for (let i4 = siblings.length - 1; i4 >= 0; i4--) {
      const currentSibling = siblings[i4];
      if (equals(elem, currentSibling)) {
        return true;
      }
      if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === elemName) {
        break;
      }
    }
    return false;
  },
  "only-of-type"(elem, { adapter, equals }) {
    const elemName = adapter.getName(elem);
    return adapter.getSiblings(elem).every((sibling) => equals(elem, sibling) || !adapter.isTag(sibling) || adapter.getName(sibling) !== elemName);
  },
  "only-child"(elem, { adapter, equals }) {
    return adapter.getSiblings(elem).every((sibling) => equals(elem, sibling) || !adapter.isTag(sibling));
  }
};
function verifyPseudoArgs(func, name, subselect, argIndex) {
  if (subselect === null) {
    if (func.length > argIndex) {
      throw new Error(`Pseudo-class :${name} requires an argument`);
    }
  } else if (func.length === argIndex) {
    throw new Error(`Pseudo-class :${name} doesn't have any arguments`);
  }
}
function isTraversal(token) {
  return token.type === "_flexibleDescendant" || isTraversal$1(token);
}
function sortRules(arr) {
  const ratings = arr.map(getQuality);
  for (let i4 = 1; i4 < arr.length; i4++) {
    const procNew = ratings[i4];
    if (procNew < 0) {
      continue;
    }
    for (let j4 = i4; j4 > 0 && procNew < ratings[j4 - 1]; j4--) {
      const token = arr[j4];
      arr[j4] = arr[j4 - 1];
      arr[j4 - 1] = token;
      ratings[j4] = ratings[j4 - 1];
      ratings[j4 - 1] = procNew;
    }
  }
}
function getAttributeQuality(token) {
  switch (token.action) {
    case AttributeAction.Exists: {
      return 10;
    }
    case AttributeAction.Equals: {
      return token.name === "id" ? 9 : 8;
    }
    case AttributeAction.Not: {
      return 7;
    }
    case AttributeAction.Start: {
      return 6;
    }
    case AttributeAction.End: {
      return 6;
    }
    case AttributeAction.Any: {
      return 5;
    }
    case AttributeAction.Hyphen: {
      return 4;
    }
    case AttributeAction.Element: {
      return 3;
    }
  }
}
function getQuality(token) {
  switch (token.type) {
    case SelectorType.Universal: {
      return 50;
    }
    case SelectorType.Tag: {
      return 30;
    }
    case SelectorType.Attribute: {
      return Math.floor(getAttributeQuality(token) / // `ignoreCase` adds some overhead, half the result if applicable.
      (token.ignoreCase ? 2 : 1));
    }
    case SelectorType.Pseudo: {
      return !token.data ? 3 : token.name === "has" || token.name === "contains" || token.name === "icontains" ? (
        // Expensive in any case  run as late as possible.
        0
      ) : Array.isArray(token.data) ? (
        // Eg. `:is`, `:not`
        Math.max(
          // If we have traversals, try to avoid executing this selector
          0,
          Math.min(...token.data.map((d4) => Math.min(...d4.map(getQuality))))
        )
      ) : 2;
    }
    default: {
      return -1;
    }
  }
}
function includesScopePseudo(t4) {
  return t4.type === SelectorType.Pseudo && (t4.name === "scope" || Array.isArray(t4.data) && t4.data.some((data2) => data2.some(includesScopePseudo)));
}
var PLACEHOLDER_ELEMENT = {};
function hasDependsOnCurrentElement(selector) {
  return selector.some((sel) => sel.length > 0 && (isTraversal(sel[0]) || sel.some(includesScopePseudo)));
}
function copyOptions(options) {
  return {
    xmlMode: !!options.xmlMode,
    lowerCaseAttributeNames: !!options.lowerCaseAttributeNames,
    lowerCaseTags: !!options.lowerCaseTags,
    quirksMode: !!options.quirksMode,
    cacheResults: !!options.cacheResults,
    pseudos: options.pseudos,
    adapter: options.adapter,
    equals: options.equals
  };
}
var is$1 = (next, token, options, context, compileToken2) => {
  const func = compileToken2(token, copyOptions(options), context);
  return func === boolbaseExports.trueFunc ? next : func === boolbaseExports.falseFunc ? boolbaseExports.falseFunc : (elem) => func(elem) && next(elem);
};
var subselects = {
  is: is$1,
  /**
   * `:matches` and `:where` are aliases for `:is`.
   */
  matches: is$1,
  where: is$1,
  not(next, token, options, context, compileToken2) {
    const func = compileToken2(token, copyOptions(options), context);
    return func === boolbaseExports.falseFunc ? next : func === boolbaseExports.trueFunc ? boolbaseExports.falseFunc : (elem) => !func(elem) && next(elem);
  },
  has(next, subselect, options, _context, compileToken2) {
    const { adapter } = options;
    const opts = copyOptions(options);
    opts.relativeSelector = true;
    const context = subselect.some((s4) => s4.some(isTraversal)) ? (
      // Used as a placeholder. Will be replaced with the actual element.
      [PLACEHOLDER_ELEMENT]
    ) : void 0;
    const skipCache = hasDependsOnCurrentElement(subselect);
    const compiled = compileToken2(subselect, opts, context);
    if (compiled === boolbaseExports.falseFunc) {
      return boolbaseExports.falseFunc;
    }
    if (context && compiled !== boolbaseExports.trueFunc) {
      return skipCache ? (elem) => {
        if (!next(elem)) {
          return false;
        }
        context[0] = elem;
        const childs = adapter.getChildren(elem);
        return findOne$1(compiled, compiled.shouldTestNextSiblings ? [
          ...childs,
          ...getNextSiblings(elem, adapter)
        ] : childs, options) !== null;
      } : cacheParentResults(next, options, (elem) => {
        context[0] = elem;
        return findOne$1(compiled, adapter.getChildren(elem), options) !== null;
      });
    }
    const hasOne = (elem) => findOne$1(compiled, adapter.getChildren(elem), options) !== null;
    return skipCache ? (elem) => next(elem) && hasOne(elem) : cacheParentResults(next, options, hasOne);
  }
};
function compilePseudoSelector(next, selector, options, context, compileToken2) {
  const { name, data: data2 } = selector;
  if (Array.isArray(data2)) {
    if (!(name in subselects)) {
      throw new Error(`Unknown pseudo-class :${name}(${data2})`);
    }
    return subselects[name](next, data2, options, context, compileToken2);
  }
  const userPseudo = options.pseudos?.[name];
  const stringPseudo = typeof userPseudo === "string" ? userPseudo : aliases[name];
  if (typeof stringPseudo === "string") {
    if (data2 != null) {
      throw new Error(`Pseudo ${name} doesn't have any arguments`);
    }
    const alias = parse$3(stringPseudo);
    return subselects["is"](next, alias, options, context, compileToken2);
  }
  if (typeof userPseudo === "function") {
    verifyPseudoArgs(userPseudo, name, data2, 1);
    return (elem) => userPseudo(elem, data2) && next(elem);
  }
  if (name in filters) {
    return filters[name](next, data2, options, context);
  }
  if (name in pseudos) {
    const pseudo = pseudos[name];
    verifyPseudoArgs(pseudo, name, data2, 2);
    return (elem) => pseudo(elem, options, data2) && next(elem);
  }
  throw new Error(`Unknown pseudo-class :${name}`);
}
function compileGeneralSelector(next, selector, options, context, compileToken2, hasExpensiveSubselector) {
  const { adapter, equals, cacheResults } = options;
  switch (selector.type) {
    case SelectorType.PseudoElement: {
      throw new Error("Pseudo-elements are not supported by css-select");
    }
    case SelectorType.ColumnCombinator: {
      throw new Error("Column combinators are not yet supported by css-select");
    }
    case SelectorType.Attribute: {
      if (selector.namespace != null) {
        throw new Error("Namespaced attributes are not yet supported by css-select");
      }
      if (!options.xmlMode || options.lowerCaseAttributeNames) {
        selector.name = selector.name.toLowerCase();
      }
      return attributeRules[selector.action](next, selector, options);
    }
    case SelectorType.Pseudo: {
      return compilePseudoSelector(next, selector, options, context, compileToken2);
    }
    // Tags
    case SelectorType.Tag: {
      if (selector.namespace != null) {
        throw new Error("Namespaced tag names are not yet supported by css-select");
      }
      let { name } = selector;
      if (!options.xmlMode || options.lowerCaseTags) {
        name = name.toLowerCase();
      }
      return function tag2(elem) {
        return adapter.getName(elem) === name && next(elem);
      };
    }
    // Traversal
    case SelectorType.Descendant: {
      if (!hasExpensiveSubselector || cacheResults === false || typeof WeakMap === "undefined") {
        return function descendant(elem) {
          let current = elem;
          while (current = getElementParent(current, adapter)) {
            if (next(current)) {
              return true;
            }
          }
          return false;
        };
      }
      const resultCache = /* @__PURE__ */ new WeakMap();
      return function cachedDescendant(elem) {
        let current = elem;
        let result;
        while (current = getElementParent(current, adapter)) {
          const cached = resultCache.get(current);
          if (cached === void 0) {
            result ?? (result = { matches: false });
            result.matches = next(current);
            resultCache.set(current, result);
            if (result.matches) {
              return true;
            }
          } else {
            if (result) {
              result.matches = cached.matches;
            }
            return cached.matches;
          }
        }
        return false;
      };
    }
    case "_flexibleDescendant": {
      return function flexibleDescendant(elem) {
        let current = elem;
        do {
          if (next(current)) {
            return true;
          }
          current = getElementParent(current, adapter);
        } while (current);
        return false;
      };
    }
    case SelectorType.Parent: {
      return function parent(elem) {
        return adapter.getChildren(elem).some((elem2) => adapter.isTag(elem2) && next(elem2));
      };
    }
    case SelectorType.Child: {
      return function child(elem) {
        const parent = getElementParent(elem, adapter);
        return parent !== null && next(parent);
      };
    }
    case SelectorType.Sibling: {
      return function sibling(elem) {
        const siblings = adapter.getSiblings(elem);
        for (let i4 = 0; i4 < siblings.length; i4++) {
          const currentSibling = siblings[i4];
          if (equals(elem, currentSibling)) {
            break;
          }
          if (adapter.isTag(currentSibling) && next(currentSibling)) {
            return true;
          }
        }
        return false;
      };
    }
    case SelectorType.Adjacent: {
      if (adapter.prevElementSibling) {
        return function adjacent(elem) {
          const previous = adapter.prevElementSibling(elem);
          return previous != null && next(previous);
        };
      }
      return function adjacent(elem) {
        const siblings = adapter.getSiblings(elem);
        let lastElement;
        for (let i4 = 0; i4 < siblings.length; i4++) {
          const currentSibling = siblings[i4];
          if (equals(elem, currentSibling)) {
            break;
          }
          if (adapter.isTag(currentSibling)) {
            lastElement = currentSibling;
          }
        }
        return !!lastElement && next(lastElement);
      };
    }
    case SelectorType.Universal: {
      if (selector.namespace != null && selector.namespace !== "*") {
        throw new Error("Namespaced universal selectors are not yet supported by css-select");
      }
      return next;
    }
  }
}
var DESCENDANT_TOKEN = { type: SelectorType.Descendant };
var FLEXIBLE_DESCENDANT_TOKEN = {
  type: "_flexibleDescendant"
};
var SCOPE_TOKEN = {
  type: SelectorType.Pseudo,
  name: "scope",
  data: null
};
function absolutize(token, { adapter }, context) {
  const hasContext = !!context?.every((e4) => e4 === PLACEHOLDER_ELEMENT || adapter.isTag(e4) && getElementParent(e4, adapter) !== null);
  for (const t4 of token) {
    if (t4.length > 0 && isTraversal(t4[0]) && t4[0].type !== SelectorType.Descendant) ;
    else if (hasContext && !t4.some(includesScopePseudo)) {
      t4.unshift(DESCENDANT_TOKEN);
    } else {
      continue;
    }
    t4.unshift(SCOPE_TOKEN);
  }
}
function compileToken(token, options, ctx) {
  token.forEach(sortRules);
  const { context = ctx, rootFunc = boolbaseExports.trueFunc } = options;
  const isArrayContext = Array.isArray(context);
  const finalContext = context && (Array.isArray(context) ? context : [context]);
  if (options.relativeSelector !== false) {
    absolutize(token, options, finalContext);
  } else if (token.some((t4) => t4.length > 0 && isTraversal(t4[0]))) {
    throw new Error("Relative selectors are not allowed when the `relativeSelector` option is disabled");
  }
  let shouldTestNextSiblings = false;
  let query = boolbaseExports.falseFunc;
  combineLoop: for (const rules of token) {
    if (rules.length >= 2) {
      const [first, second] = rules;
      if (first.type !== SelectorType.Pseudo || first.name !== "scope") ;
      else if (isArrayContext && second.type === SelectorType.Descendant) {
        rules[1] = FLEXIBLE_DESCENDANT_TOKEN;
      } else if (second.type === SelectorType.Adjacent || second.type === SelectorType.Sibling) {
        shouldTestNextSiblings = true;
      }
    }
    let next = rootFunc;
    let hasExpensiveSubselector = false;
    for (const rule of rules) {
      next = compileGeneralSelector(next, rule, options, finalContext, compileToken, hasExpensiveSubselector);
      const quality = getQuality(rule);
      if (quality === 0) {
        hasExpensiveSubselector = true;
      }
      if (next === boolbaseExports.falseFunc) {
        continue combineLoop;
      }
    }
    if (next === rootFunc) {
      return rootFunc;
    }
    query = query === boolbaseExports.falseFunc ? next : or(query, next);
  }
  query.shouldTestNextSiblings = shouldTestNextSiblings;
  return query;
}
function or(a4, b4) {
  return (elem) => a4(elem) || b4(elem);
}
var defaultEquals = (a4, b4) => a4 === b4;
var defaultOptions = {
  adapter: DomUtils,
  equals: defaultEquals
};
function convertOptionFormats(options) {
  const opts = options ?? defaultOptions;
  opts.adapter ?? (opts.adapter = DomUtils);
  opts.equals ?? (opts.equals = opts.adapter?.equals ?? defaultEquals);
  return opts;
}
function compile(selector, options, context) {
  const opts = convertOptionFormats(options);
  const next = _compileUnsafe(selector, opts, context);
  return next === boolbaseExports.falseFunc ? boolbaseExports.falseFunc : (elem) => opts.adapter.isTag(elem) && next(elem);
}
function _compileUnsafe(selector, options, context) {
  return _compileToken(typeof selector === "string" ? parse$3(selector) : selector, options, context);
}
function _compileToken(selector, options, context) {
  return compileToken(selector, convertOptionFormats(options), context);
}
function getSelectorFunc(searchFunc) {
  return function select(query, elements, options) {
    const opts = convertOptionFormats(options);
    if (typeof query !== "function") {
      query = _compileUnsafe(query, opts, elements);
    }
    const filteredElements = prepareContext(elements, opts.adapter, query.shouldTestNextSiblings);
    return searchFunc(query, filteredElements, opts);
  };
}
function prepareContext(elems, adapter, shouldTestNextSiblings = false) {
  if (shouldTestNextSiblings) {
    elems = appendNextSiblings(elems, adapter);
  }
  return Array.isArray(elems) ? adapter.removeSubsets(elems) : adapter.getChildren(elems);
}
function appendNextSiblings(elem, adapter) {
  const elems = Array.isArray(elem) ? elem.slice(0) : [elem];
  const elemsLength = elems.length;
  for (let i4 = 0; i4 < elemsLength; i4++) {
    const nextSiblings = getNextSiblings(elems[i4], adapter);
    elems.push(...nextSiblings);
  }
  return elems;
}
var selectAll = getSelectorFunc((query, elems, options) => query === boolbaseExports.falseFunc || !elems || elems.length === 0 ? [] : findAll$1(query, elems, options));
var selectOne = getSelectorFunc((query, elems, options) => query === boolbaseExports.falseFunc || !elems || elems.length === 0 ? null : findOne$1(query, elems, options));
function is(elem, query, options) {
  return (typeof query === "function" ? query : compile(query, options))(elem);
}
function arr_back(arr) {
  return arr[arr.length - 1];
}
function isTag(node) {
  return !!node && node.nodeType === NodeType.ELEMENT_NODE;
}
function getAttributeValue(elem, name) {
  return isTag(elem) ? elem.getAttribute(name) : void 0;
}
function getName(elem) {
  return (elem && elem.rawTagName || "").toLowerCase();
}
function getChildren(node) {
  return node && node.childNodes;
}
function getParent(node) {
  return node ? node.parentNode : null;
}
function getText(node) {
  return node.text;
}
function removeSubsets(nodes) {
  let idx = nodes.length;
  let node;
  let ancestor;
  let replace;
  while (--idx > -1) {
    node = ancestor = nodes[idx];
    nodes[idx] = null;
    replace = true;
    while (ancestor) {
      if (nodes.indexOf(ancestor) > -1) {
        replace = false;
        nodes.splice(idx, 1);
        break;
      }
      ancestor = getParent(ancestor);
    }
    if (replace) {
      nodes[idx] = node;
    }
  }
  return nodes;
}
function existsOne(test, elems) {
  return elems.some((elem) => {
    return isTag(elem) ? test(elem) || existsOne(test, getChildren(elem)) : false;
  });
}
function getSiblings(node) {
  const parent = getParent(node);
  return parent ? getChildren(parent) : [];
}
function hasAttrib(elem, name) {
  return getAttributeValue(elem, name) !== void 0;
}
function findOne(test, elems) {
  let elem = null;
  for (let i4 = 0, l4 = elems?.length; i4 < l4 && !elem; i4++) {
    const el = elems[i4];
    if (test(el)) {
      elem = el;
    } else {
      const childs = getChildren(el);
      if (childs && childs.length > 0) {
        elem = findOne(test, childs);
      }
    }
  }
  return elem;
}
function findAll(test, nodes) {
  let result = [];
  for (let i4 = 0, j4 = nodes.length; i4 < j4; i4++) {
    if (!isTag(nodes[i4]))
      continue;
    if (test(nodes[i4]))
      result.push(nodes[i4]);
    const childs = getChildren(nodes[i4]);
    if (childs)
      result = result.concat(findAll(test, childs));
  }
  return result;
}
var Matcher = {
  isTag,
  getAttributeValue,
  getName,
  getChildren,
  getParent,
  getText,
  removeSubsets,
  existsOne,
  getSiblings,
  hasAttrib,
  findOne,
  findAll
};
var VoidTag = class {
  addClosingSlash;
  voidTags;
  constructor(addClosingSlash = false, tags) {
    this.addClosingSlash = addClosingSlash;
    if (Array.isArray(tags)) {
      this.voidTags = tags.reduce((set2, tag2) => {
        return set2.add(tag2.toLowerCase()).add(tag2.toUpperCase()).add(tag2);
      }, /* @__PURE__ */ new Set());
    } else {
      this.voidTags = [
        "area",
        "base",
        "br",
        "col",
        "embed",
        "hr",
        "img",
        "input",
        "link",
        "meta",
        "param",
        "source",
        "track",
        "wbr"
      ].reduce((set2, tag2) => {
        return set2.add(tag2.toLowerCase()).add(tag2.toUpperCase()).add(tag2);
      }, /* @__PURE__ */ new Set());
    }
  }
  formatNode(tag2, attrs, innerHTML) {
    const addClosingSlash = this.addClosingSlash;
    const closingSpace = addClosingSlash && attrs && !attrs.endsWith(" ") ? " " : "";
    const closingSlash = addClosingSlash ? `${closingSpace}/` : "";
    return this.isVoidElement(tag2.toLowerCase()) ? `<${tag2}${attrs}${closingSlash}>` : `<${tag2}${attrs}>${innerHTML}</${tag2}>`;
  }
  isVoidElement(tag2) {
    return this.voidTags.has(tag2);
  }
};
var TextNode = class _TextNode extends Node {
  rawText;
  nodeType = NodeType.TEXT_NODE;
  rawTagName = "#text";
  constructor(rawText, parentNode = null, range2) {
    super(parentNode, range2);
    this.rawText = rawText;
  }
  clone() {
    return new _TextNode(this.rawText, null, this.range ? [...this.range] : void 0);
  }
  get text() {
    return he.decode(this.rawText);
  }
  get trimmedText() {
    return this.text.trim();
  }
  get trimmedRawText() {
    return this.rawText.trim();
  }
  get isWhitespace() {
    return /^(\s|&nbsp;)*$/.test(this.rawText);
  }
  toString() {
    return this.rawText;
  }
};
function decode$1(val) {
  return JSON.parse(JSON.stringify(he.decode(val)));
}
var Htags = ["h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup"];
var Dtags = ["details", "dialog", "dd", "div", "dt"];
var Ftags = ["fieldset", "figcaption", "figure", "footer", "form"];
var tableTags = ["table", "td", "tr"];
var htmlTags = [
  "address",
  "article",
  "aside",
  "blockquote",
  "br",
  "hr",
  "li",
  "main",
  "nav",
  "ol",
  "p",
  "pre",
  "section",
  "ul"
];
var kBlockElements = /* @__PURE__ */ new Set();
function addToKBlockElement(...args) {
  const addToSet = (array) => {
    for (let index = 0; index < array.length; index++) {
      const element = array[index];
      kBlockElements.add(element);
      kBlockElements.add(element.toUpperCase());
    }
  };
  for (const arg of args)
    addToSet(arg);
}
addToKBlockElement(Htags, Dtags, Ftags, tableTags, htmlTags);
var DOMTokenList = class {
  _set;
  _afterUpdate;
  _validate(c4) {
    if (/\s/.test(c4)) {
      throw new Error(`DOMException in DOMTokenList.add: The token '${c4}' contains HTML space characters, which are not valid in tokens.`);
    }
  }
  constructor(valuesInit = [], afterUpdate = () => null) {
    this._set = new Set(valuesInit);
    this._afterUpdate = afterUpdate;
  }
  add(c4) {
    this._validate(c4);
    this._set.add(c4);
    this._afterUpdate(this);
  }
  replace(c1, c22) {
    this._validate(c22);
    this._set.delete(c1);
    this._set.add(c22);
    this._afterUpdate(this);
  }
  remove(c4) {
    this._set.delete(c4) && this._afterUpdate(this);
  }
  toggle(c4) {
    this._validate(c4);
    if (this._set.has(c4))
      this._set.delete(c4);
    else
      this._set.add(c4);
    this._afterUpdate(this);
  }
  contains(c4) {
    return this._set.has(c4);
  }
  get length() {
    return this._set.size;
  }
  values() {
    return this._set.values();
  }
  get value() {
    return Array.from(this._set.values());
  }
  toString() {
    return Array.from(this._set.values()).join(" ");
  }
};
var HTMLElement = class _HTMLElement extends Node {
  rawAttrs;
  voidTag;
  _attrs;
  _rawAttrs;
  _parseOptions;
  rawTagName;
  id;
  classList;
  nodeType = NodeType.ELEMENT_NODE;
  quoteAttribute(attr) {
    if (attr == null) {
      return "null";
    }
    return JSON.stringify(attr.replace(/"/g, "&quot;")).replace(/\\t/g, "	").replace(/\\n/g, "\n").replace(/\\r/g, "\r").replace(/\\/g, "");
  }
  constructor(tagName, keyAttrs, rawAttrs = "", parentNode = null, range2, voidTag = new VoidTag(), _parseOptions = {}) {
    super(parentNode, range2);
    this.rawAttrs = rawAttrs;
    this.voidTag = voidTag;
    this.rawTagName = tagName;
    this.rawAttrs = rawAttrs || "";
    this.id = keyAttrs.id || "";
    this.childNodes = [];
    this._parseOptions = _parseOptions;
    this.classList = new DOMTokenList(keyAttrs.class ? keyAttrs.class.split(/\s+/) : [], (classList) => this.setAttribute("class", classList.toString()));
    if (keyAttrs.id) {
      if (!rawAttrs) {
        this.rawAttrs = `id="${keyAttrs.id}"`;
      }
    }
    if (keyAttrs.class) {
      if (!rawAttrs) {
        const cls = `class="${this.classList.toString()}"`;
        if (this.rawAttrs) {
          this.rawAttrs += ` ${cls}`;
        } else {
          this.rawAttrs = cls;
        }
      }
    }
  }
  removeChild(node) {
    this.childNodes = this.childNodes.filter((child) => {
      return child !== node;
    });
    return this;
  }
  exchangeChild(oldNode, newNode) {
    const children = this.childNodes;
    this.childNodes = children.map((child) => {
      if (child === oldNode) {
        return newNode;
      }
      return child;
    });
    return this;
  }
  get tagName() {
    return this.rawTagName ? this.rawTagName.toUpperCase() : this.rawTagName;
  }
  set tagName(newname) {
    this.rawTagName = newname.toLowerCase();
  }
  get localName() {
    return this.rawTagName.toLowerCase();
  }
  get isVoidElement() {
    return this.voidTag.isVoidElement(this.localName);
  }
  get rawText() {
    if (/^br$/i.test(this.rawTagName)) {
      return "\n";
    }
    return this.childNodes.reduce((pre, cur) => {
      return pre += cur.rawText;
    }, "");
  }
  get textContent() {
    return decode$1(this.rawText);
  }
  set textContent(val) {
    const content = [new TextNode(val, this)];
    this.childNodes = content;
  }
  get text() {
    return decode$1(this.rawText);
  }
  get structuredText() {
    let currentBlock = [];
    const blocks = [currentBlock];
    function dfs(node) {
      if (node.nodeType === NodeType.ELEMENT_NODE) {
        if (kBlockElements.has(node.rawTagName)) {
          if (currentBlock.length > 0) {
            blocks.push(currentBlock = []);
          }
          node.childNodes.forEach(dfs);
          if (currentBlock.length > 0) {
            blocks.push(currentBlock = []);
          }
        } else {
          node.childNodes.forEach(dfs);
        }
      } else if (node.nodeType === NodeType.TEXT_NODE) {
        if (node.isWhitespace) {
          currentBlock.prependWhitespace = true;
        } else {
          let text = node.trimmedText;
          if (currentBlock.prependWhitespace) {
            text = ` ${text}`;
            currentBlock.prependWhitespace = false;
          }
          currentBlock.push(text);
        }
      }
    }
    dfs(this);
    return blocks.map((block) => {
      return block.join("").replace(/\s{2,}/g, " ");
    }).join("\n").replace(/\s+$/, "");
  }
  toString() {
    const tag2 = this.rawTagName;
    if (tag2) {
      const attrs = this.rawAttrs ? ` ${this.rawAttrs}` : "";
      return this.voidTag.formatNode(tag2, attrs, this.innerHTML);
    }
    return this.innerHTML;
  }
  get innerHTML() {
    return this.childNodes.map((child) => {
      return child.toString();
    }).join("");
  }
  set innerHTML(content) {
    const r4 = parse$1(content, this._parseOptions);
    const nodes = r4.childNodes.length ? r4.childNodes : [new TextNode(content, this)];
    resetParent(nodes, this);
    resetParent(this.childNodes, null);
    this.childNodes = nodes;
  }
  set_content(content, options = {}) {
    if (content instanceof Node) {
      content = [content];
    } else if (typeof content == "string") {
      options = { ...this._parseOptions, ...options };
      const r4 = parse$1(content, options);
      content = r4.childNodes.length ? r4.childNodes : [new TextNode(r4.innerHTML, this)];
    }
    resetParent(this.childNodes, null);
    resetParent(content, this);
    this.childNodes = content;
    return this;
  }
  replaceWith(...nodes) {
    const parent = this.parentNode;
    if (!parent)
      return this;
    const content = nodes.map((node) => {
      if (node instanceof Node) {
        return [node];
      } else if (typeof node == "string") {
        const r4 = parse$1(node, this._parseOptions);
        return r4.childNodes.length ? r4.childNodes : [new TextNode(node, this)];
      }
      return [];
    }).flat();
    const idx = parent.childNodes.findIndex((child) => {
      return child === this;
    });
    resetParent([this], null);
    parent.childNodes = [
      ...parent.childNodes.slice(0, idx),
      ...resetParent(content, parent),
      ...parent.childNodes.slice(idx + 1)
    ];
    return this;
  }
  get outerHTML() {
    return this.toString();
  }
  trimRight(pattern) {
    for (let i4 = 0; i4 < this.childNodes.length; i4++) {
      const childNode = this.childNodes[i4];
      if (childNode.nodeType === NodeType.ELEMENT_NODE) {
        childNode.trimRight(pattern);
      } else {
        const index = childNode.rawText.search(pattern);
        if (index > -1) {
          childNode.rawText = childNode.rawText.substr(0, index);
          this.childNodes.length = i4 + 1;
        }
      }
    }
    return this;
  }
  get structure() {
    const res = [];
    let indention = 0;
    function write(str) {
      res.push("  ".repeat(indention) + str);
    }
    function dfs(node) {
      const idStr = node.id ? `#${node.id}` : "";
      const classStr = node.classList.length ? `.${node.classList.value.join(".")}` : "";
      write(`${node.rawTagName}${idStr}${classStr}`);
      indention++;
      node.childNodes.forEach((childNode) => {
        if (childNode.nodeType === NodeType.ELEMENT_NODE) {
          dfs(childNode);
        } else if (childNode.nodeType === NodeType.TEXT_NODE) {
          if (!childNode.isWhitespace) {
            write("#text");
          }
        }
      });
      indention--;
    }
    dfs(this);
    return res.join("\n");
  }
  removeWhitespace() {
    let o4 = 0;
    this.childNodes.forEach((node) => {
      if (node.nodeType === NodeType.TEXT_NODE) {
        if (node.isWhitespace) {
          return;
        }
        node.rawText = node.trimmedRawText;
      } else if (node.nodeType === NodeType.ELEMENT_NODE) {
        node.removeWhitespace();
      }
      this.childNodes[o4++] = node;
    });
    this.childNodes.length = o4;
    const attrs = Object.keys(this.rawAttributes).map((key) => {
      const val = this.rawAttributes[key];
      return `${key}=${JSON.stringify(val)}`;
    }).join(" ");
    this.rawAttrs = attrs;
    delete this._rawAttrs;
    return this;
  }
  querySelectorAll(selector) {
    return selectAll(selector, this, {
      xmlMode: false,
      adapter: Matcher
    });
  }
  querySelector(selector) {
    return selectOne(selector, this, {
      xmlMode: false,
      adapter: Matcher
    });
  }
  getElementsByTagName(tagName) {
    const upperCasedTagName = tagName.toUpperCase();
    const re = [];
    const stack = [];
    let currentNodeReference = this;
    let index = 0;
    while (index !== void 0 && currentNodeReference) {
      let child;
      do {
        child = currentNodeReference.childNodes[index++];
      } while (index < currentNodeReference.childNodes.length && child === void 0);
      if (child === void 0) {
        currentNodeReference = currentNodeReference.parentNode;
        index = stack.pop();
        continue;
      }
      if (child.nodeType === NodeType.ELEMENT_NODE) {
        if (tagName === "*" || child.tagName === upperCasedTagName)
          re.push(child);
        if (child.childNodes.length > 0) {
          stack.push(index);
          currentNodeReference = child;
          index = 0;
        }
      }
    }
    return re;
  }
  getElementById(id2) {
    const stack = [];
    let currentNodeReference = this;
    let index = 0;
    while (index !== void 0 && currentNodeReference) {
      let child;
      do {
        child = currentNodeReference.childNodes[index++];
      } while (index < currentNodeReference.childNodes.length && child === void 0);
      if (child === void 0) {
        currentNodeReference = currentNodeReference.parentNode;
        index = stack.pop();
        continue;
      }
      if (child.nodeType === NodeType.ELEMENT_NODE) {
        if (child.id === id2) {
          return child;
        }
        if (child.childNodes.length > 0) {
          stack.push(index);
          currentNodeReference = child;
          index = 0;
        }
      }
    }
    return null;
  }
  closest(selector) {
    const mapChild = /* @__PURE__ */ new Map();
    let el = this;
    let old = null;
    while (el) {
      if (old)
        mapChild.set(el, old);
      old = el;
      el = el.parentNode;
    }
    el = this;
    while (el) {
      const e4 = selectOne(selector, el, {
        xmlMode: true,
        adapter: {
          ...Matcher,
          getChildren(node) {
            const child = mapChild.get(node);
            return child ? [child] : [];
          },
          getSiblings(node) {
            return [node];
          }
        }
      });
      if (e4) {
        return e4;
      }
      el = el.parentNode;
    }
    return null;
  }
  appendChild(node) {
    this.append(node);
    return node;
  }
  get attrs() {
    if (this._attrs) {
      return this._attrs;
    }
    this._attrs = {};
    const attrs = this.rawAttributes;
    for (const key in attrs) {
      const val = attrs[key] || "";
      this._attrs[key.toLowerCase()] = decode$1(val);
    }
    return this._attrs;
  }
  get attributes() {
    const ret_attrs = {};
    const attrs = this.rawAttributes;
    for (const key in attrs) {
      const val = attrs[key] || "";
      ret_attrs[key] = decode$1(val);
    }
    return ret_attrs;
  }
  get rawAttributes() {
    if (this._rawAttrs) {
      return this._rawAttrs;
    }
    const attrs = {};
    if (this.rawAttrs) {
      const re = /([a-zA-Z()[\]#@$.?:][a-zA-Z0-9-._:()[\]#]*)(?:\s*=\s*((?:'[^']*')|(?:"[^"]*")|\S+))?/g;
      let match;
      while (match = re.exec(this.rawAttrs)) {
        const key = match[1];
        let val = match[2] || null;
        if (val && (val[0] === `'` || val[0] === `"`))
          val = val.slice(1, val.length - 1);
        attrs[key] = attrs[key] || val || "";
      }
    }
    this._rawAttrs = attrs;
    return attrs;
  }
  removeAttribute(key) {
    const attrs = this.rawAttributes;
    delete attrs[key];
    if (this._attrs) {
      delete this._attrs[key];
    }
    this.rawAttrs = Object.keys(attrs).map((name) => {
      const val = this.quoteAttribute(attrs[name]);
      if (val === "null" || val === '""')
        return name;
      return `${name}=${val}`;
    }).join(" ");
    if (key === "id") {
      this.id = "";
    }
    return this;
  }
  hasAttribute(key) {
    return key.toLowerCase() in this.attrs;
  }
  getAttribute(key) {
    return this.attrs[key.toLowerCase()];
  }
  setAttribute(key, value) {
    if (arguments.length < 2) {
      throw new Error("Failed to execute 'setAttribute' on 'Element'");
    }
    const k22 = key.toLowerCase();
    const attrs = this.rawAttributes;
    for (const k4 in attrs) {
      if (k4.toLowerCase() === k22) {
        key = k4;
        break;
      }
    }
    attrs[key] = String(value);
    if (this._attrs) {
      this._attrs[k22] = decode$1(attrs[key]);
    }
    this.rawAttrs = Object.keys(attrs).map((name) => {
      const val = this.quoteAttribute(attrs[name]);
      if (val === "null" || val === '""')
        return name;
      return `${name}=${val}`;
    }).join(" ");
    if (key === "id") {
      this.id = value;
    }
    return this;
  }
  setAttributes(attributes) {
    if (this._attrs) {
      delete this._attrs;
    }
    if (this._rawAttrs) {
      delete this._rawAttrs;
    }
    this.rawAttrs = Object.keys(attributes).map((name) => {
      const val = attributes[name];
      if (val === "null" || val === '""')
        return name;
      return `${name}=${this.quoteAttribute(String(val))}`;
    }).join(" ");
    return this;
  }
  insertAdjacentHTML(where, html) {
    if (arguments.length < 2) {
      throw new Error("2 arguments required");
    }
    const p4 = parse$1(html, this._parseOptions);
    if (where === "afterend") {
      this.after(...p4.childNodes);
    } else if (where === "afterbegin") {
      this.prepend(...p4.childNodes);
    } else if (where === "beforeend") {
      this.append(...p4.childNodes);
    } else if (where === "beforebegin") {
      this.before(...p4.childNodes);
    } else {
      throw new Error(`The value provided ('${where}') is not one of 'beforebegin', 'afterbegin', 'beforeend', or 'afterend'`);
    }
    return this;
  }
  prepend(...insertable) {
    const nodes = resolveInsertable(insertable, this._parseOptions);
    resetParent(nodes, this);
    this.childNodes.unshift(...nodes);
  }
  append(...insertable) {
    const nodes = resolveInsertable(insertable, this._parseOptions);
    resetParent(nodes, this);
    this.childNodes.push(...nodes);
  }
  before(...insertable) {
    if (!this.parentNode)
      return;
    const nodes = resolveInsertable(insertable, this.parentNode._parseOptions);
    const siblings = this.parentNode.childNodes;
    resetParent(nodes, this.parentNode);
    siblings.splice(siblings.indexOf(this), 0, ...nodes);
  }
  after(...insertable) {
    if (!this.parentNode)
      return;
    const nodes = resolveInsertable(insertable, this.parentNode._parseOptions);
    const siblings = this.parentNode.childNodes;
    resetParent(nodes, this.parentNode);
    siblings.splice(siblings.indexOf(this) + 1, 0, ...nodes);
  }
  get nextSibling() {
    if (this.parentNode) {
      const children = this.parentNode.childNodes;
      let i4 = 0;
      while (i4 < children.length) {
        const child = children[i4++];
        if (this === child)
          return children[i4] || null;
      }
    }
    return null;
  }
  get nextElementSibling() {
    if (this.parentNode) {
      const children = this.parentNode.childNodes;
      let i4 = 0;
      let find2 = false;
      while (i4 < children.length) {
        const child = children[i4++];
        if (find2) {
          if (child instanceof _HTMLElement) {
            return child || null;
          }
        } else if (this === child) {
          find2 = true;
        }
      }
    }
    return null;
  }
  get previousSibling() {
    if (this.parentNode) {
      const children = this.parentNode.childNodes;
      let i4 = children.length;
      while (i4 > 0) {
        const child = children[--i4];
        if (this === child)
          return children[i4 - 1] || null;
      }
    }
    return null;
  }
  get previousElementSibling() {
    if (this.parentNode) {
      const children = this.parentNode.childNodes;
      let i4 = children.length;
      let find2 = false;
      while (i4 > 0) {
        const child = children[--i4];
        if (find2) {
          if (child instanceof _HTMLElement) {
            return child || null;
          }
        } else if (this === child) {
          find2 = true;
        }
      }
    }
    return null;
  }
  get children() {
    const children = [];
    for (const childNode of this.childNodes) {
      if (childNode instanceof _HTMLElement) {
        children.push(childNode);
      }
    }
    return children;
  }
  get firstChild() {
    return this.childNodes[0];
  }
  get firstElementChild() {
    return this.children[0];
  }
  get lastChild() {
    return arr_back(this.childNodes);
  }
  get lastElementChild() {
    return this.children[this.children.length - 1];
  }
  get childElementCount() {
    return this.children.length;
  }
  get classNames() {
    return this.classList.toString();
  }
  clone() {
    return parse$1(this.toString(), this._parseOptions).firstChild;
  }
};
var kMarkupPattern = /<!--[\s\S]*?-->|<(\/?)([a-zA-Z][-.:0-9_a-zA-Z@\xB7\xC0-\xD6\xD8-\xF6\u00F8-\u03A1\u03A3-\u03D9\u03DB-\u03EF\u03F7-\u03FF\u0400-\u04FF\u0500-\u052F\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E00-\u1E9B\u1F00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2126\u212A-\u212B\u2132\u214E\u2160-\u2188\u2C60-\u2C7F\uA722-\uA787\uA78B-\uA78E\uA790-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA7FF\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64-\uAB65\uFB00-\uFB06\uFB13-\uFB17\uFF21-\uFF3A\uFF41-\uFF5A\x37F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]*)((?:\s+[^>]*?(?:(?:'[^']*')|(?:"[^"]*"))?)*)\s*(\/?)>/gu;
var kAttributePattern = /(?:^|\s)(id|class)\s*=\s*((?:'[^']*')|(?:"[^"]*")|\S+)/gi;
var kElementsClosedByOpening = {
  li: { li: true, LI: true },
  LI: { li: true, LI: true },
  p: { p: true, div: true, P: true, DIV: true },
  P: { p: true, div: true, P: true, DIV: true },
  b: { div: true, DIV: true },
  B: { div: true, DIV: true },
  td: { td: true, th: true, TD: true, TH: true },
  TD: { td: true, th: true, TD: true, TH: true },
  th: { td: true, th: true, TD: true, TH: true },
  TH: { td: true, th: true, TD: true, TH: true },
  h1: { h1: true, H1: true },
  H1: { h1: true, H1: true },
  h2: { h2: true, H2: true },
  H2: { h2: true, H2: true },
  h3: { h3: true, H3: true },
  H3: { h3: true, H3: true },
  h4: { h4: true, H4: true },
  H4: { h4: true, H4: true },
  h5: { h5: true, H5: true },
  H5: { h5: true, H5: true },
  h6: { h6: true, H6: true },
  H6: { h6: true, H6: true }
};
var kElementsClosedByClosing = {
  li: { ul: true, ol: true, UL: true, OL: true },
  LI: { ul: true, ol: true, UL: true, OL: true },
  a: { div: true, DIV: true },
  A: { div: true, DIV: true },
  b: { div: true, DIV: true },
  B: { div: true, DIV: true },
  i: { div: true, DIV: true },
  I: { div: true, DIV: true },
  p: { div: true, DIV: true },
  P: { div: true, DIV: true },
  td: { tr: true, table: true, TR: true, TABLE: true },
  TD: { tr: true, table: true, TR: true, TABLE: true },
  th: { tr: true, table: true, TR: true, TABLE: true },
  TH: { tr: true, table: true, TR: true, TABLE: true }
};
var frameflag = "documentfragmentcontainer";
function base_parse(data2, options = {}) {
  const voidTag = new VoidTag(options?.voidTag?.closingSlash, options?.voidTag?.tags);
  const elements = options.blockTextElements || {
    script: true,
    noscript: true,
    style: true,
    pre: true
  };
  const element_names = Object.keys(elements);
  const kBlockTextElements = element_names.map((it) => new RegExp(`^${it}$`, "i"));
  const kIgnoreElements = element_names.filter((it) => Boolean(elements[it])).map((it) => new RegExp(`^${it}$`, "i"));
  function element_should_be_ignore(tag2) {
    return kIgnoreElements.some((it) => it.test(tag2));
  }
  function is_block_text_element(tag2) {
    return kBlockTextElements.some((it) => it.test(tag2));
  }
  const createRange = (startPos, endPos) => [
    startPos - frameFlagOffset,
    endPos - frameFlagOffset
  ];
  const root2 = new HTMLElement("", {}, "", null, [0, data2.length], voidTag, options);
  let currentParent = root2;
  const stack = [root2];
  let lastTextPos = -1;
  let noNestedTagIndex = void 0;
  let match;
  data2 = `<${frameflag}>${data2}</${frameflag}>`;
  const { lowerCaseTagName, fixNestedATags } = options;
  const dataEndPos = data2.length - (frameflag.length + 2);
  const frameFlagOffset = frameflag.length + 2;
  while (match = kMarkupPattern.exec(data2)) {
    let { 0: matchText, 1: leadingSlash, 2: tagName, 3: attributes, 4: closingSlash } = match;
    const matchLength = matchText.length;
    const tagStartPos = kMarkupPattern.lastIndex - matchLength;
    const tagEndPos = kMarkupPattern.lastIndex;
    if (lastTextPos > -1) {
      if (lastTextPos + matchLength < tagEndPos) {
        const text = data2.substring(lastTextPos, tagStartPos);
        currentParent.appendChild(new TextNode(text, currentParent, createRange(lastTextPos, tagStartPos)));
      }
    }
    lastTextPos = kMarkupPattern.lastIndex;
    if (tagName === frameflag)
      continue;
    if (matchText[1] === "!") {
      if (options.comment) {
        const text = data2.substring(tagStartPos + 4, tagEndPos - 3);
        currentParent.appendChild(new CommentNode(text, currentParent, createRange(tagStartPos, tagEndPos)));
      }
      continue;
    }
    if (lowerCaseTagName)
      tagName = tagName.toLowerCase();
    if (!leadingSlash) {
      const attrs = {};
      for (let attMatch; attMatch = kAttributePattern.exec(attributes); ) {
        const { 1: key, 2: val } = attMatch;
        const isQuoted = val[0] === `'` || val[0] === `"`;
        attrs[key.toLowerCase()] = isQuoted ? val.slice(1, val.length - 1) : val;
      }
      const parentTagName = currentParent.rawTagName;
      if (!closingSlash && kElementsClosedByOpening[parentTagName]) {
        if (kElementsClosedByOpening[parentTagName][tagName]) {
          stack.pop();
          currentParent = arr_back(stack);
        }
      }
      if (fixNestedATags && (tagName === "a" || tagName === "A")) {
        if (noNestedTagIndex !== void 0) {
          stack.splice(noNestedTagIndex);
          currentParent = arr_back(stack);
        }
        noNestedTagIndex = stack.length;
      }
      const tagEndPos2 = kMarkupPattern.lastIndex;
      const tagStartPos2 = tagEndPos2 - matchLength;
      currentParent = currentParent.appendChild(new HTMLElement(tagName, attrs, attributes.slice(1), null, createRange(tagStartPos2, tagEndPos2), voidTag, options));
      stack.push(currentParent);
      if (is_block_text_element(tagName)) {
        const closeMarkup = `</${tagName}>`;
        const closeIndex = lowerCaseTagName ? data2.toLocaleLowerCase().indexOf(closeMarkup, kMarkupPattern.lastIndex) : data2.indexOf(closeMarkup, kMarkupPattern.lastIndex);
        const textEndPos = closeIndex === -1 ? dataEndPos : closeIndex;
        if (element_should_be_ignore(tagName)) {
          const text = data2.substring(tagEndPos2, textEndPos);
          if (text.length > 0 && /\S/.test(text)) {
            currentParent.appendChild(new TextNode(text, currentParent, createRange(tagEndPos2, textEndPos)));
          }
        }
        if (closeIndex === -1) {
          lastTextPos = kMarkupPattern.lastIndex = data2.length + 1;
        } else {
          lastTextPos = kMarkupPattern.lastIndex = closeIndex + closeMarkup.length;
          leadingSlash = "/";
        }
      }
    }
    if (leadingSlash || closingSlash || voidTag.isVoidElement(tagName)) {
      while (true) {
        if (noNestedTagIndex != null && (tagName === "a" || tagName === "A"))
          noNestedTagIndex = void 0;
        if (currentParent.rawTagName === tagName) {
          currentParent.range[1] = createRange(-1, Math.max(lastTextPos, tagEndPos))[1];
          stack.pop();
          currentParent = arr_back(stack);
          break;
        } else {
          const parentTagName = currentParent.tagName;
          if (kElementsClosedByClosing[parentTagName]) {
            if (kElementsClosedByClosing[parentTagName][tagName]) {
              stack.pop();
              currentParent = arr_back(stack);
              continue;
            }
          }
          break;
        }
      }
    }
  }
  return stack;
}
function parse$1(data2, options = {}) {
  const stack = base_parse(data2, options);
  const [root2] = stack;
  while (stack.length > 1) {
    const last = stack.pop();
    const oneBefore = arr_back(stack);
    if (last && last.parentNode && last.parentNode.parentNode) {
      if (last.parentNode === oneBefore && last.tagName === oneBefore.tagName) {
        if (options.parseNoneClosedTags !== true) {
          oneBefore.removeChild(last);
          last.childNodes.forEach((child) => {
            if (oneBefore.parentNode)
              oneBefore.parentNode.appendChild(child);
          });
          stack.pop();
        }
      } else {
        if (options.parseNoneClosedTags !== true) {
          oneBefore.removeChild(last);
          last.childNodes.forEach((child) => {
            oneBefore.appendChild(child);
          });
        }
      }
    }
  }
  return root2;
}
function resolveInsertable(insertable, options) {
  const result = [];
  for (const val of insertable) {
    if (typeof val === "string") {
      if (/<[a-zA-Z!]/.test(val)) {
        const stack = base_parse(val, options || {});
        const root2 = stack[0];
        if (root2 && root2.childNodes) {
          for (const child of root2.childNodes) {
            child.parentNode = null;
            result.push(child);
          }
        }
      } else {
        result.push(new TextNode(val));
      }
    } else {
      val.remove();
      result.push(val);
    }
  }
  return result;
}
function resetParent(nodes, parent) {
  return nodes.map((node) => {
    node.parentNode = parent;
    return node;
  });
}
function valid(data2, options = {}) {
  const stack = base_parse(data2, options);
  return Boolean(stack.length === 1);
}
function parse(data2, options = {}) {
  return parse$1(data2, options);
}
parse.parse = parse$1;
parse.HTMLElement = HTMLElement;
parse.CommentNode = CommentNode;
parse.valid = valid;
parse.Node = Node;
parse.TextNode = TextNode;
parse.NodeType = NodeType;
var ScrapeElement = class _ScrapeElement {
  elements;
  constructor(elements) {
    if (Array.isArray(elements)) {
      this.elements = elements.filter((el) => el.nodeType === NodeType.ELEMENT_NODE);
    } else {
      this.elements = elements.nodeType === NodeType.ELEMENT_NODE ? [elements] : [];
    }
  }
  find(selector) {
    const found = [];
    this.elements.forEach((el) => {
      found.push(...el.querySelectorAll(selector));
    });
    return new _ScrapeElement(found);
  }
  parent(selector) {
    const parents = [];
    this.elements.forEach((el) => {
      const p4 = el.parentNode;
      if (p4 && p4.nodeType === NodeType.ELEMENT_NODE) {
        if (!selector || is(p4, selector, { adapter: Matcher })) {
          if (!parents.includes(p4)) {
            parents.push(p4);
          }
        }
      }
    });
    return new _ScrapeElement(parents);
  }
  children(selector) {
    const children = [];
    this.elements.forEach((el) => {
      el.childNodes.forEach((child) => {
        if (child.nodeType === NodeType.ELEMENT_NODE) {
          const childEl = child;
          if (!selector || is(childEl, selector, { adapter: Matcher })) {
            children.push(childEl);
          }
        }
      });
    });
    return new _ScrapeElement(children);
  }
  siblings(selector) {
    const siblings = [];
    this.elements.forEach((el) => {
      const parent = el.parentNode;
      if (parent) {
        parent.childNodes.forEach((child) => {
          if (child !== el && child.nodeType === NodeType.ELEMENT_NODE) {
            const childEl = child;
            if (!selector || is(childEl, selector, { adapter: Matcher })) {
              if (!siblings.includes(childEl)) {
                siblings.push(childEl);
              }
            }
          }
        });
      }
    });
    return new _ScrapeElement(siblings);
  }
  next(selector) {
    const nexts = [];
    this.elements.forEach((el) => {
      let curr = el.nextElementSibling;
      while (curr) {
        if (!selector || is(curr, selector, { adapter: Matcher })) {
          nexts.push(curr);
          break;
        }
        break;
      }
    });
    return new _ScrapeElement(nexts);
  }
  prev(selector) {
    const prevs = [];
    this.elements.forEach((el) => {
      let curr = el.previousElementSibling;
      if (curr) {
        if (!selector || is(curr, selector, { adapter: Matcher })) {
          prevs.push(curr);
        }
      }
    });
    return new _ScrapeElement(prevs);
  }
  nextAll(selector) {
    const nexts = [];
    this.elements.forEach((el) => {
      let curr = el.nextElementSibling;
      while (curr) {
        if (!selector || is(curr, selector, { adapter: Matcher })) {
          nexts.push(curr);
        }
        curr = curr.nextElementSibling;
      }
    });
    return new _ScrapeElement(nexts);
  }
  prevAll(selector) {
    const prevs = [];
    this.elements.forEach((el) => {
      let curr = el.previousElementSibling;
      while (curr) {
        if (!selector || is(curr, selector, { adapter: Matcher })) {
          prevs.push(curr);
        }
        curr = curr.previousElementSibling;
      }
    });
    return new _ScrapeElement(prevs);
  }
  closest(selector) {
    const closests = [];
    this.elements.forEach((el) => {
      const found = el.closest(selector);
      if (found) {
        if (!closests.includes(found)) {
          closests.push(found);
        }
      }
    });
    return new _ScrapeElement(closests);
  }
  first() {
    return new _ScrapeElement(this.elements.slice(0, 1));
  }
  last() {
    return new _ScrapeElement(this.elements.slice(-1));
  }
  eq(index) {
    if (index < 0)
      index = this.elements.length + index;
    return new _ScrapeElement(this.elements.slice(index, index + 1));
  }
  filter(selectorOrCallback) {
    if (typeof selectorOrCallback === "string") {
      const filtered = this.elements.filter((el) => is(el, selectorOrCallback, { adapter: Matcher }));
      return new _ScrapeElement(filtered);
    } else {
      const filtered = this.elements.filter((el, index) => selectorOrCallback(new _ScrapeElement(el), index));
      return new _ScrapeElement(filtered);
    }
  }
  not(selector) {
    const filtered = this.elements.filter((el) => !is(el, selector, { adapter: Matcher }));
    return new _ScrapeElement(filtered);
  }
  has(selector) {
    const has = this.elements.filter((el) => {
      return el.querySelector(selector) !== null;
    });
    return new _ScrapeElement(has);
  }
  add(selector) {
    if (selector.trim().startsWith("<")) {
      const parsed = parse(selector);
      return new _ScrapeElement([...this.elements, ...parsed.children]);
    }
    return this;
  }
  parents(selector) {
    const parents = [];
    this.elements.forEach((el) => {
      let p4 = el.parentNode;
      while (p4 && p4.nodeType === NodeType.ELEMENT_NODE) {
        const pEl = p4;
        if (!selector || is(pEl, selector, { adapter: Matcher })) {
          if (!parents.includes(pEl)) {
            parents.push(pEl);
          }
        }
        p4 = p4.parentNode;
      }
    });
    return new _ScrapeElement(parents);
  }
  parentsUntil(selector) {
    const parents = [];
    this.elements.forEach((el) => {
      let p4 = el.parentNode;
      while (p4 && p4.nodeType === NodeType.ELEMENT_NODE) {
        const pEl = p4;
        if (is(pEl, selector, { adapter: Matcher })) {
          break;
        }
        if (!parents.includes(pEl)) {
          parents.push(pEl);
        }
        p4 = p4.parentNode;
      }
    });
    return new _ScrapeElement(parents);
  }
  nextUntil(selector) {
    const nexts = [];
    this.elements.forEach((el) => {
      let curr = el.nextElementSibling;
      while (curr) {
        if (is(curr, selector, { adapter: Matcher })) {
          break;
        }
        nexts.push(curr);
        curr = curr.nextElementSibling;
      }
    });
    return new _ScrapeElement(nexts);
  }
  prevUntil(selector) {
    const prevs = [];
    this.elements.forEach((el) => {
      let curr = el.previousElementSibling;
      while (curr) {
        if (is(curr, selector, { adapter: Matcher })) {
          break;
        }
        prevs.push(curr);
        curr = curr.previousElementSibling;
      }
    });
    return new _ScrapeElement(prevs);
  }
  slice(start, end) {
    return new _ScrapeElement(this.elements.slice(start, end));
  }
  contents() {
    const contents = [];
    this.elements.forEach((el) => {
      el.childNodes.forEach((child) => {
        if (child.nodeType === NodeType.ELEMENT_NODE) {
          contents.push(child);
        }
      });
    });
    return new _ScrapeElement(contents);
  }
  text() {
    return this.elements.map((el) => el.text).join("");
  }
  html() {
    if (this.elements.length > 0) {
      return this.elements[0].innerHTML;
    }
    return null;
  }
  outerHtml() {
    if (this.elements.length > 0) {
      return this.elements[0].outerHTML;
    }
    return "";
  }
  attr(name) {
    if (this.elements.length > 0) {
      return this.elements[0].getAttribute(name);
    }
    return void 0;
  }
  attrs() {
    if (this.elements.length > 0) {
      return this.elements[0].attributes;
    }
    return {};
  }
  data(name) {
    if (this.elements.length === 0)
      return void 0;
    const el = this.elements[0];
    const attrs = el.attributes;
    if (name) {
      return attrs[`data-${name}`];
    }
    const dataAttrs = {};
    for (const key in attrs) {
      if (key.startsWith("data-")) {
        const shortKey = key.slice(5);
        dataAttrs[shortKey] = attrs[key];
      }
    }
    return dataAttrs;
  }
  val() {
    if (this.elements.length === 0)
      return void 0;
    const el = this.elements[0];
    if (el.tagName === "INPUT") {
      return el.getAttribute("value");
    }
    if (el.tagName === "TEXTAREA") {
      return el.text;
    }
    if (el.tagName === "SELECT") {
      const option = el.querySelector("option[selected]") || el.querySelector("option");
      return option ? option.getAttribute("value") ?? option.text : void 0;
    }
    return el.getAttribute("value");
  }
  prop(name) {
    if (this.elements.length === 0)
      return void 0;
    const el = this.elements[0];
    if (name === "tagName")
      return el.tagName;
    if (name in el)
      return el[name];
    return this.attr(name);
  }
  exists() {
    return this.elements.length > 0;
  }
  get length() {
    return this.elements.length;
  }
  is(selector) {
    return this.elements.some((el) => is(el, selector, { adapter: Matcher }));
  }
  hasClass(className) {
    return this.elements.some((el) => el.classList.contains(className));
  }
  index(selector) {
    if (this.elements.length === 0)
      return -1;
    const el = this.elements[0];
    const parent = el.parentNode;
    if (!parent)
      return 0;
    const siblings = parent.childNodes.filter((n4) => n4.nodeType === NodeType.ELEMENT_NODE);
    if (selector) {
      return siblings.findIndex((s4) => s4 === el);
    }
    return siblings.indexOf(el);
  }
  each(callback) {
    this.elements.forEach((el, index) => {
      callback(new _ScrapeElement(el), index);
    });
    return this;
  }
  map(callback) {
    return this.elements.map((el, index) => {
      return callback(new _ScrapeElement(el), index);
    });
  }
  toArray() {
    return this.elements.map((el) => new _ScrapeElement(el));
  }
  reduce(callback, initialValue) {
    let accumulator = initialValue;
    this.elements.forEach((el, index) => {
      accumulator = callback(accumulator, new _ScrapeElement(el), index);
    });
    return accumulator;
  }
  some(callback) {
    return this.elements.some((el, index) => callback(new _ScrapeElement(el), index));
  }
  every(callback) {
    return this.elements.every((el, index) => callback(new _ScrapeElement(el), index));
  }
  tagName() {
    if (this.elements.length > 0) {
      return this.elements[0].tagName?.toLowerCase();
    }
    return void 0;
  }
  clone() {
    const clones = this.elements.map((el) => el.clone());
    return new _ScrapeElement(clones);
  }
  toString() {
    return this.outerHtml();
  }
  get raw() {
    return this.elements;
  }
  get(index = 0) {
    return this.elements[index];
  }
};
function resolveUrl$1(url, baseUrl) {
  if (!url)
    return "";
  if (!baseUrl)
    return url;
  try {
    if (url.startsWith("http://") || url.startsWith("https://") || url.startsWith("//")) {
      return url;
    }
    return new URL(url, baseUrl).href;
  } catch {
    return url;
  }
}
function classifyLinkType(href, baseUrl) {
  if (!href)
    return void 0;
  if (href.startsWith("mailto:"))
    return "mailto";
  if (href.startsWith("tel:"))
    return "tel";
  if (href.startsWith("#"))
    return "anchor";
  if (baseUrl) {
    try {
      const base2 = new URL(baseUrl);
      const link = new URL(href, baseUrl);
      return link.hostname === base2.hostname ? "internal" : "external";
    } catch {
      return void 0;
    }
  }
  if (href.startsWith("http://") || href.startsWith("https://") || href.startsWith("//")) {
    return "external";
  }
  return "internal";
}
function extractLinks(root2, options) {
  const selector = options?.selector || "a[href]";
  const links = [];
  root2.querySelectorAll(selector).forEach((element) => {
    let href = element.getAttribute("href") || "";
    if (options?.absolute && options?.baseUrl) {
      href = resolveUrl$1(href, options.baseUrl);
    }
    const imgs = element.querySelectorAll("img");
    const svgs = element.querySelectorAll("svg");
    links.push({
      href,
      text: element.text.trim(),
      rel: element.getAttribute("rel"),
      target: element.getAttribute("target"),
      title: element.getAttribute("title"),
      type: classifyLinkType(href, options?.baseUrl),
      hasImage: imgs.length > 0,
      hasImageWithAlt: imgs.filter((img) => !!img.getAttribute("alt")?.trim()).length > 0,
      hasSvg: svgs.length > 0,
      hasSvgWithTitle: svgs.filter((svg) => svg.querySelectorAll("title").length > 0 || !!svg.getAttribute("aria-label")).length > 0,
      ariaLabel: element.getAttribute("aria-label")
    });
  });
  return links;
}
function extractImages(root2, options) {
  const selector = options?.selector || "img[src]";
  const images = [];
  root2.querySelectorAll(selector).forEach((element) => {
    let src = element.getAttribute("src") || "";
    if (options?.absolute && options?.baseUrl) {
      src = resolveUrl$1(src, options.baseUrl);
    }
    const width = element.getAttribute("width");
    const height = element.getAttribute("height");
    images.push({
      src,
      alt: element.getAttribute("alt"),
      title: element.getAttribute("title"),
      width: width ? parseInt(width, 10) : void 0,
      height: height ? parseInt(height, 10) : void 0,
      srcset: element.getAttribute("srcset"),
      loading: element.getAttribute("loading"),
      decoding: element.getAttribute("decoding")
    });
  });
  return images;
}
function extractMeta(root2) {
  const meta = {};
  const titleEl = root2.querySelector("title");
  meta.title = titleEl ? titleEl.text.trim() || void 0 : void 0;
  const charsetMeta = root2.querySelector("meta[charset]");
  if (charsetMeta) {
    meta.charset = charsetMeta.getAttribute("charset");
  } else {
    const contentTypeMeta = root2.querySelector('meta[http-equiv="Content-Type"]');
    const contentType = contentTypeMeta ? contentTypeMeta.getAttribute("content") : null;
    if (contentType) {
      const charsetMatch = contentType.match(/charset=([^;]+)/i);
      if (charsetMatch) {
        meta.charset = charsetMatch[1].trim();
      }
    }
  }
  const canonicalEl = root2.querySelector('link[rel="canonical"]');
  if (canonicalEl) {
    meta.canonical = canonicalEl.getAttribute("href");
  }
  root2.querySelectorAll("meta[name]").forEach((element) => {
    const name = element.getAttribute("name")?.toLowerCase();
    const content = element.getAttribute("content");
    if (!name || !content)
      return;
    switch (name) {
      case "description":
        meta.description = content;
        break;
      case "keywords":
        meta.keywords = content.split(",").map((k4) => k4.trim()).filter(Boolean);
        break;
      case "author":
        meta.author = content;
        break;
      case "robots":
        meta.robots = content.split(",").map((r4) => r4.trim().toLowerCase());
        break;
      case "viewport":
        meta.viewport = content;
        break;
      default:
        meta[name] = content;
    }
  });
  return meta;
}
function extractOpenGraph(root2) {
  const og = {};
  const images = [];
  root2.querySelectorAll('meta[property^="og:"]').forEach((element) => {
    const property = element.getAttribute("property");
    const content = element.getAttribute("content");
    if (!property || !content)
      return;
    const key = property.replace("og:", "");
    switch (key) {
      case "title":
        og.title = content;
        break;
      case "type":
        og.type = content;
        break;
      case "url":
        og.url = content;
        break;
      case "image":
        images.push(content);
        break;
      case "description":
        og.description = content;
        break;
      case "site_name":
        og.siteName = content;
        break;
      case "locale":
        og.locale = content;
        break;
      default:
        og[key.replace(/_([a-z])/g, (_, c4) => c4.toUpperCase())] = content;
    }
  });
  if (images.length === 1) {
    og.image = images[0];
  } else if (images.length > 1) {
    og.image = images;
  }
  return og;
}
function extractTwitterCard(root2) {
  const twitter = {};
  root2.querySelectorAll('meta[name^="twitter:"]').forEach((element) => {
    const name = element.getAttribute("name");
    const content = element.getAttribute("content");
    if (!name || !content)
      return;
    const key = name.replace("twitter:", "");
    switch (key) {
      case "card":
        twitter.card = content;
        break;
      case "site":
        twitter.site = content;
        break;
      case "creator":
        twitter.creator = content;
        break;
      case "title":
        twitter.title = content;
        break;
      case "description":
        twitter.description = content;
        break;
      case "image":
        twitter.image = content;
        break;
      default:
        twitter[key] = content;
    }
  });
  return twitter;
}
function extractJsonLd(root2) {
  const results = [];
  root2.querySelectorAll('script[type="application/ld+json"]').forEach((element) => {
    const content = element.innerHTML;
    if (!content)
      return;
    try {
      const data2 = JSON.parse(content);
      if (data2["@graph"] && Array.isArray(data2["@graph"])) {
        results.push(...data2["@graph"]);
      } else if (Array.isArray(data2)) {
        results.push(...data2);
      } else {
        results.push(data2);
      }
    } catch {
    }
  });
  return results;
}
function extractForms(root2, selector) {
  const forms = [];
  const formSelector = selector || "form";
  root2.querySelectorAll(formSelector).forEach((formElement) => {
    const fields = [];
    formElement.querySelectorAll("input, select, textarea").forEach((fieldElement) => {
      const tagName = fieldElement.tagName?.toLowerCase();
      const type = fieldElement.getAttribute("type") || (tagName === "textarea" ? "textarea" : tagName === "select" ? "select" : "text");
      let value = fieldElement.getAttribute("value");
      if (tagName === "textarea") {
        value = fieldElement.text;
      }
      const field = {
        name: fieldElement.getAttribute("name"),
        type,
        value,
        placeholder: fieldElement.getAttribute("placeholder"),
        required: fieldElement.hasAttribute("required")
      };
      if (tagName === "select") {
        field.options = [];
        fieldElement.querySelectorAll("option").forEach((optionElement) => {
          field.options.push({
            value: optionElement.getAttribute("value") || optionElement.text,
            text: optionElement.text.trim()
          });
        });
        const selected = fieldElement.querySelector("option[selected]");
        if (selected) {
          field.value = selected.getAttribute("value") || selected.text;
        }
      }
      fields.push(field);
    });
    forms.push({
      action: formElement.getAttribute("action"),
      method: formElement.getAttribute("method")?.toUpperCase(),
      name: formElement.getAttribute("name"),
      id: formElement.getAttribute("id"),
      fields
    });
  });
  return forms;
}
function extractTables(root2, selector) {
  const tables = [];
  const tableSelector = selector || "table";
  root2.querySelectorAll(tableSelector).forEach((tableElement) => {
    const headers2 = [];
    const rows = [];
    const captionEl = tableElement.querySelector("caption");
    const caption = captionEl ? captionEl.text.trim() || void 0 : void 0;
    let headerRow = null;
    const thead = tableElement.querySelector("thead");
    if (thead) {
      thead.querySelectorAll("th, td").forEach((cell) => {
        headers2.push(cell.text.trim());
      });
    }
    if (headers2.length === 0) {
      const tr = tableElement.querySelector("tr");
      if (tr) {
        tr.childNodes.forEach((child) => {
          if (child.nodeType === NodeType.ELEMENT_NODE) {
            const el = child;
            if (["TH", "TD"].includes(el.tagName)) {
              headers2.push(el.text.trim());
            }
          }
        });
        if (headers2.length > 0) {
          headerRow = tr;
        }
      }
    }
    const allRows = tableElement.querySelectorAll("tr");
    allRows.forEach((tr) => {
      if (tr.parentNode && tr.parentNode.tagName === "THEAD") {
        return;
      }
      if (tr === headerRow) {
        return;
      }
      const row = [];
      tr.querySelectorAll("td, th").forEach((cell) => {
        row.push(cell.text.trim());
      });
      if (row.length > 0) {
        rows.push(row);
      }
    });
    if (headers2.length > 0 || rows.length > 0) {
      tables.push({
        caption,
        headers: headers2,
        rows
      });
    }
  });
  return tables;
}
function extractScripts(root2) {
  const scripts = [];
  root2.querySelectorAll("script").forEach((element) => {
    const src = element.getAttribute("src");
    const inline = !src ? element.innerHTML?.trim() : void 0;
    if (!src && !inline)
      return;
    scripts.push({
      src,
      type: element.getAttribute("type"),
      async: element.hasAttribute("async"),
      defer: element.hasAttribute("defer"),
      inline
    });
  });
  return scripts;
}
function extractStyles(root2) {
  const styles = [];
  root2.querySelectorAll('link[rel="stylesheet"]').forEach((element) => {
    styles.push({
      href: element.getAttribute("href"),
      media: element.getAttribute("media")
    });
  });
  root2.querySelectorAll("style").forEach((element) => {
    const inline = element.innerHTML?.trim();
    if (inline) {
      styles.push({
        media: element.getAttribute("media"),
        inline
      });
    }
  });
  return styles;
}
var ScrapeDocument = class _ScrapeDocument {
  rootElement;
  options;
  constructor(root2, options) {
    this.rootElement = root2;
    this.options = options || {};
  }
  static async create(html, options) {
    const root2 = parse(html);
    return new _ScrapeDocument(root2, options);
  }
  static createSync(html, options) {
    const root2 = parse(html);
    return new _ScrapeDocument(root2, options);
  }
  select(selector) {
    const elements = this.rootElement.querySelectorAll(selector);
    return new ScrapeElement(elements);
  }
  selectFirst(selector) {
    const element = this.rootElement.querySelector(selector);
    return new ScrapeElement(element ? [element] : []);
  }
  selectAll(selector) {
    const elements = this.rootElement.querySelectorAll(selector);
    return elements.map((el) => new ScrapeElement(el));
  }
  query(selector) {
    return this.select(selector);
  }
  queryAll(selector) {
    return this.selectAll(selector);
  }
  text(selector) {
    const el = this.rootElement.querySelector(selector);
    return el ? el.text.trim() : "";
  }
  texts(selector) {
    const elements = this.rootElement.querySelectorAll(selector);
    return elements.map((el) => el.text.trim()).filter((text) => text.length > 0);
  }
  attr(selector, attribute) {
    const el = this.rootElement.querySelector(selector);
    return el ? el.getAttribute(attribute) : void 0;
  }
  attrs(selector, attribute) {
    const elements = this.rootElement.querySelectorAll(selector);
    const attrs = [];
    elements.forEach((el) => {
      const val = el.getAttribute(attribute);
      if (val !== void 0) {
        attrs.push(val);
      }
    });
    return attrs;
  }
  innerHtml(selector) {
    const el = this.rootElement.querySelector(selector);
    return el ? el.innerHTML : null;
  }
  outerHtml(selector) {
    const el = this.rootElement.querySelector(selector);
    return el ? el.outerHTML : "";
  }
  links(options) {
    return extractLinks(this.rootElement, {
      ...options,
      baseUrl: this.options.baseUrl
    });
  }
  images(options) {
    return extractImages(this.rootElement, {
      ...options,
      baseUrl: this.options.baseUrl
    });
  }
  meta() {
    return extractMeta(this.rootElement);
  }
  openGraph() {
    return extractOpenGraph(this.rootElement);
  }
  twitterCard() {
    return extractTwitterCard(this.rootElement);
  }
  jsonLd() {
    return extractJsonLd(this.rootElement);
  }
  forms(selector) {
    return extractForms(this.rootElement, selector);
  }
  tables(selector) {
    return extractTables(this.rootElement, selector);
  }
  scripts() {
    return extractScripts(this.rootElement);
  }
  styles() {
    return extractStyles(this.rootElement);
  }
  extract(schema) {
    const result = {};
    for (const [key, fieldConfig] of Object.entries(schema)) {
      const value = this.extractField(fieldConfig);
      if (value === void 0) {
        const isOptional = typeof fieldConfig === "object" && fieldConfig.optional === true;
        if (!isOptional) {
          result[key] = void 0;
        }
      } else {
        result[key] = value;
      }
    }
    return result;
  }
  extractField(field) {
    if (typeof field === "string") {
      return this.text(field) || void 0;
    }
    const { selector, attribute, multiple, transform } = field;
    const defaultValue = "default" in field ? field.default : void 0;
    if (multiple) {
      const elements = this.rootElement.querySelectorAll(selector);
      const values = [];
      elements.forEach((el) => {
        let value;
        if (attribute) {
          value = el.getAttribute(attribute) || "";
        } else {
          value = el.text.trim();
        }
        if (value) {
          values.push(transform ? transform(value) : value);
        }
      });
      if (values.length === 0 && defaultValue !== void 0) {
        return defaultValue;
      }
      return values;
    } else {
      const el = this.rootElement.querySelector(selector);
      if (!el) {
        return defaultValue;
      }
      let value;
      if (attribute) {
        value = el.getAttribute(attribute) || "";
      } else {
        value = el.text.trim();
      }
      if (!value) {
        return defaultValue;
      }
      return transform ? transform(value) : value;
    }
  }
  title() {
    const el = this.rootElement.querySelector("title");
    const title = el ? el.text.trim() : "";
    return title || void 0;
  }
  body() {
    const el = this.rootElement.querySelector("body");
    return new ScrapeElement(el ? [el] : []);
  }
  head() {
    const el = this.rootElement.querySelector("head");
    return new ScrapeElement(el ? [el] : []);
  }
  html() {
    return this.rootElement.outerHTML;
  }
  root() {
    return new ScrapeElement(this.rootElement);
  }
  exists(selector) {
    return this.rootElement.querySelector(selector) !== null;
  }
  count(selector) {
    return this.rootElement.querySelectorAll(selector).length;
  }
  findByText(text, selector) {
    const elements = [];
    const candidates = selector ? this.rootElement.querySelectorAll(selector) : this.rootElement.querySelectorAll("*");
    candidates.forEach((el) => {
      if (el.text.includes(text)) {
        elements.push(new ScrapeElement(el));
      }
    });
    return elements;
  }
  findByExactText(text, selector) {
    const elements = [];
    const candidates = selector ? this.rootElement.querySelectorAll(selector) : this.rootElement.querySelectorAll("*");
    candidates.forEach((el) => {
      if (el.text.trim() === text) {
        elements.push(new ScrapeElement(el));
      }
    });
    return elements;
  }
  findByData(name, value) {
    const selector = value !== void 0 ? `[data-${name}="${value}"]` : `[data-${name}]`;
    return this.selectAll(selector);
  }
  get raw() {
    return this.rootElement;
  }
  get baseUrl() {
    return this.options.baseUrl;
  }
};
var document$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ScrapeDocument
});
var BIN_DIR = (0, import_node_path.join)((0, import_node_os.homedir)(), ".recker", "bin");
function getCurlBinName() {
  return "curl-impersonate-chrome";
}
function getCurlPath() {
  return (0, import_node_path.join)(BIN_DIR, getCurlBinName());
}
async function hasImpersonate() {
  try {
    await import_node_fs.promises.access(getCurlPath());
    return true;
  } catch {
    return false;
  }
}
var CurlTransport = class {
  async dispatch(req) {
    return new Promise(async (resolve, reject) => {
      const args = [
        "-X",
        req.method,
        req.url,
        "-i",
        "-s",
        "--compressed",
        "--no-keepalive"
      ];
      req.headers.forEach((val, key) => {
        args.push("-H", `${key}: ${val}`);
      });
      if (req.body && typeof req.body === "string") {
        args.push("-d", req.body);
      }
      let command = process.env.RECKER_CURL_BIN;
      if (!command) {
        if (await hasImpersonate()) {
          command = getCurlPath();
        } else {
          command = "curl";
        }
      }
      const child = (0, import_node_child_process.spawn)(command, args);
      const stdoutChunks = [];
      const stderrChunks = [];
      child.stdout.on("data", (chunk2) => stdoutChunks.push(chunk2));
      child.stderr.on("data", (chunk2) => stderrChunks.push(chunk2));
      child.on("error", (err) => {
        reject(new NetworkError(`Failed to spawn curl: ${err.message}`, "ERR_CURL_SPAWN", req));
      });
      child.on("close", (code) => {
        if (code !== 0) {
          const stderr = Buffer.concat(stderrChunks).toString();
          reject(new NetworkError(`Curl exited with code ${code}: ${stderr}`, "ERR_CURL_EXIT", req));
          return;
        }
        const fullOutput = Buffer.concat(stdoutChunks);
        let headerEndIndex = fullOutput.indexOf("\r\n\r\n");
        let offset = 4;
        if (headerEndIndex === -1) {
          headerEndIndex = fullOutput.indexOf("\n\n");
          offset = 2;
        }
        if (headerEndIndex !== -1) {
          const firstLine = fullOutput.subarray(0, Math.min(20, headerEndIndex)).toString();
          if (firstLine.startsWith("HTTP/1.1 100") || firstLine.startsWith("HTTP/2 100")) {
            const nextStart = headerEndIndex + offset;
            const secondSplit = fullOutput.indexOf("\r\n\r\n", nextStart);
            if (secondSplit !== -1) {
              headerEndIndex = secondSplit;
              offset = 4;
            }
          }
        }
        if (headerEndIndex === -1) {
          const nativeResponse2 = new Response(fullOutput, { status: 200, statusText: "OK" });
          resolve(new HttpResponse4(nativeResponse2, { connection: { protocol: "curl" } }));
          return;
        }
        const headerBlock = fullOutput.subarray(0, headerEndIndex).toString();
        const bodyBlock = fullOutput.subarray(headerEndIndex + offset);
        const headerLines = headerBlock.split(/\r?\n/);
        const statusLine = headerLines[0];
        let status = 200;
        let statusText = "OK";
        const statusMatch = statusLine.match(/HTTP\/[\d\.]+ (\d+) ?(.*)/);
        if (statusMatch) {
          status = parseInt(statusMatch[1], 10);
          statusText = statusMatch[2] || "";
        }
        const headers2 = new Headers();
        for (let i4 = 1; i4 < headerLines.length; i4++) {
          const line = headerLines[i4];
          const colon = line.indexOf(":");
          if (colon > 0) {
            const key = line.substring(0, colon).trim();
            const val = line.substring(colon + 1).trim();
            headers2.append(key, val);
          }
        }
        const nativeResponse = new Response(bodyBlock, {
          status,
          statusText,
          headers: headers2
        });
        resolve(new HttpResponse4(nativeResponse, {
          timings: {},
          connection: { protocol: "curl" }
        }));
      });
    });
  }
};
var curl = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  CurlTransport
});
async function fetchText(client2, url, options) {
  const response2 = await client2.get(url, {
    signal: options.signal,
    headers: options.headers,
    useCurl: options.useCurl
  });
  const blob = await response2.blob();
  const buffer = Buffer.from(await blob.arrayBuffer());
  if (buffer.length >= 2 && buffer[0] === 31 && buffer[1] === 139) {
    try {
      const decompressed = (0, import_node_zlib.gunzipSync)(buffer);
      return decompressed.toString("utf-8");
    } catch {
    }
  }
  return buffer.toString("utf-8");
}
function parseAttributes(line, prefix) {
  const attrs = {};
  const content = line.substring(prefix.length);
  const regex = /([A-Z0-9-]+)=(?:"([^"]*)"|([^,]*))/g;
  let match;
  while ((match = regex.exec(content)) !== null) {
    attrs[match[1]] = match[2] ?? match[3];
  }
  return attrs;
}
function resolveUrl(url, baseUrl) {
  if (url.startsWith("http://") || url.startsWith("https://")) {
    return url;
  }
  try {
    const base2 = new URL(baseUrl);
    const basePath = base2.pathname.substring(0, base2.pathname.lastIndexOf("/") + 1);
    return new URL(url, base2.origin + basePath).toString();
  } catch {
    return url;
  }
}
function parseMasterPlaylist(content, baseUrl) {
  const lines = content.split("\n");
  const variants = [];
  let pendingVariant = {};
  for (const rawLine of lines) {
    const line = rawLine.trim();
    if (!line)
      continue;
    if (line.startsWith("#EXT-X-STREAM-INF:")) {
      const attrs = parseAttributes(line, "#EXT-X-STREAM-INF:");
      pendingVariant = {
        bandwidth: attrs.BANDWIDTH ? parseInt(attrs.BANDWIDTH, 10) : void 0,
        resolution: attrs.RESOLUTION,
        codecs: attrs.CODECS,
        name: attrs.NAME
      };
    } else if (!line.startsWith("#") && pendingVariant.bandwidth !== void 0) {
      variants.push({
        ...pendingVariant,
        url: resolveUrl(line, baseUrl)
      });
      pendingVariant = {};
    }
  }
  return { variants, isMaster: true };
}
function parseByteRange(value, lastEnd = 0) {
  const parts = value.split("@");
  const length = parseInt(parts[0], 10);
  const offset = parts[1] ? parseInt(parts[1], 10) : lastEnd;
  return { length, offset };
}
function parseMediaPlaylist(content, baseUrl) {
  const lines = content.split("\n");
  const segments = [];
  let targetDuration = 5;
  let mediaSequence = 0;
  let discontinuitySequence = 0;
  let endList = false;
  let playlistType;
  let currentDuration = 0;
  let currentKey;
  let currentDiscontinuity = false;
  let currentProgramDateTime;
  let currentByteRange;
  let currentInitSegment;
  let lastByteEnd = 0;
  let segmentIndex = 0;
  for (const rawLine of lines) {
    const line = rawLine.trim();
    if (!line)
      continue;
    if (line.startsWith("#EXT-X-TARGETDURATION:")) {
      targetDuration = parseInt(line.split(":")[1], 10);
    } else if (line.startsWith("#EXT-X-MEDIA-SEQUENCE:")) {
      mediaSequence = parseInt(line.split(":")[1], 10);
    } else if (line.startsWith("#EXT-X-DISCONTINUITY-SEQUENCE:")) {
      discontinuitySequence = parseInt(line.split(":")[1], 10);
    } else if (line.startsWith("#EXT-X-PLAYLIST-TYPE:")) {
      playlistType = line.split(":")[1];
    } else if (line === "#EXT-X-ENDLIST") {
      endList = true;
    } else if (line === "#EXT-X-DISCONTINUITY") {
      currentDiscontinuity = true;
    } else if (line.startsWith("#EXT-X-PROGRAM-DATE-TIME:")) {
      currentProgramDateTime = new Date(line.split(":").slice(1).join(":"));
    } else if (line.startsWith("#EXT-X-KEY:")) {
      const attrs = parseAttributes(line, "#EXT-X-KEY:");
      if (attrs.METHOD === "NONE") {
        currentKey = void 0;
      } else {
        currentKey = {
          method: attrs.METHOD,
          uri: attrs.URI ? resolveUrl(attrs.URI, baseUrl) : void 0,
          iv: attrs.IV
        };
      }
    } else if (line.startsWith("#EXT-X-BYTERANGE:")) {
      const value = line.substring(17);
      currentByteRange = parseByteRange(value, lastByteEnd);
      lastByteEnd = currentByteRange.offset + currentByteRange.length;
    } else if (line.startsWith("#EXT-X-MAP:")) {
      const attrs = parseAttributes(line, "#EXT-X-MAP:");
      currentInitSegment = {
        url: resolveUrl(attrs.URI, baseUrl),
        byteRange: attrs.BYTERANGE ? parseByteRange(attrs.BYTERANGE) : void 0
      };
    } else if (line.startsWith("#EXTINF:")) {
      const durationStr = line.substring(8).split(",")[0];
      currentDuration = parseFloat(durationStr);
    } else if (!line.startsWith("#")) {
      segments.push({
        url: resolveUrl(line, baseUrl),
        duration: currentDuration,
        sequence: mediaSequence + segmentIndex,
        key: currentKey,
        discontinuity: currentDiscontinuity,
        programDateTime: currentProgramDateTime,
        byteRange: currentByteRange,
        initSegment: currentInitSegment
      });
      if (currentByteRange) {
        lastByteEnd = currentByteRange.offset + currentByteRange.length;
      }
      segmentIndex++;
      currentDiscontinuity = false;
      currentProgramDateTime = void 0;
      currentByteRange = void 0;
    }
  }
  return {
    segments,
    targetDuration,
    mediaSequence,
    endList,
    playlistType,
    discontinuitySequence
  };
}
function isMasterPlaylist(content) {
  return content.includes("#EXT-X-STREAM-INF");
}
function selectVariant(variants, quality) {
  if (!variants.length) {
    throw new Error("No variants found in master playlist");
  }
  const sorted = [...variants].sort((a4, b4) => (a4.bandwidth ?? 0) - (b4.bandwidth ?? 0));
  if (quality === "lowest") {
    return sorted[0];
  }
  if (quality === "highest" || quality === void 0) {
    return sorted[sorted.length - 1];
  }
  if (quality.resolution) {
    const match = variants.find((v4) => v4.resolution === quality.resolution);
    if (match)
      return match;
  }
  if (quality.bandwidth) {
    const target = quality.bandwidth;
    return sorted.reduce((prev, curr) => {
      const prevDiff = Math.abs((prev.bandwidth ?? 0) - target);
      const currDiff = Math.abs((curr.bandwidth ?? 0) - target);
      return currDiff < prevDiff ? curr : prev;
    });
  }
  return sorted[sorted.length - 1];
}
var HlsPromise = class {
  client;
  manifestUrl;
  options;
  seenSequences = /* @__PURE__ */ new Set();
  downloadedBytes = 0;
  downloadedSegments = 0;
  startTime = 0;
  aborted = false;
  abortController = new AbortController();
  keyCache = /* @__PURE__ */ new Map();
  initSegmentCache = /* @__PURE__ */ new Map();
  initSegmentPrepended = /* @__PURE__ */ new Set();
  defaultRetryStatusCodes = [403, 404, 408, 429, 500, 502, 503, 504];
  consecutiveErrors = 0;
  constructor(client2, manifestUrl, options = {}) {
    this.client = client2;
    this.manifestUrl = manifestUrl;
    this.options = {
      mode: "merge",
      format: "ts",
      concurrency: 5,
      ...options
    };
    if (this.options.format !== "ts") {
      throw new Error(`Format '${this.options.format}' requires ffmpeg. Use format: 'ts' or install ffmpeg.`);
    }
  }
  get [Symbol.toStringTag]() {
    return "HlsPromise";
  }
  then(onfulfilled, onrejected) {
    return Promise.reject(new Error("HlsPromise requires .download(), .stream(), or .pipe() to execute")).then(onfulfilled, onrejected);
  }
  catch(onrejected) {
    return this.then(null, onrejected);
  }
  finally(onfinally) {
    return this.then(() => {
      onfinally?.();
    }, () => {
      onfinally?.();
    });
  }
  cancel() {
    this.aborted = true;
    this.abortController.abort();
  }
  async download(dest) {
    this.startTime = Date.now();
    const mediaPlaylistUrl = await this.resolveMediaPlaylist();
    if (this.options.mode === "chunks") {
      await this.downloadChunks(mediaPlaylistUrl, dest);
    } else {
      if (typeof dest !== "string") {
        throw new Error("Merge mode requires a string path, not a function");
      }
      await this.downloadMerged(mediaPlaylistUrl, dest);
    }
  }
  async *stream() {
    this.startTime = Date.now();
    const mediaPlaylistUrl = await this.resolveMediaPlaylist();
    const isLive = this.isLiveMode();
    const maxDuration = this.getMaxDuration();
    const concurrency = this.options.concurrency ?? 5;
    let pollInterval = 2e3;
    while (!this.aborted) {
      if (this.consecutiveErrors >= this.getMaxConsecutiveErrors()) {
        throw new Error(`Too many consecutive errors (${this.consecutiveErrors}). Limit: ${this.getMaxConsecutiveErrors()}. Stopping download.`);
      }
      let playlist;
      try {
        playlist = await this.fetchMediaPlaylist(mediaPlaylistUrl);
      } catch (err) {
        if (isLive && this.consecutiveErrors < this.getMaxConsecutiveErrors()) {
          if (this.options.onError) {
            this.options.onError(new Error(`Playlist fetch failed: ${err.message}. Retrying...`));
          }
          await this.sleep(pollInterval);
          continue;
        }
        throw err;
      }
      pollInterval = Math.max(1e3, playlist.targetDuration * 1e3 / 2);
      const newSegments = playlist.segments.filter((s4) => !this.seenSequences.has(s4.sequence));
      for (const segment of newSegments) {
        this.seenSequences.add(segment.sequence);
      }
      if (newSegments.length > 0) {
        yield* this.downloadSegmentsConcurrent(newSegments, concurrency, playlist, isLive, maxDuration);
      }
      if (!isLive || playlist.endList) {
        break;
      }
      if (maxDuration && Date.now() - this.startTime > maxDuration) {
        break;
      }
      await this.sleep(pollInterval);
    }
  }
  async *downloadSegmentsConcurrent(segments, concurrency, playlist, isLive, maxDuration) {
    const results = /* @__PURE__ */ new Map();
    const pending = /* @__PURE__ */ new Map();
    let nextToYield = 0;
    let nextToStart = 0;
    const startDownload = (index) => {
      const segment = segments[index];
      const promise2 = this.downloadSegment(segment).then((data2) => ({
        index,
        data: data2 ? {
          sequence: segment.sequence,
          duration: segment.duration,
          data: data2,
          url: segment.url,
          downloadedAt: /* @__PURE__ */ new Date()
        } : null
      }));
      pending.set(index, promise2);
    };
    while (nextToStart < segments.length && pending.size < concurrency) {
      startDownload(nextToStart++);
    }
    while (nextToYield < segments.length) {
      if (this.aborted)
        break;
      if (maxDuration && Date.now() - this.startTime > maxDuration) {
        break;
      }
      if (this.consecutiveErrors >= this.getMaxConsecutiveErrors()) {
        throw new Error(`Too many consecutive errors (${this.consecutiveErrors}). Limit: ${this.getMaxConsecutiveErrors()}. Stopping download.`);
      }
      if (pending.size > 0) {
        const completed = await Promise.race(pending.values());
        pending.delete(completed.index);
        results.set(completed.index, completed.data);
        if (nextToStart < segments.length && pending.size < concurrency) {
          startDownload(nextToStart++);
        }
      }
      while (results.has(nextToYield)) {
        const segmentData = results.get(nextToYield);
        results.delete(nextToYield);
        nextToYield++;
        if (!segmentData) {
          continue;
        }
        this.downloadedSegments++;
        this.downloadedBytes += segmentData.data.byteLength;
        this.emitProgress(playlist, isLive);
        if (this.options.onSegment) {
          await this.options.onSegment(segmentData);
        }
        yield segmentData;
      }
    }
  }
  async pipe(writable) {
    try {
      for await (const segment of this.stream()) {
        const canContinue = writable.write(segment.data);
        if (!canContinue) {
          await new Promise((resolve) => writable.once("drain", resolve));
        }
      }
    } finally {
      if ("end" in writable && typeof writable.end === "function") {
        writable.end();
      }
    }
  }
  async info() {
    const content = await fetchText(this.client, this.manifestUrl, {
      signal: this.abortController.signal,
      headers: this.options.headers,
      useCurl: this.options.useCurl
    });
    if (isMasterPlaylist(content)) {
      const master = parseMasterPlaylist(content, this.manifestUrl);
      const selectedVariant = selectVariant(master.variants, this.options.quality);
      const playlistContent = await fetchText(this.client, selectedVariant.url, {
        signal: this.abortController.signal,
        headers: this.options.headers,
        useCurl: this.options.useCurl
      });
      const playlist2 = parseMediaPlaylist(playlistContent, selectedVariant.url);
      const totalDuration2 = playlist2.endList ? playlist2.segments.reduce((sum, s4) => sum + s4.duration, 0) : void 0;
      return {
        master,
        playlist: playlist2,
        selectedVariant,
        isLive: !playlist2.endList,
        totalDuration: totalDuration2
      };
    }
    const playlist = parseMediaPlaylist(content, this.manifestUrl);
    const totalDuration = playlist.endList ? playlist.segments.reduce((sum, s4) => sum + s4.duration, 0) : void 0;
    return {
      playlist,
      isLive: !playlist.endList,
      totalDuration
    };
  }
  async resolveMediaPlaylist() {
    const headers2 = {
      ...this.options.headers
    };
    const content = await fetchText(this.client, this.manifestUrl, {
      signal: this.abortController.signal,
      headers: headers2,
      useCurl: this.options.useCurl
    });
    if (!isMasterPlaylist(content)) {
      return this.manifestUrl;
    }
    const master = parseMasterPlaylist(content, this.manifestUrl);
    const variant = selectVariant(master.variants, this.options.quality);
    return variant.url;
  }
  async fetchMediaPlaylist(url) {
    const content = await this.withRetry(async () => {
      return fetchText(this.client, url, {
        signal: this.abortController.signal,
        headers: this.options.headers,
        useCurl: this.options.useCurl
      });
    }, "Fetch playlist", false);
    if (!content) {
      throw new Error("Failed to fetch media playlist");
    }
    return parseMediaPlaylist(content, url);
  }
  async getKey(uri) {
    if (this.keyCache.has(uri)) {
      return this.keyCache.get(uri);
    }
    const response2 = await this.client.get(uri, {
      headers: this.options.headers,
      signal: this.abortController.signal,
      useCurl: this.options.useCurl
    });
    const blob = await response2.blob();
    const arrayBuffer = await blob.arrayBuffer();
    const key = Buffer.from(arrayBuffer);
    if (key.length !== 16) {
      throw new Error(`Invalid AES-128 key length: ${key.length} bytes (expected 16)`);
    }
    this.keyCache.set(uri, key);
    return key;
  }
  generateIV(mediaSequence) {
    const iv = Buffer.alloc(16);
    iv.writeBigUInt64BE(BigInt(mediaSequence), 8);
    return iv;
  }
  parseIV(ivString) {
    const hex = ivString.startsWith("0x") || ivString.startsWith("0X") ? ivString.slice(2) : ivString;
    return Buffer.from(hex.padStart(32, "0"), "hex");
  }
  decryptSegment(data2, key, iv) {
    const decipher = (0, import_node_crypto2.createDecipheriv)("aes-128-cbc", key, iv);
    decipher.setAutoPadding(true);
    return Buffer.concat([decipher.update(data2), decipher.final()]);
  }
  async getInitSegment(init) {
    const cacheKey = `${init.url}:${init.byteRange?.offset ?? 0}:${init.byteRange?.length ?? 0}`;
    if (this.initSegmentCache.has(cacheKey)) {
      return this.initSegmentCache.get(cacheKey);
    }
    const headers2 = { ...this.options.headers };
    if (init.byteRange) {
      const { offset, length } = init.byteRange;
      headers2["Range"] = `bytes=${offset}-${offset + length - 1}`;
    }
    const response2 = await this.client.get(init.url, {
      headers: headers2,
      signal: this.abortController.signal,
      useCurl: this.options.useCurl
    });
    const blob = await response2.blob();
    const arrayBuffer = await blob.arrayBuffer();
    const data2 = Buffer.from(arrayBuffer);
    this.initSegmentCache.set(cacheKey, data2);
    return data2;
  }
  async downloadSegment(segment) {
    const result = await this.withRetry(async () => {
      const headers2 = { ...this.options.headers };
      if (segment.byteRange) {
        const { offset, length } = segment.byteRange;
        headers2["Range"] = `bytes=${offset}-${offset + length - 1}`;
      }
      const response2 = await this.client.get(segment.url, {
        headers: headers2,
        signal: this.abortController.signal,
        useCurl: this.options.useCurl
      });
      const blob = await response2.blob();
      const arrayBuffer = await blob.arrayBuffer();
      let data2 = Buffer.from(arrayBuffer);
      if (segment.key && segment.key.method === "AES-128") {
        if (!segment.key.uri) {
          throw new Error("AES-128 encryption specified but no key URI provided");
        }
        const key = await this.getKey(segment.key.uri);
        const iv = segment.key.iv ? this.parseIV(segment.key.iv) : this.generateIV(segment.sequence);
        data2 = this.decryptSegment(data2, key, iv);
      } else if (segment.key && segment.key.method === "SAMPLE-AES") {
        throw new Error("SAMPLE-AES encryption is not supported. This typically requires DRM handling.");
      }
      if (segment.initSegment) {
        const initKey = `${segment.initSegment.url}:${segment.initSegment.byteRange?.offset ?? 0}`;
        if (!this.initSegmentPrepended.has(initKey)) {
          const initData = await this.getInitSegment(segment.initSegment);
          data2 = Buffer.concat([initData, data2]);
          this.initSegmentPrepended.add(initKey);
        }
      }
      return new Uint8Array(data2);
    }, `Segment ${segment.sequence}`, true);
    return result;
  }
  async downloadMerged(playlistUrl, outputPath) {
    await (0, import_promises.mkdir)((0, import_node_path.dirname)(outputPath), { recursive: true });
    const output = (0, import_node_fs.createWriteStream)(outputPath, { flags: "a" });
    try {
      await this.pipe(output);
    } catch (error2) {
      output.destroy();
      throw error2;
    }
  }
  async downloadChunks(playlistUrl, dest) {
    const getPath = typeof dest === "string" ? (seg) => (0, import_node_path.join)(dest, `segment-${seg.sequence}.ts`) : dest;
    const baseDir = typeof dest === "string" ? dest : (0, import_node_path.dirname)(getPath({ sequence: 0, duration: 0, url: "" }));
    await (0, import_promises.mkdir)(baseDir, { recursive: true });
    for await (const segment of this.stream()) {
      const filePath = getPath({
        sequence: segment.sequence,
        duration: segment.duration,
        url: segment.url
      });
      await (0, import_promises.mkdir)((0, import_node_path.dirname)(filePath), { recursive: true });
      const output = (0, import_node_fs.createWriteStream)(filePath);
      await new Promise((resolve, reject) => {
        output.write(segment.data, (err) => {
          if (err)
            reject(err);
          else {
            output.end();
            resolve();
          }
        });
      });
    }
  }
  isLiveMode() {
    return this.options.live === true || typeof this.options.live === "object";
  }
  getMaxDuration() {
    if (typeof this.options.live === "object" && this.options.live.duration) {
      return this.options.live.duration;
    }
    return void 0;
  }
  emitProgress(playlist, isLive) {
    if (!this.options.onProgress)
      return;
    this.options.onProgress({
      downloadedSegments: this.downloadedSegments,
      totalSegments: isLive ? void 0 : playlist.segments.length,
      downloadedBytes: this.downloadedBytes,
      currentSegment: Math.max(...this.seenSequences),
      isLive,
      elapsed: Date.now() - this.startTime
    });
  }
  sleep(ms) {
    return new Promise((resolve) => {
      const timeout = setTimeout(resolve, ms);
      this.abortController.signal.addEventListener("abort", () => {
        clearTimeout(timeout);
        resolve();
      }, { once: true });
    });
  }
  getRetryConfig() {
    const isLive = this.isLiveMode();
    const userConfig = this.options.retry || {};
    return {
      maxAttempts: userConfig.maxAttempts ?? (isLive ? 5 : 3),
      delay: userConfig.delay ?? 1e3,
      maxDelay: userConfig.maxDelay ?? 3e4,
      backoff: userConfig.backoff ?? 2,
      jitter: userConfig.jitter ?? true,
      statusCodes: userConfig.statusCodes ?? this.defaultRetryStatusCodes
    };
  }
  getMaxConsecutiveErrors() {
    const isLive = this.isLiveMode();
    return this.options.maxConsecutiveErrors ?? (isLive ? 10 : 3);
  }
  calculateRetryDelay(attempt, config) {
    let delay = config.delay * Math.pow(config.backoff, attempt);
    delay = Math.min(delay, config.maxDelay);
    if (config.jitter) {
      const jitterRange = delay * 0.25;
      delay = delay - jitterRange + Math.random() * jitterRange * 2;
    }
    return Math.round(delay);
  }
  isRetryableError(error2, config) {
    if (error2.code === "ECONNRESET" || error2.code === "ETIMEDOUT" || error2.code === "ENOTFOUND") {
      return true;
    }
    const status = error2.status || error2.statusCode || error2.response?.status;
    if (status && config.statusCodes.includes(status)) {
      return true;
    }
    return false;
  }
  async withRetry(fn, context, skipOnFail = false) {
    const config = this.getRetryConfig();
    const isLive = this.isLiveMode();
    let lastError = null;
    for (let attempt = 0; attempt <= config.maxAttempts; attempt++) {
      if (this.aborted) {
        throw new Error("Aborted");
      }
      try {
        const result = await fn();
        this.consecutiveErrors = 0;
        return result;
      } catch (error2) {
        lastError = error2;
        if (!this.isRetryableError(error2, config)) {
          if (this.options.onError) {
            this.options.onError(error2);
          }
          if (skipOnFail && isLive) {
            this.consecutiveErrors++;
            return null;
          }
          throw error2;
        }
        if (attempt < config.maxAttempts) {
          const delay = this.calculateRetryDelay(attempt, config);
          if (this.options.onError) {
            const retryError = new Error(`${context}: ${error2.message}. Retrying in ${delay}ms (attempt ${attempt + 1}/${config.maxAttempts})`);
            retryError.cause = error2;
            retryError.isRetry = true;
            this.options.onError(retryError);
          }
          await this.sleep(delay);
        }
      }
    }
    this.consecutiveErrors++;
    if (this.options.onError && lastError) {
      this.options.onError(lastError);
    }
    if (skipOnFail && isLive) {
      return null;
    }
    throw lastError || new Error(`${context}: All retry attempts failed`);
  }
};
var hls = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  HlsPromise
});
var Http2MetricsCollector = class {
  origins = /* @__PURE__ */ new Map();
  sessions = /* @__PURE__ */ new Map();
  streams = /* @__PURE__ */ new Map();
  startTime = Date.now();
  maxOrigins;
  constructor(options = {}) {
    this.maxOrigins = options.maxOrigins ?? 1e3;
  }
  recordSession(info2) {
    const metrics = this.getOrCreateOrigin(info2.origin);
    const sessionKey = `${info2.origin}:${Date.now()}`;
    switch (info2.event) {
      case "connect":
        metrics.sessions.total++;
        metrics.sessions.active++;
        this.sessions.set(sessionKey, {
          origin: info2.origin,
          startTime: Date.now(),
          streamCount: 0,
          activeStreams: 0,
          maxConcurrentStreams: info2.maxConcurrentStreams
        });
        if (info2.localSettings)
          metrics.settings = { ...metrics.settings, local: info2.localSettings };
        if (info2.remoteSettings)
          metrics.settings = { ...metrics.settings, remote: info2.remoteSettings };
        break;
      case "settings":
        if (info2.localSettings)
          metrics.settings = { ...metrics.settings, local: info2.localSettings };
        if (info2.remoteSettings)
          metrics.settings = { ...metrics.settings, remote: info2.remoteSettings };
        break;
      case "close":
        metrics.sessions.active = Math.max(0, metrics.sessions.active - 1);
        if (info2.duration) {
          const n4 = metrics.sessions.total;
          metrics.sessions.avgDuration = (metrics.sessions.avgDuration * (n4 - 1) + info2.duration) / n4;
        }
        break;
      case "goaway":
      case "error":
        metrics.sessions.failed++;
        metrics.sessions.active = Math.max(0, metrics.sessions.active - 1);
        break;
    }
    metrics.lastActivity = Date.now();
  }
  recordStream(info2) {
    const metrics = this.getOrCreateOrigin(info2.origin);
    const streamKey = `${info2.origin}:${info2.streamId}`;
    switch (info2.event) {
      case "open":
        metrics.streams.total++;
        metrics.streams.active++;
        this.streams.set(streamKey, {
          origin: info2.origin,
          startTime: Date.now(),
          bytesSent: 0,
          bytesReceived: 0
        });
        break;
      case "data":
        const dataState = this.streams.get(streamKey);
        if (dataState) {
          if (info2.bytesSent)
            dataState.bytesSent += info2.bytesSent;
          if (info2.bytesReceived)
            dataState.bytesReceived += info2.bytesReceived;
        }
        break;
      case "close":
        metrics.streams.active = Math.max(0, metrics.streams.active - 1);
        if (info2.duration) {
          const n4 = metrics.streams.total;
          metrics.streams.avgDuration = (metrics.streams.avgDuration * (n4 - 1) + info2.duration) / n4;
        }
        this.streams.delete(streamKey);
        break;
      case "error":
        metrics.streams.failed++;
        metrics.streams.active = Math.max(0, metrics.streams.active - 1);
        this.streams.delete(streamKey);
        break;
    }
    metrics.lastActivity = Date.now();
  }
  recordFlowControl(info2) {
    const metrics = this.getOrCreateOrigin(info2.origin);
    switch (info2.event) {
      case "window-update":
        metrics.flowControl.windowUpdates++;
        break;
      case "blocked":
        metrics.flowControl.blockedCount++;
        break;
      case "unblocked":
        if (info2.blockedDuration) {
          metrics.flowControl.totalBlockedTime += info2.blockedDuration;
        }
        break;
    }
    metrics.lastActivity = Date.now();
  }
  getOriginMetrics(origin) {
    return this.origins.get(origin);
  }
  getSummary() {
    let totalSessions = 0;
    let activeSessions = 0;
    let totalStreams = 0;
    let activeStreams = 0;
    let errors2 = 0;
    for (const metrics of this.origins.values()) {
      totalSessions += metrics.sessions.total;
      activeSessions += metrics.sessions.active;
      totalStreams += metrics.streams.total;
      activeStreams += metrics.streams.active;
      errors2 += metrics.sessions.failed + metrics.streams.failed;
    }
    return {
      origins: new Map(this.origins),
      totals: {
        sessions: totalSessions,
        activeSessions,
        streams: totalStreams,
        activeStreams,
        errors: errors2
      },
      uptime: Date.now() - this.startTime
    };
  }
  getTopOrigins(n4 = 10) {
    return Array.from(this.origins.values()).sort((a4, b4) => b4.streams.total - a4.streams.total).slice(0, n4);
  }
  reset() {
    this.origins.clear();
    this.sessions.clear();
    this.streams.clear();
    this.startTime = Date.now();
  }
  pruneStale(maxAge = 60 * 60 * 1e3) {
    const cutoff = Date.now() - maxAge;
    let pruned = 0;
    for (const [origin, metrics] of this.origins) {
      if (metrics.sessions.active === 0 && metrics.streams.active === 0 && metrics.lastActivity < cutoff) {
        this.origins.delete(origin);
        pruned++;
      }
    }
    return pruned;
  }
  getOrCreateOrigin(origin) {
    let metrics = this.origins.get(origin);
    if (!metrics) {
      if (this.origins.size >= this.maxOrigins) {
        this.pruneStale();
        if (this.origins.size >= this.maxOrigins) {
          const oldest = Array.from(this.origins.entries()).filter(([, m4]) => m4.sessions.active === 0 && m4.streams.active === 0).sort((a4, b4) => a4[1].lastActivity - b4[1].lastActivity)[0];
          if (oldest)
            this.origins.delete(oldest[0]);
        }
      }
      metrics = {
        origin,
        sessions: { total: 0, active: 0, failed: 0, avgDuration: 0 },
        streams: { total: 0, active: 0, failed: 0, avgDuration: 0 },
        flowControl: { windowUpdates: 0, blockedCount: 0, totalBlockedTime: 0 },
        lastActivity: Date.now()
      };
      this.origins.set(origin, metrics);
    }
    return metrics;
  }
};
var globalCollector = null;
function getGlobalHttp2Metrics() {
  if (!globalCollector) {
    globalCollector = new Http2MetricsCollector();
  }
  return globalCollector;
}
function createHttp2MetricsHooks(collector) {
  const c4 = getGlobalHttp2Metrics();
  return {
    onHttp2Session: [(info2) => c4.recordSession(info2)],
    onHttp2Stream: [(info2) => c4.recordStream(info2)],
    onHttp2FlowControl: [(info2) => c4.recordFlowControl(info2)]
  };
}
var CircuitBreaker = class {
  threshold;
  resetTimeout;
  circuits;
  constructor(options = {}) {
    this.threshold = options.threshold || 5;
    this.resetTimeout = options.resetTimeout || 3e4;
    this.circuits = /* @__PURE__ */ new Map();
  }
  getKey(hostname) {
    return hostname || "unknown";
  }
  getStats(key) {
    if (!this.circuits.has(key)) {
      this.circuits.set(key, {
        failures: 0,
        lastFailureTime: 0,
        state: "CLOSED"
      });
    }
    return this.circuits.get(key);
  }
  canRequest(hostname) {
    const key = this.getKey(hostname);
    const stats2 = this.getStats(key);
    if (stats2.state === "OPEN") {
      const now = Date.now();
      if (now - stats2.lastFailureTime > this.resetTimeout) {
        stats2.state = "HALF_OPEN";
        return true;
      }
      return false;
    }
    return true;
  }
  recordSuccess(hostname) {
    const key = this.getKey(hostname);
    const stats2 = this.getStats(key);
    if (stats2.state === "HALF_OPEN" || stats2.state === "CLOSED") {
      stats2.state = "CLOSED";
      stats2.failures = 0;
    }
  }
  recordFailure(hostname) {
    const key = this.getKey(hostname);
    const stats2 = this.getStats(key);
    stats2.failures++;
    stats2.lastFailureTime = Date.now();
    if (stats2.state === "HALF_OPEN") {
      stats2.state = "OPEN";
    } else if (stats2.state === "CLOSED" && stats2.failures >= this.threshold) {
      stats2.state = "OPEN";
    }
  }
  getState(hostname) {
    const key = this.getKey(hostname);
    return this.getStats(key).state;
  }
};
var RequestDeduplicator = class {
  pending;
  constructor() {
    this.pending = /* @__PURE__ */ new Map();
  }
  generateKey(method, url) {
    return `${method}:${url}`;
  }
  async dedupe(method, url, requestFn) {
    if (method !== "GET" && method !== "HEAD") {
      return requestFn();
    }
    const key = this.generateKey(method, url);
    if (this.pending.has(key)) {
      return this.pending.get(key);
    }
    const promise2 = requestFn().finally(() => {
      this.pending.delete(key);
    });
    this.pending.set(key, promise2);
    return promise2;
  }
  get size() {
    return this.pending.size;
  }
};
function calculateRetryDelay(attempt, baseDelay, maxDelay, useJitter = true) {
  let delay = Math.pow(2, attempt - 1) * baseDelay;
  delay = Math.min(delay, maxDelay);
  if (useJitter) {
    const jitterRange = delay * 0.25;
    const jitterAmount = Math.random() * jitterRange * 2 - jitterRange;
    delay += jitterAmount;
  }
  return Math.max(0, Math.floor(delay));
}
function isRetryableError(error2, statusCode) {
  if (error2) {
    const h2Error = parseHttp2Error(error2);
    if (h2Error) {
      return h2Error.retriable;
    }
    if (error2 instanceof Http2Error) {
      return error2.retriable;
    }
    const code = error2.code;
    if (code === "ECONNRESET" || code === "ETIMEDOUT" || code === "ENOTFOUND" || code === "ECONNREFUSED" || code === "EPIPE" || code === "UND_ERR_SOCKET" || code === "UND_ERR_CONNECT_TIMEOUT" || code === "UND_ERR_HEADERS_TIMEOUT" || code === "UND_ERR_BODY_TIMEOUT") {
      return true;
    }
    if (error2.name === "TimeoutError" || error2.message?.includes("timeout")) {
      return true;
    }
  }
  if (statusCode) {
    return [408, 429, 500, 502, 503, 504].includes(statusCode);
  }
  return false;
}
function getHttp2RetryDelay(error2) {
  const h2Error = parseHttp2Error(error2);
  if (h2Error && h2Error.errorCode === "ENHANCE_YOUR_CALM") {
    return 5e3 + Math.random() * 5e3;
  }
  return void 0;
}
function parseRetryAfter(headerValue) {
  if (!headerValue)
    return void 0;
  const seconds = parseInt(headerValue, 10);
  if (!isNaN(seconds) && seconds >= 0) {
    return seconds * 1e3;
  }
  const date3 = Date.parse(headerValue);
  if (!isNaN(date3)) {
    const delay = date3 - Date.now();
    return delay > 0 ? delay : void 0;
  }
  return void 0;
}
var ReckerHttpHandler = class {
  options;
  client;
  deduplicator;
  circuitBreaker;
  metrics;
  http2MetricsEnabled;
  constructor(options = {}) {
    this.options = {
      connectTimeout: 1e4,
      headersTimeout: 3e4,
      bodyTimeout: 6e4,
      keepAliveTimeout: 4e3,
      keepAliveMaxTimeout: 6e5,
      connections: 100,
      pipelining: 10,
      http2: true,
      http2MaxConcurrentStreams: 100,
      http2Preset: "performance",
      // Default to performance preset for S3 workloads
      expectContinue: 2 * 1024 * 1024,
      // 2MB threshold for Expect: 100-Continue
      enableHttp2Metrics: false,
      enableDedup: true,
      enableCircuitBreaker: true,
      circuitBreakerThreshold: 5,
      circuitBreakerResetTimeout: 3e4,
      enableRetry: true,
      maxRetries: 3,
      retryDelay: 1e3,
      maxRetryDelay: 3e4,
      retryJitter: true,
      respectRetryAfter: true,
      ...options
    };
    this.http2MetricsEnabled = this.options.enableHttp2Metrics;
    const http2Config = this.options.http2 ? this.options.http2Preset ? expandHTTP2Options(this.options.http2Preset) : { enabled: true, maxConcurrentStreams: this.options.http2MaxConcurrentStreams } : false;
    const hooks = this.http2MetricsEnabled ? createHttp2MetricsHooks() : void 0;
    this.client = createClient({
      timeout: {
        lookup: 5e3,
        connect: this.options.connectTimeout,
        secureConnect: this.options.connectTimeout,
        response: this.options.headersTimeout,
        request: this.options.bodyTimeout
      },
      http2: http2Config,
      expectContinue: this.options.expectContinue,
      concurrency: {
        max: this.options.connections * 10,
        agent: {
          connections: this.options.connections,
          pipelining: this.options.pipelining,
          keepAlive: true,
          keepAliveTimeout: this.options.keepAliveTimeout,
          keepAliveMaxTimeout: this.options.keepAliveMaxTimeout
        }
      },
      hooks,
      observability: this.http2MetricsEnabled
    });
    this.deduplicator = this.options.enableDedup ? new RequestDeduplicator() : null;
    this.circuitBreaker = this.options.enableCircuitBreaker ? new CircuitBreaker({
      threshold: this.options.circuitBreakerThreshold,
      resetTimeout: this.options.circuitBreakerResetTimeout
    }) : null;
    this.metrics = {
      requests: 0,
      retries: 0,
      deduped: 0,
      circuitBreakerTrips: 0
    };
  }
  get metadata() {
    return this.client?.metadata ?? { handlerProtocol: "http/1.1" };
  }
  async handle(request2, { abortSignal: abortSignal2, requestTimeout } = {}) {
    const hostname = request2.hostname;
    const method = request2.method;
    if (this.circuitBreaker && !this.circuitBreaker.canRequest(hostname)) {
      this.metrics.circuitBreakerTrips++;
      throw new Error(`Circuit breaker OPEN for ${hostname}`);
    }
    const doRequest = async () => {
      this.metrics.requests++;
      let lastError;
      let attempt = 0;
      const maxAttempts = this.options.enableRetry ? this.options.maxRetries + 1 : 1;
      while (attempt < maxAttempts) {
        attempt++;
        try {
          const headers2 = {};
          for (const [key, value] of Object.entries(request2.headers)) {
            if (value !== void 0) {
              headers2[key] = value;
            }
          }
          const result = await this.client.handle({
            protocol: request2.protocol,
            hostname: request2.hostname,
            port: request2.port,
            path: request2.path,
            query: request2.query,
            method: request2.method,
            headers: headers2,
            body: request2.body
          }, {
            abortSignal: abortSignal2,
            requestTimeout: requestTimeout || this.options.bodyTimeout
          });
          const statusCode = result.response.statusCode;
          if (this.options.enableRetry && attempt < maxAttempts && isRetryableError(null, statusCode)) {
            this.metrics.retries++;
            let delay;
            if (this.options.respectRetryAfter) {
              const retryAfter = parseRetryAfter(result.response.headers["retry-after"] ?? null);
              delay = retryAfter !== void 0 ? Math.min(retryAfter, this.options.maxRetryDelay) : calculateRetryDelay(attempt, this.options.retryDelay, this.options.maxRetryDelay, this.options.retryJitter);
            } else {
              delay = calculateRetryDelay(attempt, this.options.retryDelay, this.options.maxRetryDelay, this.options.retryJitter);
            }
            await new Promise((resolve) => setTimeout(resolve, delay));
            continue;
          }
          if (this.circuitBreaker) {
            this.circuitBreaker.recordSuccess(hostname);
          }
          return result;
        } catch (error2) {
          lastError = error2;
          if (this.circuitBreaker) {
            this.circuitBreaker.recordFailure(hostname);
          }
          if (this.options.enableRetry && attempt < maxAttempts && isRetryableError(error2)) {
            this.metrics.retries++;
            const h2Delay = getHttp2RetryDelay(error2);
            const delay = h2Delay !== void 0 ? Math.min(h2Delay, this.options.maxRetryDelay) : calculateRetryDelay(attempt, this.options.retryDelay, this.options.maxRetryDelay, this.options.retryJitter);
            await new Promise((resolve) => setTimeout(resolve, delay));
            continue;
          }
          throw error2;
        }
      }
      throw lastError;
    };
    if (this.deduplicator) {
      const protocol = request2.protocol || "https:";
      const url = `${protocol}//${hostname}${request2.path}`;
      const originalRequests = this.metrics.requests;
      const result = await this.deduplicator.dedupe(method, url, doRequest);
      if (this.metrics.requests === originalRequests) {
        this.metrics.deduped++;
      }
      return result;
    }
    return doRequest();
  }
  updateHttpClientConfig(key, value) {
    this.options[key] = value;
  }
  httpHandlerConfigs() {
    return { ...this.options };
  }
  getMetrics() {
    const metrics = {
      ...this.metrics,
      circuitStates: this.circuitBreaker ? Object.fromEntries(this.circuitBreaker.circuits) : {},
      pendingDeduped: this.deduplicator?.size || 0
    };
    if (this.http2MetricsEnabled) {
      const h2Summary = getGlobalHttp2Metrics().getSummary();
      metrics.http2 = {
        sessions: h2Summary.totals.sessions,
        activeSessions: h2Summary.totals.activeSessions,
        streams: h2Summary.totals.streams,
        activeStreams: h2Summary.totals.activeStreams,
        errors: h2Summary.totals.errors
      };
    }
    return metrics;
  }
  resetMetrics() {
    this.metrics = {
      requests: 0,
      retries: 0,
      deduped: 0,
      circuitBreakerTrips: 0
    };
  }
  destroy() {
    this.client = null;
    this.deduplicator = null;
    this.circuitBreaker = null;
  }
};
var BaseError = class extends Error {
  bucket;
  key;
  thrownAt;
  code;
  statusCode;
  requestId;
  awsMessage;
  original;
  commandName;
  commandInput;
  metadata;
  description;
  suggestion;
  retriable;
  docs;
  title;
  hint;
  data;
  constructor(context) {
    const { verbose, bucket, key, message = "Unknown error", code, statusCode, requestId, awsMessage, original, commandName, commandInput, metadata, description, suggestion, retriable, docs, title, hint, ...rest } = context;
    let finalMessage = message;
    if (verbose) {
      finalMessage = message + `

Verbose:

${JSON.stringify(rest, null, 2)}`;
    }
    super(finalMessage);
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error(finalMessage).stack;
    }
    this.name = this.constructor.name;
    this.bucket = bucket;
    this.key = key;
    this.thrownAt = /* @__PURE__ */ new Date();
    this.code = code;
    this.statusCode = statusCode ?? 500;
    this.requestId = requestId;
    this.awsMessage = awsMessage;
    this.original = original;
    this.commandName = commandName;
    this.commandInput = commandInput;
    this.metadata = metadata;
    this.description = description;
    this.suggestion = suggestion;
    this.retriable = retriable ?? false;
    this.docs = docs;
    this.title = title || this.constructor.name;
    this.hint = hint;
    this.data = {
      bucket,
      key,
      ...rest,
      verbose,
      message,
      suggestion: this.suggestion,
      retriable: this.retriable,
      docs: this.docs,
      title: this.title,
      hint: this.hint
    };
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      code: this.code,
      statusCode: this.statusCode,
      requestId: this.requestId,
      awsMessage: this.awsMessage,
      bucket: this.bucket,
      key: this.key,
      thrownAt: this.thrownAt,
      retriable: this.retriable,
      suggestion: this.suggestion,
      docs: this.docs,
      title: this.title,
      hint: this.hint,
      commandName: this.commandName,
      commandInput: this.commandInput,
      metadata: this.metadata,
      description: this.description,
      data: this.data,
      original: this.original,
      stack: this.stack
    };
  }
  toString() {
    return `${this.name} | ${this.message}`;
  }
};
var S3dbError = class extends BaseError {
  constructor(message, details = {}) {
    let code;
    let statusCode;
    let requestId;
    let awsMessage;
    let original = details.original;
    let metadata;
    if (details.original && typeof details.original === "object") {
      const awsError = details.original;
      original = details.original;
      code = awsError.code || awsError.Code || awsError.name;
      statusCode = awsError.statusCode || awsError.$metadata?.httpStatusCode;
      requestId = awsError.requestId || awsError.$metadata?.requestId;
      awsMessage = awsError.message;
      metadata = awsError.$metadata ? { ...awsError.$metadata } : void 0;
    }
    super({
      message,
      ...details,
      code,
      statusCode,
      requestId,
      awsMessage,
      original,
      metadata
    });
  }
};
var DatabaseError = class extends S3dbError {
  constructor(message, details = {}) {
    const merged = {
      statusCode: details.statusCode ?? 500,
      retriable: details.retriable ?? false,
      suggestion: details.suggestion ?? "Check database configuration and ensure the operation parameters are valid.",
      ...details
    };
    super(message, merged);
    Object.assign(this, merged);
  }
};
var ValidationError2 = class extends S3dbError {
  field;
  value;
  constraint;
  constructor(message, details = {}) {
    const merged = {
      statusCode: details.statusCode ?? 422,
      retriable: details.retriable ?? false,
      suggestion: details.suggestion ?? "Review validation errors and adjust the request payload before retrying.",
      ...details
    };
    super(message, merged);
    this.field = details.field;
    this.value = details.value;
    this.constraint = details.constraint;
    Object.assign(this, merged);
  }
};
var PermissionError = class extends S3dbError {
  constructor(message, details = {}) {
    const merged = {
      statusCode: details.statusCode ?? 403,
      retriable: details.retriable ?? false,
      suggestion: details.suggestion ?? "Verify IAM permissions, bucket policies, and credentials before retrying.",
      ...details
    };
    super(message, merged);
    Object.assign(this, merged);
  }
};
var ResourceNotFound = class extends S3dbError {
  resourceName;
  id;
  constructor(details) {
    const { bucket, resourceName, id: id2, original, ...rest } = details;
    if (typeof id2 !== "string") {
      throw new ValidationError2("ResourceNotFound requires id to be a string", {
        field: "id",
        value: id2,
        retriable: false,
        suggestion: "Provide the resource id as a string when constructing ResourceNotFound."
      });
    }
    if (typeof bucket !== "string") {
      throw new ValidationError2("ResourceNotFound requires bucket to be a string", {
        field: "bucket",
        value: bucket,
        retriable: false,
        suggestion: "Provide the bucket name as a string when constructing ResourceNotFound."
      });
    }
    if (typeof resourceName !== "string") {
      throw new ValidationError2("ResourceNotFound requires resourceName to be a string", {
        field: "resourceName",
        value: resourceName,
        retriable: false,
        suggestion: "Provide the resource name as a string when constructing ResourceNotFound."
      });
    }
    super(`Resource not found: ${resourceName}/${id2} [bucket:${bucket}]`, {
      bucket,
      resourceName,
      id: id2,
      original,
      statusCode: rest.statusCode ?? 404,
      retriable: rest.retriable ?? false,
      suggestion: rest.suggestion ?? "Confirm the resource ID and ensure it exists before retrying.",
      ...rest
    });
    this.resourceName = resourceName;
    this.id = id2;
  }
};
var NoSuchBucket = class extends S3dbError {
  constructor(details) {
    const { bucket, original, ...rest } = details;
    if (typeof bucket !== "string") {
      throw new ValidationError2("NoSuchBucket requires bucket to be a string", {
        field: "bucket",
        value: bucket,
        retriable: false,
        suggestion: "Provide the bucket name as a string when constructing NoSuchBucket."
      });
    }
    super(`Bucket does not exists [bucket:${bucket}]`, {
      bucket,
      original,
      statusCode: rest.statusCode ?? 404,
      retriable: rest.retriable ?? false,
      suggestion: rest.suggestion ?? "Verify the bucket name and AWS region. Create the bucket if it is missing.",
      ...rest
    });
  }
};
var NoSuchKey = class extends S3dbError {
  resourceName;
  id;
  constructor(details) {
    const { bucket, key, resourceName, id: id2, original, ...rest } = details;
    if (typeof key !== "string") {
      throw new ValidationError2("NoSuchKey requires key to be a string", {
        field: "key",
        value: key,
        retriable: false,
        suggestion: "Provide the object key as a string when constructing NoSuchKey."
      });
    }
    if (typeof bucket !== "string") {
      throw new ValidationError2("NoSuchKey requires bucket to be a string", {
        field: "bucket",
        value: bucket,
        retriable: false,
        suggestion: "Provide the bucket name as a string when constructing NoSuchKey."
      });
    }
    if (id2 !== void 0 && typeof id2 !== "string") {
      throw new ValidationError2("NoSuchKey requires id to be a string when provided", {
        field: "id",
        value: id2,
        retriable: false,
        suggestion: "Provide the resource id as a string when including it in NoSuchKey."
      });
    }
    super(`No such key: ${key} [bucket:${bucket}]`, {
      bucket,
      key,
      resourceName,
      id: id2,
      original,
      statusCode: rest.statusCode ?? 404,
      retriable: rest.retriable ?? false,
      suggestion: rest.suggestion ?? "Check if the object key is correct and that the object was uploaded.",
      ...rest
    });
    this.resourceName = resourceName;
    this.id = id2;
  }
};
var MissingMetadata = class extends S3dbError {
  constructor(details) {
    const { bucket, original, ...rest } = details;
    if (typeof bucket !== "string") {
      throw new ValidationError2("MissingMetadata requires bucket to be a string", {
        field: "bucket",
        value: bucket,
        retriable: false,
        suggestion: "Provide the bucket name as a string when constructing MissingMetadata."
      });
    }
    super(`Missing metadata for bucket [bucket:${bucket}]`, {
      bucket,
      original,
      statusCode: rest.statusCode ?? 500,
      retriable: rest.retriable ?? false,
      suggestion: rest.suggestion ?? "Re-upload metadata or run db.uploadMetadataFile() to regenerate it.",
      ...rest
    });
  }
};
var InvalidResourceItem = class extends S3dbError {
  constructor(details) {
    const { bucket, resourceName, attributes, validation, message, original, ...rest } = details;
    if (typeof bucket !== "string") {
      throw new ValidationError2("InvalidResourceItem requires bucket to be a string", {
        field: "bucket",
        value: bucket,
        retriable: false,
        suggestion: "Provide the bucket name as a string when constructing InvalidResourceItem."
      });
    }
    if (typeof resourceName !== "string") {
      throw new ValidationError2("InvalidResourceItem requires resourceName to be a string", {
        field: "resourceName",
        value: resourceName,
        retriable: false,
        suggestion: "Provide the resource name as a string when constructing InvalidResourceItem."
      });
    }
    super(message || `Validation error: This item is not valid. Resource=${resourceName} [bucket:${bucket}].
${JSON.stringify(validation, null, 2)}`, {
      bucket,
      resourceName,
      attributes,
      validation,
      original,
      statusCode: rest.statusCode ?? 422,
      retriable: rest.retriable ?? false,
      suggestion: rest.suggestion ?? "Fix validation errors on the provided attributes before retrying the request.",
      ...rest
    });
  }
};
var UnknownError = class extends S3dbError {
};
function mapAwsError(err, context = {}) {
  const awsErr = err;
  const code = awsErr.code || awsErr.Code || awsErr.name;
  const metadata = awsErr.$metadata ? { ...awsErr.$metadata } : void 0;
  const { commandName, commandInput } = context;
  let description;
  if (code === "NoSuchKey" || code === "NotFound") {
    description = "The specified key does not exist in the bucket. Check if the key exists and if your credentials have permission to access it.";
    return new NoSuchKey({
      bucket: context.bucket ?? "",
      key: context.key ?? "",
      resourceName: context.resourceName,
      id: context.id,
      original: err,
      metadata,
      commandName,
      commandInput,
      description,
      retriable: false
    });
  }
  if (code === "NoSuchBucket") {
    description = "The specified bucket does not exist. Check if the bucket name is correct and if your credentials have permission to access it.";
    return new NoSuchBucket({
      bucket: context.bucket ?? "",
      original: err,
      metadata,
      commandName,
      commandInput,
      description,
      retriable: false
    });
  }
  if (code === "AccessDenied" || awsErr.statusCode === 403 || code === "Forbidden") {
    description = "Access denied. Check your AWS credentials, IAM permissions, and bucket policy.";
    return new PermissionError("Access denied", {
      ...context,
      original: err,
      metadata,
      commandName,
      commandInput,
      description,
      retriable: false
    });
  }
  if (code === "ValidationError" || awsErr.statusCode === 400) {
    description = "Validation error. Check the request parameters and payload format.";
    return new ValidationError2("Validation error", {
      ...context,
      original: err,
      metadata,
      commandName,
      commandInput,
      description,
      retriable: false
    });
  }
  if (code === "MissingMetadata") {
    description = "Object metadata is missing or invalid. Check if the object was uploaded correctly.";
    return new MissingMetadata({
      bucket: context.bucket ?? "",
      original: err,
      metadata,
      commandName,
      commandInput,
      description,
      retriable: false
    });
  }
  const errorDetails = [
    `Unknown error: ${err.message || err.toString()}`,
    awsErr.code && `Code: ${awsErr.code}`,
    awsErr.statusCode && `Status: ${awsErr.statusCode}`,
    err.stack && `Stack: ${err.stack.split("\n")[0]}`
  ].filter(Boolean).join(" | ");
  description = `Check the error details and AWS documentation. Original error: ${err.message || err.toString()}`;
  return new UnknownError(errorDetails, {
    ...context,
    original: err,
    metadata,
    commandName,
    commandInput,
    description,
    retriable: context.retriable ?? false
  });
}
var ConnectionStringError = class extends S3dbError {
  constructor(message, details = {}) {
    const description = details.description || "Invalid connection string format. Check the connection string syntax and credentials.";
    const merged = {
      statusCode: details.statusCode ?? 400,
      retriable: details.retriable ?? false,
      suggestion: details.suggestion ?? "Fix the connection string and retry the operation.",
      description,
      ...details
    };
    super(message, merged);
  }
};
var CryptoError = class extends S3dbError {
  constructor(message, details = {}) {
    const description = details.description || "Cryptography operation failed. Check if the crypto library is available and input is valid.";
    const merged = {
      statusCode: details.statusCode ?? 500,
      retriable: details.retriable ?? false,
      suggestion: details.suggestion ?? "Validate crypto inputs and environment setup before retrying.",
      description,
      ...details
    };
    super(message, merged);
  }
};
var SchemaError = class extends S3dbError {
  constructor(message, details = {}) {
    const description = details.description || "Schema validation failed. Check schema definition and input data format.";
    const merged = {
      statusCode: details.statusCode ?? 400,
      retriable: details.retriable ?? false,
      suggestion: details.suggestion ?? "Update the schema or adjust the data to match the schema definition.",
      description,
      ...details
    };
    super(message, merged);
  }
};
var ResourceError = class extends S3dbError {
  constructor(message, details = {}) {
    const description = details.description || "Resource operation failed. Check resource configuration, attributes, and operation context.";
    const merged = {
      statusCode: details.statusCode ?? 400,
      retriable: details.retriable ?? false,
      suggestion: details.suggestion ?? "Review the resource configuration and request payload before retrying.",
      description,
      ...details
    };
    super(message, merged);
    Object.assign(this, merged);
  }
};
var PartitionError = class extends S3dbError {
  constructor(message, details = {}) {
    let description = details.description;
    if (!description && details.resourceName && details.partitionName && details.fieldName) {
      const { resourceName, partitionName, fieldName, availableFields = [] } = details;
      description = `
Partition Field Validation Error

Resource: ${resourceName}
Partition: ${partitionName}
Missing Field: ${fieldName}

Available fields in schema:
${availableFields.map((f4) => `  \u2022 ${f4}`).join("\n") || "  (no fields defined)"}

Possible causes:
1. Field was removed from schema but partition still references it
2. Typo in partition field name
3. Nested field path is incorrect (use dot notation like 'utm.source')

Solution:
${details.strictValidation === false ? "  \u2022 Update partition definition to use existing fields" : `  \u2022 Add missing field to schema, OR
  \u2022 Update partition definition to use existing fields, OR
  \u2022 Use strictValidation: false to skip this check during testing`}

Docs: https://github.com/forattini-dev/s3db.js/blob/main/docs/README.md#partitions
`.trim();
    }
    super(message, {
      ...details,
      statusCode: details.statusCode ?? 400,
      retriable: details.retriable ?? false,
      description
    });
  }
};
var PluginStorageError = class extends S3dbError {
  constructor(message, details = {}) {
    const { pluginSlug = "unknown", key = "", operation: operation2 = "unknown", ...rest } = details;
    let description = details.description;
    if (!description) {
      description = `
Plugin Storage Error

Plugin: ${pluginSlug}
Key: ${key}
Operation: ${operation2}

Possible causes:
1. Storage not initialized (plugin not installed)
2. Invalid key format
3. S3 operation failed
4. Permissions issue

Solution:
Ensure plugin has access to storage and key is valid.

Docs: https://github.com/forattini-dev/s3db.js/blob/main/docs/plugins/README.md#plugin-storage
`.trim();
    }
    super(message, {
      ...rest,
      pluginSlug,
      key,
      operation: operation2,
      statusCode: rest.statusCode ?? 500,
      retriable: rest.retriable ?? false,
      description
    });
  }
};
var BehaviorError = class extends S3dbError {
  constructor(message, details = {}) {
    const { behavior = "unknown", availableBehaviors = [], ...rest } = details;
    let description = details.description;
    if (!description) {
      description = `
Behavior Error

Requested: ${behavior}
Available: ${availableBehaviors.join(", ") || "body-overflow, body-only, truncate-data, enforce-limits, user-managed"}

Possible causes:
1. Behavior name misspelled
2. Custom behavior not registered

Solution:
Use one of the available behaviors or register custom behavior.

Docs: https://github.com/forattini-dev/s3db.js/blob/main/docs/README.md#behaviors
`.trim();
    }
    super(message, {
      ...rest,
      behavior,
      availableBehaviors,
      statusCode: rest.statusCode ?? 400,
      retriable: rest.retriable ?? false,
      description
    });
  }
};
var StreamError2 = class extends S3dbError {
  constructor(message, details = {}) {
    const { operation: operation2 = "unknown", resource, ...rest } = details;
    let description = details.description;
    if (!description) {
      description = `
Stream Error

Operation: ${operation2}
${resource ? `Resource: ${resource}` : ""}

Possible causes:
1. Stream not properly initialized
2. Resource not available
3. Network error during streaming

Solution:
Check stream configuration and resource availability.

Docs: https://github.com/forattini-dev/s3db.js/blob/main/docs/README.md#streaming
`.trim();
    }
    super(message, {
      ...rest,
      operation: operation2,
      resource,
      statusCode: rest.statusCode ?? 500,
      retriable: rest.retriable ?? false,
      description
    });
  }
};
var MetadataLimitError = class extends S3dbError {
  constructor(message, details = {}) {
    const { totalSize, effectiveLimit, absoluteLimit = 2047, excess, resourceName, operation: operation2, ...rest } = details;
    let description = details.description;
    if (!description && totalSize && effectiveLimit) {
      description = `
S3 Metadata Size Limit Exceeded

Current Size: ${totalSize} bytes
Effective Limit: ${effectiveLimit} bytes
Absolute Limit: ${absoluteLimit} bytes
${excess ? `Excess: ${excess} bytes` : ""}
${resourceName ? `Resource: ${resourceName}` : ""}
${operation2 ? `Operation: ${operation2}` : ""}

S3 has a hard limit of 2KB (2047 bytes) for object metadata.

Solutions:
1. Use 'body-overflow' behavior to store excess in body
2. Use 'body-only' behavior to store everything in body
3. Reduce number of fields
4. Use shorter field values
5. Enable advanced metadata encoding

Example:
  await db.createResource({
    name: '${resourceName || "myResource"}',
    behavior: 'body-overflow',  // Automatically handles overflow
    attributes: { ... }
  });

Docs: https://github.com/forattini-dev/s3db.js/blob/main/docs/README.md#metadata-size-limits
`.trim();
    }
    super(message, {
      ...rest,
      totalSize,
      effectiveLimit,
      absoluteLimit,
      excess,
      resourceName,
      operation: operation2,
      statusCode: rest.statusCode ?? 413,
      retriable: rest.retriable ?? false,
      description
    });
  }
};
async function dynamicCrypto() {
  let lib;
  if (typeof process !== "undefined") {
    lib = import_crypto.default.webcrypto;
  } else if (typeof window !== "undefined") {
    lib = window.crypto;
  }
  if (!lib)
    throw new CryptoError("Could not load any crypto library", { context: "dynamicCrypto" });
  return lib;
}
async function encrypt(content, passphrase) {
  const [okCrypto, errCrypto, cryptoLib] = await tryFn$1(dynamicCrypto);
  if (!okCrypto)
    throw new CryptoError("Crypto API not available", { original: errCrypto });
  const salt = cryptoLib.getRandomValues(new Uint8Array(16));
  const [okKey, errKey, key] = await tryFn$1(() => getKeyMaterial(passphrase, salt));
  const iv = cryptoLib.getRandomValues(new Uint8Array(12));
  const encoder = new TextEncoder();
  const encodedContent = encoder.encode(content);
  const [okEnc, errEnc, encryptedContent] = await tryFn$1(() => cryptoLib.subtle.encrypt({ name: "AES-GCM", iv }, key, encodedContent));
  if (!okEnc)
    throw new CryptoError("Encryption failed", { original: errEnc, content });
  const encryptedData = new Uint8Array(salt.length + iv.length + encryptedContent.byteLength);
  encryptedData.set(salt);
  encryptedData.set(iv, salt.length);
  encryptedData.set(new Uint8Array(encryptedContent), salt.length + iv.length);
  return arrayBufferToBase64(encryptedData);
}
async function decrypt(encryptedBase64, passphrase) {
  const [okCrypto, errCrypto, cryptoLib] = await tryFn$1(dynamicCrypto);
  if (!okCrypto)
    throw new CryptoError("Crypto API not available", { original: errCrypto });
  const encryptedData = base64ToArrayBuffer(encryptedBase64);
  const salt = encryptedData.slice(0, 16);
  const iv = encryptedData.slice(16, 28);
  const encryptedContent = encryptedData.slice(28);
  const [okKey, errKey, key] = await tryFn$1(() => getKeyMaterial(passphrase, salt));
  if (!okKey)
    throw new CryptoError("Key derivation failed (decrypt)", { original: errKey, passphrase, salt });
  const [okDec, errDec, decryptedContent] = await tryFn$1(() => cryptoLib.subtle.decrypt({ name: "AES-GCM", iv }, key, encryptedContent));
  if (!okDec)
    throw new CryptoError("Decryption failed", { original: errDec, encryptedBase64 });
  const decoder = new TextDecoder();
  return decoder.decode(decryptedContent);
}
async function md5(data2) {
  if (typeof process === "undefined") {
    throw new CryptoError("MD5 hashing is only available in Node.js environment", { context: "md5" });
  }
  const [ok, err, result] = await tryFn$1(async () => {
    return import_crypto.default.createHash("md5").update(data2).digest("base64");
  });
  if (!ok) {
    throw new CryptoError("MD5 hashing failed", { original: err, data: data2 });
  }
  return result;
}
async function getKeyMaterial(passphrase, salt) {
  const [okCrypto, errCrypto, cryptoLib] = await tryFn$1(dynamicCrypto);
  if (!okCrypto)
    throw new CryptoError("Crypto API not available", { original: errCrypto });
  const encoder = new TextEncoder();
  const keyMaterial = encoder.encode(passphrase);
  const [okImport, errImport, baseKey] = await tryFn$1(() => cryptoLib.subtle.importKey("raw", keyMaterial, { name: "PBKDF2" }, false, ["deriveKey"]));
  if (!okImport)
    throw new CryptoError("importKey failed", { original: errImport, passphrase });
  const [okDerive, errDerive, derivedKey] = await tryFn$1(() => cryptoLib.subtle.deriveKey({
    name: "PBKDF2",
    salt,
    iterations: 1e5,
    hash: "SHA-256"
  }, baseKey, { name: "AES-GCM", length: 256 }, true, ["encrypt", "decrypt"]));
  if (!okDerive)
    throw new CryptoError("deriveKey failed", { original: errDerive, passphrase, salt });
  return derivedKey;
}
function arrayBufferToBase64(buffer) {
  if (typeof process !== "undefined") {
    return Buffer.from(buffer).toString("base64");
  } else {
    const [ok, err, binary] = tryFnSync(() => String.fromCharCode.apply(null, Array.from(new Uint8Array(buffer))));
    if (!ok)
      throw new CryptoError("Failed to convert ArrayBuffer to base64 (browser)", { original: err });
    return window.btoa(binary);
  }
}
function base64ToArrayBuffer(base64) {
  if (typeof process !== "undefined") {
    return new Uint8Array(Buffer.from(base64, "base64"));
  } else {
    const [ok, err, binaryString] = tryFnSync(() => window.atob(base64));
    if (!ok)
      throw new CryptoError("Failed to decode base64 (browser)", { original: err });
    const len = binaryString.length;
    const bytes = new Uint8Array(len);
    for (let i4 = 0; i4 < len; i4++) {
      bytes[i4] = binaryString.charCodeAt(i4);
    }
    return bytes;
  }
}
var BUILT_IN_SENSITIVE_FIELDS = [
  "password",
  "passwd",
  "pwd",
  "passphrase",
  "secret",
  "token",
  "auth",
  "authorization",
  "apikey",
  "api_key",
  "api-key",
  "apitoken",
  "api_token",
  "api-token",
  "apisecret",
  "api_secret",
  "api-secret",
  "authtoken",
  "auth_token",
  "auth-token",
  "bearertoken",
  "bearer_token",
  "bearer-token",
  "accesskey",
  "access_key",
  "access-key",
  "accesskeyid",
  "access_key_id",
  "access-key-id",
  "secretkey",
  "secret_key",
  "secret-key",
  "secretaccesskey",
  "secret_access_key",
  "secret-access-key",
  "awsaccesskey",
  "aws_access_key",
  "aws-access-key",
  "awsaccesskeyid",
  "aws_access_key_id",
  "aws-access-key-id",
  "awssecretkey",
  "aws_secret_key",
  "aws-secret-key",
  "awssecretaccesskey",
  "aws_secret_access_key",
  "aws-secret-access-key",
  "awstoken",
  "aws_token",
  "aws-token",
  "sessiontoken",
  "session_token",
  "session-token",
  "gcpaccesskey",
  "gcp_access_key",
  "gcp-access-key",
  "gcpsecretkey",
  "gcp_secret_key",
  "gcp-secret-key",
  "gcpapikey",
  "gcp_api_key",
  "gcp-api-key",
  "azurekey",
  "azure_key",
  "azure-key",
  "azurekeysecret",
  "azure_key_secret",
  "azure-key-secret",
  "azuretoken",
  "azure_token",
  "azure-token",
  "azuresecretkey",
  "azure_secret_key",
  "azure-secret-key",
  "connectionstring",
  "connection_string",
  "connection-string",
  "dbpassword",
  "db_password",
  "db-password",
  "dbtoken",
  "db_token",
  "db-token",
  "dbsecret",
  "db_secret",
  "db-secret",
  "mongodburi",
  "mongodb_uri",
  "mongodb-uri",
  "postgresqlpassword",
  "postgresql_password",
  "postgresql-password",
  "clientsecret",
  "client_secret",
  "client-secret",
  "clientid",
  "client_id",
  "client-id",
  "oauth2secret",
  "oauth2_secret",
  "oauth2-secret",
  "oidcsecret",
  "oidc_secret",
  "oidc-secret",
  "encryptionkey",
  "encryption_key",
  "encryption-key",
  "cryptokey",
  "crypto_key",
  "crypto-key",
  "hmackey",
  "hmac_key",
  "hmac-key",
  "rsaprivatekey",
  "rsa_private_key",
  "rsa-private-key",
  "privatekeyid",
  "private_key_id",
  "private-key-id",
  "privatekey",
  "private_key",
  "private-key",
  "certificate",
  "cert",
  "certificatekey",
  "certificate_key",
  "certificate-key",
  "credential",
  "credentials",
  "hash",
  "nonce",
  "jti",
  "fingerprint",
  "sessionid",
  "session_id",
  "session-id",
  "refreshtoken",
  "refresh_token",
  "refresh-token"
];
function createRedactRules(customPatterns = []) {
  const redactPaths = [];
  for (const field of BUILT_IN_SENSITIVE_FIELDS) {
    redactPaths.push(field);
    redactPaths.push(`*.${field}`);
    redactPaths.push(`**.${field}`);
  }
  if (customPatterns.length > 0) ;
  return redactPaths;
}
var sharedPrettyTransport = null;
var sharedDestination = null;
function serializeError(err) {
  if (!err || typeof err !== "object") {
    return err;
  }
  const error2 = err;
  if (typeof error2.toJSON === "function") {
    return error2.toJSON();
  }
  return {
    ...error2,
    message: error2.message,
    stack: error2.stack
  };
}
function createPrettyTransport() {
  return {
    target: "pino-pretty",
    options: {
      colorize: true,
      translateTime: "HH:MM:ss.l",
      ignore: "pid,hostname",
      singleLine: false
    }
  };
}
function getSharedPrettyTransport() {
  if (!sharedPrettyTransport) {
    sharedPrettyTransport = import_pino.default.transport(createPrettyTransport());
  }
  return sharedPrettyTransport;
}
function getSharedDestination(format2) {
  const envFormat = process.env.S3DB_LOG_FORMAT?.toLowerCase();
  const effectiveFormat = format2 ?? (envFormat === "json" ? "json" : "pretty");
  if (effectiveFormat === "json") {
    return void 0;
  }
  if (!sharedDestination) {
    sharedDestination = getSharedPrettyTransport();
  }
  return sharedDestination;
}
function createDefaultTransport() {
  const envFormat = process.env.S3DB_LOG_FORMAT?.toLowerCase();
  if (envFormat === "json") {
    return void 0;
  }
  return createPrettyTransport();
}
function createLogger(options = {}) {
  const { level = "info", name, format: format2, transport, bindings = {}, redactPatterns = [] } = options;
  const redactRules = createRedactRules(redactPatterns);
  const normalizedBindings = bindings && typeof bindings === "object" ? bindings : {};
  const useSharedDestination = !transport && format2 !== "json";
  const destination = useSharedDestination ? getSharedDestination(format2) : void 0;
  const config = {
    level,
    redact: redactRules,
    serializers: {
      err: serializeError,
      error: serializeError
    }
  };
  if (transport) {
    config.transport = transport;
  } else if (format2 === "json") ;
  else if (!destination) {
    config.transport = createDefaultTransport();
  }
  let logger3;
  if (destination) {
    logger3 = (0, import_pino.default)({ ...config, name }, destination);
  } else {
    logger3 = (0, import_pino.default)({ ...config, name });
  }
  const baseBindings = name ? { ...normalizedBindings, name } : normalizedBindings;
  if (baseBindings && Object.keys(baseBindings).length > 0) {
    logger3 = logger3.child(baseBindings);
  }
  return logger3;
}
function getLoggerOptionsFromEnv(configOptions = {}) {
  const options = { ...configOptions };
  if (process.env.S3DB_LOG_LEVEL) {
    options.level = process.env.S3DB_LOG_LEVEL;
  }
  if (process.env.S3DB_LOG_FORMAT) {
    const format2 = process.env.S3DB_LOG_FORMAT.toLowerCase();
    if (format2 === "json" || format2 === "pretty") {
      options.format = format2;
    }
  } else if (process.env.S3DB_LOG_PRETTY === "false") {
    options.format = "json";
  } else if (process.env.S3DB_LOG_PRETTY === "true") {
    options.format = "pretty";
  }
  return options;
}
var logger2 = createLogger({ name: "IdGenerator", level: "info" });
var FALLBACK_URL_ALPHABET = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
var PASSWORD_ALPHABET = "ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz23456789";
var POOL_SIZE_MULTIPLIER2 = 128;
var pool2;
var poolOffset2 = 0;
function fillPool2(bytes) {
  if (!pool2 || pool2.length < bytes) {
    pool2 = Buffer.allocUnsafe(bytes * POOL_SIZE_MULTIPLIER2);
    (0, import_node_crypto2.randomFillSync)(pool2);
    poolOffset2 = 0;
  } else if (poolOffset2 + bytes > pool2.length) {
    (0, import_node_crypto2.randomFillSync)(pool2);
    poolOffset2 = 0;
  }
  poolOffset2 += bytes;
}
function randomFromPool(bytes) {
  bytes |= 0;
  fillPool2(bytes);
  return pool2.subarray(poolOffset2 - bytes, poolOffset2);
}
function customRandomFallback(alphabet2, defaultSize, getRandom) {
  const mask = (2 << 31 - Math.clz32(alphabet2.length - 1 | 1)) - 1;
  const step = Math.ceil(1.6 * mask * defaultSize / alphabet2.length);
  return (size = defaultSize) => {
    if (!size)
      return "";
    let id2 = "";
    while (true) {
      const bytes = getRandom(step);
      let i4 = step;
      while (i4--) {
        id2 += alphabet2[bytes[i4] & mask] || "";
        if (id2.length >= size)
          return id2;
      }
    }
  };
}
function customAlphabetFallback(alphabet2, size = 21) {
  return customRandomFallback(alphabet2, size, randomFromPool);
}
var activeCustomAlphabet = customAlphabetFallback;
var activeUrlAlphabet = FALLBACK_URL_ALPHABET;
var idGeneratorImpl = activeCustomAlphabet(activeUrlAlphabet, 22);
var passwordGeneratorImpl = activeCustomAlphabet(PASSWORD_ALPHABET, 16);
var nanoidReadyPromise = Promise.resolve().then(() => (init_nanoid(), nanoid_exports)).then((mod) => {
  const resolvedCustomAlphabet = mod?.customAlphabet ?? activeCustomAlphabet;
  const resolvedUrlAlphabet = mod?.urlAlphabet ?? activeUrlAlphabet;
  activeCustomAlphabet = resolvedCustomAlphabet;
  activeUrlAlphabet = resolvedUrlAlphabet;
  idGeneratorImpl = activeCustomAlphabet(activeUrlAlphabet, 22);
  passwordGeneratorImpl = activeCustomAlphabet(PASSWORD_ALPHABET, 16);
}).catch((error2) => {
  if (typeof process !== "undefined" && process?.env?.S3DB_DEBUG) {
    logger2.warn({ error: error2.message }, 'Failed to dynamically import "nanoid". Using fallback implementation.');
  }
});
function initializeNanoid() {
  return nanoidReadyPromise;
}
var idGenerator = (size) => idGeneratorImpl(size);
var passwordGenerator = (size) => passwordGeneratorImpl(size);
var getUrlAlphabet = () => activeUrlAlphabet;
var createCustomGenerator = (alphabet2, size) => activeCustomAlphabet(alphabet2, size);
var id = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  createCustomGenerator,
  getUrlAlphabet,
  idGenerator,
  initializeNanoid,
  passwordGenerator
});
var CONTENT_TYPE_DICT = {
  "application/json": "j",
  "application/xml": "X",
  "application/ld+json": "J",
  "text/html": "H",
  "text/plain": "T",
  "text/css": "C",
  "text/javascript": "V",
  "text/csv": "v",
  "image/png": "P",
  "image/jpeg": "I",
  "image/gif": "G",
  "image/svg+xml": "S",
  "image/webp": "W",
  "application/pdf": "Q",
  "application/zip": "z",
  "application/octet-stream": "o",
  "application/x-www-form-urlencoded": "u",
  "multipart/form-data": "F",
  "font/woff": "w",
  "font/woff2": "f"
};
var URL_PREFIX_DICT = {
  "/api/v1/": "@1",
  "/api/v2/": "@2",
  "/api/v3/": "@3",
  "/api/": "@a",
  "https://api.example.com/": "@A",
  "https://api.": "@H",
  "https://www.": "@W",
  "https://": "@h",
  "http://": "@t",
  "https://s3.amazonaws.com/": "@s",
  "https://s3-": "@S",
  "http://localhost:": "@L",
  "http://localhost": "@l",
  "/v1/": "@v",
  "/users/": "@u",
  "/products/": "@p"
};
var STATUS_MESSAGE_DICT = {
  "processing": "p",
  "completed": "c",
  "succeeded": "s",
  "failed": "f",
  "cancelled": "x",
  "timeout": "t",
  "retrying": "r",
  "authorized": "a",
  "captured": "K",
  "refunded": "R",
  "declined": "d",
  "shipped": "h",
  "delivered": "D",
  "returned": "e",
  "in_transit": "i",
  "initialized": "n",
  "terminated": "m"
};
var CONTENT_TYPE_REVERSE = Object.fromEntries(Object.entries(CONTENT_TYPE_DICT).map(([k4, v4]) => [v4, k4]));
var URL_PREFIX_REVERSE = Object.fromEntries(Object.entries(URL_PREFIX_DICT).map(([k4, v4]) => [v4, k4]));
var STATUS_MESSAGE_REVERSE = Object.fromEntries(Object.entries(STATUS_MESSAGE_DICT).map(([k4, v4]) => [v4, k4]));
var COMBINED_DICT = {
  ...CONTENT_TYPE_DICT,
  ...STATUS_MESSAGE_DICT
};
var COMBINED_REVERSE = {
  ...CONTENT_TYPE_REVERSE,
  ...STATUS_MESSAGE_REVERSE
};
function dictionaryEncode(value) {
  if (typeof value !== "string" || !value) {
    return null;
  }
  if (COMBINED_DICT[value]) {
    return {
      encoded: "d:" + COMBINED_DICT[value],
      encoding: "dictionary",
      originalLength: value.length,
      encodedLength: 2 + COMBINED_DICT[value].length,
      dictionaryType: "exact",
      savings: value.length - (2 + COMBINED_DICT[value].length)
    };
  }
  const sortedPrefixes = Object.entries(URL_PREFIX_DICT).sort(([a4], [b4]) => b4.length - a4.length);
  for (const [prefix, code] of sortedPrefixes) {
    if (value.startsWith(prefix)) {
      const remainder = value.substring(prefix.length);
      const encoded = "d:" + code + remainder;
      return {
        encoded,
        encoding: "dictionary",
        originalLength: value.length,
        encodedLength: encoded.length,
        dictionaryType: "prefix",
        prefix,
        remainder,
        savings: value.length - encoded.length
      };
    }
  }
  return null;
}
function dictionaryDecode(encoded) {
  if (typeof encoded !== "string" || !encoded.startsWith("d:")) {
    return null;
  }
  const payload2 = encoded.substring(2);
  if (payload2.length === 0) {
    return null;
  }
  if (payload2.length === 1) {
    const decoded = COMBINED_REVERSE[payload2];
    if (decoded) {
      return decoded;
    }
  }
  if (payload2.startsWith("@")) {
    const prefixCode = payload2.substring(0, 2);
    const remainder = payload2.substring(2);
    const prefix = URL_PREFIX_REVERSE[prefixCode];
    if (prefix) {
      return prefix + remainder;
    }
  }
  return null;
}
var analysisCache = /* @__PURE__ */ new Map();
var MAX_CACHE_SIZE = 500;
function isAsciiOnly(str) {
  return /^[\x20-\x7E]*$/.test(str);
}
function analyzeString(str) {
  if (!str || typeof str !== "string") {
    return { type: "none", safe: true };
  }
  if (analysisCache.has(str)) {
    return analysisCache.get(str);
  }
  if (isAsciiOnly(str)) {
    const result2 = {
      type: "ascii",
      safe: true,
      stats: { ascii: str.length, latin1: 0, multibyte: 0 }
    };
    cacheAnalysisResult(str, result2);
    return result2;
  }
  let asciiCount = 0;
  let latin1Count = 0;
  let multibyteCount = 0;
  for (let i4 = 0; i4 < str.length; i4++) {
    const code = str.charCodeAt(i4);
    if (code >= 32 && code <= 126) {
      asciiCount++;
    } else if (code < 32 || code === 127) {
      multibyteCount++;
    } else if (code >= 128 && code <= 255) {
      latin1Count++;
    } else {
      multibyteCount++;
    }
  }
  const hasMultibyte = multibyteCount > 0;
  const hasLatin1 = latin1Count > 0;
  let result;
  if (!hasLatin1 && !hasMultibyte) {
    result = {
      type: "ascii",
      safe: true,
      stats: { ascii: asciiCount, latin1: 0, multibyte: 0 }
    };
  } else if (hasMultibyte) {
    const multibyteRatio = multibyteCount / str.length;
    if (multibyteRatio > 0.3) {
      result = {
        type: "base64",
        safe: false,
        reason: "high multibyte content",
        stats: { ascii: asciiCount, latin1: latin1Count, multibyte: multibyteCount }
      };
    } else {
      result = {
        type: "url",
        safe: false,
        reason: "contains multibyte characters",
        stats: { ascii: asciiCount, latin1: latin1Count, multibyte: multibyteCount }
      };
    }
  } else {
    const latin1Ratio = latin1Count / str.length;
    if (latin1Ratio > 0.5) {
      result = {
        type: "base64",
        safe: false,
        reason: "high Latin-1 content",
        stats: { ascii: asciiCount, latin1: latin1Count, multibyte: 0 }
      };
    } else {
      result = {
        type: "url",
        safe: false,
        reason: "contains Latin-1 extended characters",
        stats: { ascii: asciiCount, latin1: latin1Count, multibyte: 0 }
      };
    }
  }
  cacheAnalysisResult(str, result);
  return result;
}
function cacheAnalysisResult(str, result) {
  if (analysisCache.size >= MAX_CACHE_SIZE) {
    const firstKey = analysisCache.keys().next().value;
    if (firstKey !== void 0) {
      analysisCache.delete(firstKey);
    }
  }
  analysisCache.set(str, result);
}
var COMMON_VALUES = {
  "active": { encoded: "active", encoding: "none" },
  "inactive": { encoded: "inactive", encoding: "none" },
  "pending": { encoded: "pending", encoding: "none" },
  "completed": { encoded: "completed", encoding: "none" },
  "failed": { encoded: "failed", encoding: "none" },
  "success": { encoded: "success", encoding: "none" },
  "error": { encoded: "error", encoding: "none" },
  "processing": { encoded: "processing", encoding: "none" },
  "queued": { encoded: "queued", encoding: "none" },
  "cancelled": { encoded: "cancelled", encoding: "none" },
  "GET": { encoded: "GET", encoding: "none" },
  "POST": { encoded: "POST", encoding: "none" },
  "PUT": { encoded: "PUT", encoding: "none" },
  "DELETE": { encoded: "DELETE", encoding: "none" },
  "PATCH": { encoded: "PATCH", encoding: "none" },
  "HEAD": { encoded: "HEAD", encoding: "none" },
  "OPTIONS": { encoded: "OPTIONS", encoding: "none" },
  "200": { encoded: "200", encoding: "none" },
  "201": { encoded: "201", encoding: "none" },
  "204": { encoded: "204", encoding: "none" },
  "301": { encoded: "301", encoding: "none" },
  "302": { encoded: "302", encoding: "none" },
  "304": { encoded: "304", encoding: "none" },
  "400": { encoded: "400", encoding: "none" },
  "401": { encoded: "401", encoding: "none" },
  "403": { encoded: "403", encoding: "none" },
  "404": { encoded: "404", encoding: "none" },
  "405": { encoded: "405", encoding: "none" },
  "409": { encoded: "409", encoding: "none" },
  "422": { encoded: "422", encoding: "none" },
  "429": { encoded: "429", encoding: "none" },
  "500": { encoded: "500", encoding: "none" },
  "502": { encoded: "502", encoding: "none" },
  "503": { encoded: "503", encoding: "none" },
  "504": { encoded: "504", encoding: "none" },
  "OK": { encoded: "OK", encoding: "none" },
  "Created": { encoded: "Created", encoding: "none" },
  "paid": { encoded: "paid", encoding: "none" },
  "unpaid": { encoded: "unpaid", encoding: "none" },
  "refunded": { encoded: "refunded", encoding: "none" },
  "pending_payment": { encoded: "pending_payment", encoding: "none" },
  "authorized": { encoded: "authorized", encoding: "none" },
  "captured": { encoded: "captured", encoding: "none" },
  "declined": { encoded: "declined", encoding: "none" },
  "voided": { encoded: "voided", encoding: "none" },
  "chargeback": { encoded: "chargeback", encoding: "none" },
  "disputed": { encoded: "disputed", encoding: "none" },
  "settled": { encoded: "settled", encoding: "none" },
  "reversed": { encoded: "reversed", encoding: "none" },
  "shipped": { encoded: "shipped", encoding: "none" },
  "delivered": { encoded: "delivered", encoding: "none" },
  "returned": { encoded: "returned", encoding: "none" },
  "in_transit": { encoded: "in_transit", encoding: "none" },
  "out_for_delivery": { encoded: "out_for_delivery", encoding: "none" },
  "ready_to_ship": { encoded: "ready_to_ship", encoding: "none" },
  "backordered": { encoded: "backordered", encoding: "none" },
  "pre_order": { encoded: "pre_order", encoding: "none" },
  "on_hold": { encoded: "on_hold", encoding: "none" },
  "awaiting_pickup": { encoded: "awaiting_pickup", encoding: "none" },
  "admin": { encoded: "admin", encoding: "none" },
  "moderator": { encoded: "moderator", encoding: "none" },
  "owner": { encoded: "owner", encoding: "none" },
  "editor": { encoded: "editor", encoding: "none" },
  "viewer": { encoded: "viewer", encoding: "none" },
  "contributor": { encoded: "contributor", encoding: "none" },
  "guest": { encoded: "guest", encoding: "none" },
  "member": { encoded: "member", encoding: "none" },
  "trace": { encoded: "trace", encoding: "none" },
  "debug": { encoded: "debug", encoding: "none" },
  "info": { encoded: "info", encoding: "none" },
  "warn": { encoded: "warn", encoding: "none" },
  "fatal": { encoded: "fatal", encoding: "none" },
  "emergency": { encoded: "emergency", encoding: "none" },
  "dev": { encoded: "dev", encoding: "none" },
  "development": { encoded: "development", encoding: "none" },
  "staging": { encoded: "staging", encoding: "none" },
  "production": { encoded: "production", encoding: "none" },
  "test": { encoded: "test", encoding: "none" },
  "qa": { encoded: "qa", encoding: "none" },
  "uat": { encoded: "uat", encoding: "none" },
  "create": { encoded: "create", encoding: "none" },
  "read": { encoded: "read", encoding: "none" },
  "update": { encoded: "update", encoding: "none" },
  "delete": { encoded: "delete", encoding: "none" },
  "list": { encoded: "list", encoding: "none" },
  "search": { encoded: "search", encoding: "none" },
  "count": { encoded: "count", encoding: "none" },
  "enabled": { encoded: "enabled", encoding: "none" },
  "disabled": { encoded: "disabled", encoding: "none" },
  "archived": { encoded: "archived", encoding: "none" },
  "draft": { encoded: "draft", encoding: "none" },
  "published": { encoded: "published", encoding: "none" },
  "scheduled": { encoded: "scheduled", encoding: "none" },
  "expired": { encoded: "expired", encoding: "none" },
  "locked": { encoded: "locked", encoding: "none" },
  "low": { encoded: "low", encoding: "none" },
  "medium": { encoded: "medium", encoding: "none" },
  "high": { encoded: "high", encoding: "none" },
  "urgent": { encoded: "urgent", encoding: "none" },
  "critical": { encoded: "critical", encoding: "none" },
  "true": { encoded: "true", encoding: "none" },
  "false": { encoded: "false", encoding: "none" },
  "yes": { encoded: "yes", encoding: "none" },
  "no": { encoded: "no", encoding: "none" },
  "on": { encoded: "on", encoding: "none" },
  "off": { encoded: "off", encoding: "none" },
  "1": { encoded: "1", encoding: "none" },
  "0": { encoded: "0", encoding: "none" },
  "null": { encoded: "null", encoding: "special" },
  "undefined": { encoded: "undefined", encoding: "special" },
  "none": { encoded: "none", encoding: "none" },
  "N/A": { encoded: "N/A", encoding: "none" }
};
function metadataEncode(value) {
  if (value === null) {
    return { encoded: "null", encoding: "special" };
  }
  if (value === void 0) {
    return { encoded: "undefined", encoding: "special" };
  }
  const stringValue = String(value);
  if (stringValue.startsWith("d:") || stringValue.startsWith("u:") || stringValue.startsWith("b:")) {
    return {
      encoded: "b:" + Buffer.from(stringValue, "utf8").toString("base64"),
      encoding: "base64",
      reason: "force-encoded to prevent decoding ambiguity"
    };
  }
  const dictResult = dictionaryEncode(stringValue);
  if (dictResult && dictResult.savings > 0) {
    return {
      encoded: dictResult.encoded,
      encoding: "dictionary",
      dictionaryType: dictResult.dictionaryType,
      savings: dictResult.savings,
      compressionRatio: (dictResult.encodedLength / dictResult.originalLength).toFixed(3)
    };
  }
  if (COMMON_VALUES[stringValue]) {
    return COMMON_VALUES[stringValue];
  }
  const analysis = analyzeString(stringValue);
  switch (analysis.type) {
    case "none":
    case "ascii":
      return {
        encoded: stringValue,
        encoding: "none",
        analysis
      };
    case "url":
      return {
        encoded: "u:" + encodeURIComponent(stringValue),
        encoding: "url",
        analysis
      };
    case "base64":
      return {
        encoded: "b:" + Buffer.from(stringValue, "utf8").toString("base64"),
        encoding: "base64",
        analysis
      };
    default:
      return {
        encoded: "b:" + Buffer.from(stringValue, "utf8").toString("base64"),
        encoding: "base64",
        analysis
      };
  }
}
function metadataDecode(value) {
  if (value === "null") {
    return null;
  }
  if (value === "undefined") {
    return void 0;
  }
  if (value === null || value === void 0 || typeof value !== "string") {
    return value;
  }
  if (value.startsWith("d:")) {
    const decoded = dictionaryDecode(value);
    if (decoded !== null) {
      return decoded;
    }
  }
  if (value.length >= 2) {
    const firstChar = value.charCodeAt(0);
    const secondChar = value.charCodeAt(1);
    if (secondChar === 58) {
      if (firstChar === 117) {
        if (value.length === 2)
          return value;
        try {
          return decodeURIComponent(value.substring(2));
        } catch {
          return value;
        }
      }
      if (firstChar === 98) {
        if (value.length === 2)
          return value;
        try {
          const decoded = Buffer.from(value.substring(2), "base64").toString("utf8");
          return decoded;
        } catch {
          return value;
        }
      }
    }
  }
  return value;
}
var S3_DEFAULT_REGION = "us-east-1";
var S3_DEFAULT_ENDPOINT = "https://s3.us-east-1.amazonaws.com";
var ConnectionString = class {
  region;
  bucket;
  accessKeyId;
  secretAccessKey;
  endpoint;
  keyPrefix;
  forcePathStyle;
  clientType;
  basePath;
  clientOptions;
  constructor(connectionString) {
    const [ok, err, parsed] = tryFnSync(() => new URL(connectionString));
    if (!ok) {
      throw new ConnectionStringError("Invalid connection string: " + connectionString, {
        original: err,
        input: connectionString
      });
    }
    const uri = parsed;
    this.region = S3_DEFAULT_REGION;
    this.bucket = "s3db";
    this.accessKeyId = void 0;
    this.secretAccessKey = void 0;
    this.endpoint = S3_DEFAULT_ENDPOINT;
    this.keyPrefix = "";
    if (uri.protocol === "s3:")
      this.defineFromS3(uri);
    else if (uri.protocol === "file:")
      this.defineFromFileUri(uri);
    else if (uri.protocol === "memory:")
      this.defineFromMemoryUri(uri);
    else
      this.defineFromCustomUri(uri);
    this.clientOptions = this._parseQueryParams(uri.searchParams);
  }
  _parseQueryParams(searchParams) {
    const result = {};
    for (const [key, value] of searchParams.entries()) {
      const keys2 = key.split(".");
      let current = result;
      for (let i4 = 0; i4 < keys2.length - 1; i4++) {
        const k4 = keys2[i4];
        if (!current[k4] || typeof current[k4] !== "object") {
          current[k4] = {};
        }
        current = current[k4];
      }
      const finalKey = keys2[keys2.length - 1];
      current[finalKey] = this._coerceValue(value);
    }
    return result;
  }
  _coerceValue(value) {
    if (value === "true")
      return true;
    if (value === "false")
      return false;
    if (/^-?\d+$/.test(value))
      return parseInt(value, 10);
    if (/^-?\d+\.\d+$/.test(value))
      return parseFloat(value);
    return value;
  }
  defineFromS3(uri) {
    const [okBucket, errBucket, bucket] = tryFnSync(() => decodeURIComponent(uri.hostname));
    if (!okBucket) {
      throw new ConnectionStringError("Invalid bucket in connection string", {
        original: errBucket,
        input: uri.hostname
      });
    }
    this.bucket = bucket || "s3db";
    const [okUser, errUser, user] = tryFnSync(() => decodeURIComponent(uri.username));
    if (!okUser) {
      throw new ConnectionStringError("Invalid accessKeyId in connection string", {
        original: errUser,
        input: uri.username
      });
    }
    this.accessKeyId = user;
    const [okPass, errPass, pass] = tryFnSync(() => decodeURIComponent(uri.password));
    if (!okPass) {
      throw new ConnectionStringError("Invalid secretAccessKey in connection string", {
        original: errPass,
        input: uri.password
      });
    }
    this.secretAccessKey = pass;
    this.endpoint = S3_DEFAULT_ENDPOINT;
    if (["/", "", null].includes(uri.pathname)) {
      this.keyPrefix = "";
    } else {
      const [, ...subpath] = uri.pathname.split("/");
      this.keyPrefix = [...subpath || []].join("/");
    }
  }
  defineFromCustomUri(uri) {
    this.forcePathStyle = true;
    this.endpoint = uri.origin;
    const [okUser, errUser, user] = tryFnSync(() => decodeURIComponent(uri.username));
    if (!okUser) {
      throw new ConnectionStringError("Invalid accessKeyId in connection string", {
        original: errUser,
        input: uri.username
      });
    }
    this.accessKeyId = user;
    const [okPass, errPass, pass] = tryFnSync(() => decodeURIComponent(uri.password));
    if (!okPass) {
      throw new ConnectionStringError("Invalid secretAccessKey in connection string", {
        original: errPass,
        input: uri.password
      });
    }
    this.secretAccessKey = pass;
    if (["/", "", null].includes(uri.pathname)) {
      this.bucket = "s3db";
      this.keyPrefix = "";
    } else {
      const [, bucket, ...subpath] = uri.pathname.split("/");
      if (!bucket) {
        this.bucket = "s3db";
      } else {
        const [okBucket, errBucket, bucketDecoded] = tryFnSync(() => decodeURIComponent(bucket));
        if (!okBucket) {
          throw new ConnectionStringError("Invalid bucket in connection string", {
            original: errBucket,
            input: bucket
          });
        }
        this.bucket = bucketDecoded;
      }
      this.keyPrefix = [...subpath || []].join("/");
    }
  }
  defineFromFileUri(uri) {
    this.clientType = "filesystem";
    this.forcePathStyle = true;
    this.accessKeyId = void 0;
    this.secretAccessKey = void 0;
    let pathname = uri.pathname || "";
    if (uri.hostname && uri.hostname.match(/^[a-zA-Z]$/)) {
      pathname = `${uri.hostname}:${pathname}`;
    } else if (uri.hostname && uri.hostname !== "localhost") {
      pathname = `//${uri.hostname}${pathname}`;
    }
    const [okPath, errPath, decodedPath] = tryFnSync(() => decodeURIComponent(pathname));
    if (!okPath) {
      throw new ConnectionStringError("Invalid path in file:// connection string", {
        original: errPath,
        input: pathname
      });
    }
    if (!decodedPath || decodedPath === "/" || decodedPath === "") {
      throw new ConnectionStringError("file:// connection string requires a path", {
        input: uri.href,
        suggestion: "Use file:///absolute/path or file://./relative/path"
      });
    }
    const segments = decodedPath.split("/").filter(Boolean);
    if (segments.length === 0) {
      throw new ConnectionStringError("file:// connection string requires a path", {
        input: uri.href,
        suggestion: "Use file:///absolute/path or file://./relative/path"
      });
    }
    if (decodedPath.startsWith("./") || decodedPath.startsWith("../")) {
      this.basePath = import_path.default.resolve(decodedPath);
      this.bucket = "s3db";
      this.keyPrefix = "";
    } else if (segments.length === 1) {
      this.basePath = import_path.default.resolve("/", segments[0]);
      this.bucket = "s3db";
      this.keyPrefix = "";
    } else if (segments.length === 2) {
      const [baseSegment, bucketSegment] = segments;
      this.basePath = import_path.default.resolve("/", baseSegment);
      this.bucket = bucketSegment;
      this.keyPrefix = "";
    } else {
      const [baseSegment, bucketSegment, ...prefixSegments] = segments;
      this.basePath = import_path.default.resolve("/", baseSegment);
      this.bucket = bucketSegment;
      this.keyPrefix = prefixSegments.join("/");
    }
    this.endpoint = `file://${this.basePath}`;
    this.region = "local";
  }
  defineFromMemoryUri(uri) {
    this.clientType = "memory";
    this.forcePathStyle = true;
    this.accessKeyId = void 0;
    this.secretAccessKey = void 0;
    const bucketFromHost = uri.hostname || "";
    if (bucketFromHost) {
      const [okBucket, , decodedBucket] = tryFnSync(() => decodeURIComponent(bucketFromHost));
      this.bucket = okBucket ? decodedBucket : bucketFromHost;
    } else {
      this.bucket = "s3db";
    }
    if (["/", "", null].includes(uri.pathname)) {
      this.keyPrefix = "";
    } else {
      const [, ...subpath] = uri.pathname.split("/");
      const decodedSegments = (subpath || []).map((segment) => {
        if (!segment) {
          return segment;
        }
        const [okSegment, , decodedSegment] = tryFnSync(() => decodeURIComponent(segment));
        return okSegment ? decodedSegment : segment;
      });
      this.keyPrefix = decodedSegments.filter(Boolean).join("/");
    }
    this.endpoint = "memory://localhost";
    this.region = "us-east-1";
  }
};
var AdaptiveTuning = class {
  minConcurrency;
  maxConcurrency;
  targetLatency;
  targetMemoryPercent;
  adjustmentInterval;
  metrics;
  currentConcurrency;
  lastAdjustment;
  intervalId;
  constructor(options = {}) {
    this.minConcurrency = options.minConcurrency || 1;
    this.maxConcurrency = options.maxConcurrency || 100;
    this.targetLatency = options.targetLatency || 200;
    this.targetMemoryPercent = options.targetMemoryPercent || 0.7;
    this.adjustmentInterval = options.adjustmentInterval || 5e3;
    this.metrics = {
      latencies: [],
      throughputs: [],
      memoryUsages: [],
      errorRates: [],
      concurrencyHistory: []
    };
    this.currentConcurrency = this.suggestInitial();
    this.lastAdjustment = Date.now();
    this.intervalId = null;
    this.startMonitoring();
  }
  suggestInitial() {
    const totalMemoryMB = import_os.default.totalmem() / 1024 / 1024;
    const freeMemoryMB = import_os.default.freemem() / 1024 / 1024;
    const usedPercent = (totalMemoryMB - freeMemoryMB) / totalMemoryMB;
    let suggested;
    if (totalMemoryMB < 512) {
      suggested = 2;
    } else if (totalMemoryMB < 1024) {
      suggested = 5;
    } else if (totalMemoryMB < 2048) {
      suggested = 10;
    } else if (totalMemoryMB < 4096) {
      suggested = 20;
    } else if (totalMemoryMB < 8192) {
      suggested = 30;
    } else {
      suggested = 20;
    }
    if (usedPercent > 0.8) {
      suggested = Math.max(1, Math.floor(suggested * 0.5));
    } else if (usedPercent > 0.7) {
      suggested = Math.max(1, Math.floor(suggested * 0.7));
    }
    suggested = Math.min(Math.max(this.minConcurrency, Math.floor(suggested * 0.5)), 20);
    return suggested;
  }
  recordTaskMetrics(task) {
    const memoryUsed = process.memoryUsage().heapUsed / import_os.default.totalmem();
    this.metrics.latencies.push(task.latency);
    this.metrics.memoryUsages.push(memoryUsed);
    if (this.metrics.latencies.length > 100) {
      this.metrics.latencies.shift();
      this.metrics.memoryUsages.shift();
    }
    const recentTasks = this.metrics.latencies.filter((_, i4) => {
      return i4 >= this.metrics.latencies.length - 10;
    }).length;
    const windowMs = 1e3;
    const throughput = recentTasks / windowMs * 1e3;
    this.metrics.throughputs.push(throughput);
    if (this.metrics.throughputs.length > 100) {
      this.metrics.throughputs.shift();
    }
  }
  startMonitoring() {
    this.intervalId = setInterval(() => {
      this.adjust();
    }, this.adjustmentInterval);
    if (this.intervalId.unref) {
      this.intervalId.unref();
    }
  }
  adjust() {
    if (this.metrics.latencies.length < 10) {
      return null;
    }
    const avgLatency = this._avg(this.metrics.latencies);
    const avgMemory = this._avg(this.metrics.memoryUsages);
    const avgThroughput = this._avg(this.metrics.throughputs);
    let adjustment = 0;
    let reason = "";
    if (avgMemory > this.targetMemoryPercent) {
      adjustment = -Math.ceil(this.currentConcurrency * 0.2);
      reason = `memory pressure (${(avgMemory * 100).toFixed(1)}%)`;
    } else if (avgLatency > this.targetLatency * 1.5) {
      adjustment = -Math.ceil(this.currentConcurrency * 0.1);
      reason = `high latency (${avgLatency.toFixed(0)}ms)`;
    } else if (avgLatency < this.targetLatency * 0.5 && avgMemory < this.targetMemoryPercent * 0.8) {
      adjustment = Math.ceil(this.currentConcurrency * 0.2);
      reason = "good performance, scaling up";
    } else if (avgLatency > this.targetLatency * 1.2) {
      adjustment = -Math.ceil(this.currentConcurrency * 0.05);
      reason = "slight latency increase";
    }
    if (adjustment !== 0) {
      const newConcurrency = Math.max(this.minConcurrency, Math.min(this.maxConcurrency, this.currentConcurrency + adjustment));
      if (newConcurrency !== this.currentConcurrency) {
        const oldConcurrency = this.currentConcurrency;
        this.currentConcurrency = newConcurrency;
        this.lastAdjustment = Date.now();
        this.metrics.concurrencyHistory.push({
          timestamp: Date.now(),
          old: oldConcurrency,
          new: newConcurrency,
          reason,
          metrics: {
            avgLatency,
            avgMemory,
            avgThroughput
          }
        });
        if (this.metrics.concurrencyHistory.length > 100) {
          this.metrics.concurrencyHistory.shift();
        }
        return newConcurrency;
      }
    }
    return null;
  }
  getConcurrency() {
    return this.currentConcurrency;
  }
  getMetrics() {
    if (this.metrics.latencies.length === 0) {
      return {
        current: this.currentConcurrency,
        avgLatency: 0,
        avgMemory: 0,
        avgThroughput: 0,
        history: []
      };
    }
    return {
      current: this.currentConcurrency,
      avgLatency: this._avg(this.metrics.latencies),
      avgMemory: this._avg(this.metrics.memoryUsages),
      avgThroughput: this._avg(this.metrics.throughputs),
      history: this.metrics.concurrencyHistory.slice(-10)
    };
  }
  stop() {
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = null;
    }
  }
  _avg(arr) {
    if (arr.length === 0)
      return 0;
    return arr.reduce((a4, b4) => a4 + b4, 0) / arr.length;
  }
};
var SignatureStats = class {
  alpha;
  maxEntries;
  entries;
  constructor(options = {}) {
    this.alpha = typeof options.alpha === "number" ? options.alpha : 0.2;
    this.maxEntries = Math.max(1, options.maxEntries ?? 256);
    this.entries = /* @__PURE__ */ new Map();
  }
  record(signature, metrics = {}) {
    if (!signature) {
      return;
    }
    const entry = this.entries.get(signature) || {
      signature,
      count: 0,
      avgQueueWait: 0,
      avgExecution: 0,
      successRate: 1
    };
    entry.count++;
    entry.avgQueueWait = this._mix(entry.avgQueueWait, metrics.queueWait ?? 0);
    entry.avgExecution = this._mix(entry.avgExecution, metrics.execution ?? 0);
    entry.successRate = this._mix(entry.successRate, metrics.success === false ? 0 : 1);
    this.entries.set(signature, entry);
    if (this.entries.size > this.maxEntries) {
      const oldestKey = this.entries.keys().next().value;
      if (oldestKey) {
        this.entries.delete(oldestKey);
      }
    }
  }
  snapshot(limit = 10) {
    if (this.entries.size === 0) {
      return [];
    }
    const sorted = Array.from(this.entries.values()).sort((a4, b4) => {
      if (a4.avgExecution === b4.avgExecution) {
        return b4.count - a4.count;
      }
      return b4.avgExecution - a4.avgExecution;
    });
    return sorted.slice(0, limit).map((entry) => ({
      signature: entry.signature,
      count: entry.count,
      avgQueueWait: Number(entry.avgQueueWait.toFixed(2)),
      avgExecution: Number(entry.avgExecution.toFixed(2)),
      successRate: Number(entry.successRate.toFixed(2))
    }));
  }
  reset() {
    this.entries.clear();
  }
  _mix(current, incoming) {
    if (current === 0)
      return incoming;
    return current * (1 - this.alpha) + incoming * this.alpha;
  }
};
var FifoTaskQueue = class {
  buffer;
  mask;
  head;
  tail;
  constructor(capacity = 32) {
    const size = this._normalizeCapacity(capacity);
    this.buffer = new Array(size);
    this.mask = size - 1;
    this.head = 0;
    this.tail = 0;
  }
  get length() {
    return this.tail - this.head;
  }
  enqueue(value) {
    if (this.length >= this.buffer.length) {
      this._grow();
    }
    const index = this.tail & this.mask;
    this.buffer[index] = value;
    this.tail++;
  }
  dequeue() {
    if (this.head === this.tail) {
      return null;
    }
    const index = this.head & this.mask;
    const value = this.buffer[index];
    this.buffer[index] = void 0;
    this.head++;
    if (this.head === this.tail) {
      this.head = 0;
      this.tail = 0;
    }
    return value;
  }
  flush(callback) {
    if (typeof callback === "function") {
      for (let i4 = this.head; i4 < this.tail; i4++) {
        const value = this.buffer[i4 & this.mask];
        if (value !== void 0) {
          callback(value);
        }
      }
    }
    this.clear();
  }
  clear() {
    if (this.head !== this.tail) {
      for (let i4 = this.head; i4 < this.tail; i4++) {
        this.buffer[i4 & this.mask] = void 0;
      }
    }
    this.head = 0;
    this.tail = 0;
  }
  setAgingMultiplier(_multiplier) {
  }
  toArray() {
    const len = this.length;
    if (len === 0) {
      return [];
    }
    const snapshot = new Array(len);
    for (let i4 = 0; i4 < len; i4++) {
      snapshot[i4] = this.buffer[this.head + i4 & this.mask];
    }
    return snapshot;
  }
  _grow() {
    const newSize = this.buffer.length * 2;
    const next = new Array(newSize);
    const len = this.length;
    for (let i4 = 0; i4 < len; i4++) {
      next[i4] = this.buffer[this.head + i4 & this.mask];
    }
    this.buffer = next;
    this.mask = newSize - 1;
    this.head = 0;
    this.tail = len;
  }
  _normalizeCapacity(value) {
    let size = 8;
    const normalized = Number.isFinite(value) && value > 0 ? Math.ceil(value) : size;
    const target = Math.max(size, normalized);
    while (size < target) {
      size <<= 1;
    }
    return size;
  }
};
var PriorityTaskQueue = class {
  heap;
  counter;
  agingMs;
  maxAgingBoost;
  agingMultiplier;
  _agingEnabled;
  constructor(options = {}) {
    this.heap = [];
    this.counter = 0;
    this.agingMs = options.agingMs ?? 0;
    this.maxAgingBoost = options.maxAgingBoost ?? 0;
    this.agingMultiplier = 1;
    this._agingEnabled = this.agingMs > 0 && this.maxAgingBoost > 0;
  }
  get length() {
    return this.heap.length;
  }
  enqueue(task) {
    const node = {
      task,
      priority: task.priority || 0,
      order: this.counter++
    };
    if (this._agingEnabled) {
      node.enqueuedAt = Date.now();
    }
    this.heap.push(node);
    this._bubbleUp(this.heap.length - 1);
  }
  dequeue() {
    if (this.heap.length === 0) {
      return null;
    }
    const topNode = this.heap[0];
    const lastNode = this.heap.pop();
    if (this.heap.length > 0 && lastNode) {
      this.heap[0] = lastNode;
      this._bubbleDown(0);
    }
    return topNode.task;
  }
  flush(callback) {
    if (typeof callback === "function") {
      for (const node of this.heap) {
        callback(node.task);
      }
    }
    this.clear();
  }
  clear() {
    this.heap.length = 0;
  }
  setAgingMultiplier(multiplier) {
    if (!this._agingEnabled) {
      return;
    }
    if (typeof multiplier !== "number" || Number.isNaN(multiplier)) {
      return;
    }
    this.agingMultiplier = Math.min(4, Math.max(0.25, multiplier));
  }
  _bubbleUp(index) {
    const now = this._agingTimestamp();
    const agingBase = this._agingBase();
    while (index > 0) {
      const parentIndex = index - 1 >> 1;
      if (this._isHigherPriority(parentIndex, index, now, agingBase)) {
        break;
      }
      this._swap(index, parentIndex);
      index = parentIndex;
    }
  }
  _bubbleDown(index) {
    const length = this.heap.length;
    if (length === 0) {
      return;
    }
    const now = this._agingTimestamp();
    const agingBase = this._agingBase();
    while (true) {
      const left = (index << 1) + 1;
      const right = left + 1;
      let largest = index;
      if (left < length && this._isHigherPriority(left, largest, now, agingBase)) {
        largest = left;
      }
      if (right < length && this._isHigherPriority(right, largest, now, agingBase)) {
        largest = right;
      }
      if (largest === index) {
        break;
      }
      this._swap(index, largest);
      index = largest;
    }
  }
  _isHigherPriority(indexA, indexB, now, agingBase) {
    const heap = this.heap;
    const nodeA = heap[indexA];
    const nodeB = heap[indexB];
    if (!nodeA)
      return false;
    if (!nodeB)
      return true;
    const priorityA = this._priorityValue(nodeA, now, agingBase);
    const priorityB = this._priorityValue(nodeB, now, agingBase);
    if (priorityA === priorityB) {
      return nodeA.order < nodeB.order;
    }
    return priorityA > priorityB;
  }
  _priorityValue(node, now, agingBase) {
    if (!this._agingEnabled || !agingBase) {
      return node.priority;
    }
    const waited = Math.max(0, now - (node.enqueuedAt || 0));
    if (waited <= 0) {
      return node.priority;
    }
    const bonus = Math.min(this.maxAgingBoost, waited / agingBase);
    return node.priority + bonus;
  }
  _swap(i4, j4) {
    const tmp = this.heap[i4];
    this.heap[i4] = this.heap[j4];
    this.heap[j4] = tmp;
  }
  _agingTimestamp() {
    return this._agingEnabled ? Date.now() : 0;
  }
  _agingBase() {
    if (!this._agingEnabled) {
      return 0;
    }
    const base2 = this.agingMs * this.agingMultiplier;
    if (!base2 || !Number.isFinite(base2)) {
      return 0;
    }
    return base2;
  }
};
function getFnName(fn) {
  if (typeof fn === "function" && fn.name) {
    return fn.name;
  }
  return "anonymous";
}
function extractLengthHint(item) {
  if (item == null)
    return void 0;
  if (typeof item === "string" || Array.isArray(item)) {
    return item.length;
  }
  if (typeof item === "object") {
    const obj = item;
    if (typeof obj.length === "number") {
      return obj.length;
    }
    if (typeof obj.size === "number") {
      return obj.size;
    }
  }
  return void 0;
}
function deriveSignature(fn, metadata = {}, signatureOverride, priority = 0) {
  if (signatureOverride)
    return signatureOverride;
  if (metadata.signature)
    return metadata.signature;
  const fnName = getFnName(fn);
  const hintSource = metadata.item ?? metadata.items ?? metadata.payload ?? metadata.body ?? metadata.data ?? metadata.value;
  const lengthHint = metadata.itemLength ?? metadata.length ?? (typeof metadata.size === "number" ? metadata.size : void 0) ?? extractLengthHint(hintSource);
  const hint = lengthHint != null ? `${fnName}:${lengthHint}` : fnName;
  return `${hint}:p${priority}`;
}
var INTERNAL_DEFER = "__taskExecutorInternalDefer";
var MemorySampler = class {
  interval;
  lastSampleTime;
  lastSample;
  constructor(interval = 100) {
    this.interval = Math.max(25, interval);
    this.lastSampleTime = 0;
    this.lastSample = { heapUsed: 0 };
    this.sampleNow();
  }
  snapshot() {
    return this.lastSample.heapUsed;
  }
  maybeSample() {
    if (Date.now() - this.lastSampleTime >= this.interval) {
      return this.sampleNow();
    }
    return this.snapshot();
  }
  sampleNow() {
    this.lastSample = process.memoryUsage();
    this.lastSampleTime = Date.now();
    return this.lastSample.heapUsed;
  }
};
var RollingMetrics = class {
  size;
  entries;
  index;
  length;
  sums;
  errorCount;
  constructor(size = 256) {
    this.size = size;
    this.entries = new Array(size);
    this.index = 0;
    this.length = 0;
    this.sums = {
      queueWait: 0,
      execution: 0,
      retries: 0
    };
    this.errorCount = 0;
  }
  push(entry) {
    const old = this.entries[this.index];
    if (old) {
      this.sums.queueWait -= old.queueWait;
      this.sums.execution -= old.execution;
      this.sums.retries -= old.retries;
      if (!old.success) {
        this.errorCount--;
      }
    }
    this.entries[this.index] = entry;
    this.index = (this.index + 1) % this.size;
    if (this.length < this.size) {
      this.length++;
    }
    this.sums.queueWait += entry.queueWait;
    this.sums.execution += entry.execution;
    this.sums.retries += entry.retries;
    if (!entry.success) {
      this.errorCount++;
    }
  }
  snapshot() {
    if (this.length === 0) {
      return {
        sampleSize: 0,
        avgQueueWait: 0,
        avgExecution: 0,
        avgRetries: 0,
        errorRate: 0
      };
    }
    return {
      sampleSize: this.length,
      avgQueueWait: this.sums.queueWait / this.length,
      avgExecution: this.sums.execution / this.length,
      avgRetries: this.sums.retries / this.length,
      errorRate: this.errorCount / this.length
    };
  }
};
var RollingWindow = class {
  windowMs;
  events;
  constructor(windowMs = 1e3) {
    this.windowMs = Math.max(250, windowMs);
    this.events = [];
  }
  record(timestamp = Date.now(), success = true) {
    this.events.push({ timestamp, success });
    this._prune();
  }
  snapshot() {
    this._prune();
    const count = this.events.length;
    if (count === 0) {
      return {
        windowMs: this.windowMs,
        throughputPerSec: 0,
        successRate: 1
      };
    }
    const now = Date.now();
    const effectiveWindow = Math.max(1, Math.min(this.windowMs, now - this.events[0].timestamp));
    const throughputPerSec = count / effectiveWindow * 1e3;
    const successCount = this.events.filter((e4) => e4.success).length;
    return {
      windowMs: this.windowMs,
      throughputPerSec,
      successRate: successCount / count
    };
  }
  _prune() {
    const cutoff = Date.now() - this.windowMs;
    while (this.events.length > 0 && this.events[0].timestamp < cutoff) {
      this.events.shift();
    }
  }
};
var TasksPool = class _TasksPool extends import_events.EventEmitter {
  features;
  lightMode;
  bareMode;
  autoConcurrency;
  retries;
  retryDelay;
  timeout;
  retryableErrors;
  retryStrategy;
  priorityConfig;
  queue;
  active;
  paused;
  stopped;
  stats;
  rollingMetrics;
  monitoring;
  taskMetrics;
  memorySampler;
  rollingWindow;
  signatureStats;
  tuner;
  autoTuningConfig;
  _configuredConcurrency;
  _effectiveConcurrency;
  _drainInProgress;
  _pendingDrain;
  _activeWaiters;
  _lightActiveTasks;
  _monitoringState;
  _lastTunedConcurrency;
  constructor(options = {}) {
    super();
    const requestedRetries = options.retries ?? 3;
    const monitoringRequested = options.monitoring?.enabled ?? true;
    const requestedMonitoringMode = options.monitoring?.mode;
    const requestedProfile = options.features?.profile;
    const needsRichProfile = requestedRetries > 0;
    let profile = requestedProfile || (needsRichProfile ? "balanced" : "light");
    const defaultMonitoringMode = options.monitoring?.collectMetrics || requestedMonitoringMode === "detailed" ? "detailed" : "passive";
    const monitoringMode = monitoringRequested ? requestedMonitoringMode || defaultMonitoringMode : "light";
    if (profile === "light" && monitoringRequested && monitoringMode !== "passive") {
      profile = "balanced";
    }
    this.features = {
      profile,
      emitEvents: options.features?.emitEvents ?? profile !== "bare",
      signatureInsights: options.features?.signatureInsights ?? true
    };
    this.lightMode = this.features.profile === "light" || this.features.profile === "bare";
    this.bareMode = this.features.profile === "bare";
    const tunerInstance = options.autoTuning?.instance;
    const autoTuningRequested = options.autoTuning?.enabled || tunerInstance;
    const requestedConcurrency = options.concurrency ?? 10;
    this.autoConcurrency = requestedConcurrency === "auto";
    this._configuredConcurrency = this.autoConcurrency ? "auto" : this._normalizeConcurrency(requestedConcurrency);
    this._effectiveConcurrency = this.autoConcurrency ? this._defaultAutoConcurrency() : this._configuredConcurrency;
    this.retries = requestedRetries;
    this.retryDelay = options.retryDelay || 1e3;
    this.timeout = options.timeout ?? 3e4;
    this.retryableErrors = options.retryableErrors || [
      "NetworkingError",
      "TimeoutError",
      "RequestTimeout",
      "ServiceUnavailable",
      "SlowDown",
      "RequestLimitExceeded"
    ];
    this.retryStrategy = {
      jitter: options.retryStrategy?.jitter ?? true,
      minDelay: options.retryStrategy?.minDelay ?? 50,
      maxDelay: options.retryStrategy?.maxDelay ?? 3e4,
      clampDelay: options.retryStrategy?.clampDelay ?? 250,
      pressureClampThreshold: options.retryStrategy?.pressureClampThreshold ?? 4,
      pressureSkipThreshold: options.retryStrategy?.pressureSkipThreshold ?? 10,
      latencyTarget: options.retryStrategy?.latencyTarget ?? 2e3
    };
    this.priorityConfig = {
      agingMs: options.queue?.agingMs ?? 250,
      maxAgingBoost: options.queue?.maxAgingBoost ?? 3,
      latencyTarget: options.queue?.latencyTarget ?? 500
    };
    this.queue = this.lightMode ? new FifoTaskQueue() : new PriorityTaskQueue(this.priorityConfig);
    this.active = /* @__PURE__ */ new Map();
    this.paused = false;
    this.stopped = false;
    this._drainInProgress = false;
    this._pendingDrain = false;
    this._activeWaiters = [];
    this.stats = {
      queueSize: 0,
      activeCount: 0,
      processedCount: 0,
      errorCount: 0,
      retryCount: 0
    };
    this.rollingMetrics = new RollingMetrics(256);
    this._lightActiveTasks = 0;
    this._monitoringState = {
      lastExport: 0,
      lastProcessed: 0
    };
    const monitoringEnabled = !this.bareMode && monitoringRequested;
    const collectMetricsRequested = options.monitoring?.collectMetrics ?? false;
    const collectMetrics = monitoringEnabled && (collectMetricsRequested || monitoringMode === "detailed");
    this.monitoring = {
      enabled: monitoringEnabled,
      mode: monitoringMode,
      collectMetrics,
      sampleRate: this._normalizeSampleRate(options.monitoring?.sampleRate ?? 0),
      telemetryRate: this._normalizeSampleRate(options.monitoring?.telemetrySampleRate ?? (collectMetrics || autoTuningRequested ? 1 : 0.2)),
      sampleInterval: options.monitoring?.sampleInterval ?? 100,
      rollingWindowMs: options.monitoring?.rollingWindowMs ?? 1e3,
      reportInterval: options.monitoring?.reportInterval ?? 1e3,
      signatureSampleLimit: Math.max(1, options.monitoring?.signatureSampleLimit ?? 8),
      exporter: typeof options.monitoring?.exporter === "function" ? options.monitoring.exporter : null
    };
    this.taskMetrics = /* @__PURE__ */ new Map();
    this.memorySampler = this.monitoring.collectMetrics && this.monitoring.sampleRate > 0 && this.monitoring.mode !== "light" ? new MemorySampler(this.monitoring.sampleInterval) : null;
    this.rollingWindow = this.monitoring.collectMetrics ? new RollingWindow(this.monitoring.rollingWindowMs) : null;
    this.signatureStats = this.features.signatureInsights ? new SignatureStats({
      alpha: options.monitoring?.signatureAlpha,
      maxEntries: options.monitoring?.signatureMaxEntries
    }) : null;
    this.tuner = null;
    this._lastTunedConcurrency = null;
    if (!this.bareMode && autoTuningRequested) {
      this.autoTuningConfig = options.autoTuning;
      this.tuner = tunerInstance || new AdaptiveTuning(options.autoTuning);
      const tuned = this.tuner.getConcurrency();
      if (typeof tuned === "number" && tuned > 0) {
        this.setConcurrency(tuned);
        this._lastTunedConcurrency = tuned;
      }
    }
  }
  _normalizeConcurrency(concurrency) {
    if (typeof concurrency === "number" && concurrency >= 1) {
      return concurrency;
    }
    return 10;
  }
  get concurrency() {
    return this._configuredConcurrency;
  }
  get effectiveConcurrency() {
    return this._effectiveConcurrency;
  }
  _defaultAutoConcurrency() {
    try {
      const cpuCount = Math.max(1, (0, import_os.cpus)()?.length || 0);
      return Math.min(Math.max(cpuCount, 4), 20);
    } catch {
      return 10;
    }
  }
  _normalizeSampleRate(value) {
    if (typeof value !== "number" || Number.isNaN(value)) {
      return 1;
    }
    if (value <= 0)
      return 0;
    if (value >= 1)
      return 1;
    return value;
  }
  _shouldSampleMetrics() {
    if (!this.monitoring.collectMetrics) {
      return false;
    }
    if (this.monitoring.sampleRate <= 0) {
      return false;
    }
    if (this.monitoring.sampleRate >= 1) {
      return true;
    }
    return Math.random() < this.monitoring.sampleRate;
  }
  _shouldCaptureAttemptTimeline(taskCollectMetrics) {
    if (taskCollectMetrics) {
      return true;
    }
    if (this.monitoring.collectMetrics || this.monitoring.mode === "detailed") {
      return true;
    }
    return false;
  }
  setTuner(tuner) {
    this.tuner = tuner;
    if (this.autoConcurrency) {
      this._effectiveConcurrency = tuner.getConcurrency();
      this.processNext();
      this._lastTunedConcurrency = this._effectiveConcurrency;
    }
  }
  async enqueue(fn, options = {}) {
    let internalDefer = false;
    if (options && options[INTERNAL_DEFER]) {
      internalDefer = true;
      options = { ...options };
      delete options[INTERNAL_DEFER];
    }
    const collectMetrics = this._shouldSampleMetrics();
    const captureAttemptTimeline = this._shouldCaptureAttemptTimeline(collectMetrics);
    const taskMetadata = {
      ...options.metadata || {}
    };
    const task = {
      id: nanoid(),
      fn,
      priority: options.priority || 0,
      retries: options.retries ?? this.retries,
      timeout: options.timeout ?? this.timeout,
      metadata: taskMetadata,
      attemptCount: 0,
      createdAt: Date.now(),
      startedAt: null,
      completedAt: null,
      collectMetrics,
      timings: {
        queueWait: null,
        execution: null,
        retryDelays: captureAttemptTimeline ? [] : null,
        retryDelayTotal: 0,
        total: null,
        failedAttempts: captureAttemptTimeline ? [] : null
      },
      controller: null,
      performance: {
        heapUsedBefore: null,
        heapUsedAfter: null,
        heapDelta: null
      },
      signature: "",
      promise: null,
      resolve: null,
      reject: null
    };
    task.signature = deriveSignature(fn, taskMetadata, options.signature, task.priority);
    let resolve;
    let reject;
    const promise2 = new Promise((res, rej) => {
      resolve = res;
      reject = rej;
    });
    task.promise = promise2;
    task.resolve = (result) => {
      this._recordTaskCompletion(task, result, null);
      resolve(result);
    };
    task.reject = (error2) => {
      this._recordTaskCompletion(task, null, error2);
      reject(error2);
    };
    this._insertByPriority(task);
    this.stats.queueSize = this.queue.length;
    if (!internalDefer) {
      this.processNext();
    }
    return promise2;
  }
  async addBatch(fns, options = {}) {
    const errors2 = [];
    const batchId = nanoid();
    const promises2 = fns.map((fn, index) => {
      const taskOptions = {
        priority: options.priority,
        retries: options.retries,
        timeout: options.timeout,
        metadata: { ...options.metadata, batchId, index },
        [INTERNAL_DEFER]: true
      };
      return this.enqueue(fn, taskOptions).then((result) => {
        if (options.onItemComplete) {
          options.onItemComplete(result, index);
        }
        return result;
      }).catch((error2) => {
        errors2.push({ error: error2, index });
        if (options.onItemError) {
          options.onItemError(error2, index);
        }
        throw error2;
      });
    });
    if (promises2.length > 0) {
      this.processNext();
    }
    const settled = await Promise.allSettled(promises2);
    const orderedResults = settled.map((s4) => {
      if (s4.status === "fulfilled")
        return s4.value;
      return null;
    });
    return { results: orderedResults, errors: errors2, batchId };
  }
  /**
   * Process an array of items with controlled concurrency.
   * This is a convenience method that mimics PromisePool.for().process() API.
   *
   * @example
   * const { results, errors } = await TasksPool.map(
   *   users,
   *   async (user) => fetchUserData(user.id),
   *   { concurrency: 10 }
   * );
   */
  static async map(items, processor, options = {}) {
    const { concurrency = 10, onItemComplete, onItemError } = options;
    const pool3 = new _TasksPool({
      concurrency,
      features: { profile: "bare", emitEvents: false }
    });
    const fns = items.map((item, index) => async () => processor(item, index));
    const batchOptions = {
      onItemComplete,
      onItemError: onItemError ? (error2, index) => onItemError(error2, items[index], index) : void 0
    };
    const { results, errors: errors2 } = await pool3.addBatch(fns, batchOptions);
    await pool3.destroy();
    return {
      results: results.filter((r4) => r4 !== null),
      errors: errors2.map((e4) => ({ error: e4.error, item: items[e4.index], index: e4.index }))
    };
  }
  processNext() {
    if (this.lightMode) {
      this._processLightQueue();
      return;
    }
    if (this.paused || this.stopped || this.queue.length === 0) {
      this._pendingDrain = false;
      return;
    }
    if (this._drainInProgress) {
      this._pendingDrain = true;
      return;
    }
    this._drainInProgress = true;
    do {
      this._pendingDrain = false;
      this._drainQueue();
    } while (this._pendingDrain && !this.paused && !this.stopped && this.queue.length > 0);
    this._drainInProgress = false;
  }
  _drainQueue() {
    while (this._canProcessNext()) {
      const task = this.queue.dequeue();
      if (!task)
        break;
      this.stats.queueSize = this.queue.length;
      const taskPromise = this._executeTaskWithRetry(task);
      this.active.set(taskPromise, task);
      this.stats.activeCount = this.active.size;
      this._safeEmit("pool:taskStarted", task);
      taskPromise.then((result) => {
        this.active.delete(taskPromise);
        this.stats.activeCount = this.active.size;
        this.stats.processedCount++;
        task.resolve(result);
        this._safeEmit("pool:taskCompleted", task, result);
        this._applyTunedConcurrency();
      }).catch((error2) => {
        this.active.delete(taskPromise);
        this.stats.activeCount = this.active.size;
        this.stats.errorCount++;
        task.reject(error2);
        this._safeEmit("pool:taskError", task, error2);
        this._applyTunedConcurrency();
      }).finally(() => {
        this._maybeExportMonitoringSample("task");
        this._notifyActiveWaiters();
        this.processNext();
        if (this.active.size === 0 && this.queue.length === 0) {
          this._safeEmit("pool:drained");
        }
      });
    }
  }
  _canProcessNext() {
    return !this.paused && !this.stopped && this.queue.length > 0 && this._currentActiveCount() < this.effectiveConcurrency;
  }
  _processLightQueue() {
    if (this.paused || this.stopped) {
      return;
    }
    if (this.bareMode) {
      this._processBareQueue();
      return;
    }
    while (this.queue.length > 0 && this._lightActiveTasks < this.effectiveConcurrency) {
      const task = this.queue.dequeue();
      if (!task)
        break;
      this.stats.queueSize = this.queue.length;
      this._lightActiveTasks++;
      this.stats.activeCount = this._lightActiveTasks;
      this._safeEmit("pool:taskStarted", task);
      const taskPromise = this._executeTaskWithRetry(task);
      taskPromise.then((result) => {
        this.stats.processedCount++;
        task.resolve(result);
        this._safeEmit("pool:taskCompleted", task, result);
        this._applyTunedConcurrency();
      }).catch((error2) => {
        this.stats.errorCount++;
        task.reject(error2);
        this._safeEmit("pool:taskError", task, error2);
        this._applyTunedConcurrency();
      }).finally(() => {
        this._lightActiveTasks--;
        this.stats.activeCount = this._lightActiveTasks;
        this._notifyActiveWaiters();
        this._maybeExportMonitoringSample("task");
        if (this._lightActiveTasks === 0 && this.queue.length === 0) {
          this._safeEmit("pool:drained");
        } else {
          this._processLightQueue();
        }
      });
    }
  }
  _processBareQueue() {
    while (this.queue.length > 0 && this._lightActiveTasks < this.effectiveConcurrency) {
      const task = this.queue.dequeue();
      if (!task)
        break;
      this._lightActiveTasks++;
      const taskPromise = this._executeBareTask(task);
      taskPromise.then((result) => {
        task.resolve(result);
        this._applyTunedConcurrency();
      }).catch((error2) => {
        task.reject(error2);
        this._applyTunedConcurrency();
      }).finally(() => {
        this._lightActiveTasks--;
        this._notifyActiveWaiters();
        if (this._lightActiveTasks === 0 && this.queue.length === 0) {
          this._safeEmit("pool:drained");
        } else {
          this._processBareQueue();
        }
      });
    }
  }
  async _executeTaskWithRetry(task) {
    if (this.bareMode || task.retries === 0 && !this._shouldEnforceTimeout(task.timeout)) {
      return await this._runSingleAttempt(task);
    }
    let lastError;
    for (let attempt = 0; attempt <= task.retries; attempt++) {
      task.attemptCount = attempt + 1;
      if (attempt === 0) {
        task.startedAt = Date.now();
        task.timings.queueWait = task.startedAt - task.createdAt;
      }
      try {
        const result = await this._runSingleAttempt(task);
        return result;
      } catch (error2) {
        lastError = error2;
        if (task.timings.failedAttempts) {
          task.timings.failedAttempts.push({
            attempt: attempt + 1,
            duration: task.timings.execution || 0,
            error: error2.message
          });
        }
        const isRetryable = this._isErrorRetryable(error2);
        const hasRetriesLeft = attempt < task.retries;
        if (isRetryable && hasRetriesLeft) {
          this.stats.retryCount++;
          this._safeEmit("pool:taskRetry", task, attempt + 1);
          const delayMs = this._computeRetryDelay(task, attempt, error2);
          if (delayMs == null) {
            throw error2;
          }
          const delayStartTime = Date.now();
          const delayController = typeof AbortController !== "undefined" ? new AbortController() : null;
          task.delayController = delayController;
          await this._sleep(delayMs, delayController?.signal);
          const delayEndTime = Date.now();
          const retryDuration = delayEndTime - delayStartTime;
          if (task.timings.retryDelays) {
            task.timings.retryDelays.push(retryDuration);
          }
          task.timings.retryDelayTotal = (task.timings.retryDelayTotal || 0) + retryDuration;
          task.delayController = null;
        } else {
          throw error2;
        }
      } finally {
        task.controller = null;
        task.delayController = null;
      }
    }
    throw lastError;
  }
  async _runSingleAttempt(task) {
    if (typeof task.startedAt !== "number") {
      task.startedAt = Date.now();
      task.timings.queueWait = task.startedAt - task.createdAt;
    }
    if (task.collectMetrics && this.memorySampler) {
      task.performance.heapUsedBefore = this._readHeapUsage("before");
    }
    const controller = this._shouldEnforceTimeout(task.timeout) && typeof AbortController !== "undefined" ? new AbortController() : null;
    task.controller = controller || null;
    const attemptStartTime = Date.now();
    const context = this._buildTaskContext(task, controller);
    const executionPromise = task.fn(context);
    const result = this._shouldEnforceTimeout(task.timeout) ? await this._executeWithTimeout(executionPromise, task.timeout, task, controller) : await executionPromise;
    const attemptEndTime = Date.now();
    task.timings.execution = attemptEndTime - attemptStartTime;
    if (task.collectMetrics && this.memorySampler) {
      task.performance.heapUsedAfter = this._readHeapUsage("after");
      task.performance.heapDelta = this._computeHeapDelta(task.performance.heapUsedBefore, task.performance.heapUsedAfter);
    }
    task.controller = null;
    return result;
  }
  async _executeBareTask(task) {
    return await this._runSingleAttempt(task);
  }
  async _executeWithTimeout(promise2, timeout, task, controller) {
    let timerId;
    const timeoutPromise = new Promise((_, reject) => {
      timerId = setTimeout(() => {
        const timeoutError = new Error(`Task ${task.id} timed out after ${timeout}ms`);
        timeoutError.name = "TimeoutError";
        timeoutError.code = "EOPERATIONS_TIMEOUT";
        if (controller && typeof controller.abort === "function") {
          controller.abort(timeoutError);
        }
        reject(timeoutError);
      }, timeout);
    });
    try {
      return await Promise.race([promise2, timeoutPromise]);
    } finally {
      clearTimeout(timerId);
    }
  }
  _isErrorRetryable(error2) {
    if (this.retryableErrors.length === 0) {
      return true;
    }
    return this.retryableErrors.some((errorType) => {
      return error2.name === errorType || error2.code === errorType || error2.constructor.name === errorType;
    });
  }
  _insertByPriority(task) {
    this.queue.enqueue(task);
  }
  _recordTaskCompletion(task, result, error2) {
    task.completedAt = Date.now();
    task.timings.total = task.completedAt - task.createdAt;
    const totalRetryDelay = task.timings.retryDelays ? task.timings.retryDelays.reduce((a4, b4) => a4 + b4, 0) : task.timings.retryDelayTotal || 0;
    task.timings.overhead = task.timings.total - (task.timings.execution || 0) - totalRetryDelay;
    if (this.tuner?.recordTaskMetrics) {
      try {
        this.tuner.recordTaskMetrics({
          latency: task.timings.execution || 0,
          queueWait: task.timings.queueWait ?? 0,
          success: !error2,
          retries: task.attemptCount - 1,
          heapDelta: task.performance.heapDelta || 0
        });
      } catch (tunerError) {
        this._safeEmit("tuner:error", tunerError);
      }
    }
    if (this.monitoring.collectMetrics && task.collectMetrics) {
      this._storeTaskMetrics(task, error2);
    }
    if (this.signatureStats) {
      this.signatureStats.record(task.signature, {
        queueWait: task.timings.queueWait || 0,
        execution: task.timings.execution || 0,
        success: !error2
      });
    }
    if (this.monitoring.enabled) {
      this._safeEmit("pool:taskMetrics", {
        taskId: task.id,
        timings: task.timings,
        performance: task.performance,
        metadata: task.metadata
      });
    }
    this._recordRollingMetrics(task, error2);
  }
  _storeTaskMetrics(task, error2) {
    const timingsSnapshot = {
      ...task.timings,
      retryDelays: task.timings.retryDelays ? task.timings.retryDelays.slice(0) : [],
      failedAttempts: task.timings.failedAttempts ? task.timings.failedAttempts.map((attempt) => ({ ...attempt })) : []
    };
    const performanceSnapshot = task.performance ? { ...task.performance } : { heapUsedBefore: null, heapUsedAfter: null, heapDelta: null };
    this.taskMetrics.set(task.id, {
      id: task.id,
      metadata: task.metadata,
      timings: timingsSnapshot,
      performance: performanceSnapshot,
      attemptCount: task.attemptCount,
      createdAt: task.createdAt,
      startedAt: task.startedAt,
      completedAt: task.completedAt,
      success: !error2
    });
    if (this.taskMetrics.size > 1e3) {
      const oldestKey = this.taskMetrics.keys().next().value;
      if (oldestKey) {
        this.taskMetrics.delete(oldestKey);
      }
    }
  }
  _recordRollingMetrics(task, error2) {
    const entry = {
      queueWait: task.timings.queueWait || 0,
      execution: task.timings.execution || 0,
      retries: (task.attemptCount || 1) - 1,
      success: !error2
    };
    this.rollingMetrics?.push(entry);
    this.rollingWindow?.record(task.completedAt || Date.now(), entry.success);
    this._syncQueueAging();
  }
  async pause() {
    this.paused = true;
    while (this.active.size > 0) {
      await this._waitForActive();
    }
    this._safeEmit("pool:paused");
  }
  resume() {
    this.paused = false;
    this.processNext();
    this._safeEmit("pool:resumed");
  }
  stop() {
    this.stopped = true;
    this.queue.flush((task) => {
      task.reject(new Error("Task cancelled by stop()"));
    });
    this.stats.queueSize = this.queue.length;
    this.active.forEach((task) => {
      if (task.controller && typeof task.controller.abort === "function") {
        task.controller.abort(new Error("Task cancelled by stop()"));
      }
      if (task.delayController && typeof task.delayController.abort === "function") {
        task.delayController.abort(new Error("Task cancelled by stop()"));
      }
    });
    this._safeEmit("pool:stopped");
    if (this.tuner?.stop) {
      this.tuner.stop();
    }
  }
  async drain() {
    while (this.queue.length > 0 || this._currentActiveCount() > 0) {
      await this._waitForActive();
    }
    this._safeEmit("pool:drained");
    this._maybeExportMonitoringSample("drain", true);
  }
  async _waitForActive() {
    if (this._currentActiveCount() === 0)
      return;
    await new Promise((resolve) => {
      this._activeWaiters.push(resolve);
    });
  }
  _notifyActiveWaiters() {
    if (this._activeWaiters.length === 0) {
      return;
    }
    const waiters = this._activeWaiters;
    this._activeWaiters = [];
    for (const resolve of waiters) {
      resolve();
    }
  }
  setConcurrency(n4) {
    if (n4 === "auto") {
      this.autoConcurrency = true;
      this._configuredConcurrency = "auto";
      this._effectiveConcurrency = this._defaultAutoConcurrency();
      this.processNext();
      return;
    }
    if (typeof n4 !== "number" || n4 < 1) {
      throw new Error("Concurrency must be >= 1");
    }
    const normalized = this._normalizeConcurrency(n4);
    this.autoConcurrency = false;
    this._configuredConcurrency = normalized;
    this._effectiveConcurrency = normalized;
    this.processNext();
  }
  getConcurrency() {
    return this.concurrency;
  }
  getStats() {
    return {
      ...this.stats,
      queueSize: this.queue.length,
      activeCount: this._currentActiveCount(),
      concurrency: this.concurrency,
      effectiveConcurrency: this.effectiveConcurrency,
      paused: this.paused,
      stopped: this.stopped,
      rolling: this.getRollingMetrics()
    };
  }
  getTaskMetrics(taskId) {
    return this.taskMetrics.get(taskId);
  }
  getRollingMetrics() {
    return {
      samples: this.rollingMetrics?.snapshot() || null,
      throughput: this.rollingWindow?.snapshot() || null
    };
  }
  getSignatureInsights(limit = 5) {
    if (!this.signatureStats) {
      return [];
    }
    return this.signatureStats.snapshot(limit);
  }
  getAggregateMetrics(since = 0) {
    const tasks = Array.from(this.taskMetrics.values()).filter((t4) => t4.completedAt && t4.completedAt > since);
    if (tasks.length === 0)
      return null;
    return {
      count: tasks.length,
      avgQueueWait: this._avg(tasks.map((t4) => t4.timings.queueWait || 0)),
      avgExecution: this._avg(tasks.map((t4) => t4.timings.execution || 0)),
      avgTotal: this._avg(tasks.map((t4) => t4.timings.total || 0)),
      p50Execution: this._percentile(tasks.map((t4) => t4.timings.execution || 0), 0.5),
      p95Execution: this._percentile(tasks.map((t4) => t4.timings.execution || 0), 0.95),
      p99Execution: this._percentile(tasks.map((t4) => t4.timings.execution || 0), 0.99),
      avgHeapDelta: this._avg(tasks.map((t4) => t4.performance.heapDelta || 0)),
      errorRate: tasks.filter((t4) => t4.timings.failedAttempts && t4.timings.failedAttempts.length > 0).length / tasks.length,
      avgRetries: this._avg(tasks.map((t4) => (t4.attemptCount || 1) - 1)),
      autoTuning: this.tuner ? this.tuner.getMetrics() : null
    };
  }
  _avg(arr) {
    if (arr.length === 0)
      return 0;
    return arr.reduce((a4, b4) => a4 + b4, 0) / arr.length;
  }
  _percentile(arr, p4) {
    if (arr.length === 0)
      return 0;
    const sorted = arr.slice().sort((a4, b4) => a4 - b4);
    const index = Math.ceil(sorted.length * p4) - 1;
    return sorted[Math.max(0, index)];
  }
  _sleep(ms, signal) {
    if (signal && typeof signal.aborted !== "undefined") {
      return (0, import_promises3.setTimeout)(ms, void 0, { signal });
    }
    return (0, import_promises3.setTimeout)(ms);
  }
  _buildTaskContext(task, controller) {
    return {
      id: task.id,
      attempt: task.attemptCount,
      retries: task.retries,
      metadata: task.metadata,
      signal: controller?.signal
    };
  }
  _readHeapUsage(stage) {
    if (!this.memorySampler)
      return null;
    if (this.monitoring.mode === "full") {
      return this.memorySampler.sampleNow();
    }
    if (this.monitoring.mode === "balanced") {
      return stage === "after" ? this.memorySampler.maybeSample() : this.memorySampler.snapshot();
    }
    return this.memorySampler.snapshot();
  }
  _computeHeapDelta(before, after) {
    if (typeof before !== "number" || typeof after !== "number") {
      return null;
    }
    return after - before;
  }
  _shouldEnforceTimeout(timeout) {
    if (this.bareMode) {
      return false;
    }
    if (timeout == null) {
      return false;
    }
    if (!Number.isFinite(timeout)) {
      return false;
    }
    return timeout > 0;
  }
  _computeRetryDelay(task, attempt, error2) {
    const base2 = this.retryDelay * Math.pow(2, attempt);
    const saturation = (this.queue.length + this.active.size) / Math.max(1, this.effectiveConcurrency);
    if (saturation >= this.retryStrategy.pressureSkipThreshold) {
      return null;
    }
    let delayMs = base2;
    const latencyTarget = this._latencyTargetMs();
    if (saturation >= this.retryStrategy.pressureClampThreshold || (task.timings.queueWait || 0) > latencyTarget) {
      delayMs = Math.min(delayMs, this.retryStrategy.clampDelay);
    }
    if (this._isTransientNetworkError(error2)) {
      delayMs = Math.max(this.retryStrategy.minDelay, delayMs * 0.5);
    }
    if (this.retryStrategy.jitter) {
      const jitterWindow = Math.max(1, delayMs * 0.2);
      delayMs = delayMs - jitterWindow / 2 + Math.random() * jitterWindow;
    }
    delayMs = Math.min(Math.max(delayMs, this.retryStrategy.minDelay), this.retryStrategy.maxDelay);
    return delayMs;
  }
  _isTransientNetworkError(error2) {
    const message = `${error2.name || ""} ${error2.code || ""} ${error2.message || ""}`;
    return /timeout|network|throttl|slowdown|temporarily unavailable/i.test(message);
  }
  _latencyTargetMs() {
    if (this.tuner && typeof this.tuner.targetLatency === "number") {
      const target = this.tuner.targetLatency;
      if (target > 0) {
        return target;
      }
    }
    if (this.autoTuningConfig?.targetLatency) {
      return this.autoTuningConfig.targetLatency;
    }
    return this.retryStrategy.latencyTarget;
  }
  _syncQueueAging() {
    if (!this.queue?.setAgingMultiplier || !this.rollingMetrics) {
      return;
    }
    const snapshot = this.rollingMetrics.snapshot();
    if (!snapshot.sampleSize)
      return;
    const target = this._latencyTargetMs();
    if (!target)
      return;
    const ratio = snapshot.avgQueueWait / Math.max(1, target);
    const multiplier = Math.min(4, Math.max(0.25, ratio || 1));
    this.queue.setAgingMultiplier(multiplier);
  }
  _safeEmit(event, ...args) {
    if (!this.features.emitEvents) {
      return;
    }
    super.emit(event, ...args);
  }
  _currentActiveCount() {
    return this.lightMode ? this._lightActiveTasks : this.active.size;
  }
  _maybeExportMonitoringSample(stage, force = false) {
    if (!this.monitoring.enabled || !this.monitoring.exporter) {
      return;
    }
    const now = Date.now();
    if (!force && now - this._monitoringState.lastExport < this.monitoring.reportInterval) {
      return;
    }
    const completed = this.stats.processedCount + this.stats.errorCount;
    const deltaCompleted = completed - this._monitoringState.lastProcessed;
    const elapsed = Math.max(1, now - this._monitoringState.lastExport || this.monitoring.reportInterval);
    const throughput = deltaCompleted > 0 ? deltaCompleted / elapsed * 1e3 : 0;
    const snapshot = {
      timestamp: now,
      stage,
      profile: this.features.profile,
      queueSize: this.queue.length,
      activeCount: this._currentActiveCount(),
      processed: this.stats.processedCount,
      errors: this.stats.errorCount,
      retries: this.stats.retryCount,
      throughput,
      signatureInsights: this.signatureStats ? this.signatureStats.snapshot(this.monitoring.signatureSampleLimit) : []
    };
    this._monitoringState.lastExport = now;
    this._monitoringState.lastProcessed = completed;
    try {
      this.monitoring.exporter(snapshot);
    } catch {
    }
  }
  _applyTunedConcurrency() {
    if (!this.tuner) {
      return;
    }
    const tuned = this.tuner.getConcurrency();
    if (typeof tuned === "number" && tuned > 0 && tuned !== this._lastTunedConcurrency && tuned !== this.effectiveConcurrency) {
      this.setConcurrency(tuned);
      this._lastTunedConcurrency = tuned;
    }
  }
  async process(items, processor, options = {}) {
    const results = [];
    const errors2 = [];
    const promises2 = items.map((item, index) => {
      return this.enqueue(async () => {
        return await processor(item, index, this);
      }, {
        priority: options.priority,
        retries: options.retries,
        timeout: options.timeout,
        metadata: { index, totalCount: options.totalCount || items.length }
      }).then((result) => {
        results.push(result);
        if (options.onSuccess) {
          options.onSuccess(item, result);
        }
        return result;
      }).catch((error2) => {
        errors2.push({ item, error: error2, index });
        if (options.onError) {
          options.onError(item, error2);
        }
      });
    });
    await Promise.all(promises2);
    return { results, errors: errors2 };
  }
  async destroy() {
    this.stop();
    await this.drain();
    this.taskMetrics.clear();
    this.removeAllListeners();
  }
};
var S3Client = class extends import_events.default {
  id;
  logLevel;
  logger;
  config;
  connectionString;
  httpClientOptions;
  client;
  _inflightCoalescing;
  taskExecutorConfig;
  taskExecutor;
  constructor({ logLevel = "info", logger: logger3 = null, id: id2 = null, AwsS3Client: providedClient, connectionString, httpClientOptions = {}, taskExecutor = false, executorPool = null }) {
    super();
    this.logLevel = logLevel;
    const noop2 = () => {
    };
    this.logger = logger3 || {
      debug: noop2,
      info: noop2,
      warn: noop2,
      error: noop2,
      trace: noop2
    };
    this.id = id2 ?? idGenerator(77);
    this.config = new ConnectionString(connectionString);
    this.connectionString = connectionString;
    this.httpClientOptions = {
      keepAlive: true,
      keepAliveMsecs: 1e3,
      maxSockets: httpClientOptions.maxSockets || 50,
      maxFreeSockets: httpClientOptions.maxFreeSockets || 10,
      timeout: 6e4,
      ...httpClientOptions
    };
    this.client = providedClient || this.createClient();
    this._inflightCoalescing = /* @__PURE__ */ new Map();
    const poolConfig = executorPool ?? taskExecutor ?? false;
    this.taskExecutorConfig = this._normalizeTaskExecutorConfig(poolConfig);
    this.taskExecutor = this.taskExecutorConfig.enabled ? this._createTasksPool() : null;
  }
  async _coalesce(key, operationFn) {
    if (this._inflightCoalescing.has(key)) {
      return this._inflightCoalescing.get(key);
    }
    const promise2 = operationFn().finally(() => {
      this._inflightCoalescing.delete(key);
    });
    this._inflightCoalescing.set(key, promise2);
    return promise2;
  }
  _normalizeTaskExecutorConfig(config) {
    const envEnabled = process.env.S3DB_EXECUTOR_ENABLED;
    const envConcurrency = process.env.S3DB_CONCURRENCY;
    if (config === false || typeof config === "object" && config?.enabled === false || envEnabled === "false" || envEnabled === "0") {
      return { enabled: false };
    }
    let defaultConcurrency = 10;
    if (envConcurrency) {
      const parsed = parseInt(envConcurrency, 10);
      if (!isNaN(parsed) && parsed > 0) {
        defaultConcurrency = parsed;
      }
    }
    const configObj = typeof config === "object" ? config : {};
    const normalized = {
      enabled: configObj.enabled ?? true,
      concurrency: configObj.concurrency ?? defaultConcurrency,
      retries: configObj.retries ?? 3,
      retryDelay: configObj.retryDelay ?? 1e3,
      timeout: configObj.timeout ?? 3e4,
      retryableErrors: configObj.retryableErrors ?? [
        "ECONNRESET",
        "ETIMEDOUT",
        "ENOTFOUND",
        "EAI_AGAIN",
        "EPIPE",
        "ECONNREFUSED",
        "SlowDown",
        "ServiceUnavailable",
        "InternalError",
        "RequestTimeout",
        "ThrottlingException",
        "ProvisionedThroughputExceededException"
      ],
      autotune: configObj.autotune ?? null,
      monitoring: configObj.monitoring ?? { collectMetrics: true }
    };
    return normalized;
  }
  _createTasksPool() {
    const poolConfig = {
      concurrency: this.taskExecutorConfig.concurrency,
      retries: this.taskExecutorConfig.retries,
      retryDelay: this.taskExecutorConfig.retryDelay,
      timeout: this.taskExecutorConfig.timeout,
      retryableErrors: this.taskExecutorConfig.retryableErrors,
      monitoring: this.taskExecutorConfig.monitoring
    };
    if (poolConfig.concurrency === "auto") {
      const tuner = new AdaptiveTuning(this.taskExecutorConfig.autotune || {});
      poolConfig.concurrency = tuner.currentConcurrency;
      poolConfig.autotune = tuner;
    } else if (this.taskExecutorConfig.autotune) {
      const tuner = new AdaptiveTuning({
        ...this.taskExecutorConfig.autotune,
        minConcurrency: poolConfig.concurrency
      });
      poolConfig.autotune = tuner;
    }
    const pool3 = new TasksPool(poolConfig);
    pool3.on("pool:taskStarted", (task) => {
      const typedTask = task;
      this.emit("pool:taskStarted", typedTask);
    });
    pool3.on("pool:taskCompleted", (task) => this.emit("pool:taskCompleted", task));
    pool3.on("pool:taskFailed", (task, error2) => this.emit("pool:taskFailed", task, error2));
    pool3.on("pool:taskRetried", (task, attempt) => this.emit("pool:taskRetried", task, attempt));
    return pool3;
  }
  async _executeOperation(fn, options = {}) {
    if (!this.taskExecutor || options.bypassPool) {
      return await fn();
    }
    if (this.logLevel === "debug" || this.logLevel === "trace") {
      const stats2 = this.taskExecutor.getStats();
      if ((stats2.queueSize ?? 0) > 5 || (stats2.activeCount ?? 0) > (stats2.effectiveConcurrency ?? 10) * 0.8) {
        this.logger.debug(`[S3Client] Pool Load: Active=${stats2.activeCount}/${stats2.effectiveConcurrency}, Queue=${stats2.queueSize}, Operation=${options.metadata?.operation || "unknown"}`);
      }
    }
    const enqueueStart = Date.now();
    const result = await this.taskExecutor.enqueue(fn, {
      priority: options.priority ?? 0,
      retries: options.retries,
      timeout: options.timeout,
      metadata: options.metadata || {}
    });
    const totalMs = Date.now() - enqueueStart;
    if (totalMs > 100) {
      const op2 = options.metadata?.operation || "unknown";
      const key = String(options.metadata?.key || "?").substring(0, 50);
      const stats2 = this.taskExecutor?.stats || {};
      this.logger.warn({ op: op2, totalMs, key, queueSize: stats2.queueSize || 0, active: stats2.activeCount || 0 }, `[PERF] S3Client._executeOperation SLOW`);
    }
    return result;
  }
  async _executeBatch(fns, options = {}) {
    const wrapped = fns.map((fn, index) => Promise.resolve().then(() => fn()).then((value) => {
      options.onItemComplete?.(value, index);
      return value;
    }).catch((error2) => {
      options.onItemError?.(error2, index);
      throw error2;
    }));
    const settled = await Promise.allSettled(wrapped);
    const results = settled.map((state2) => state2.status === "fulfilled" ? state2.value : null);
    const errors2 = settled.map((state2, index) => state2.status === "rejected" ? { error: state2.reason, index } : null).filter((e4) => e4 !== null);
    return { results, errors: errors2 };
  }
  getQueueStats() {
    return this.taskExecutor ? this.taskExecutor.getStats() : null;
  }
  getAggregateMetrics(since = 0) {
    return this.taskExecutor ? this.taskExecutor.getAggregateMetrics(since) : null;
  }
  async pausePool() {
    if (!this.taskExecutor)
      return null;
    return this.taskExecutor.pause();
  }
  resumePool() {
    if (!this.taskExecutor)
      return null;
    this.taskExecutor.resume();
  }
  async drainPool() {
    if (!this.taskExecutor)
      return null;
    return this.taskExecutor.drain();
  }
  stopPool() {
    if (!this.taskExecutor)
      return;
    this.taskExecutor.stop();
  }
  destroy() {
    if (this.client && typeof this.client.destroy === "function") {
      this.client.destroy();
    }
    this.stopPool();
    this.removeAllListeners();
  }
  createClient() {
    const httpHandler = new ReckerHttpHandler(this.httpClientOptions);
    const options = {
      region: this.config.region,
      endpoint: this.config.endpoint,
      requestHandler: httpHandler
    };
    if (this.config.forcePathStyle)
      options.forcePathStyle = true;
    if (this.config.accessKeyId) {
      options.credentials = {
        accessKeyId: this.config.accessKeyId,
        secretAccessKey: this.config.secretAccessKey
      };
    }
    const client2 = new import_client_s3.S3Client(options);
    client2.middlewareStack.add((next, context) => async (args) => {
      if (context.commandName === "DeleteObjectsCommand") {
        const body2 = args.request.body;
        if (body2 && typeof body2 === "string") {
          const contentMd5 = await md5(body2);
          args.request.headers["Content-MD5"] = contentMd5;
        }
      }
      return next(args);
    }, {
      step: "build",
      name: "addContentMd5ForDeleteObjects",
      priority: "high"
    });
    return client2;
  }
  async sendCommand(command) {
    this.emit("cl:request", command.constructor.name, command.input);
    const [ok, err, response2] = await tryFn$1(() => this.client.send(command));
    if (!ok) {
      const bucket = this.config.bucket;
      const key = command.input && command.input.Key;
      throw mapAwsError(err, {
        bucket,
        key,
        commandName: command.constructor.name,
        commandInput: command.input
      });
    }
    this.emit("cl:response", command.constructor.name, response2, command.input);
    return response2;
  }
  async putObject(params) {
    const { key, metadata, contentType, body: body2, contentEncoding, contentLength, ifMatch, ifNoneMatch } = params;
    return await this._executeOperation(async () => {
      const keyPrefix = typeof this.config.keyPrefix === "string" ? this.config.keyPrefix : "";
      keyPrefix ? import_path.default.join(keyPrefix, key) : key;
      const stringMetadata = {};
      if (metadata) {
        for (const [k4, v4] of Object.entries(metadata)) {
          const validKey = String(k4).replace(/[^a-zA-Z0-9\-_]/g, "_");
          const { encoded } = metadataEncode(v4);
          stringMetadata[validKey] = encoded;
        }
      }
      const options = {
        Bucket: this.config.bucket,
        Key: keyPrefix ? import_path.default.join(keyPrefix, key) : key,
        Metadata: stringMetadata,
        Body: body2 || Buffer.alloc(0)
      };
      if (contentType !== void 0)
        options.ContentType = contentType;
      if (contentEncoding !== void 0)
        options.ContentEncoding = contentEncoding;
      if (contentLength !== void 0)
        options.ContentLength = contentLength;
      if (ifMatch !== void 0)
        options.IfMatch = ifMatch;
      if (ifNoneMatch !== void 0)
        options.IfNoneMatch = ifNoneMatch;
      const [ok, err, response2] = await tryFn$1(() => this.sendCommand(new import_client_s3.PutObjectCommand(options)));
      this.emit("cl:PutObject", err || response2, { key, metadata, contentType, body: body2, contentEncoding, contentLength });
      if (!ok) {
        throw mapAwsError(err, {
          bucket: this.config.bucket,
          key,
          commandName: "PutObjectCommand",
          commandInput: options
        });
      }
      return response2;
    }, { metadata: { operation: "putObject", key } });
  }
  async getObject(key) {
    const getStart = Date.now();
    this.logger.debug({ key: key?.substring(0, 60) }, `[S3Client.getObject] START`);
    return await this._executeOperation(async () => {
      const keyPrefix = typeof this.config.keyPrefix === "string" ? this.config.keyPrefix : "";
      const options = {
        Bucket: this.config.bucket,
        Key: keyPrefix ? import_path.default.join(keyPrefix, key) : key
      };
      const cmdStart = Date.now();
      const [ok, err, response2] = await tryFn$1(async () => {
        const res = await this.sendCommand(new import_client_s3.GetObjectCommand(options));
        if (res.Metadata) {
          const decodedMetadata = {};
          for (const [k4, value] of Object.entries(res.Metadata)) {
            decodedMetadata[k4] = metadataDecode(value);
          }
          res.Metadata = decodedMetadata;
        }
        return res;
      });
      const cmdMs = Date.now() - cmdStart;
      this.emit("cl:GetObject", err || response2, { key });
      if (!ok) {
        this.logger.debug({ key: key?.substring(0, 60), cmdMs, err: err?.name }, `[S3Client.getObject] ERROR`);
        throw mapAwsError(err, {
          bucket: this.config.bucket,
          key,
          commandName: "GetObjectCommand",
          commandInput: options
        });
      }
      const totalMs = Date.now() - getStart;
      if (totalMs > 50) {
        this.logger.warn({ totalMs, cmdMs, key: key?.substring(0, 60) }, `[PERF] S3Client.getObject SLOW`);
      } else {
        this.logger.debug({ totalMs, key: key?.substring(0, 60) }, `[S3Client.getObject] complete`);
      }
      return response2;
    }, { metadata: { operation: "getObject", key } });
  }
  async headObject(key) {
    return await this._executeOperation(async () => {
      const keyPrefix = typeof this.config.keyPrefix === "string" ? this.config.keyPrefix : "";
      const options = {
        Bucket: this.config.bucket,
        Key: keyPrefix ? import_path.default.join(keyPrefix, key) : key
      };
      const [ok, err, response2] = await tryFn$1(async () => {
        const res = await this.sendCommand(new import_client_s3.HeadObjectCommand(options));
        if (res.Metadata) {
          const decodedMetadata = {};
          for (const [k4, value] of Object.entries(res.Metadata)) {
            decodedMetadata[k4] = metadataDecode(value);
          }
          res.Metadata = decodedMetadata;
        }
        return res;
      });
      this.emit("cl:HeadObject", err || response2, { key });
      if (!ok) {
        throw mapAwsError(err, {
          bucket: this.config.bucket,
          key,
          commandName: "HeadObjectCommand",
          commandInput: options
        });
      }
      return response2;
    }, { metadata: { operation: "headObject", key } });
  }
  async copyObject(params) {
    const { from, to, metadata, metadataDirective, contentType } = params;
    return await this._executeOperation(async () => {
      const keyPrefix = typeof this.config.keyPrefix === "string" ? this.config.keyPrefix : "";
      const options = {
        Bucket: this.config.bucket,
        Key: keyPrefix ? import_path.default.join(keyPrefix, to) : to,
        CopySource: import_path.default.join(this.config.bucket, keyPrefix ? import_path.default.join(keyPrefix, from) : from)
      };
      if (metadataDirective) {
        options.MetadataDirective = metadataDirective;
      }
      if (metadata && typeof metadata === "object") {
        const encodedMetadata = {};
        for (const [k4, value] of Object.entries(metadata)) {
          const { encoded } = metadataEncode(value);
          encodedMetadata[k4] = encoded;
        }
        options.Metadata = encodedMetadata;
      }
      if (contentType) {
        options.ContentType = contentType;
      }
      const [ok, err, response2] = await tryFn$1(() => this.sendCommand(new import_client_s3.CopyObjectCommand(options)));
      this.emit("cl:CopyObject", err || response2, { from, to, metadataDirective });
      if (!ok) {
        throw mapAwsError(err, {
          bucket: this.config.bucket,
          key: to,
          commandName: "CopyObjectCommand",
          commandInput: options
        });
      }
      return response2;
    }, { metadata: { operation: "copyObject", from, to } });
  }
  async exists(key) {
    const [ok, err] = await tryFn$1(() => this.headObject(key));
    if (ok)
      return true;
    if (err.name === "NoSuchKey" || err.name === "NotFound")
      return false;
    throw err;
  }
  async deleteObject(key) {
    return await this._executeOperation(async () => {
      const keyPrefix = typeof this.config.keyPrefix === "string" ? this.config.keyPrefix : "";
      const options = {
        Bucket: this.config.bucket,
        Key: keyPrefix ? import_path.default.join(keyPrefix, key) : key
      };
      const [ok, err, response2] = await tryFn$1(() => this.sendCommand(new import_client_s3.DeleteObjectCommand(options)));
      this.emit("cl:DeleteObject", err || response2, { key });
      if (!ok) {
        throw mapAwsError(err, {
          bucket: this.config.bucket,
          key,
          commandName: "DeleteObjectCommand",
          commandInput: options
        });
      }
      return response2;
    }, { metadata: { operation: "deleteObject", key } });
  }
  async deleteObjects(keys2) {
    const keyPrefix = typeof this.config.keyPrefix === "string" ? this.config.keyPrefix : "";
    const packages = chunk_default(keys2, 1e3);
    const results = [];
    const errors2 = [];
    for (const packageKeys of packages) {
      const [ok, err, response2] = await tryFn$1(async () => {
        return await this._executeOperation(async () => {
          for (const key of packageKeys) {
            await this.exists(key);
          }
          const options = {
            Bucket: this.config.bucket,
            Delete: {
              Objects: packageKeys.map((key) => ({
                Key: keyPrefix ? import_path.default.join(keyPrefix, key) : key
              }))
            }
          };
          const [ok2, err2, res] = await tryFn$1(() => this.sendCommand(new import_client_s3.DeleteObjectsCommand(options)));
          if (!ok2)
            throw err2;
          return res;
        }, { metadata: { operation: "deleteObjects", count: packageKeys.length } });
      });
      if (ok) {
        results.push(response2);
      } else {
        errors2.push({ message: err.message, raw: err });
      }
    }
    const report = {
      deleted: results,
      notFound: errors2
    };
    this.emit("cl:DeleteObjects", report, keys2);
    return report;
  }
  async deleteAll({ prefix } = {}) {
    const keyPrefix = typeof this.config.keyPrefix === "string" ? this.config.keyPrefix : "";
    let continuationToken;
    let totalDeleted = 0;
    do {
      const listCommand = new import_client_s3.ListObjectsV2Command({
        Bucket: this.config.bucket,
        Prefix: keyPrefix ? import_path.default.join(keyPrefix, prefix || "") : prefix || "",
        ContinuationToken: continuationToken
      });
      const listResponse = await this.client.send(listCommand);
      if (listResponse.Contents && listResponse.Contents.length > 0) {
        const deleteCommand = new import_client_s3.DeleteObjectsCommand({
          Bucket: this.config.bucket,
          Delete: {
            Objects: listResponse.Contents.map((obj) => ({ Key: obj.Key }))
          }
        });
        const deleteResponse = await this.client.send(deleteCommand);
        const deletedCount = deleteResponse.Deleted ? deleteResponse.Deleted.length : 0;
        totalDeleted += deletedCount;
        this.emit("cl:DeleteAll", {
          prefix,
          batch: deletedCount,
          total: totalDeleted
        });
      }
      continuationToken = listResponse.IsTruncated ? listResponse.NextContinuationToken : void 0;
    } while (continuationToken);
    this.emit("cl:DeleteAllComplete", {
      prefix,
      totalDeleted
    });
    return totalDeleted;
  }
  async moveObject({ from, to }) {
    const [ok, err] = await tryFn$1(async () => {
      await this.copyObject({ from, to });
      await this.deleteObject(from);
    });
    if (!ok) {
      throw new UnknownError("Unknown error in moveObject", { bucket: this.config.bucket, from, to, original: err });
    }
    return true;
  }
  async listObjects(params = {}) {
    const { prefix, maxKeys = 1e3, continuationToken } = params;
    const listStart = Date.now();
    this.logger.debug({ prefix: prefix?.substring(0, 60), maxKeys }, `[S3Client.listObjects] START`);
    const options = {
      Bucket: this.config.bucket,
      MaxKeys: maxKeys,
      ContinuationToken: continuationToken || void 0,
      Prefix: this.config.keyPrefix ? import_path.default.join(this.config.keyPrefix, prefix || "") : prefix || ""
    };
    const [ok, err, response2] = await tryFn$1(() => this.sendCommand(new import_client_s3.ListObjectsV2Command(options)));
    const totalMs = Date.now() - listStart;
    if (!ok) {
      this.logger.warn({ totalMs, prefix: prefix?.substring(0, 60), err: err?.name }, `[S3Client.listObjects] ERROR`);
      throw new UnknownError("Unknown error in listObjects", { prefix, bucket: this.config.bucket, original: err });
    }
    if (totalMs > 100) {
      this.logger.warn({ totalMs, prefix: prefix?.substring(0, 60), keys: response2?.KeyCount || 0 }, `[PERF] S3Client.listObjects SLOW`);
    } else {
      this.logger.debug({ totalMs, prefix: prefix?.substring(0, 60), keys: response2?.KeyCount || 0 }, `[S3Client.listObjects] complete`);
    }
    this.emit("cl:ListObjects", response2, options);
    return response2;
  }
  async count({ prefix } = {}) {
    let count = 0;
    let truncated = true;
    let continuationToken;
    while (truncated) {
      const options = {
        prefix,
        continuationToken
      };
      const response2 = await this.listObjects(options);
      count += response2.KeyCount || 0;
      truncated = response2.IsTruncated || false;
      continuationToken = response2.NextContinuationToken;
    }
    this.emit("cl:Count", count, { prefix });
    return count;
  }
  async getAllKeys({ prefix } = {}) {
    let keys2 = [];
    let truncated = true;
    let continuationToken;
    let iterations = 0;
    const startTotal = Date.now();
    while (truncated) {
      iterations++;
      const options = {
        prefix,
        continuationToken
      };
      const startList = Date.now();
      const response2 = await this.listObjects(options);
      const listMs = Date.now() - startList;
      if (listMs > 500) {
        this.logger.warn({ iterations, listMs, prefix: prefix?.substring(0, 60) }, `[PERF] S3Client.getAllKeys: listObjects iteration SLOW`);
      }
      if (response2.Contents) {
        keys2 = keys2.concat(response2.Contents.map((x4) => x4.Key));
      }
      truncated = response2.IsTruncated || false;
      continuationToken = response2.NextContinuationToken;
    }
    const totalMs = Date.now() - startTotal;
    if (totalMs > 100) {
      this.logger.warn({ totalMs, iterations, keysCount: keys2.length, prefix: prefix?.substring(0, 60) }, `[PERF] S3Client.getAllKeys SLOW TOTAL`);
    }
    if (this.config.keyPrefix) {
      keys2 = keys2.map((x4) => x4.replace(this.config.keyPrefix, "")).map((x4) => x4.startsWith("/") ? x4.replace("/", "") : x4);
    }
    this.emit("cl:GetAllKeys", keys2, { prefix });
    return keys2;
  }
  async getContinuationTokenAfterOffset(params = {}) {
    const { prefix, offset = 1e3 } = params;
    if (offset === 0)
      return null;
    let truncated = true;
    let continuationToken;
    let skipped = 0;
    while (truncated) {
      const maxKeys = offset < 1e3 ? offset : offset - skipped > 1e3 ? 1e3 : offset - skipped;
      const options = {
        prefix,
        maxKeys,
        continuationToken
      };
      const res = await this.listObjects(options);
      if (res.Contents) {
        skipped += res.Contents.length;
      }
      truncated = res.IsTruncated || false;
      continuationToken = res.NextContinuationToken;
      if (skipped >= offset) {
        break;
      }
    }
    this.emit("cl:GetContinuationTokenAfterOffset", continuationToken || null, params);
    return continuationToken || null;
  }
  async getKeysPage(params = {}) {
    const pageStart = Date.now();
    const { prefix, offset = 0, amount = 100 } = params;
    this.logger.debug({ prefix: prefix?.substring(0, 60), offset, amount }, `[S3Client.getKeysPage] START`);
    let keys2 = [];
    let truncated = true;
    let continuationToken;
    let iterations = 0;
    if (offset > 0) {
      const tokenStart = Date.now();
      continuationToken = await this.getContinuationTokenAfterOffset({
        prefix,
        offset
      }) || void 0;
      const tokenMs = Date.now() - tokenStart;
      this.logger.debug({ tokenMs, hasToken: !!continuationToken }, `[S3Client.getKeysPage] getContinuationTokenAfterOffset`);
      if (!continuationToken) {
        this.emit("cl:GetKeysPage", [], params);
        return [];
      }
    }
    while (truncated) {
      iterations++;
      const options = {
        prefix,
        continuationToken
      };
      const res = await this.listObjects(options);
      if (res.Contents) {
        keys2 = keys2.concat(res.Contents.map((x4) => x4.Key));
      }
      truncated = res.IsTruncated || false;
      continuationToken = res.NextContinuationToken;
      if (keys2.length >= amount) {
        keys2 = keys2.slice(0, amount);
        break;
      }
    }
    if (this.config.keyPrefix) {
      keys2 = keys2.map((x4) => x4.replace(this.config.keyPrefix, "")).map((x4) => x4.startsWith("/") ? x4.replace("/", "") : x4);
    }
    const totalMs = Date.now() - pageStart;
    if (totalMs > 100) {
      this.logger.warn({ totalMs, iterations, keysCount: keys2.length, prefix: prefix?.substring(0, 60) }, `[PERF] S3Client.getKeysPage SLOW`);
    } else {
      this.logger.debug({ totalMs, iterations, keysCount: keys2.length }, `[S3Client.getKeysPage] complete`);
    }
    this.emit("cl:GetKeysPage", keys2, params);
    return keys2;
  }
  async moveAllObjects({ prefixFrom, prefixTo }) {
    const keys2 = await this.getAllKeys({ prefix: prefixFrom });
    const results = [];
    const errors2 = [];
    for (const key of keys2) {
      const to = key.replace(prefixFrom, prefixTo);
      const [ok, err] = await tryFn$1(async () => {
        await this.moveObject({
          from: key,
          to
        });
      });
      if (ok) {
        results.push(to);
      } else {
        errors2.push({
          message: err.message,
          raw: err,
          item: key
        });
      }
    }
    this.emit("cl:MoveAllObjects", { results, errors: errors2 }, { prefixFrom, prefixTo });
    if (errors2.length > 0) {
      throw new UnknownError("Some objects could not be moved", {
        bucket: this.config.bucket,
        operation: "moveAllObjects",
        prefixFrom,
        prefixTo,
        totalKeys: keys2.length,
        failedCount: errors2.length,
        successCount: results.length,
        errors: errors2.map((e4) => ({ message: e4.message, raw: e4.raw })),
        suggestion: "Check S3 permissions and retry failed objects individually"
      });
    }
    return results;
  }
};
var TasksRunner = class _TasksRunner extends import_events.EventEmitter {
  static notRun = /* @__PURE__ */ Symbol("notRun");
  static failed = /* @__PURE__ */ Symbol("failed");
  features;
  lightMode;
  bareMode;
  concurrency;
  retries;
  retryDelay;
  timeout;
  retryableErrors;
  active;
  paused;
  stopped;
  stats;
  processedItems;
  taskMetrics;
  monitoring;
  signatureStats;
  tuner;
  autoTuningConfig;
  _queue;
  _activeWaiters;
  _activeLightTasks;
  _taskMetricsOrder;
  _monitoringState;
  _lastTunedConcurrency;
  constructor(options = {}) {
    super();
    const requestedRetries = options.retries ?? 3;
    const monitoringRequested = options.monitoring?.enabled ?? false;
    const requestedMonitoringMode = options.monitoring?.mode;
    const requestedProfile = options.features?.profile;
    const autoTuningRequested = options.autoTuning?.enabled || options.autoTuning?.instance;
    const needsRichProfile = requestedRetries > 0 || !!options.priority || autoTuningRequested;
    let profile = requestedProfile || (needsRichProfile ? "balanced" : "light");
    const defaultMonitoringMode = options.monitoring?.collectMetrics || options.monitoring?.mode === "detailed" ? "detailed" : "passive";
    const monitoringMode = monitoringRequested ? requestedMonitoringMode || defaultMonitoringMode : "light";
    if (profile === "light" && monitoringRequested && monitoringMode !== "passive") {
      profile = "balanced";
    }
    this.features = {
      profile,
      emitEvents: options.features?.emitEvents ?? profile !== "bare",
      trackProcessedItems: options.features?.trackProcessedItems ?? (profile !== "light" && profile !== "bare"),
      signatureInsights: options.features?.signatureInsights ?? true
    };
    this.lightMode = this.features.profile === "light" || this.features.profile === "bare";
    this.bareMode = this.features.profile === "bare";
    this.concurrency = options.concurrency || 5;
    this.retries = requestedRetries;
    this.retryDelay = options.retryDelay || 1e3;
    this.timeout = options.timeout ?? 3e4;
    this.retryableErrors = options.retryableErrors || [];
    this._queue = this.lightMode ? new FifoTaskQueue() : new PriorityTaskQueue();
    this.active = /* @__PURE__ */ new Set();
    this.paused = false;
    this.stopped = false;
    this._activeWaiters = [];
    this.stats = {
      queueSize: 0,
      activeCount: 0,
      processedCount: 0,
      errorCount: 0,
      retryCount: 0
    };
    this.processedItems = this.features.trackProcessedItems ? [] : null;
    this.taskMetrics = /* @__PURE__ */ new Map();
    const monitoringEnabled = !this.bareMode && monitoringRequested;
    const collectMetricsRequested = options.monitoring?.collectMetrics ?? false;
    const collectMetrics = monitoringEnabled && (collectMetricsRequested || monitoringMode === "detailed");
    this.monitoring = {
      enabled: monitoringEnabled,
      mode: monitoringMode,
      collectMetrics,
      sampleRate: this._normalizeSampleRate(options.monitoring?.sampleRate ?? 1),
      maxSamples: Math.max(1, options.monitoring?.maxSamples ?? 512),
      rollingWindowMs: options.monitoring?.rollingWindowMs ?? 1e3,
      reportInterval: options.monitoring?.reportInterval ?? 1e3,
      telemetryRate: this._normalizeSampleRate(options.monitoring?.telemetrySampleRate ?? (collectMetrics || autoTuningRequested ? 1 : 0.2)),
      signatureSampleLimit: Math.max(1, options.monitoring?.signatureSampleLimit ?? 8),
      exporter: typeof options.monitoring?.exporter === "function" ? options.monitoring.exporter : null
    };
    this._taskMetricsOrder = [];
    this._activeLightTasks = 0;
    this._monitoringState = {
      lastExport: 0,
      lastProcessed: 0
    };
    this.signatureStats = this.features.signatureInsights ? new SignatureStats({
      alpha: options.monitoring?.signatureAlpha,
      maxEntries: options.monitoring?.signatureMaxEntries
    }) : null;
    this.tuner = null;
    this._lastTunedConcurrency = null;
    const tunerInstance = options.autoTuning?.instance;
    if (!this.bareMode && autoTuningRequested) {
      this.autoTuningConfig = options.autoTuning;
      this.tuner = tunerInstance || new AdaptiveTuning(options.autoTuning);
      const tunedConcurrency = this.tuner.getConcurrency();
      if (typeof tunedConcurrency === "number" && tunedConcurrency > 0) {
        this.setConcurrency(tunedConcurrency);
        this._lastTunedConcurrency = tunedConcurrency;
      }
    }
  }
  get queue() {
    if (typeof this._queue.toArray === "function") {
      return this._queue.toArray();
    }
    if (Array.isArray(this._queue.heap)) {
      return this._queue.heap.map((node) => node.task);
    }
    return [];
  }
  async process(items, processor, options) {
    const iterableOptions = {
      ...options,
      totalCount: typeof items?.length === "number" && Number.isFinite(items.length) ? items.length : options?.totalCount
    };
    return await this.processIterable(items, processor, iterableOptions);
  }
  async enqueue(fn, options = {}) {
    const taskMetadata = {
      ...options.metadata || {}
    };
    const task = {
      id: nanoid(),
      fn,
      priority: options.priority || 0,
      retries: options.retries ?? this.retries,
      timeout: options.timeout ?? this.timeout,
      metadata: taskMetadata,
      attemptCount: 0,
      createdAt: Date.now(),
      signature: "",
      promise: null,
      resolve: null,
      reject: null
    };
    task.signature = deriveSignature(fn, taskMetadata, options.signature, task.priority);
    this._primeTaskTelemetry(task);
    let resolve;
    let reject;
    const promise2 = new Promise((res, rej) => {
      resolve = res;
      reject = rej;
    });
    task.promise = promise2;
    task.resolve = resolve;
    task.reject = reject;
    this._insertByPriority(task);
    this.stats.queueSize = this._queue.length;
    this.processNext();
    return promise2;
  }
  async processIterable(iterable, processor, options = {}) {
    const results = [];
    const errors2 = [];
    let index = 0;
    let processedCount = 0;
    const totalCount = typeof options.totalCount === "number" && options.totalCount >= 0 ? options.totalCount : null;
    const reportProgress = (item) => {
      processedCount++;
      if (!options.onProgress)
        return;
      const percentage = totalCount != null && totalCount > 0 ? (processedCount / totalCount * 100).toFixed(2) : null;
      options.onProgress(item, {
        processedCount,
        totalCount,
        percentage
      });
    };
    for await (const item of iterable) {
      if (this.stopped)
        break;
      const currentIndex = index;
      this.enqueue(async () => {
        return await processor(item, currentIndex, this);
      }, {
        priority: options.priority,
        retries: options.retries,
        timeout: options.timeout,
        metadata: { item, index: currentIndex, itemLength: extractLengthHint(item) }
      }).then((result) => {
        results.push(result);
        options.onItemComplete?.(item, result);
        reportProgress(item);
      }).catch((error2) => {
        errors2.push({ item, error: error2, index: currentIndex });
        options.onItemError?.(item, error2);
        reportProgress(item);
      });
      index++;
      if (this._currentActiveCount() >= this.concurrency) {
        await this._waitForSlot();
      }
    }
    await this.drain();
    return { results, errors: errors2 };
  }
  async processCorresponding(items, processor, options = {}) {
    const results = Array(items.length).fill(_TasksRunner.notRun);
    for (let index = 0; index < items.length; index++) {
      if (this.stopped)
        break;
      const item = items[index];
      this.enqueue(async () => {
        return await processor(item, index, this);
      }, {
        priority: options.priority,
        retries: options.retries,
        timeout: options.timeout,
        metadata: { item, index, itemLength: extractLengthHint(item) }
      }).then((result) => {
        results[index] = result;
      }).catch((error2) => {
        results[index] = _TasksRunner.failed;
        options.onItemError?.(item, error2);
      });
      if (this._currentActiveCount() >= this.concurrency) {
        await this._waitForSlot();
      }
    }
    await this.drain();
    return results;
  }
  processNext() {
    if (this.lightMode) {
      this._processLightQueue();
      return;
    }
    while (!this.paused && !this.stopped && this.active.size < this.concurrency && this._queue.length > 0) {
      const task = this._queue.dequeue();
      if (!task)
        break;
      this.stats.queueSize = this._queue.length;
      this._markTaskDequeued(task);
      const taskPromise = this._executeTaskWithRetry(task);
      this.active.add(taskPromise);
      this.stats.activeCount = this.active.size;
      this._safeEmit("taskStart", task);
      taskPromise.then((result) => {
        this.active.delete(taskPromise);
        this.stats.activeCount = this.active.size;
        this.stats.processedCount++;
        if (this.processedItems) {
          this.processedItems.push(task.metadata.item);
        }
        this._recordTaskMetrics(task, true);
        task.resolve(result);
        this._safeEmit("taskComplete", task, result);
      }).catch((error2) => {
        this.active.delete(taskPromise);
        this.stats.activeCount = this.active.size;
        this.stats.errorCount++;
        this._recordTaskMetrics(task, false, error2);
        task.reject(error2);
        this._safeEmit("taskError", task, error2);
      }).finally(() => {
        this._maybeExportMonitoringSample("task");
        this._notifyActiveWaiters();
        this.processNext();
        if (this.active.size === 0 && this._queue.length === 0) {
          this._safeEmit("drained");
        }
      });
    }
  }
  _processLightQueue() {
    if (this.paused || this.stopped) {
      return;
    }
    if (this.bareMode) {
      this._processBareQueue();
      return;
    }
    while (this._queue.length > 0 && this._activeLightTasks < this.concurrency) {
      const task = this._queue.dequeue();
      if (!task)
        break;
      this._markTaskDequeued(task);
      this._activeLightTasks++;
      this.stats.activeCount = this._activeLightTasks;
      this.stats.queueSize = this._queue.length;
      const taskPromise = this._executeTaskWithRetry(task);
      this._safeEmit("taskStart", task);
      taskPromise.then((result) => {
        this.stats.processedCount++;
        if (this.processedItems) {
          this.processedItems.push(task.metadata.item);
        }
        this._recordTaskMetrics(task, true);
        task.resolve(result);
        this._safeEmit("taskComplete", task, result);
      }).catch((error2) => {
        this.stats.errorCount++;
        this._recordTaskMetrics(task, false, error2);
        task.reject(error2);
        this._safeEmit("taskError", task, error2);
      }).finally(() => {
        this._maybeExportMonitoringSample("task");
        this._activeLightTasks--;
        this.stats.activeCount = this._activeLightTasks;
        this._notifyActiveWaiters();
        if (this._activeLightTasks === 0 && this._queue.length === 0) {
          this._safeEmit("drained");
        } else {
          this._processLightQueue();
        }
      });
    }
  }
  _processBareQueue() {
    while (this._queue.length > 0 && this._activeLightTasks < this.concurrency) {
      const task = this._queue.dequeue();
      if (!task)
        break;
      this._activeLightTasks++;
      const taskPromise = this._executeBareTask(task);
      taskPromise.then((result) => {
        task.resolve(result);
      }).catch((error2) => {
        task.reject(error2);
      }).finally(() => {
        this._activeLightTasks--;
        this._notifyActiveWaiters();
        if (this._activeLightTasks === 0 && this._queue.length === 0) {
          this._safeEmit("drained");
        } else {
          this._processBareQueue();
        }
      });
    }
  }
  _currentActiveCount() {
    return this.lightMode ? this._activeLightTasks : this.active.size;
  }
  _maybeExportMonitoringSample(stage, force = false) {
    if (!this.monitoring.enabled || !this.monitoring.exporter) {
      return;
    }
    const now = Date.now();
    if (!force && now - this._monitoringState.lastExport < this.monitoring.reportInterval) {
      return;
    }
    const completed = this.stats.processedCount + this.stats.errorCount;
    const deltaCompleted = completed - this._monitoringState.lastProcessed;
    const elapsed = Math.max(1, now - this._monitoringState.lastExport || this.monitoring.reportInterval);
    const throughput = deltaCompleted > 0 ? deltaCompleted / elapsed * 1e3 : 0;
    const snapshot = {
      timestamp: now,
      stage,
      profile: this.features.profile,
      queueSize: this._queue.length,
      activeCount: this._currentActiveCount(),
      processed: this.stats.processedCount,
      errors: this.stats.errorCount,
      retries: this.stats.retryCount,
      throughput,
      signatureInsights: this.signatureStats ? this.signatureStats.snapshot(this.monitoring.signatureSampleLimit) : []
    };
    this._monitoringState.lastExport = now;
    this._monitoringState.lastProcessed = completed;
    try {
      this.monitoring.exporter(snapshot);
    } catch {
    }
  }
  async _executeTaskWithRetry(task) {
    if (this.bareMode || task.retries === 0 && !this._shouldEnforceTimeout(task.timeout)) {
      return await this._runSingleAttempt(task);
    }
    let lastError;
    for (let attempt = 0; attempt <= task.retries; attempt++) {
      task.attemptCount = attempt + 1;
      const attemptStartedAt = this.monitoring.enabled ? Date.now() : 0;
      try {
        const result = await this._runSingleAttempt(task);
        return result;
      } catch (error2) {
        lastError = error2;
        const isRetryable = this._isErrorRetryable(error2);
        const hasRetriesLeft = attempt < task.retries;
        if (this.monitoring.enabled && task.telemetry) {
          task.telemetry.failedAttempts.push({
            attempt: attempt + 1,
            duration: Date.now() - attemptStartedAt,
            errorName: error2?.name || error2?.constructor?.name || "Error",
            errorMessage: error2?.message || ""
          });
        }
        if (isRetryable && hasRetriesLeft) {
          this.stats.retryCount++;
          this._safeEmit("taskRetry", task, attempt + 1);
          const delayMs = this.retryDelay * Math.pow(2, attempt);
          await this._sleep(delayMs);
        } else {
          throw error2;
        }
      }
    }
    throw lastError;
  }
  async _runSingleAttempt(task) {
    const operation2 = task.fn();
    if (!this._shouldEnforceTimeout(task.timeout)) {
      return await operation2;
    }
    return await this._executeWithTimeout(operation2, task.timeout, task);
  }
  async _executeBareTask(task) {
    return await this._runSingleAttempt(task);
  }
  _shouldEnforceTimeout(timeout) {
    if (this.bareMode) {
      return false;
    }
    if (timeout == null) {
      return false;
    }
    if (!Number.isFinite(timeout)) {
      return false;
    }
    return timeout > 0;
  }
  async _executeWithTimeout(promise2, timeout, task) {
    let timerId;
    const timeoutPromise = new Promise((_, reject) => {
      timerId = setTimeout(() => {
        reject(new Error(`Task ${task.id} timed out after ${timeout}ms`));
      }, timeout);
    });
    try {
      return await Promise.race([promise2, timeoutPromise]);
    } finally {
      clearTimeout(timerId);
    }
  }
  _isErrorRetryable(error2) {
    if (this.retryableErrors.length === 0) {
      return true;
    }
    return this.retryableErrors.some((errorType) => {
      return error2.name === errorType || error2.code === errorType || error2.constructor.name === errorType;
    });
  }
  _insertByPriority(task) {
    this._queue.enqueue(task);
  }
  async _waitForSlot() {
    while (this._currentActiveCount() >= this.concurrency) {
      await this._waitForActive();
    }
  }
  async _waitForActive() {
    if (this._currentActiveCount() === 0)
      return;
    await new Promise((resolve) => {
      this._activeWaiters.push(resolve);
    });
  }
  _notifyActiveWaiters() {
    if (this._activeWaiters.length === 0) {
      return;
    }
    const waiters = this._activeWaiters;
    this._activeWaiters = [];
    for (const resolve of waiters) {
      resolve();
    }
  }
  _sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
  _primeTaskTelemetry(task) {
    if (!this.monitoring.enabled && !this.tuner && !this.signatureStats) {
      return;
    }
    if (!this._shouldTrackTelemetry()) {
      return;
    }
    task.telemetry = {
      enqueuedAt: task.createdAt,
      failedAttempts: []
    };
  }
  _markTaskDequeued(task) {
    if (!task.telemetry) {
      return;
    }
    if (typeof task.telemetry.enqueuedAt !== "number") {
      task.telemetry.enqueuedAt = task.createdAt || Date.now();
    }
    task.telemetry.startedAt = Date.now();
  }
  _shouldSampleMetrics() {
    if (!this.monitoring.collectMetrics) {
      return false;
    }
    if (this.monitoring.sampleRate >= 1) {
      return true;
    }
    if (this.monitoring.sampleRate <= 0) {
      return false;
    }
    return Math.random() < this.monitoring.sampleRate;
  }
  _shouldTrackTelemetry() {
    if (!this.monitoring.enabled && !this.tuner && !this.signatureStats) {
      return false;
    }
    if (this.tuner || this.monitoring.mode === "detailed" || this.monitoring.collectMetrics) {
      return true;
    }
    if (this.monitoring.telemetryRate >= 1) {
      return true;
    }
    if (this.monitoring.telemetryRate <= 0) {
      return false;
    }
    return Math.random() < this.monitoring.telemetryRate;
  }
  _storeTaskMetric(entry) {
    this.taskMetrics.set(entry.id, entry);
    this._taskMetricsOrder.push(entry.id);
    if (this._taskMetricsOrder.length > this.monitoring.maxSamples) {
      const oldest = this._taskMetricsOrder.shift();
      if (oldest) {
        this.taskMetrics.delete(oldest);
      }
    }
  }
  _recordTaskMetrics(task, success, error2) {
    if (!this.monitoring.enabled && !this.tuner && !this.signatureStats) {
      return;
    }
    if (!task.telemetry) {
      if (this.signatureStats) {
        this.signatureStats.record(task.signature, { success });
      }
      return;
    }
    const telemetry = task.telemetry || {};
    const completedAt = Date.now();
    const enqueuedAt = typeof telemetry.enqueuedAt === "number" ? telemetry.enqueuedAt : task.createdAt || completedAt;
    const startedAt = typeof telemetry.startedAt === "number" ? telemetry.startedAt : completedAt;
    const queueWait = Math.max(0, startedAt - enqueuedAt);
    const execution = Math.max(0, completedAt - startedAt);
    const total = Math.max(0, completedAt - (task.createdAt || enqueuedAt));
    let entry = null;
    if (this.monitoring.enabled) {
      entry = {
        id: task.id,
        completedAt,
        success,
        attemptCount: task.attemptCount,
        timings: {
          queueWait,
          execution,
          total,
          failedAttempts: telemetry.failedAttempts || []
        },
        performance: {},
        error: success ? null : {
          name: error2?.name || error2?.constructor?.name || "Error",
          message: error2?.message || ""
        }
      };
      if (this._shouldSampleMetrics()) {
        this._storeTaskMetric(entry);
      }
    }
    if (this.tuner?.recordTaskMetrics) {
      try {
        this.tuner.recordTaskMetrics({
          latency: execution,
          queueWait,
          success,
          retries: (task.attemptCount || 1) - 1,
          heapDelta: entry?.performance?.heapDelta || 0
        });
      } catch (tunerError) {
        this._safeEmit("tuner:error", tunerError);
      }
      this._applyTunedConcurrency();
    }
    if (this.signatureStats) {
      this.signatureStats.record(task.signature, {
        queueWait,
        execution,
        success
      });
    }
    delete task.telemetry;
  }
  async pause() {
    this.paused = true;
    while (this.active.size > 0) {
      await this._waitForActive();
    }
    this._safeEmit("paused");
  }
  resume() {
    this.paused = false;
    this.processNext();
    this._safeEmit("resumed");
  }
  stop() {
    this.stopped = true;
    this._queue.flush((task) => {
      task.promise?.catch(() => {
      });
      task.reject(new Error("Task cancelled by stop()"));
    });
    this.stats.queueSize = this._queue.length;
    this._safeEmit("stopped");
  }
  async drain() {
    while (this._queue.length > 0 || this._currentActiveCount() > 0) {
      await this._waitForActive();
    }
    this._safeEmit("drained");
  }
  setConcurrency(n4) {
    if (n4 < 1) {
      throw new Error("Concurrency must be >= 1");
    }
    this.concurrency = n4;
    this.processNext();
  }
  getConcurrency() {
    return this.concurrency;
  }
  getStats() {
    return {
      ...this.stats,
      queueSize: this._queue.length,
      activeCount: this._currentActiveCount(),
      concurrency: this.concurrency,
      paused: this.paused,
      stopped: this.stopped,
      rolling: this.getRollingMetrics()
    };
  }
  getRollingMetrics() {
    if (!this.monitoring.enabled || !this.monitoring.collectMetrics) {
      return null;
    }
    const entries = Array.from(this.taskMetrics.values());
    if (entries.length === 0) {
      return {
        sampleSize: 0,
        avgQueueWait: 0,
        avgExecution: 0,
        avgRetries: 0,
        errorRate: 0
      };
    }
    return {
      sampleSize: entries.length,
      avgQueueWait: this._avg(entries.map((t4) => t4.timings.queueWait || 0)),
      avgExecution: this._avg(entries.map((t4) => t4.timings.execution || 0)),
      avgRetries: this._avg(entries.map((t4) => (t4.attemptCount || 1) - 1)),
      errorRate: entries.filter((t4) => !t4.success).length / entries.length
    };
  }
  getSignatureInsights(limit = 5) {
    if (!this.signatureStats) {
      return [];
    }
    return this.signatureStats.snapshot(limit);
  }
  getAggregateMetrics(since = 0) {
    if (!this.monitoring.enabled || !this.monitoring.collectMetrics) {
      return null;
    }
    const entries = Array.from(this.taskMetrics.values()).filter((entry) => !since || (entry.completedAt || 0) > since);
    if (entries.length === 0) {
      return null;
    }
    const executions = entries.map((entry) => entry.timings.execution || 0);
    return {
      count: entries.length,
      avgQueueWait: this._avg(entries.map((entry) => entry.timings.queueWait || 0)),
      avgExecution: this._avg(executions),
      avgTotal: this._avg(entries.map((entry) => entry.timings.total || 0)),
      p50Execution: this._percentile(executions, 0.5),
      p95Execution: this._percentile(executions, 0.95),
      p99Execution: this._percentile(executions, 0.99),
      errorRate: entries.filter((entry) => !entry.success).length / entries.length,
      avgRetries: this._avg(entries.map((entry) => (entry.attemptCount || 1) - 1))
    };
  }
  getProgress() {
    const total = this.stats.processedCount + this.stats.errorCount + this._queue.length + this._currentActiveCount();
    const completed = this.stats.processedCount + this.stats.errorCount;
    return {
      total,
      completed,
      pending: this._queue.length,
      active: this._currentActiveCount(),
      percentage: total > 0 ? (completed / total * 100).toFixed(2) : 0
    };
  }
  reset() {
    this._queue = this.lightMode ? new FifoTaskQueue() : new PriorityTaskQueue();
    this.active.clear();
    this.paused = false;
    this.stopped = false;
    this.processedItems = this.features.trackProcessedItems ? [] : null;
    this.taskMetrics.clear();
    this._taskMetricsOrder = [];
    this.signatureStats?.reset();
    this._activeWaiters = [];
    this._activeLightTasks = 0;
    this.stats = {
      queueSize: 0,
      activeCount: 0,
      processedCount: 0,
      errorCount: 0,
      retryCount: 0
    };
  }
  async destroy() {
    this.stop();
    this.removeAllListeners();
    if (this.tuner?.stop) {
      this.tuner.stop();
    }
  }
  _safeEmit(event, ...args) {
    if (!this.features.emitEvents) {
      return;
    }
    super.emit(event, ...args);
  }
  _applyTunedConcurrency() {
    if (!this.tuner) {
      return;
    }
    const tuned = this.tuner.getConcurrency();
    if (typeof tuned === "number" && tuned > 0 && tuned !== this._lastTunedConcurrency && tuned !== this.concurrency) {
      this.setConcurrency(tuned);
      this._lastTunedConcurrency = tuned;
    }
  }
  _normalizeSampleRate(value) {
    if (typeof value !== "number" || Number.isNaN(value)) {
      return 1;
    }
    if (value <= 0)
      return 0;
    if (value >= 1)
      return 1;
    return value;
  }
  _avg(arr) {
    if (!arr || arr.length === 0) {
      return 0;
    }
    const sum = arr.reduce((a4, b4) => a4 + b4, 0);
    return sum / arr.length;
  }
  _percentile(arr, p4) {
    if (!arr || arr.length === 0) {
      return 0;
    }
    const sorted = arr.slice().sort((a4, b4) => a4 - b4);
    const index = Math.min(sorted.length - 1, Math.max(0, Math.ceil(sorted.length * p4) - 1));
    return sorted[index] ?? 0;
  }
  static async process(items, processor, options = {}) {
    const runner = new _TasksRunner(options);
    const result = await runner.process(items, processor, options);
    runner.destroy();
    return result;
  }
  static withConcurrency(concurrency) {
    return new _TasksRunner({ concurrency });
  }
};
var MemoryStorage2 = class {
  objects;
  bucket;
  enforceLimits;
  metadataLimit;
  maxObjectSize;
  persistPath;
  autoPersist;
  logLevel;
  maxMemoryMB;
  maxMemoryBytes;
  currentMemoryBytes;
  evictionEnabled;
  _stats;
  logger;
  constructor(config = {}) {
    this.objects = /* @__PURE__ */ new Map();
    this.bucket = config.bucket || "s3db";
    this.enforceLimits = Boolean(config.enforceLimits);
    this.metadataLimit = config.metadataLimit ?? 2048;
    this.maxObjectSize = config.maxObjectSize ?? 5 * 1024 * 1024 * 1024;
    this.persistPath = config.persistPath;
    this.autoPersist = Boolean(config.autoPersist);
    this.logLevel = config.logLevel || "info";
    this.maxMemoryMB = config.maxMemoryMB ?? 512;
    this.maxMemoryBytes = this.maxMemoryMB * 1024 * 1024;
    this.currentMemoryBytes = 0;
    this.evictionEnabled = config.evictionEnabled !== false;
    this._stats = {
      evictions: 0,
      evictedBytes: 0,
      peakMemoryBytes: 0
    };
    if (config.logger) {
      this.logger = config.logger;
    } else {
      this.logger = createLogger({ name: "MemoryStorage", level: this.logLevel });
    }
  }
  _generateETag(body2) {
    const buffer = this._toBuffer(body2);
    return (0, import_crypto.createHash)("md5").update(buffer).digest("hex");
  }
  _toBuffer(body2) {
    if (Buffer.isBuffer(body2)) {
      return body2;
    }
    if (body2 === void 0 || body2 === null) {
      return Buffer.alloc(0);
    }
    return Buffer.from(body2);
  }
  _formatEtag(etag) {
    return `"${etag}"`;
  }
  _normalizeEtagHeader(headerValue) {
    if (headerValue === void 0 || headerValue === null) {
      return [];
    }
    return String(headerValue).split(",").map((value) => value.trim()).filter(Boolean).map((value) => value.replace(/^W\//i, "").replace(/^['"]|['"]$/g, ""));
  }
  _encodeContinuationToken(key) {
    return Buffer.from(String(key), "utf8").toString("base64");
  }
  _decodeContinuationToken(token) {
    try {
      const normalized = String(token).trim();
      const decoded = Buffer.from(normalized, "base64").toString("utf8");
      const reencoded = Buffer.from(decoded, "utf8").toString("base64").replace(/=+$/, "");
      const normalizedNoPad = normalized.replace(/=+$/, "");
      if (!decoded || reencoded !== normalizedNoPad) {
        throw new Error("Invalid continuation token format");
      }
      return decoded;
    } catch (error2) {
      throw new ValidationError2("Invalid continuation token", {
        field: "ContinuationToken",
        retriable: false,
        suggestion: "Use the NextContinuationToken returned by a previous ListObjectsV2 response.",
        original: error2
      });
    }
  }
  _extractCommonPrefix(prefix, delimiter, key) {
    if (!delimiter)
      return null;
    const hasPrefix = Boolean(prefix);
    if (hasPrefix && !key.startsWith(prefix)) {
      return null;
    }
    const remainder = hasPrefix ? key.slice(prefix.length) : key;
    const index = remainder.indexOf(delimiter);
    if (index === -1) {
      return null;
    }
    const baseLength = hasPrefix ? prefix.length : 0;
    return key.slice(0, baseLength + index + delimiter.length);
  }
  _calculateMetadataSize(metadata) {
    if (!metadata)
      return 0;
    let size = 0;
    for (const [key, value] of Object.entries(metadata)) {
      size += Buffer.byteLength(key, "utf8");
      size += Buffer.byteLength(String(value), "utf8");
    }
    return size;
  }
  _validateLimits(body2, metadata) {
    if (!this.enforceLimits)
      return;
    const metadataSize = this._calculateMetadataSize(metadata);
    if (metadataSize > this.metadataLimit) {
      throw new MetadataLimitError("Metadata limit exceeded in memory storage", {
        bucket: this.bucket,
        totalSize: metadataSize,
        effectiveLimit: this.metadataLimit,
        operation: "put",
        retriable: false,
        suggestion: "Reduce metadata size or disable enforceLimits in MemoryClient configuration."
      });
    }
    const bodySize = Buffer.isBuffer(body2) ? body2.length : Buffer.byteLength(body2 || "", "utf8");
    if (bodySize > this.maxObjectSize) {
      throw new ResourceError("Object size exceeds in-memory limit", {
        bucket: this.bucket,
        operation: "put",
        size: bodySize,
        maxObjectSize: this.maxObjectSize,
        statusCode: 413,
        retriable: false,
        suggestion: "Store smaller objects or increase maxObjectSize when instantiating MemoryClient."
      });
    }
  }
  async put(key, params) {
    const { body: body2, metadata, contentType, contentEncoding, contentLength, ifMatch, ifNoneMatch } = params;
    this._validateLimits(body2, metadata);
    const existing = this.objects.get(key);
    if (ifMatch !== void 0) {
      const expectedEtags = this._normalizeEtagHeader(ifMatch);
      const currentEtag = existing ? existing.etag : null;
      const matches = expectedEtags.length > 0 && currentEtag ? expectedEtags.includes(currentEtag) : false;
      if (!existing || !matches) {
        throw new ResourceError(`Precondition failed: ETag mismatch for key "${key}"`, {
          bucket: this.bucket,
          key,
          code: "PreconditionFailed",
          statusCode: 412,
          retriable: false,
          suggestion: "Fetch the latest object and retry with the current ETag in options.ifMatch."
        });
      }
    }
    if (ifNoneMatch !== void 0) {
      const normalized = this._normalizeEtagHeader(ifNoneMatch);
      const targetValue = existing ? existing.etag : null;
      const shouldFail = ifNoneMatch === "*" && Boolean(existing) || normalized.length > 0 && existing && targetValue && normalized.includes(targetValue);
      if (shouldFail) {
        throw new ResourceError(`Precondition failed: object already exists for key "${key}"`, {
          bucket: this.bucket,
          key,
          code: "PreconditionFailed",
          statusCode: 412,
          retriable: false,
          suggestion: 'Use ifNoneMatch: "*" only when the object should not exist or remove the conditional header.'
        });
      }
    }
    const buffer = this._toBuffer(body2);
    const etag = this._generateETag(buffer);
    const lastModified = (/* @__PURE__ */ new Date()).toISOString();
    const size = buffer.length;
    const existingSize = existing ? existing.size : 0;
    const memoryDelta = size - existingSize;
    this._evictIfNeeded(memoryDelta > 0 ? memoryDelta : 0);
    const objectData = {
      body: buffer,
      metadata: metadata ? { ...metadata } : {},
      contentType: contentType || "application/octet-stream",
      etag,
      lastModified,
      size,
      contentEncoding,
      contentLength: typeof contentLength === "number" ? contentLength : size
    };
    this.objects.set(key, objectData);
    this._trackMemory(memoryDelta);
    this.logger.debug({ key, size, etag }, `PUT ${key} (${size} bytes, etag: ${etag})`);
    if (this.autoPersist && this.persistPath) {
      await this.saveToDisk();
    }
    return {
      ETag: this._formatEtag(etag),
      VersionId: null,
      ServerSideEncryption: null,
      Location: `/${this.bucket}/${key}`
    };
  }
  async get(key) {
    const obj = this.objects.get(key);
    if (!obj) {
      const error2 = new ResourceError(`Object not found: ${key}`, {
        bucket: this.bucket,
        key,
        code: "NoSuchKey",
        statusCode: 404,
        retriable: false,
        suggestion: "Ensure the key exists before attempting to read it."
      });
      error2.name = "NoSuchKey";
      throw error2;
    }
    this._touchKey(key);
    this.logger.debug({ key, size: obj.size }, `GET ${key} (${obj.size} bytes)`);
    const bodyStream = import_stream.Readable.from(obj.body);
    bodyStream.transformToString = async (encoding2 = "utf-8") => {
      const chunks = [];
      for await (const chunk2 of bodyStream) {
        chunks.push(chunk2);
      }
      return Buffer.concat(chunks).toString(encoding2);
    };
    bodyStream.transformToByteArray = async () => {
      const chunks = [];
      for await (const chunk2 of bodyStream) {
        chunks.push(chunk2);
      }
      return new Uint8Array(Buffer.concat(chunks));
    };
    bodyStream.transformToWebStream = () => {
      return import_stream.Readable.toWeb(bodyStream);
    };
    return {
      Body: bodyStream,
      Metadata: { ...obj.metadata },
      ContentType: obj.contentType,
      ContentLength: obj.size,
      ETag: this._formatEtag(obj.etag),
      LastModified: new Date(obj.lastModified),
      ContentEncoding: obj.contentEncoding
    };
  }
  async head(key) {
    const obj = this.objects.get(key);
    if (!obj) {
      const error2 = new ResourceError(`Object not found: ${key}`, {
        bucket: this.bucket,
        key,
        code: "NoSuchKey",
        statusCode: 404,
        retriable: false,
        suggestion: "Ensure the key exists before attempting to read it."
      });
      error2.name = "NoSuchKey";
      throw error2;
    }
    this._touchKey(key);
    this.logger.debug({ key }, `HEAD ${key}`);
    return {
      Metadata: { ...obj.metadata },
      ContentType: obj.contentType,
      ContentLength: obj.size,
      ETag: this._formatEtag(obj.etag),
      LastModified: new Date(obj.lastModified),
      ContentEncoding: obj.contentEncoding
    };
  }
  async copy(from, to, params) {
    const { metadata, metadataDirective, contentType } = params;
    const source = this.objects.get(from);
    if (!source) {
      throw new ResourceError(`Source object not found: ${from}`, {
        bucket: this.bucket,
        key: from,
        code: "NoSuchKey",
        statusCode: 404,
        retriable: false,
        suggestion: "Copy requires an existing source object. Verify the source key before retrying."
      });
    }
    let finalMetadata = { ...source.metadata };
    if (metadataDirective === "REPLACE" && metadata) {
      finalMetadata = metadata;
    } else if (metadata) {
      finalMetadata = { ...finalMetadata, ...metadata };
    }
    await this.put(to, {
      body: source.body,
      metadata: finalMetadata,
      contentType: contentType || source.contentType,
      contentEncoding: source.contentEncoding
    });
    this.logger.debug({ from, to }, `COPY ${from} \u2192 ${to}`);
    const destination = this.objects.get(to);
    return {
      CopyObjectResult: {
        ETag: this._formatEtag(destination.etag),
        LastModified: new Date(destination.lastModified).toISOString()
      },
      BucketKeyEnabled: false,
      VersionId: null,
      ServerSideEncryption: null
    };
  }
  exists(key) {
    return this.objects.has(key);
  }
  async delete(key) {
    const obj = this.objects.get(key);
    const existed = Boolean(obj);
    if (obj) {
      this._trackMemory(-obj.size);
    }
    this.objects.delete(key);
    this.logger.debug({ key, existed }, `DELETE ${key} (existed: ${existed})`);
    if (this.autoPersist && this.persistPath) {
      await this.saveToDisk();
    }
    return {
      DeleteMarker: false,
      VersionId: null
    };
  }
  async deleteMultiple(keys2) {
    const deleted = [];
    const errors2 = [];
    for (const key of keys2) {
      try {
        await this.delete(key);
        deleted.push({ Key: key });
      } catch (error2) {
        const err = error2;
        errors2.push({
          Key: key,
          Code: err.name || "InternalError",
          Message: err.message
        });
      }
    }
    this.logger.debug({ deletedCount: deleted.length, errorCount: errors2.length }, `DELETE BATCH (${deleted.length} deleted, ${errors2.length} errors)`);
    return { Deleted: deleted, Errors: errors2 };
  }
  async list(params) {
    const { prefix = "", delimiter = null, maxKeys = 1e3, continuationToken = null, startAfter = null } = params;
    const sortedKeys = Array.from(this.objects.keys()).sort();
    const prefixFilter = prefix || "";
    let filteredKeys = prefixFilter ? sortedKeys.filter((key) => key.startsWith(prefixFilter)) : sortedKeys;
    let startAfterKey = null;
    if (continuationToken) {
      startAfterKey = this._decodeContinuationToken(continuationToken);
    } else if (startAfter) {
      startAfterKey = startAfter;
    }
    if (startAfterKey) {
      filteredKeys = filteredKeys.filter((key) => key > startAfterKey);
    }
    const contents = [];
    const commonPrefixes = /* @__PURE__ */ new Set();
    let processed = 0;
    let lastKeyInPage = null;
    for (const key of filteredKeys) {
      if (processed >= maxKeys) {
        break;
      }
      const prefixEntry = delimiter ? this._extractCommonPrefix(prefixFilter, delimiter, key) : null;
      if (prefixEntry) {
        if (!commonPrefixes.has(prefixEntry)) {
          commonPrefixes.add(prefixEntry);
        }
        continue;
      }
      const obj = this.objects.get(key);
      contents.push({
        Key: key,
        Size: obj.size,
        LastModified: new Date(obj.lastModified),
        ETag: this._formatEtag(obj.etag),
        StorageClass: "STANDARD"
      });
      processed++;
      lastKeyInPage = key;
    }
    const hasMoreKeys = filteredKeys.length > contents.length;
    const nextContinuationToken = hasMoreKeys && lastKeyInPage ? this._encodeContinuationToken(lastKeyInPage) : null;
    this.logger.debug({ prefix, objectCount: contents.length, prefixCount: commonPrefixes.size, truncated: Boolean(nextContinuationToken) }, `LIST prefix="${prefix}" (${contents.length} objects, ${commonPrefixes.size} prefixes, truncated=${Boolean(nextContinuationToken)})`);
    return {
      Contents: contents,
      CommonPrefixes: Array.from(commonPrefixes).map((commonPrefix) => ({ Prefix: commonPrefix })),
      IsTruncated: Boolean(nextContinuationToken),
      ContinuationToken: continuationToken || void 0,
      NextContinuationToken: nextContinuationToken,
      KeyCount: contents.length,
      MaxKeys: maxKeys,
      Prefix: prefix || void 0,
      Delimiter: delimiter || void 0,
      StartAfter: startAfter || void 0
    };
  }
  snapshot() {
    const snapshot = {
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      bucket: this.bucket,
      objectCount: this.objects.size,
      objects: {}
    };
    for (const [key, obj] of this.objects.entries()) {
      snapshot.objects[key] = {
        body: obj.body.toString("base64"),
        metadata: obj.metadata,
        contentType: obj.contentType,
        etag: obj.etag,
        lastModified: obj.lastModified,
        size: obj.size,
        contentEncoding: obj.contentEncoding,
        contentLength: obj.contentLength
      };
    }
    return snapshot;
  }
  restore(snapshot) {
    if (!snapshot || !snapshot.objects) {
      throw new ValidationError2("Invalid snapshot format", {
        field: "snapshot",
        retriable: false,
        suggestion: "Provide the snapshot returned by MemoryStorage.snapshot() before calling restore()."
      });
    }
    this.objects.clear();
    this.currentMemoryBytes = 0;
    let totalBytes = 0;
    for (const [key, obj] of Object.entries(snapshot.objects)) {
      const body2 = Buffer.from(obj.body, "base64");
      totalBytes += body2.length;
      this.objects.set(key, {
        body: body2,
        metadata: obj.metadata,
        contentType: obj.contentType,
        etag: obj.etag,
        lastModified: obj.lastModified,
        size: obj.size,
        contentEncoding: obj.contentEncoding,
        contentLength: obj.contentLength
      });
    }
    this._trackMemory(totalBytes);
    this.logger.debug({ objectCount: this.objects.size }, `Restored snapshot with ${this.objects.size} objects`);
  }
  async saveToDisk(customPath) {
    const path3 = customPath || this.persistPath;
    if (!path3) {
      throw new ValidationError2("No persist path configured", {
        field: "persistPath",
        retriable: false,
        suggestion: "Provide a persistPath when creating MemoryClient or pass a custom path to saveToDisk()."
      });
    }
    const snapshot = this.snapshot();
    const json = JSON.stringify(snapshot, null, 2);
    const [ok, err] = await tryFn$1(() => (0, import_promises4.writeFile)(path3, json, "utf-8"));
    if (!ok) {
      throw new ResourceError(`Failed to save to disk: ${err.message}`, {
        bucket: this.bucket,
        operation: "saveToDisk",
        statusCode: 500,
        retriable: false,
        suggestion: "Check filesystem permissions and available disk space, then retry.",
        original: err
      });
    }
    this.logger.debug({ objectCount: this.objects.size, path: path3 }, `Saved ${this.objects.size} objects to ${path3}`);
    return path3;
  }
  async loadFromDisk(customPath) {
    const path3 = customPath || this.persistPath;
    if (!path3) {
      throw new ValidationError2("No persist path configured", {
        field: "persistPath",
        retriable: false,
        suggestion: "Provide a persistPath when creating MemoryClient or pass a custom path to loadFromDisk()."
      });
    }
    const [ok, err, json] = await tryFn$1(() => (0, import_promises4.readFile)(path3, "utf-8"));
    if (!ok) {
      throw new ResourceError(`Failed to load from disk: ${err.message}`, {
        bucket: this.bucket,
        operation: "loadFromDisk",
        statusCode: 500,
        retriable: false,
        suggestion: "Verify the file exists and is readable, then retry.",
        original: err
      });
    }
    const snapshot = JSON.parse(json);
    this.restore(snapshot);
    this.logger.debug({ objectCount: this.objects.size, path: path3 }, `Loaded ${this.objects.size} objects from ${path3}`);
    return snapshot;
  }
  getStats() {
    return {
      objectCount: this.objects.size,
      totalSize: this.currentMemoryBytes,
      totalSizeFormatted: this._formatBytes(this.currentMemoryBytes),
      keys: this.getKeys(),
      bucket: this.bucket,
      maxMemoryMB: this.maxMemoryMB,
      memoryUsagePercent: this.maxMemoryBytes > 0 ? Math.round(this.currentMemoryBytes / this.maxMemoryBytes * 100) : 0,
      evictions: this._stats.evictions,
      evictedBytes: this._stats.evictedBytes,
      peakMemoryBytes: this._stats.peakMemoryBytes
    };
  }
  getKeys() {
    return Array.from(this.objects.keys()).sort();
  }
  _formatBytes(bytes) {
    if (bytes === 0)
      return "0 Bytes";
    const k4 = 1024;
    const sizes = ["Bytes", "KB", "MB", "GB"];
    const i4 = Math.floor(Math.log(bytes) / Math.log(k4));
    return Math.round(bytes / Math.pow(k4, i4) * 100) / 100 + " " + sizes[i4];
  }
  _trackMemory(deltaBytes) {
    this.currentMemoryBytes += deltaBytes;
    if (this.currentMemoryBytes > this._stats.peakMemoryBytes) {
      this._stats.peakMemoryBytes = this.currentMemoryBytes;
    }
  }
  _touchKey(key) {
    const obj = this.objects.get(key);
    if (obj) {
      this.objects.delete(key);
      this.objects.set(key, obj);
    }
  }
  _evictIfNeeded(requiredBytes = 0) {
    if (!this.evictionEnabled)
      return 0;
    const targetBytes = this.maxMemoryBytes;
    const neededSpace = this.currentMemoryBytes + requiredBytes;
    if (neededSpace <= targetBytes)
      return 0;
    let evictedBytes = 0;
    const keysToEvict = [];
    for (const [key, obj] of this.objects) {
      if (this.currentMemoryBytes - evictedBytes + requiredBytes <= targetBytes) {
        break;
      }
      keysToEvict.push(key);
      evictedBytes += obj.size;
    }
    for (const key of keysToEvict) {
      const obj = this.objects.get(key);
      if (obj) {
        this.objects.delete(key);
        this._stats.evictions++;
        this._stats.evictedBytes += obj.size;
      }
    }
    this.currentMemoryBytes -= evictedBytes;
    if (keysToEvict.length > 0) {
      this.logger.debug({ evicted: keysToEvict.length, bytes: evictedBytes }, `LRU evicted ${keysToEvict.length} objects (${this._formatBytes(evictedBytes)})`);
    }
    return evictedBytes;
  }
  clear() {
    this.objects.clear();
    this.currentMemoryBytes = 0;
    this.logger.debug("Cleared all objects");
  }
  resetStats() {
    this._stats = {
      evictions: 0,
      evictedBytes: 0,
      peakMemoryBytes: this.currentMemoryBytes
    };
  }
};
var pathPosix$1 = import_path.default.posix;
var globalStorageRegistry$1 = /* @__PURE__ */ new Map();
var MemoryClient = class extends import_events.default {
  id;
  logLevel;
  logger;
  taskExecutorMonitoring;
  taskManager;
  storage;
  bucket;
  keyPrefix;
  region;
  _keyPrefixForStrip;
  connectionString;
  config;
  constructor(config = {}) {
    super();
    this.id = config.id || idGenerator(77);
    this.logLevel = config.logLevel || "info";
    if (config.logger) {
      this.logger = config.logger;
    } else {
      this.logger = createLogger({ name: "MemoryClient", level: this.logLevel });
    }
    this.taskExecutorMonitoring = config.taskExecutorMonitoring ? { ...config.taskExecutorMonitoring } : null;
    if (config.taskExecutor) {
      this.taskManager = config.taskExecutor;
    } else {
      this.taskManager = new TasksRunner({
        concurrency: config.concurrency || 5,
        retries: config.retries ?? 3,
        retryDelay: config.retryDelay ?? 1e3,
        timeout: config.timeout ?? 3e4,
        retryableErrors: config.retryableErrors || [],
        monitoring: this.taskExecutorMonitoring || void 0
      });
    }
    this.bucket = config.bucket || "s3db";
    this.keyPrefix = config.keyPrefix || "";
    this.region = config.region || "memory";
    this._keyPrefixForStrip = this.keyPrefix ? pathPosix$1.join(this.keyPrefix, "") : "";
    this.connectionString = `memory://${this.bucket}${this.keyPrefix ? "/" + this.keyPrefix : ""}`;
    const storageKey = `${this.bucket}`;
    if (!globalStorageRegistry$1.has(storageKey)) {
      globalStorageRegistry$1.set(storageKey, new MemoryStorage2({
        bucket: this.bucket,
        enforceLimits: config.enforceLimits || false,
        metadataLimit: config.metadataLimit || 2048,
        maxObjectSize: config.maxObjectSize || 5 * 1024 * 1024 * 1024,
        persistPath: config.persistPath,
        autoPersist: config.autoPersist,
        logLevel: this.logLevel,
        maxMemoryMB: config.maxMemoryMB,
        evictionEnabled: config.evictionEnabled
      }));
    }
    this.storage = globalStorageRegistry$1.get(storageKey);
    this.config = {
      bucket: this.bucket,
      keyPrefix: this.keyPrefix,
      region: this.region,
      endpoint: "memory://",
      forcePathStyle: true
    };
    this.logger.debug({ id: this.id, bucket: this.bucket }, `Initialized (id: ${this.id}, bucket: ${this.bucket})`);
  }
  getQueueStats() {
    if (this.taskManager && typeof this.taskManager.getStats === "function") {
      return this.taskManager.getStats();
    }
    return null;
  }
  getAggregateMetrics(since = 0) {
    if (this.taskManager && typeof this.taskManager.getAggregateMetrics === "function") {
      return this.taskManager.getAggregateMetrics(since);
    }
    return null;
  }
  async sendCommand(command) {
    const commandName = command.constructor.name;
    const input = command.input || {};
    this.emit("cl:request", commandName, input);
    this.emit("command.request", commandName, input);
    let response2;
    try {
      switch (commandName) {
        case "PutObjectCommand":
          response2 = await this._handlePutObject(input);
          break;
        case "GetObjectCommand":
          response2 = await this._handleGetObject(input);
          break;
        case "HeadObjectCommand":
          response2 = await this._handleHeadObject(input);
          break;
        case "CopyObjectCommand":
          response2 = await this._handleCopyObject(input);
          break;
        case "DeleteObjectCommand":
          response2 = await this._handleDeleteObject(input);
          break;
        case "DeleteObjectsCommand":
          response2 = await this._handleDeleteObjects(input);
          break;
        case "ListObjectsV2Command":
          response2 = await this._handleListObjects(input);
          break;
        default:
          throw new DatabaseError(`Unsupported command: ${commandName}`, {
            operation: "sendCommand",
            statusCode: 400,
            retriable: false,
            suggestion: "Use one of the supported commands: PutObject, GetObject, HeadObject, CopyObject, DeleteObject, DeleteObjects, or ListObjectsV2."
          });
      }
      this.emit("cl:response", commandName, response2, input);
      this.emit("command.response", commandName, response2, input);
      return response2;
    } catch (error2) {
      if (error2 instanceof BaseError) {
        throw error2;
      }
      const mappedError = mapAwsError(error2, {
        bucket: this.bucket,
        key: input.Key,
        commandName,
        commandInput: input
      });
      throw mappedError;
    }
  }
  async _handlePutObject(input) {
    const key = this._applyKeyPrefix(input.Key);
    const metadata = this._encodeMetadata(input.Metadata || {});
    const contentType = input.ContentType;
    const body2 = input.Body;
    const contentEncoding = input.ContentEncoding;
    const contentLength = input.ContentLength;
    const ifMatch = input.IfMatch;
    const ifNoneMatch = input.IfNoneMatch;
    return await this.storage.put(key, {
      body: body2,
      metadata,
      contentType,
      contentEncoding,
      contentLength,
      ifMatch,
      ifNoneMatch
    });
  }
  async _handleGetObject(input) {
    const key = this._applyKeyPrefix(input.Key);
    const response2 = await this.storage.get(key);
    return this._decodeMetadataResponse(response2);
  }
  async _handleHeadObject(input) {
    const key = this._applyKeyPrefix(input.Key);
    const response2 = await this.storage.head(key);
    return this._decodeMetadataResponse(response2);
  }
  async _handleCopyObject(input) {
    const { sourceBucket, sourceKey } = this._parseCopySource(input.CopySource);
    if (sourceBucket !== this.bucket) {
      throw new DatabaseError(`Cross-bucket copy is not supported in MemoryClient (requested ${sourceBucket} \u2192 ${this.bucket})`, {
        operation: "CopyObject",
        retriable: false,
        suggestion: "Instantiate a MemoryClient with the desired bucket or copy within the same bucket."
      });
    }
    const destinationKey = this._applyKeyPrefix(input.Key);
    const encodedMetadata = this._encodeMetadata(input.Metadata);
    return await this.storage.copy(sourceKey, destinationKey, {
      metadata: encodedMetadata,
      metadataDirective: input.MetadataDirective,
      contentType: input.ContentType
    });
  }
  async _handleDeleteObject(input) {
    const key = this._applyKeyPrefix(input.Key);
    return await this.storage.delete(key);
  }
  async _handleDeleteObjects(input) {
    const objects = input.Delete?.Objects || [];
    const keys2 = objects.map((obj) => this._applyKeyPrefix(obj.Key));
    return await this.storage.deleteMultiple(keys2);
  }
  async _handleListObjects(input) {
    const fullPrefix = this._applyKeyPrefix(input.Prefix || "");
    const params = {
      prefix: fullPrefix,
      delimiter: input.Delimiter,
      maxKeys: input.MaxKeys,
      continuationToken: input.ContinuationToken
    };
    if (input.StartAfter) {
      params.startAfter = this._applyKeyPrefix(input.StartAfter || void 0);
    }
    const response2 = await this.storage.list(params);
    return this._normalizeListResponse(response2);
  }
  async putObject(params) {
    const { key, metadata, contentType, body: body2, contentEncoding, contentLength, ifMatch, ifNoneMatch } = params;
    const fullKey = this._applyKeyPrefix(key);
    const stringMetadata = this._encodeMetadata(metadata) || {};
    const input = { Key: key, Metadata: metadata, ContentType: contentType, Body: body2, ContentEncoding: contentEncoding, ContentLength: contentLength, IfMatch: ifMatch, IfNoneMatch: ifNoneMatch };
    const response2 = await this.storage.put(fullKey, {
      body: body2,
      metadata: stringMetadata,
      contentType,
      contentEncoding,
      contentLength,
      ifMatch,
      ifNoneMatch
    });
    this.emit("cl:response", "PutObjectCommand", response2, input);
    return response2;
  }
  async getObject(key) {
    const fullKey = this._applyKeyPrefix(key);
    const input = { Key: key };
    const response2 = await this.storage.get(fullKey);
    const decodedResponse = this._decodeMetadataResponse(response2);
    this.emit("cl:response", "GetObjectCommand", decodedResponse, input);
    return decodedResponse;
  }
  async headObject(key) {
    const fullKey = this._applyKeyPrefix(key);
    const input = { Key: key };
    const response2 = await this.storage.head(fullKey);
    const decodedResponse = this._decodeMetadataResponse(response2);
    this.emit("cl:response", "HeadObjectCommand", decodedResponse, input);
    return decodedResponse;
  }
  async copyObject(params) {
    const { from, to, metadata, metadataDirective, contentType } = params;
    const fullFrom = this._applyKeyPrefix(from);
    const fullTo = this._applyKeyPrefix(to);
    const encodedMetadata = this._encodeMetadata(metadata);
    const input = { CopySource: from, Key: to, Metadata: metadata, MetadataDirective: metadataDirective, ContentType: contentType };
    const response2 = await this.storage.copy(fullFrom, fullTo, {
      metadata: encodedMetadata,
      metadataDirective,
      contentType
    });
    this.emit("cl:response", "CopyObjectCommand", response2, input);
    return response2;
  }
  async exists(key) {
    const fullKey = this._applyKeyPrefix(key);
    return this.storage.exists(fullKey);
  }
  async deleteObject(key) {
    const fullKey = this._applyKeyPrefix(key);
    const input = { Key: key };
    const response2 = await this.storage.delete(fullKey);
    this.emit("cl:response", "DeleteObjectCommand", response2, input);
    return response2;
  }
  async deleteObjects(keys2) {
    const fullKeys = keys2.map((key) => this._applyKeyPrefix(key));
    const input = { Delete: { Objects: keys2.map((key) => ({ Key: key })) } };
    const batches = chunk_default(fullKeys, this.taskManager.concurrency || 5);
    const allResults = { Deleted: [], Errors: [] };
    const { results } = await this.taskManager.process(batches, async (batch) => {
      return await this.storage.deleteMultiple(batch);
    });
    for (const result of results) {
      allResults.Deleted.push(...result.Deleted.map((item) => ({ Key: this._stripKeyPrefix(item.Key) })));
      allResults.Errors.push(...result.Errors);
    }
    this.emit("cl:response", "DeleteObjectsCommand", allResults, input);
    return allResults;
  }
  async listObjects(params = {}) {
    const { prefix = "", delimiter = null, maxKeys = 1e3, continuationToken = null, startAfter = null } = params;
    const fullPrefix = this._applyKeyPrefix(prefix || "");
    const listParams = {
      prefix: fullPrefix,
      delimiter,
      maxKeys,
      continuationToken
    };
    if (startAfter) {
      listParams.startAfter = this._applyKeyPrefix(startAfter);
    }
    const input = { Prefix: prefix, Delimiter: delimiter, MaxKeys: maxKeys, ContinuationToken: continuationToken, StartAfter: startAfter };
    const response2 = await this.storage.list(listParams);
    const normalized = this._normalizeListResponse(response2);
    this.emit("cl:response", "ListObjectsV2Command", normalized, input);
    return normalized;
  }
  async getKeysPage(params = {}) {
    const { prefix = "", offset = 0, amount = 100 } = params;
    let keys2 = [];
    let truncated = true;
    let continuationToken;
    if (offset > 0) {
      const fullPrefix = this._applyKeyPrefix(prefix || "");
      const response2 = await this.storage.list({
        prefix: fullPrefix,
        maxKeys: offset + amount
      });
      keys2 = (response2.Contents || []).map((x4) => this._stripKeyPrefix(x4.Key)).slice(offset, offset + amount);
      truncated = Boolean(response2.NextContinuationToken);
      continuationToken = response2.NextContinuationToken || void 0;
    } else {
      while (truncated) {
        const remaining = amount - keys2.length;
        if (remaining <= 0) {
          break;
        }
        const res = await this.listObjects({
          prefix,
          continuationToken,
          maxKeys: remaining
        });
        if (res.Contents) {
          keys2 = keys2.concat(res.Contents.map((x4) => x4.Key));
        }
        truncated = res.IsTruncated || false;
        continuationToken = res.NextContinuationToken || void 0;
        if (keys2.length >= amount) {
          keys2 = keys2.slice(0, amount);
          break;
        }
      }
    }
    this.emit("cl:GetKeysPage", keys2, params);
    return keys2;
  }
  async getAllKeys(params = {}) {
    const { prefix = "" } = params;
    const fullPrefix = this._applyKeyPrefix(prefix || "");
    const response2 = await this.storage.list({
      prefix: fullPrefix,
      maxKeys: Number.MAX_SAFE_INTEGER
    });
    const keys2 = (response2.Contents || []).map((x4) => this._stripKeyPrefix(x4.Key));
    this.emit("cl:GetAllKeys", keys2, params);
    return keys2;
  }
  async count(params = {}) {
    const { prefix = "" } = params;
    const keys2 = await this.getAllKeys({ prefix });
    const count = keys2.length;
    this.emit("cl:Count", count, { prefix });
    return count;
  }
  async deleteAll(params = {}) {
    const { prefix = "" } = params;
    const keys2 = await this.getAllKeys({ prefix });
    let totalDeleted = 0;
    if (keys2.length > 0) {
      const result = await this.deleteObjects(keys2);
      totalDeleted = result.Deleted.length;
      this.emit("deleteAll", {
        prefix,
        batch: totalDeleted,
        total: totalDeleted
      });
    }
    this.emit("deleteAllComplete", {
      prefix,
      totalDeleted
    });
    return totalDeleted;
  }
  async getContinuationTokenAfterOffset(params = {}) {
    const { prefix = "", offset = 1e3 } = params;
    if (offset === 0)
      return null;
    const keys2 = await this.getAllKeys({ prefix });
    if (offset >= keys2.length) {
      this.emit("cl:GetContinuationTokenAfterOffset", null, { prefix, offset });
      return null;
    }
    const keyForToken = keys2[offset];
    const fullKey = this._applyKeyPrefix(keyForToken || "");
    const token = this._encodeContinuationTokenKey(fullKey);
    this.emit("cl:GetContinuationTokenAfterOffset", token, { prefix, offset });
    return token;
  }
  async moveObject(params) {
    const { from, to } = params;
    const [ok, err] = await tryFn$1(async () => {
      await this.copyObject({ from, to, metadataDirective: "COPY" });
      await this.deleteObject(from);
    });
    if (!ok) {
      throw new DatabaseError("Unknown error in moveObject", {
        bucket: this.bucket,
        from,
        to,
        original: err
      });
    }
    return true;
  }
  async moveAllObjects(params) {
    const { prefixFrom, prefixTo } = params;
    const keys2 = await this.getAllKeys({ prefix: prefixFrom });
    const { results, errors: errors2 } = await this.taskManager.process(keys2, async (key) => {
      const to = key.replace(prefixFrom, prefixTo);
      await this.moveObject({ from: key, to });
      return { from: key, to };
    });
    this.emit("moveAllObjects", { results, errors: errors2 });
    if (errors2.length > 0) {
      const error2 = new Error("Some objects could not be moved");
      error2.context = {
        bucket: this.bucket,
        operation: "moveAllObjects",
        prefixFrom,
        prefixTo,
        totalKeys: keys2.length,
        failedCount: errors2.length,
        successCount: results.length,
        errors: errors2
      };
      throw error2;
    }
    return results;
  }
  snapshot() {
    return this.storage.snapshot();
  }
  restore(snapshot) {
    this.storage.restore(snapshot);
  }
  async clear() {
    this.storage.clear();
  }
  getStats() {
    return this.storage.getStats();
  }
  destroy() {
  }
  _encodeMetadata(metadata) {
    if (!metadata)
      return void 0;
    const encoded = {};
    for (const [rawKey, value] of Object.entries(metadata)) {
      const validKey = String(rawKey).replace(/[^a-zA-Z0-9\-_]/g, "_").toLowerCase();
      const { encoded: encodedValue } = metadataEncode(value);
      encoded[validKey] = encodedValue;
    }
    return encoded;
  }
  _decodeMetadataResponse(response2) {
    const decodedMetadata = {};
    if (response2.Metadata) {
      for (const [k4, v4] of Object.entries(response2.Metadata)) {
        decodedMetadata[k4] = metadataDecode(v4);
      }
    }
    return {
      ...response2,
      Metadata: decodedMetadata
    };
  }
  _applyKeyPrefix(key) {
    if (!this.keyPrefix) {
      if (key === void 0 || key === null) {
        return "";
      }
      return key;
    }
    if (key === void 0 || key === null || key === "") {
      return pathPosix$1.join(this.keyPrefix, "");
    }
    return pathPosix$1.join(this.keyPrefix, key);
  }
  _stripKeyPrefix(key = "") {
    if (!this.keyPrefix) {
      return key;
    }
    const normalizedPrefix = this._keyPrefixForStrip;
    if (normalizedPrefix && key.startsWith(normalizedPrefix)) {
      return key.slice(normalizedPrefix.length).replace(/^\/+/, "");
    }
    return key;
  }
  _encodeContinuationTokenKey(key) {
    return Buffer.from(String(key), "utf8").toString("base64");
  }
  _parseCopySource(copySource) {
    const trimmedSource = String(copySource || "").replace(/^\//, "");
    const [sourcePath] = trimmedSource.split("?");
    const decodedSource = decodeURIComponent(sourcePath ?? "");
    const [sourceBucket, ...sourceKeyParts] = decodedSource.split("/");
    if (!sourceBucket || sourceKeyParts.length === 0) {
      throw new DatabaseError(`Invalid CopySource value: ${copySource}`, {
        operation: "CopyObject",
        retriable: false,
        suggestion: 'Provide CopySource in the format "<bucket>/<key>" as expected by AWS S3.'
      });
    }
    return {
      sourceBucket,
      sourceKey: sourceKeyParts.join("/")
    };
  }
  _normalizeListResponse(response2) {
    const rawContents = Array.isArray(response2.Contents) ? response2.Contents : [];
    const contents = rawContents.map((item) => ({
      ...item,
      Key: this._stripKeyPrefix(item.Key)
    }));
    const rawPrefixes = Array.isArray(response2.CommonPrefixes) ? response2.CommonPrefixes : [];
    const commonPrefixes = rawPrefixes.map(({ Prefix }) => ({
      Prefix: this._stripKeyPrefix(Prefix)
    }));
    return {
      Contents: contents,
      CommonPrefixes: commonPrefixes,
      IsTruncated: response2.IsTruncated,
      ContinuationToken: response2.ContinuationToken,
      NextContinuationToken: response2.NextContinuationToken,
      KeyCount: contents.length,
      MaxKeys: response2.MaxKeys,
      Prefix: this.keyPrefix ? void 0 : response2.Prefix,
      Delimiter: response2.Delimiter,
      StartAfter: response2.StartAfter
    };
  }
  static clearBucketStorage(bucket) {
    const storage = globalStorageRegistry$1.get(bucket);
    if (storage) {
      storage.clear();
    }
    globalStorageRegistry$1.delete(bucket);
  }
  static clearAllStorage() {
    for (const storage of globalStorageRegistry$1.values()) {
      storage.clear();
    }
    globalStorageRegistry$1.clear();
  }
};
function bumpProcessMaxListeners(delta) {
  if (delta === 0 || typeof process === "undefined")
    return;
  if (typeof process.getMaxListeners !== "function" || typeof process.setMaxListeners !== "function")
    return;
  const current = process.getMaxListeners();
  if (current === 0 && delta > 0)
    return;
  const newValue = Math.max(0, current + delta);
  process.setMaxListeners(newValue);
}
function createStepExpression(value) {
  return ["*", "/", String(value)].join("");
}
function createHourlyStepExpression(value) {
  return ["0 ", createStepExpression(value), " * * *"].join("");
}
function createDailyStepExpression(value) {
  return ["0 0 ", createStepExpression(value), " * *"].join("");
}
function intervalToCron(ms) {
  const seconds = Math.max(1, Math.floor(ms / 1e3));
  if (seconds < 60) {
    return `${createStepExpression(seconds)} * * * * *`;
  }
  const minutes = Math.floor(seconds / 60);
  if (minutes < 60) {
    return `${createStepExpression(minutes)} * * * *`;
  }
  const hours = Math.floor(minutes / 60);
  if (hours < 24) {
    return createHourlyStepExpression(hours);
  }
  const days = Math.floor(hours / 24);
  return createDailyStepExpression(days);
}
var CronManager = class {
  options;
  logger;
  jobs;
  _cron;
  _destroyed;
  _signalHandlersSetup;
  _boundShutdownHandler;
  _boundErrorHandler;
  disabled;
  constructor(options = {}) {
    const envDisabled = typeof process !== "undefined" && process.env.S3DB_DISABLE_CRON === "true";
    const explicitDisabled = typeof options.disabled === "boolean" ? options.disabled : void 0;
    const isDisabled = explicitDisabled !== void 0 ? explicitDisabled : envDisabled;
    this.options = {
      logLevel: options.logLevel || "info",
      shutdownTimeout: options.shutdownTimeout || 3e4,
      exitOnSignal: options.exitOnSignal !== false,
      disabled: isDisabled
    };
    if (options.logger) {
      this.logger = options.logger;
    } else {
      const logLevel = this.options.logLevel;
      this.logger = createLogger({ name: "CronManager", level: logLevel });
    }
    this.jobs = /* @__PURE__ */ new Map();
    this._cron = null;
    this._destroyed = false;
    this._signalHandlersSetup = false;
    this.disabled = this.options.disabled;
    this.logger.debug({ disabled: this.disabled }, "CronManager initialized");
    if (!this.disabled) {
      this._setupSignalHandlers();
    }
  }
  _setupSignalHandlers() {
    if (this.disabled || this._signalHandlersSetup)
      return;
    this._boundShutdownHandler = this._handleShutdown.bind(this);
    this._boundErrorHandler = this._handleError.bind(this);
    bumpProcessMaxListeners(5);
    process.once("SIGTERM", this._boundShutdownHandler);
    process.once("SIGINT", this._boundShutdownHandler);
    process.once("beforeExit", this._boundShutdownHandler);
    process.once("uncaughtException", this._boundErrorHandler);
    process.once("unhandledRejection", this._boundErrorHandler);
    this._signalHandlersSetup = true;
    this.logger.debug("Signal handlers registered");
  }
  removeSignalHandlers() {
    if (!this._signalHandlersSetup)
      return;
    if (this._boundShutdownHandler) {
      process.removeListener("SIGTERM", this._boundShutdownHandler);
      process.removeListener("SIGINT", this._boundShutdownHandler);
      process.removeListener("beforeExit", this._boundShutdownHandler);
    }
    if (this._boundErrorHandler) {
      process.removeListener("uncaughtException", this._boundErrorHandler);
      process.removeListener("unhandledRejection", this._boundErrorHandler);
    }
    this._signalHandlersSetup = false;
    bumpProcessMaxListeners(-5);
    this.logger.debug("Signal handlers removed");
  }
  _handleShutdown(signal) {
    if (this._destroyed)
      return;
    this.logger.debug({ signal }, `Received ${signal}, shutting down...`);
    this.shutdown({ signal }).then(() => {
      if (this.options.exitOnSignal) {
        process.exit(0);
      }
    }).catch((error2) => {
      this.logger.error({ error: error2.message, stack: error2.stack }, "Shutdown error");
      if (this.options.exitOnSignal) {
        process.exit(1);
      }
    });
  }
  _handleError(error2) {
    this.logger.error({ error: error2.message, stack: error2.stack }, "Uncaught error");
    this.shutdown({ error: error2 }).then(() => {
      if (this.options.exitOnSignal) {
        process.exit(1);
      }
    }).catch(() => {
      if (this.options.exitOnSignal) {
        process.exit(1);
      }
    });
  }
  async _loadCron() {
    if (this._cron)
      return this._cron;
    const isTestEnv = typeof process !== "undefined" && process.env.NODE_ENV === "test";
    try {
      const cronModule = await import("node-cron");
      this._cron = cronModule.default || cronModule;
      this.logger.debug("node-cron loaded");
      return this._cron;
    } catch (error2) {
      if (isTestEnv) {
        this.logger.warn({ error: error2.message }, `Falling back to in-memory cron stub for tests`);
        this._cron = this._createTestCronStub();
        return this._cron;
      }
      throw new Error("Failed to load the bundled node-cron dependency. Try reinstalling packages with `pnpm install`.\nError: " + error2.message);
    }
  }
  async schedule(expression, fn, name, options = {}) {
    if (this._destroyed) {
      this.logger.warn({ name }, `Cannot schedule job '${name}' - manager is destroyed`);
      return null;
    }
    if (this.disabled) {
      this.logger.debug({ name }, `Scheduling disabled - skipping job '${name}'`);
      return this._createStubTask(name, fn);
    }
    const { replace = false, ...cronOptions } = options || {};
    if (this.jobs.has(name)) {
      if (!replace) {
        throw new Error(`[CronManager] Job '${name}' already exists`);
      }
      const stopped = this.stop(name);
      if (!stopped && this.jobs.has(name)) {
        this.jobs.delete(name);
      }
      this.logger.debug({ name }, `Replaced existing job '${name}'`);
    }
    const cron = await this._loadCron();
    const task = cron.schedule(expression, fn, {
      scheduled: cronOptions.scheduled !== false,
      timezone: cronOptions.timezone,
      recoverMissedExecutions: cronOptions.recoverMissedExecutions || false
    });
    if (cronOptions.scheduled !== false && task?.start) {
      task.start();
    }
    this.jobs.set(name, {
      task,
      expression,
      fn,
      options: { ...cronOptions, replace },
      createdAt: Date.now()
    });
    this.logger.debug({ name, expression }, `Scheduled job '${name}': ${expression}`);
    return task;
  }
  async scheduleInterval(ms, fn, name, options = {}) {
    const expression = intervalToCron(ms);
    return this.schedule(expression, fn, name, options);
  }
  stop(name) {
    const jobName = typeof name === "string" ? name : String(name);
    if (!this.jobs.has(name)) {
      this.logger.trace?.({ name: jobName }, `Job '${jobName}' not found`);
      return false;
    }
    const entry = this.jobs.get(name);
    try {
      entry.task?.stop?.();
      entry.task?.destroy?.();
      this.jobs.delete(name);
      this.logger.debug({ name }, `Stopped job '${name}'`);
      return true;
    } catch (error2) {
      this.logger.error({ name, error: error2.message, stack: error2.stack }, `Error stopping job '${name}'`);
      return false;
    }
  }
  getStats() {
    const stats2 = {
      totalJobs: this.jobs.size,
      jobs: [],
      isDestroyed: this._destroyed
    };
    for (const [name, entry] of this.jobs.entries()) {
      stats2.jobs.push({
        name,
        expression: entry.expression,
        createdAt: entry.createdAt,
        uptime: Date.now() - entry.createdAt
      });
    }
    return stats2;
  }
  isDestroyed() {
    return this._destroyed;
  }
  async shutdown(options = {}) {
    if (this._destroyed) {
      this.logger.debug("Already destroyed");
      return;
    }
    const timeout = options.timeout || this.options.shutdownTimeout;
    this.logger.debug({ jobCount: this.jobs.size }, `Shutting down ${this.jobs.size} jobs...`);
    if (this.disabled) {
      this.jobs.clear();
      this._destroyed = true;
      return;
    }
    const stopPromises = [];
    for (const [name, entry] of this.jobs.entries()) {
      const stopPromise = new Promise((resolve, reject) => {
        try {
          entry.task?.stop?.();
          entry.task?.destroy?.();
          resolve();
        } catch (error2) {
          reject(error2);
        }
      });
      const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error(`Stop timeout for job '${name}'`)), timeout));
      stopPromises.push(Promise.race([stopPromise, timeoutPromise]).catch((error2) => {
        this.logger.warn({ name, error: error2.message }, `Error stopping job '${name}'`);
      }));
    }
    await Promise.allSettled(stopPromises);
    this.jobs.clear();
    this._destroyed = true;
    this.logger.debug("Shutdown complete");
  }
  _createStubTask(name, fn) {
    const logger3 = this.logger;
    return {
      start() {
      },
      stop() {
      },
      destroy() {
      },
      async run(...args) {
        try {
          await fn?.();
        } catch (error2) {
          logger3.error({ name, error: error2.message, stack: error2.stack }, `Stub task '${name}' execution error`);
        }
      }
    };
  }
  _inferIntervalFromExpression(expression) {
    if (!expression || typeof expression !== "string") {
      return 6e4;
    }
    const parts = expression.trim().split(/\s+/);
    if (parts.length === 6) {
      const secondsPart = parts[0] ?? "";
      const match = secondsPart.match(/^\*\/(\d+)$/);
      if (match && match[1]) {
        const step = parseInt(match[1], 10);
        if (!Number.isNaN(step) && step > 0) {
          return Math.max(step * 1e3, 10);
        }
      }
    }
    if (parts.length >= 5) {
      const minutesPart = parts[0] ?? "";
      const match = minutesPart.match(/^\*\/(\d+)$/);
      if (match && match[1]) {
        const step = parseInt(match[1], 10);
        if (!Number.isNaN(step) && step > 0) {
          return Math.max(step * 6e4, 10);
        }
      }
    }
    return 6e4;
  }
  _createTestCronStub() {
    const setIntervalFn = (globalThis.originalSetInterval || globalThis.setInterval || setInterval).bind(globalThis);
    const clearIntervalFn = (globalThis.originalClearInterval || globalThis.clearInterval || clearInterval).bind(globalThis);
    const logger3 = this.logger;
    const inferInterval = this._inferIntervalFromExpression.bind(this);
    return {
      schedule: (expression, fn, options = {}) => {
        const intervalMs = inferInterval(expression);
        let timerId = null;
        const run2 = async () => {
          try {
            await fn?.();
          } catch (err) {
            logger3.warn({ error: err?.message || String(err) }, "Test cron stub task error");
          }
        };
        const start = () => {
          if (timerId !== null)
            return;
          timerId = setIntervalFn(run2, intervalMs);
        };
        const stop = () => {
          if (timerId === null)
            return;
          clearIntervalFn(timerId);
          timerId = null;
        };
        const destroy = () => {
          stop();
        };
        if (options.scheduled !== false) {
          start();
        }
        return {
          start,
          stop,
          destroy,
          run: run2
        };
      }
    };
  }
};
var _globalCronManager = null;
function getCronManager(options = {}) {
  if (!_globalCronManager) {
    _globalCronManager = new CronManager(options);
  }
  return _globalCronManager;
}
var FileSystemStorage = class {
  basePath;
  bucket;
  enforceLimits;
  metadataLimit;
  maxObjectSize;
  logLevel;
  enableCompression;
  compressionThreshold;
  compressionLevel;
  enableTTL;
  defaultTTL;
  cleanupInterval;
  enableLocking;
  lockTimeout;
  enableBackup;
  backupSuffix;
  enableJournal;
  journalFile;
  enableStats;
  isWindows;
  locks;
  stats;
  logger;
  cronManager;
  cleanupJobName;
  constructor(config = {}) {
    this.basePath = config.basePath || "./s3db-data";
    this.bucket = config.bucket || "s3db";
    this.enforceLimits = Boolean(config.enforceLimits);
    this.metadataLimit = config.metadataLimit ?? 2048;
    this.maxObjectSize = config.maxObjectSize ?? 5 * 1024 * 1024 * 1024;
    this.logLevel = config.logLevel || "info";
    const compressionConfig = config.compression || {};
    this.enableCompression = Boolean(compressionConfig.enabled);
    this.compressionThreshold = compressionConfig.threshold ?? 1024;
    this.compressionLevel = compressionConfig.level ?? 6;
    const ttlConfig = config.ttl || {};
    this.enableTTL = Boolean(ttlConfig.enabled);
    this.defaultTTL = ttlConfig.defaultTTL ?? 36e5;
    this.cleanupInterval = ttlConfig.cleanupInterval ?? 3e5;
    const lockingConfig = config.locking || {};
    this.enableLocking = Boolean(lockingConfig.enabled);
    this.lockTimeout = lockingConfig.timeout ?? 5e3;
    const backupConfig = config.backup || {};
    this.enableBackup = Boolean(backupConfig.enabled);
    this.backupSuffix = backupConfig.suffix ?? ".bak";
    const journalConfig = config.journal || {};
    this.enableJournal = Boolean(journalConfig.enabled);
    this.journalFile = journalConfig.file ?? "operations.journal";
    const statsConfig = config.stats || {};
    this.enableStats = Boolean(statsConfig.enabled);
    this.isWindows = (0, import_os.platform)() === "win32";
    this.basePath = import_path.default.resolve(this.basePath);
    this.locks = /* @__PURE__ */ new Map();
    this.stats = {
      gets: 0,
      puts: 0,
      deletes: 0,
      errors: 0,
      compressionSaved: 0,
      totalCompressed: 0,
      totalUncompressed: 0
    };
    if (config.logger) {
      this.logger = config.logger;
    } else {
      this.logger = createLogger({ name: "FileSystemStorage", level: this.logLevel });
    }
    this.cronManager = getCronManager();
    this.cleanupJobName = null;
    if (this.enableTTL && this.cleanupInterval > 0) {
      this._initCleanup();
    }
    const features = [];
    if (this.enableCompression)
      features.push(`compression:${this.compressionThreshold}b`);
    if (this.enableTTL)
      features.push(`ttl:${this.defaultTTL}ms`);
    if (this.enableLocking)
      features.push("locking");
    if (this.enableBackup)
      features.push("backup");
    if (this.enableJournal)
      features.push("journal");
    if (this.enableStats)
      features.push("stats");
    this.logger.debug({ basePath: this.basePath, features }, `Initialized (basePath: ${this.basePath}${features.length ? ", features: " + features.join(", ") : ""})`);
  }
  _keyToPath(key) {
    const normalizedKey = key.replace(/\//g, import_path.default.sep);
    return import_path.default.join(this.basePath, normalizedKey);
  }
  _pathToKey(filePath) {
    const relativePath = import_path.default.relative(this.basePath, filePath);
    return relativePath.split(import_path.default.sep).join("/");
  }
  _getObjectPath(key) {
    return this._keyToPath(key);
  }
  _getMetadataPath(key) {
    return this._keyToPath(key) + ".meta.json";
  }
  async _ensureDirectory(filePath) {
    const dir = import_path.default.dirname(filePath);
    const [ok, err] = await tryFn$1(() => (0, import_promises4.mkdir)(dir, { recursive: true }));
    if (!ok && err.code !== "EEXIST") {
      throw this._mapFilesystemError(err, { path: dir, operation: "mkdir" });
    }
  }
  _generateETag(body2) {
    const buffer = this._toBuffer(body2);
    return (0, import_crypto.createHash)("md5").update(buffer).digest("hex");
  }
  _toBuffer(body2) {
    if (Buffer.isBuffer(body2)) {
      return body2;
    }
    if (body2 === void 0 || body2 === null) {
      return Buffer.alloc(0);
    }
    return Buffer.from(body2);
  }
  _formatEtag(etag) {
    return `"${etag}"`;
  }
  _normalizeEtagHeader(headerValue) {
    if (headerValue === void 0 || headerValue === null) {
      return [];
    }
    return String(headerValue).split(",").map((value) => value.trim()).filter(Boolean).map((value) => value.replace(/^W\//i, "").replace(/^['"]|['"]$/g, ""));
  }
  _encodeContinuationToken(key) {
    return Buffer.from(String(key), "utf8").toString("base64");
  }
  _decodeContinuationToken(token) {
    try {
      const normalized = String(token).trim();
      const decoded = Buffer.from(normalized, "base64").toString("utf8");
      const reencoded = Buffer.from(decoded, "utf8").toString("base64").replace(/=+$/, "");
      const normalizedNoPad = normalized.replace(/=+$/, "");
      if (!decoded || reencoded !== normalizedNoPad) {
        throw new Error("Invalid continuation token format");
      }
      return decoded;
    } catch (error2) {
      throw new ValidationError2("Invalid continuation token", {
        field: "ContinuationToken",
        retriable: false,
        suggestion: "Use the NextContinuationToken returned by a previous ListObjectsV2 response.",
        original: error2
      });
    }
  }
  _extractCommonPrefix(prefix, delimiter, key) {
    if (!delimiter)
      return null;
    const hasPrefix = Boolean(prefix);
    if (hasPrefix && !key.startsWith(prefix)) {
      return null;
    }
    const remainder = hasPrefix ? key.slice(prefix.length) : key;
    const index = remainder.indexOf(delimiter);
    if (index === -1) {
      return null;
    }
    const baseLength = hasPrefix ? prefix.length : 0;
    return key.slice(0, baseLength + index + delimiter.length);
  }
  _calculateMetadataSize(metadata) {
    if (!metadata)
      return 0;
    let size = 0;
    for (const [key, value] of Object.entries(metadata)) {
      size += Buffer.byteLength(key, "utf8");
      size += Buffer.byteLength(String(value), "utf8");
    }
    return size;
  }
  _validateLimits(body2, metadata) {
    if (!this.enforceLimits)
      return;
    const metadataSize = this._calculateMetadataSize(metadata);
    if (metadataSize > this.metadataLimit) {
      throw new MetadataLimitError("Metadata limit exceeded in filesystem storage", {
        bucket: this.bucket,
        totalSize: metadataSize,
        effectiveLimit: this.metadataLimit,
        operation: "put",
        retriable: false,
        suggestion: "Reduce metadata size or disable enforceLimits in FileSystemClient configuration."
      });
    }
    const bodySize = Buffer.isBuffer(body2) ? body2.length : Buffer.byteLength(body2 || "", "utf8");
    if (bodySize > this.maxObjectSize) {
      throw new ResourceError("Object size exceeds filesystem limit", {
        bucket: this.bucket,
        operation: "put",
        size: bodySize,
        maxObjectSize: this.maxObjectSize,
        statusCode: 413,
        retriable: false,
        suggestion: "Store smaller objects or increase maxObjectSize when instantiating FileSystemClient."
      });
    }
  }
  async _writeAtomic(filePath, data2) {
    await this._ensureDirectory(filePath);
    const tempPath = `${filePath}.tmp.${Date.now()}.${idGenerator(6)}`;
    try {
      await (0, import_promises4.writeFile)(tempPath, data2);
      await (0, import_promises4.rename)(tempPath, filePath);
    } catch (error2) {
      try {
        await (0, import_promises4.unlink)(tempPath);
      } catch (cleanupError) {
      }
      throw error2;
    }
  }
  async _readMetadata(key) {
    const metaPath = this._getMetadataPath(key);
    const [ok, err, json] = await tryFn$1(() => (0, import_promises4.readFile)(metaPath, "utf-8"));
    if (!ok) {
      throw this._mapFilesystemError(err, { key, path: metaPath, operation: "readMetadata" });
    }
    return JSON.parse(json);
  }
  async _writeMetadata(key, metadata) {
    const metaPath = this._getMetadataPath(key);
    const json = JSON.stringify(metadata, null, 2);
    await this._writeAtomic(metaPath, json);
  }
  _initCleanup() {
    this.cleanupJobName = `filesystem-storage-cleanup-${Date.now()}`;
    this.cronManager.scheduleInterval(this.cleanupInterval, () => {
      this._runCleanup().catch((err) => {
        this.logger.warn({ error: err.message }, "Cleanup error");
      });
    }, this.cleanupJobName);
  }
  async _runCleanup() {
    if (!this.enableTTL || this.defaultTTL <= 0)
      return;
    let cleaned = 0;
    const now = Date.now();
    for await (const entry of this._walkDirectory(this.basePath)) {
      try {
        const [ok, , metaData] = await tryFn$1(() => this._readMetadata(entry.key));
        if (!ok)
          continue;
        const expiresAt = metaData.expiresAt;
        if (expiresAt && expiresAt < now) {
          await this.delete(entry.key);
          cleaned++;
        }
      } catch (err) {
      }
    }
    if (cleaned > 0) {
      this.logger.debug({ cleaned }, `Cleanup: removed ${cleaned} expired objects`);
    }
  }
  async _acquireLock(key) {
    if (!this.enableLocking)
      return;
    const startTime = Date.now();
    while (this.locks.has(key)) {
      if (Date.now() - startTime > this.lockTimeout) {
        throw new ResourceError(`Lock timeout for key: ${key}`, {
          bucket: this.bucket,
          key,
          code: "LockTimeout",
          statusCode: 408,
          retriable: true,
          suggestion: "Increase lockTimeout or investigate concurrent writes holding the lock."
        });
      }
      await new Promise((resolve) => setTimeout(resolve, 10));
    }
    this.locks.set(key, Date.now());
  }
  _releaseLock(key) {
    if (!this.enableLocking)
      return;
    this.locks.delete(key);
  }
  async _journalOperation(operation2, key, metadata = {}) {
    if (!this.enableJournal)
      return;
    const entry = {
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      operation: operation2,
      key,
      metadata
    };
    const journalPath = import_path.default.join(this.basePath, this.journalFile);
    const line = JSON.stringify(entry) + "\n";
    await tryFn$1(() => (0, import_promises4.appendFile)(journalPath, line, "utf8"));
  }
  async _createBackup(filePath) {
    if (!this.enableBackup)
      return;
    if (!(0, import_fs.existsSync)(filePath))
      return;
    const backupPath = filePath + this.backupSuffix;
    await tryFn$1(() => (0, import_promises4.copyFile)(filePath, backupPath));
  }
  _compressBody(body2) {
    if (!this.enableCompression) {
      return { buffer: this._toBuffer(body2), compressed: false };
    }
    const buffer = this._toBuffer(body2);
    const originalSize = buffer.length;
    if (originalSize < this.compressionThreshold) {
      return { buffer, compressed: false, originalSize };
    }
    const compressedBuffer = import_zlib.default.gzipSync(buffer, { level: this.compressionLevel });
    const compressedSize = compressedBuffer.length;
    if (this.enableStats) {
      this.stats.totalUncompressed += originalSize;
      this.stats.totalCompressed += compressedSize;
      this.stats.compressionSaved += originalSize - compressedSize;
    }
    return {
      buffer: compressedBuffer,
      compressed: true,
      originalSize,
      compressedSize,
      compressionRatio: (compressedSize / originalSize).toFixed(3)
    };
  }
  _decompressBody(buffer, isCompressed) {
    if (!isCompressed || !this.enableCompression) {
      return buffer;
    }
    try {
      return import_zlib.default.gunzipSync(buffer);
    } catch (error2) {
      this.logger.warn({ error: error2.message }, "Decompression failed, returning raw buffer");
      return buffer;
    }
  }
  getStats() {
    if (!this.enableStats) {
      return null;
    }
    const avgCompressionRatio = this.stats.totalUncompressed > 0 ? (this.stats.totalCompressed / this.stats.totalUncompressed).toFixed(3) : 1;
    return {
      ...this.stats,
      avgCompressionRatio,
      features: {
        compression: this.enableCompression,
        ttl: this.enableTTL,
        locking: this.enableLocking,
        backup: this.enableBackup,
        journal: this.enableJournal,
        stats: this.enableStats
      }
    };
  }
  _mapFilesystemError(error2, context = {}) {
    const { key, path: filePath, operation: operation2 } = context;
    const errnoError = error2;
    switch (errnoError.code) {
      case "ENOENT":
        const err = new ResourceError(`Object not found: ${key || filePath}`, {
          bucket: this.bucket,
          key,
          path: filePath,
          code: "NoSuchKey",
          statusCode: 404,
          retriable: false,
          suggestion: "Ensure the key exists before attempting to read it.",
          original: error2
        });
        err.name = "NoSuchKey";
        return err;
      case "EACCES":
      case "EPERM":
        return new ResourceError(`Permission denied: ${key || filePath}`, {
          bucket: this.bucket,
          key,
          path: filePath,
          code: "AccessDenied",
          statusCode: 403,
          retriable: false,
          suggestion: "Check filesystem permissions for the basePath directory.",
          original: error2
        });
      case "ENOSPC":
        return new ResourceError("No space left on device", {
          bucket: this.bucket,
          key,
          path: filePath,
          code: "ServiceUnavailable",
          statusCode: 503,
          retriable: true,
          suggestion: "Free up disk space and retry the operation.",
          original: error2
        });
      case "EISDIR":
      case "ENOTDIR":
        return new ResourceError(`Invalid object state: ${errnoError.message}`, {
          bucket: this.bucket,
          key,
          path: filePath,
          code: "InvalidObjectState",
          statusCode: 400,
          retriable: false,
          suggestion: "The key conflicts with a directory. Use a different key.",
          original: error2
        });
      case "ENAMETOOLONG":
        return new ResourceError("Key too long for filesystem", {
          bucket: this.bucket,
          key,
          path: filePath,
          code: "KeyTooLongError",
          statusCode: 400,
          retriable: false,
          suggestion: "Shorten the key or partition names to fit within OS path limits.",
          original: error2
        });
      case "EMFILE":
      case "ENFILE":
        return new ResourceError("Too many open files", {
          bucket: this.bucket,
          key,
          path: filePath,
          code: "ServiceUnavailable",
          statusCode: 503,
          retriable: true,
          suggestion: "Reduce concurrent operations or increase system file descriptor limit.",
          original: error2
        });
      default:
        return new ResourceError(`Filesystem error: ${errnoError.message}`, {
          bucket: this.bucket,
          key,
          path: filePath,
          code: errnoError.code || "InternalError",
          statusCode: 500,
          retriable: false,
          suggestion: "Check filesystem state and retry.",
          original: error2
        });
    }
  }
  async put(key, params) {
    const { body: body2, metadata, contentType, contentEncoding, contentLength, ifMatch, ifNoneMatch, ttl } = params;
    await this._acquireLock(key);
    try {
      this._validateLimits(body2, metadata);
      const objectPath = this._getObjectPath(key);
      const metaPath = this._getMetadataPath(key);
      const exists = (0, import_fs.existsSync)(objectPath);
      if (ifMatch !== void 0) {
        if (!exists) {
          throw new ResourceError(`Precondition failed: object does not exist for key "${key}"`, {
            bucket: this.bucket,
            key,
            code: "PreconditionFailed",
            statusCode: 412,
            retriable: false,
            suggestion: "Fetch the latest object and retry with the current ETag in options.ifMatch."
          });
        }
        const currentMeta = await this._readMetadata(key);
        const expectedEtags = this._normalizeEtagHeader(ifMatch);
        const matches = expectedEtags.includes(currentMeta.etag);
        if (!matches) {
          throw new ResourceError(`Precondition failed: ETag mismatch for key "${key}"`, {
            bucket: this.bucket,
            key,
            code: "PreconditionFailed",
            statusCode: 412,
            retriable: false,
            suggestion: "Fetch the latest object and retry with the current ETag in options.ifMatch."
          });
        }
      }
      if (ifNoneMatch !== void 0) {
        if (ifNoneMatch === "*" && exists) {
          throw new ResourceError(`Precondition failed: object already exists for key "${key}"`, {
            bucket: this.bucket,
            key,
            code: "PreconditionFailed",
            statusCode: 412,
            retriable: false,
            suggestion: 'Use ifNoneMatch: "*" only when the object should not exist or remove the conditional header.'
          });
        }
        if (exists && ifNoneMatch !== "*") {
          const currentMeta = await this._readMetadata(key);
          const normalized = this._normalizeEtagHeader(ifNoneMatch);
          if (normalized.includes(currentMeta.etag)) {
            throw new ResourceError(`Precondition failed: ETag matches for key "${key}"`, {
              bucket: this.bucket,
              key,
              code: "PreconditionFailed",
              statusCode: 412,
              retriable: false,
              suggestion: "Remove ifNoneMatch header if you want to overwrite the object."
            });
          }
        }
      }
      await this._createBackup(objectPath);
      const compressionResult = this._compressBody(body2);
      const buffer = compressionResult.buffer;
      const etag = this._generateETag(buffer);
      const lastModified = (/* @__PURE__ */ new Date()).toISOString();
      const size = buffer.length;
      const effectiveTTL = ttl ?? (this.enableTTL ? this.defaultTTL : null);
      const expiresAt = effectiveTTL ? Date.now() + effectiveTTL : null;
      const [okBody, errBody] = await tryFn$1(() => this._writeAtomic(objectPath, buffer));
      if (!okBody) {
        if (this.enableStats)
          this.stats.errors++;
        throw this._mapFilesystemError(errBody, { key, path: objectPath, operation: "put" });
      }
      const metaData = {
        metadata: metadata ? { ...metadata } : {},
        contentType: contentType || "application/octet-stream",
        etag,
        lastModified,
        size,
        contentEncoding,
        contentLength: typeof contentLength === "number" ? contentLength : size,
        compressed: compressionResult.compressed || false,
        originalSize: compressionResult.originalSize,
        compressionRatio: compressionResult.compressionRatio,
        expiresAt,
        body: buffer
      };
      const [okMeta, errMeta] = await tryFn$1(() => this._writeMetadata(key, metaData));
      if (!okMeta) {
        await tryFn$1(() => (0, import_promises4.unlink)(objectPath));
        if (this.enableStats)
          this.stats.errors++;
        throw this._mapFilesystemError(errMeta, { key, path: metaPath, operation: "put" });
      }
      await this._journalOperation("put", key, {
        size,
        compressed: compressionResult.compressed,
        expiresAt
      });
      if (this.enableStats) {
        this.stats.puts++;
      }
      const info2 = [
        `${size} bytes`,
        `etag: ${etag}`
      ];
      if (compressionResult.compressed) {
        info2.push(`compressed: ${compressionResult.originalSize}\u2192${size} (${compressionResult.compressionRatio}x)`);
      }
      if (expiresAt) {
        info2.push(`ttl: ${effectiveTTL}ms`);
      }
      this.logger.debug({ key, size, etag, compressed: compressionResult.compressed, ttl: effectiveTTL }, `PUT ${key} (${info2.join(", ")})`);
      return {
        ETag: this._formatEtag(etag),
        VersionId: null,
        ServerSideEncryption: null,
        Location: `/${this.bucket}/${key}`
      };
    } finally {
      this._releaseLock(key);
    }
  }
  async get(key) {
    const objectPath = this._getObjectPath(key);
    const metaPath = this._getMetadataPath(key);
    const [okMeta, errMeta, metaData] = await tryFn$1(() => this._readMetadata(key));
    if (!okMeta) {
      throw this._mapFilesystemError(errMeta, { key, path: metaPath, operation: "get" });
    }
    const metadata = metaData;
    if (this.enableTTL && metadata.expiresAt && metadata.expiresAt < Date.now()) {
      await this.delete(key);
      throw this._mapFilesystemError({ code: "ENOENT", message: "Object has expired" }, { key, path: objectPath, operation: "get" });
    }
    const [okBody, errBody, bodyBuffer] = await tryFn$1(() => (0, import_promises4.readFile)(objectPath));
    if (!okBody) {
      if (this.enableStats)
        this.stats.errors++;
      throw this._mapFilesystemError(errBody, { key, path: objectPath, operation: "get" });
    }
    const finalBuffer = this._decompressBody(bodyBuffer, metadata.compressed);
    if (this.enableStats) {
      this.stats.gets++;
    }
    const info2 = [`${metadata.size} bytes`];
    if (metadata.compressed) {
      info2.push(`decompressed: ${metadata.size}\u2192${finalBuffer.length}`);
    }
    this.logger.debug({ key, size: metadata.size, compressed: metadata.compressed }, `GET ${key} (${info2.join(", ")})`);
    const bodyStream = import_stream.Readable.from(finalBuffer);
    bodyStream.transformToString = async (encoding2 = "utf-8") => {
      const chunks = [];
      for await (const chunk2 of bodyStream) {
        chunks.push(chunk2);
      }
      return Buffer.concat(chunks).toString(encoding2);
    };
    bodyStream.transformToByteArray = async () => {
      const chunks = [];
      for await (const chunk2 of bodyStream) {
        chunks.push(chunk2);
      }
      return new Uint8Array(Buffer.concat(chunks));
    };
    bodyStream.transformToWebStream = () => {
      return import_stream.Readable.toWeb(bodyStream);
    };
    return {
      Body: bodyStream,
      Metadata: { ...metadata.metadata },
      ContentType: metadata.contentType,
      ContentLength: finalBuffer.length,
      ETag: this._formatEtag(metadata.etag),
      LastModified: new Date(metadata.lastModified),
      ContentEncoding: metadata.contentEncoding
    };
  }
  async head(key) {
    const metaPath = this._getMetadataPath(key);
    const [ok, err, metaData] = await tryFn$1(() => this._readMetadata(key));
    if (!ok) {
      throw this._mapFilesystemError(err, { key, path: metaPath, operation: "head" });
    }
    const metadata = metaData;
    this.logger.debug({ key }, `HEAD ${key}`);
    return {
      Metadata: { ...metadata.metadata },
      ContentType: metadata.contentType,
      ContentLength: metadata.size,
      ETag: this._formatEtag(metadata.etag),
      LastModified: new Date(metadata.lastModified),
      ContentEncoding: metadata.contentEncoding
    };
  }
  async copy(from, to, params) {
    const { metadata, metadataDirective, contentType } = params;
    const sourceObjectPath = this._getObjectPath(from);
    this._getMetadataPath(from);
    if (!(0, import_fs.existsSync)(sourceObjectPath)) {
      throw new ResourceError(`Source object not found: ${from}`, {
        bucket: this.bucket,
        key: from,
        code: "NoSuchKey",
        statusCode: 404,
        retriable: false,
        suggestion: "Copy requires an existing source object. Verify the source key before retrying."
      });
    }
    const sourceMeta = await this._readMetadata(from);
    let finalMetadata = { ...sourceMeta.metadata };
    if (metadataDirective === "REPLACE" && metadata) {
      finalMetadata = metadata;
    } else if (metadata) {
      finalMetadata = { ...finalMetadata, ...metadata };
    }
    const destObjectPath = this._getObjectPath(to);
    await this._ensureDirectory(destObjectPath);
    const [okCopy, errCopy] = await tryFn$1(() => (0, import_promises4.copyFile)(sourceObjectPath, destObjectPath));
    if (!okCopy) {
      throw this._mapFilesystemError(errCopy, { key: to, path: destObjectPath, operation: "copy" });
    }
    const destMeta = {
      metadata: finalMetadata,
      contentType: contentType || sourceMeta.contentType,
      etag: sourceMeta.etag,
      lastModified: (/* @__PURE__ */ new Date()).toISOString(),
      size: sourceMeta.size,
      contentEncoding: sourceMeta.contentEncoding,
      contentLength: sourceMeta.contentLength,
      body: sourceMeta.body
    };
    await this._writeMetadata(to, destMeta);
    this.logger.debug({ from, to }, `COPY ${from} \u2192 ${to}`);
    return {
      CopyObjectResult: {
        ETag: this._formatEtag(destMeta.etag),
        LastModified: destMeta.lastModified
      },
      BucketKeyEnabled: false,
      VersionId: null,
      ServerSideEncryption: null
    };
  }
  async delete(key) {
    const objectPath = this._getObjectPath(key);
    const metaPath = this._getMetadataPath(key);
    await tryFn$1(() => (0, import_promises4.unlink)(objectPath));
    await tryFn$1(() => (0, import_promises4.unlink)(metaPath));
    if (this.enableBackup) {
      const backupPath = objectPath + this.backupSuffix;
      await tryFn$1(() => (0, import_promises4.unlink)(backupPath));
    }
    await this._journalOperation("delete", key);
    if (this.enableStats) {
      this.stats.deletes++;
    }
    this.logger.debug({ key }, `DELETE ${key}`);
    return {
      DeleteMarker: false,
      VersionId: null
    };
  }
  async deleteMultiple(keys2) {
    const deleted = [];
    const errors2 = [];
    for (const key of keys2) {
      try {
        await this.delete(key);
        deleted.push({ Key: key });
      } catch (error2) {
        const err = error2;
        errors2.push({
          Key: key,
          Code: err.name || "InternalError",
          Message: err.message
        });
      }
    }
    this.logger.debug({ deletedCount: deleted.length, errorCount: errors2.length }, `DELETE BATCH (${deleted.length} deleted, ${errors2.length} errors)`);
    return { Deleted: deleted, Errors: errors2 };
  }
  async *_walkDirectory(dirPath, prefix = "") {
    let entries;
    try {
      entries = await (0, import_promises4.readdir)(dirPath, { withFileTypes: true });
    } catch (error2) {
      if (error2.code === "ENOENT") {
        return;
      }
      throw error2;
    }
    const files = [];
    for (const entry of entries) {
      const fullPath = import_path.default.join(dirPath, entry.name);
      if (entry.isDirectory()) {
        yield* this._walkDirectory(fullPath, prefix);
      } else if (entry.isFile() && !entry.name.endsWith(".meta.json")) {
        files.push({ entry, fullPath });
      }
    }
    const fileBatches = chunk_default(files, 50);
    for (const batch of fileBatches) {
      const promises2 = batch.map(async ({ entry, fullPath }) => {
        const key = this._pathToKey(fullPath);
        if (!prefix || key.startsWith(prefix)) {
          const [ok, , stats2] = await tryFn$1(() => (0, import_promises4.stat)(fullPath));
          if (ok) {
            return {
              key,
              path: fullPath,
              size: stats2.size,
              mtime: stats2.mtime
            };
          }
        }
        return null;
      });
      const results = await Promise.all(promises2);
      for (const res of results) {
        if (res)
          yield res;
      }
    }
  }
  async list(params) {
    const { prefix = "", delimiter = null, maxKeys = 1e3, continuationToken = null, startAfter = null } = params;
    const prefixFilter = prefix || "";
    this.logger.debug({ prefix, delimiter, maxKeys, continuationToken, startAfter }, "[FileSystemStorage.list] Initial params");
    const startPath = prefixFilter ? this._keyToPath(prefixFilter) : this.basePath;
    this.logger.debug({ startPath, prefixFilter }, "[FileSystemStorage.list] Derived startPath");
    let searchPath;
    try {
      const startStats = await (0, import_promises4.stat)(startPath);
      searchPath = startStats.isDirectory() ? startPath : import_path.default.dirname(startPath);
      this.logger.debug({ startPath, searchPath, isDirectory: startStats.isDirectory() }, "[FileSystemStorage.list] stat success");
    } catch (err) {
      if (err.code === "ENOENT") {
        this.logger.debug({ startPath, error: err.message }, "[FileSystemStorage.list] startPath does not exist, searching parent");
        searchPath = import_path.default.dirname(startPath);
      } else {
        this.logger.error({ error: err.message }, "[FileSystemStorage.list] Error stating startPath");
        throw err;
      }
    }
    this.logger.debug({ searchPath }, "[FileSystemStorage.list] Final searchPath");
    const allKeys = [];
    for await (const entry of this._walkDirectory(searchPath, prefixFilter)) {
      allKeys.push(entry);
    }
    this.logger.debug({ count: allKeys.length, keys: allKeys.map((k4) => k4.key) }, "[FileSystemStorage.list] Keys from _walkDirectory");
    allKeys.sort((a4, b4) => a4.key.localeCompare(b4.key));
    let startAfterKey = null;
    if (continuationToken) {
      startAfterKey = this._decodeContinuationToken(continuationToken);
    } else if (startAfter) {
      startAfterKey = startAfter;
    }
    let filteredKeys = startAfterKey ? allKeys.filter((entry) => entry.key > startAfterKey) : allKeys;
    const contents = [];
    const commonPrefixes = /* @__PURE__ */ new Set();
    let processed = 0;
    let lastKeyInPage = null;
    for (const entry of filteredKeys) {
      if (processed >= maxKeys) {
        break;
      }
      const prefixEntry = delimiter ? this._extractCommonPrefix(prefixFilter, delimiter, entry.key) : null;
      if (prefixEntry) {
        if (!commonPrefixes.has(prefixEntry)) {
          commonPrefixes.add(prefixEntry);
        }
        continue;
      }
      const [ok, , metaData] = await tryFn$1(() => this._readMetadata(entry.key));
      const etag = ok ? metaData.etag : this._generateETag(Buffer.alloc(0));
      contents.push({
        Key: entry.key,
        Size: entry.size,
        LastModified: new Date(entry.mtime),
        ETag: this._formatEtag(etag),
        StorageClass: "STANDARD"
      });
      processed++;
      lastKeyInPage = entry.key;
    }
    const hasMoreKeys = filteredKeys.length > contents.length;
    const nextContinuationToken = hasMoreKeys && lastKeyInPage ? this._encodeContinuationToken(lastKeyInPage) : null;
    this.logger.debug({ prefix, objectCount: contents.length, prefixCount: commonPrefixes.size, truncated: Boolean(nextContinuationToken) }, `LIST prefix="${prefix}" (${contents.length} objects, ${commonPrefixes.size} prefixes, truncated=${Boolean(nextContinuationToken)})`);
    return {
      Contents: contents,
      CommonPrefixes: Array.from(commonPrefixes).map((commonPrefix) => ({ Prefix: commonPrefix })),
      IsTruncated: Boolean(nextContinuationToken),
      ContinuationToken: continuationToken || void 0,
      NextContinuationToken: nextContinuationToken,
      KeyCount: contents.length,
      MaxKeys: maxKeys,
      Prefix: prefix || void 0,
      Delimiter: delimiter || void 0,
      StartAfter: startAfter || void 0
    };
  }
  exists(key) {
    const objectPath = this._getObjectPath(key);
    return (0, import_fs.existsSync)(objectPath);
  }
  async clear() {
    if (!this.basePath.includes("s3db") && !this.basePath.includes("data")) {
      throw new ValidationError2("Cannot clear basePath - does not look like a data directory", {
        basePath: this.basePath,
        retriable: false,
        suggestion: 'Only directories with "s3db" or "data" in the path can be cleared for safety.'
      });
    }
    const { rm: rm2 } = await import("fs/promises");
    await tryFn$1(() => rm2(this.basePath, { recursive: true, force: true }));
    await this._ensureDirectory(this.basePath);
    this.logger.debug({ basePath: this.basePath }, `Cleared all objects from ${this.basePath}`);
  }
  destroy() {
    if (this.cleanupJobName) {
      this.cronManager.stop(this.cleanupJobName);
      this.cleanupJobName = null;
    }
    this.logger.debug("Destroyed (cleanup stopped)");
  }
};
var pathPosix = import_path.default.posix;
var globalStorageRegistry = /* @__PURE__ */ new Map();
var FileSystemClient = class extends import_events.default {
  id;
  logLevel;
  logger;
  taskExecutorMonitoring;
  taskManager;
  storage;
  basePath;
  bucket;
  keyPrefix;
  region;
  _keyPrefixForStrip;
  connectionString;
  config;
  constructor(config = {}) {
    super();
    this.id = config.id || idGenerator(77);
    this.logLevel = config.logLevel || "info";
    if (config.logger) {
      this.logger = config.logger;
    } else {
      this.logger = createLogger({ name: "FileSystemClient", level: this.logLevel });
    }
    this.taskExecutorMonitoring = config.taskExecutorMonitoring ? { ...config.taskExecutorMonitoring } : null;
    if (config.taskExecutor) {
      this.taskManager = config.taskExecutor;
    } else {
      this.taskManager = new TasksRunner({
        concurrency: config.concurrency || 5,
        retries: config.retries ?? 3,
        retryDelay: config.retryDelay ?? 1e3,
        timeout: config.timeout ?? 3e4,
        retryableErrors: config.retryableErrors || [],
        monitoring: this.taskExecutorMonitoring || void 0
      });
    }
    this.basePath = config.basePath || "./s3db-data";
    this.bucket = config.bucket || "s3db";
    this.keyPrefix = config.keyPrefix || "";
    this.region = config.region || "local";
    this._keyPrefixForStrip = this.keyPrefix ? pathPosix.join(this.keyPrefix, "") : "";
    this.basePath = import_path.default.resolve(this.basePath);
    const encodedBasePath = encodeURI(this.basePath);
    this.connectionString = `file://${encodedBasePath}`;
    if (!globalStorageRegistry.has(this.basePath)) {
      globalStorageRegistry.set(this.basePath, new FileSystemStorage({
        basePath: this.basePath,
        bucket: this.bucket,
        enforceLimits: config.enforceLimits || false,
        metadataLimit: config.metadataLimit || 2048,
        maxObjectSize: config.maxObjectSize || 5 * 1024 * 1024 * 1024,
        logLevel: this.logLevel,
        compression: config.compression,
        ttl: config.ttl,
        locking: config.locking,
        backup: config.backup,
        journal: config.journal,
        stats: config.stats
      }));
    }
    this.storage = globalStorageRegistry.get(this.basePath);
    this.config = {
      bucket: this.bucket,
      keyPrefix: this.keyPrefix,
      region: this.region,
      basePath: this.basePath,
      endpoint: `file://${this.basePath}`,
      forcePathStyle: true
    };
    this.logger.debug({ id: this.id, basePath: this.basePath, bucket: this.bucket }, `Initialized (id: ${this.id}, basePath: ${this.basePath}, bucket: ${this.bucket})`);
  }
  getQueueStats() {
    if (this.taskManager && typeof this.taskManager.getStats === "function") {
      return this.taskManager.getStats();
    }
    return null;
  }
  getAggregateMetrics(since = 0) {
    if (this.taskManager && typeof this.taskManager.getAggregateMetrics === "function") {
      return this.taskManager.getAggregateMetrics(since);
    }
    return null;
  }
  async sendCommand(command) {
    const commandName = command.constructor.name;
    const input = command.input || {};
    this.emit("cl:request", commandName, input);
    this.emit("command.request", commandName, input);
    let response2;
    try {
      switch (commandName) {
        case "PutObjectCommand":
          response2 = await this._handlePutObject(input);
          break;
        case "GetObjectCommand":
          response2 = await this._handleGetObject(input);
          break;
        case "HeadObjectCommand":
          response2 = await this._handleHeadObject(input);
          break;
        case "CopyObjectCommand":
          response2 = await this._handleCopyObject(input);
          break;
        case "DeleteObjectCommand":
          response2 = await this._handleDeleteObject(input);
          break;
        case "DeleteObjectsCommand":
          response2 = await this._handleDeleteObjects(input);
          break;
        case "ListObjectsV2Command":
          response2 = await this._handleListObjects(input);
          break;
        default:
          throw new DatabaseError(`Unsupported command: ${commandName}`, {
            operation: "sendCommand",
            statusCode: 400,
            retriable: false,
            suggestion: "Use one of the supported commands: PutObject, GetObject, HeadObject, CopyObject, DeleteObject, DeleteObjects, or ListObjectsV2."
          });
      }
      this.emit("cl:response", commandName, response2, input);
      this.emit("command.response", commandName, response2, input);
      return response2;
    } catch (error2) {
      if (error2 instanceof BaseError) {
        throw error2;
      }
      const mappedError = mapAwsError(error2, {
        bucket: this.bucket,
        key: input.Key,
        commandName,
        commandInput: input
      });
      throw mappedError;
    }
  }
  async _handlePutObject(input) {
    const key = this._applyKeyPrefix(input.Key);
    const metadata = this._encodeMetadata(input.Metadata || {});
    const contentType = input.ContentType;
    const body2 = input.Body;
    const contentEncoding = input.ContentEncoding;
    const contentLength = input.ContentLength;
    const ifMatch = input.IfMatch;
    const ifNoneMatch = input.IfNoneMatch;
    return await this.storage.put(key, {
      body: body2,
      metadata,
      contentType,
      contentEncoding,
      contentLength,
      ifMatch,
      ifNoneMatch
    });
  }
  async _handleGetObject(input) {
    const key = this._applyKeyPrefix(input.Key);
    const response2 = await this.storage.get(key);
    return this._decodeMetadataResponse(response2);
  }
  async _handleHeadObject(input) {
    const key = this._applyKeyPrefix(input.Key);
    const response2 = await this.storage.head(key);
    return this._decodeMetadataResponse(response2);
  }
  async _handleCopyObject(input) {
    const { sourceBucket, sourceKey } = this._parseCopySource(input.CopySource);
    if (sourceBucket !== this.bucket) {
      throw new DatabaseError(`Cross-bucket copy is not supported in FileSystemClient (requested ${sourceBucket} \u2192 ${this.bucket})`, {
        operation: "CopyObject",
        retriable: false,
        suggestion: "Instantiate a FileSystemClient with the desired bucket or copy within the same bucket."
      });
    }
    const destinationKey = this._applyKeyPrefix(input.Key);
    const encodedMetadata = this._encodeMetadata(input.Metadata);
    return await this.storage.copy(sourceKey, destinationKey, {
      metadata: encodedMetadata,
      metadataDirective: input.MetadataDirective,
      contentType: input.ContentType
    });
  }
  async _handleDeleteObject(input) {
    const key = this._applyKeyPrefix(input.Key);
    return await this.storage.delete(key);
  }
  async _handleDeleteObjects(input) {
    const objects = input.Delete?.Objects || [];
    const keys2 = objects.map((obj) => this._applyKeyPrefix(obj.Key));
    return await this.storage.deleteMultiple(keys2);
  }
  async _handleListObjects(input) {
    const fullPrefix = this._applyKeyPrefix(input.Prefix || "");
    const params = {
      prefix: fullPrefix,
      delimiter: input.Delimiter,
      maxKeys: input.MaxKeys,
      continuationToken: input.ContinuationToken
    };
    if (input.StartAfter) {
      params.startAfter = this._applyKeyPrefix(input.StartAfter);
    }
    const response2 = await this.storage.list(params);
    return this._normalizeListResponse(response2);
  }
  async putObject(params) {
    const { key, metadata, contentType, body: body2, contentEncoding, contentLength, ifMatch, ifNoneMatch } = params;
    const fullKey = this._applyKeyPrefix(key);
    const stringMetadata = this._encodeMetadata(metadata) || {};
    const input = { Key: key, Metadata: metadata, ContentType: contentType, Body: body2, ContentEncoding: contentEncoding, ContentLength: contentLength, IfMatch: ifMatch, IfNoneMatch: ifNoneMatch };
    const response2 = await this.storage.put(fullKey, {
      body: body2,
      metadata: stringMetadata,
      contentType,
      contentEncoding,
      contentLength,
      ifMatch,
      ifNoneMatch
    });
    this.emit("cl:response", "PutObjectCommand", response2, input);
    return response2;
  }
  async getObject(key) {
    const fullKey = this._applyKeyPrefix(key);
    const input = { Key: key };
    const response2 = await this.storage.get(fullKey);
    const decodedResponse = this._decodeMetadataResponse(response2);
    this.emit("cl:response", "GetObjectCommand", decodedResponse, input);
    return decodedResponse;
  }
  async headObject(key) {
    const fullKey = this._applyKeyPrefix(key);
    const input = { Key: key };
    const response2 = await this.storage.head(fullKey);
    const decodedResponse = this._decodeMetadataResponse(response2);
    this.emit("cl:response", "HeadObjectCommand", decodedResponse, input);
    return decodedResponse;
  }
  async copyObject(params) {
    const { from, to, metadata, metadataDirective, contentType } = params;
    const fullFrom = this._applyKeyPrefix(from);
    const fullTo = this._applyKeyPrefix(to);
    const encodedMetadata = this._encodeMetadata(metadata);
    const input = { CopySource: from, Key: to, Metadata: metadata, MetadataDirective: metadataDirective, ContentType: contentType };
    const response2 = await this.storage.copy(fullFrom, fullTo, {
      metadata: encodedMetadata,
      metadataDirective,
      contentType
    });
    this.emit("cl:response", "CopyObjectCommand", response2, input);
    return response2;
  }
  async exists(key) {
    const fullKey = this._applyKeyPrefix(key);
    return this.storage.exists(fullKey);
  }
  async deleteObject(key) {
    const fullKey = this._applyKeyPrefix(key);
    const input = { Key: key };
    const response2 = await this.storage.delete(fullKey);
    this.emit("cl:response", "DeleteObjectCommand", response2, input);
    return response2;
  }
  async deleteObjects(keys2) {
    const fullKeys = keys2.map((key) => this._applyKeyPrefix(key));
    const input = { Delete: { Objects: keys2.map((key) => ({ Key: key })) } };
    const batches = chunk_default(fullKeys, this.taskManager.concurrency || 5);
    const allResults = { Deleted: [], Errors: [] };
    const { results } = await this.taskManager.process(batches, async (batch) => {
      return await this.storage.deleteMultiple(batch);
    });
    for (const result of results) {
      allResults.Deleted.push(...result.Deleted.map((item) => ({ Key: this._stripKeyPrefix(item.Key) })));
      allResults.Errors.push(...result.Errors);
    }
    this.emit("cl:response", "DeleteObjectsCommand", allResults, input);
    return allResults;
  }
  async listObjects(params = {}) {
    const { prefix = "", delimiter = null, maxKeys = 1e3, continuationToken = null, startAfter = null } = params;
    const fullPrefix = this._applyKeyPrefix(prefix || "");
    const listParams = {
      prefix: fullPrefix,
      delimiter,
      maxKeys,
      continuationToken
    };
    if (startAfter) {
      listParams.startAfter = this._applyKeyPrefix(startAfter);
    }
    const input = { Prefix: prefix, Delimiter: delimiter, MaxKeys: maxKeys, ContinuationToken: continuationToken, StartAfter: startAfter };
    const response2 = await this.storage.list(listParams);
    const normalized = this._normalizeListResponse(response2);
    this.emit("cl:response", "ListObjectsV2Command", normalized, input);
    return normalized;
  }
  async getKeysPage(params = {}) {
    const { prefix = "", offset = 0, amount = 100 } = params;
    let keys2 = [];
    let truncated = true;
    let continuationToken;
    if (offset > 0) {
      const fullPrefix = this._applyKeyPrefix(prefix || "");
      const response2 = await this.storage.list({
        prefix: fullPrefix,
        maxKeys: offset + amount
      });
      keys2 = (response2.Contents || []).map((x4) => this._stripKeyPrefix(x4.Key)).slice(offset, offset + amount);
      truncated = Boolean(response2.NextContinuationToken);
      continuationToken = response2.NextContinuationToken || void 0;
    } else {
      while (truncated) {
        const remaining = amount - keys2.length;
        if (remaining <= 0) {
          break;
        }
        const res = await this.listObjects({
          prefix,
          continuationToken,
          maxKeys: remaining
        });
        if (res.Contents) {
          keys2 = keys2.concat(res.Contents.map((x4) => x4.Key));
        }
        truncated = res.IsTruncated || false;
        continuationToken = res.NextContinuationToken || void 0;
        if (keys2.length >= amount) {
          keys2 = keys2.slice(0, amount);
          break;
        }
      }
    }
    this.emit("cl:GetKeysPage", keys2, params);
    return keys2;
  }
  async getAllKeys(params = {}) {
    const { prefix = "" } = params;
    const fullPrefix = this._applyKeyPrefix(prefix || "");
    const response2 = await this.storage.list({
      prefix: fullPrefix,
      maxKeys: Number.MAX_SAFE_INTEGER
    });
    const keys2 = (response2.Contents || []).map((x4) => this._stripKeyPrefix(x4.Key));
    this.emit("cl:GetAllKeys", keys2, params);
    return keys2;
  }
  async count(params = {}) {
    const { prefix = "" } = params;
    const keys2 = await this.getAllKeys({ prefix });
    const count = keys2.length;
    this.emit("cl:Count", count, { prefix });
    return count;
  }
  async deleteAll(params = {}) {
    const { prefix = "" } = params;
    const keys2 = await this.getAllKeys({ prefix });
    let totalDeleted = 0;
    if (keys2.length > 0) {
      const result = await this.deleteObjects(keys2);
      totalDeleted = result.Deleted.length;
      this.emit("deleteAll", {
        prefix,
        batch: totalDeleted,
        total: totalDeleted
      });
    }
    this.emit("deleteAllComplete", {
      prefix,
      totalDeleted
    });
    return totalDeleted;
  }
  async getContinuationTokenAfterOffset(params = {}) {
    const { prefix = "", offset = 1e3 } = params;
    if (offset === 0)
      return null;
    const keys2 = await this.getAllKeys({ prefix });
    if (offset >= keys2.length) {
      this.emit("cl:GetContinuationTokenAfterOffset", null, { prefix, offset });
      return null;
    }
    const keyForToken = keys2[offset];
    const fullKey = this._applyKeyPrefix(keyForToken || "");
    const token = this._encodeContinuationTokenKey(fullKey);
    this.emit("cl:GetContinuationTokenAfterOffset", token, { prefix, offset });
    return token;
  }
  async moveObject(params) {
    const { from, to } = params;
    const [ok, err] = await tryFn$1(async () => {
      await this.copyObject({ from, to, metadataDirective: "COPY" });
      await this.deleteObject(from);
    });
    if (!ok) {
      throw new DatabaseError("Unknown error in moveObject", {
        bucket: this.bucket,
        from,
        to,
        original: err
      });
    }
    return true;
  }
  async moveAllObjects(params) {
    const { prefixFrom, prefixTo } = params;
    const keys2 = await this.getAllKeys({ prefix: prefixFrom });
    const { results, errors: errors2 } = await this.taskManager.process(keys2, async (key) => {
      const to = key.replace(prefixFrom, prefixTo);
      await this.moveObject({ from: key, to });
      return { from: key, to };
    });
    this.emit("moveAllObjects", { results, errors: errors2 });
    if (errors2.length > 0) {
      const error2 = new Error("Some objects could not be moved");
      error2.context = {
        bucket: this.bucket,
        operation: "moveAllObjects",
        prefixFrom,
        prefixTo,
        totalKeys: keys2.length,
        failedCount: errors2.length,
        successCount: results.length,
        errors: errors2
      };
      throw error2;
    }
    return results;
  }
  async clear() {
    await this.storage.clear();
  }
  _encodeMetadata(metadata) {
    if (!metadata)
      return void 0;
    const encoded = {};
    for (const [rawKey, value] of Object.entries(metadata)) {
      const validKey = String(rawKey).replace(/[^a-zA-Z0-9\-_]/g, "_").toLowerCase();
      const { encoded: encodedValue } = metadataEncode(value);
      encoded[validKey] = encodedValue;
    }
    return encoded;
  }
  _decodeMetadataResponse(response2) {
    const decodedMetadata = {};
    if (response2.Metadata) {
      for (const [k4, v4] of Object.entries(response2.Metadata)) {
        decodedMetadata[k4] = metadataDecode(v4);
      }
    }
    return {
      ...response2,
      Metadata: decodedMetadata
    };
  }
  _applyKeyPrefix(key) {
    if (!this.keyPrefix) {
      if (key === void 0 || key === null) {
        return "";
      }
      return key;
    }
    if (key === void 0 || key === null || key === "") {
      return pathPosix.join(this.keyPrefix, "");
    }
    return pathPosix.join(this.keyPrefix, key);
  }
  _stripKeyPrefix(key = "") {
    if (!this.keyPrefix) {
      return key;
    }
    const normalizedPrefix = this._keyPrefixForStrip;
    if (normalizedPrefix && key.startsWith(normalizedPrefix)) {
      return key.slice(normalizedPrefix.length).replace(/^\/+/, "");
    }
    return key;
  }
  _encodeContinuationTokenKey(key) {
    return Buffer.from(String(key), "utf8").toString("base64");
  }
  _parseCopySource(copySource) {
    const trimmedSource = String(copySource || "").replace(/^\//, "");
    const [sourcePath] = trimmedSource.split("?");
    const decodedSource = decodeURIComponent(sourcePath ?? "");
    const [sourceBucket, ...sourceKeyParts] = decodedSource.split("/");
    if (!sourceBucket || sourceKeyParts.length === 0) {
      throw new DatabaseError(`Invalid CopySource value: ${copySource}`, {
        operation: "CopyObject",
        retriable: false,
        suggestion: 'Provide CopySource in the format "<bucket>/<key>" as expected by AWS S3.'
      });
    }
    return {
      sourceBucket,
      sourceKey: sourceKeyParts.join("/")
    };
  }
  _normalizeListResponse(response2) {
    const rawContents = Array.isArray(response2.Contents) ? response2.Contents : [];
    const contents = rawContents.map((item) => ({
      ...item,
      Key: this._stripKeyPrefix(item.Key)
    }));
    const rawPrefixes = Array.isArray(response2.CommonPrefixes) ? response2.CommonPrefixes : [];
    const commonPrefixes = rawPrefixes.map(({ Prefix }) => ({
      Prefix: this._stripKeyPrefix(Prefix)
    }));
    return {
      Contents: contents,
      CommonPrefixes: commonPrefixes,
      IsTruncated: response2.IsTruncated,
      ContinuationToken: response2.ContinuationToken,
      NextContinuationToken: response2.NextContinuationToken,
      KeyCount: contents.length,
      MaxKeys: response2.MaxKeys,
      Prefix: this.keyPrefix ? void 0 : response2.Prefix,
      Delimiter: response2.Delimiter,
      StartAfter: response2.StartAfter
    };
  }
  getStats() {
    return this.storage.getStats();
  }
  destroy() {
    if (this.storage && typeof this.storage.destroy === "function") {
      this.storage.destroy();
    }
  }
  static clearPathStorage(basePath) {
    const absolutePath = import_path.default.resolve(basePath);
    const storage = globalStorageRegistry.get(absolutePath);
    if (storage && typeof storage.destroy === "function") {
      storage.destroy();
    }
    globalStorageRegistry.delete(absolutePath);
  }
  static clearAllStorage() {
    for (const storage of globalStorageRegistry.values()) {
      if (typeof storage.destroy === "function") {
        storage.destroy();
      }
    }
    globalStorageRegistry.clear();
  }
};
var ProcessManager = class {
  options;
  logger;
  intervals;
  timeouts;
  cleanups;
  isShuttingDown;
  shutdownPromise;
  _boundSignalHandler;
  _boundUncaughtHandler;
  _boundUnhandledHandler;
  _signalHandlersSetup;
  constructor(options = {}) {
    this.options = {
      logLevel: options.logLevel || "info",
      shutdownTimeout: options.shutdownTimeout || 3e4,
      exitOnSignal: options.exitOnSignal !== false
    };
    if (options.logger) {
      this.logger = options.logger;
    } else {
      const logLevel = this.options.logLevel;
      this.logger = createLogger({ name: "ProcessManager", level: logLevel });
    }
    this.intervals = /* @__PURE__ */ new Map();
    this.timeouts = /* @__PURE__ */ new Map();
    this.cleanups = /* @__PURE__ */ new Map();
    this.isShuttingDown = false;
    this.shutdownPromise = null;
    this._signalHandlersSetup = false;
    this._boundSignalHandler = this._handleSignal.bind(this);
    this._boundUncaughtHandler = null;
    this._boundUnhandledHandler = null;
    this._setupSignalHandlers();
    this.logger.debug({ shutdownTimeout: this.options.shutdownTimeout }, "ProcessManager initialized");
  }
  setInterval(fn, interval, name) {
    if (this.isShuttingDown) {
      throw new Error(`[ProcessManager] Cannot register interval '${name}' during shutdown`);
    }
    if (this.intervals.has(name)) {
      this.logger.warn({ name }, `interval '${name}' already exists, clearing previous`);
      this.clearInterval(name);
    }
    const start = Date.now();
    let expected = start + interval;
    let timerId;
    const tick = () => {
      const now = Date.now();
      const drift = now - expected;
      let executions = 1;
      if (drift > interval) {
        executions += Math.floor(drift / interval);
      }
      try {
        for (let i4 = 0; i4 < executions; i4++)
          fn();
      } finally {
        expected += executions * interval;
        const nextDelay = Math.max(0, interval - drift % interval);
        timerId = setTimeout(tick, nextDelay);
      }
    };
    timerId = setTimeout(tick, interval);
    this.intervals.set(name, { id: timerId, fn, interval, precise: true });
    this.logger.debug({ name, interval }, `registered interval '${name}' (${interval}ms)`);
    return timerId;
  }
  clearInterval(name) {
    const entry = this.intervals.get(name);
    if (entry) {
      if (entry.precise) {
        clearTimeout(entry.id);
      } else {
        clearInterval(entry.id);
      }
      this.intervals.delete(name);
      this.logger.debug({ name }, `cleared interval '${name}'`);
    }
  }
  setTimeout(fn, delay, name) {
    if (this.isShuttingDown) {
      throw new Error(`[ProcessManager] Cannot register timeout '${name}' during shutdown`);
    }
    if (this.timeouts.has(name)) {
      this.logger.warn({ name }, `timeout '${name}' already exists, clearing previous`);
      this.clearTimeout(name);
    }
    const id2 = setTimeout(() => {
      fn();
      this.timeouts.delete(name);
    }, delay);
    this.timeouts.set(name, { id: id2, fn, delay });
    this.logger.debug({ name, delay }, `registered timeout '${name}' (${delay}ms)`);
    return id2;
  }
  clearTimeout(name) {
    const entry = this.timeouts.get(name);
    if (entry) {
      clearTimeout(entry.id);
      this.timeouts.delete(name);
      this.logger.debug({ name }, `cleared timeout '${name}'`);
    }
  }
  registerCleanup(cleanupFn, name) {
    if (this.isShuttingDown) {
      throw new Error(`[ProcessManager] Cannot register cleanup '${name}' during shutdown`);
    }
    if (this.cleanups.has(name)) {
      this.logger.warn({ name }, `cleanup '${name}' already registered, replacing`);
    }
    this.cleanups.set(name, cleanupFn);
    this.logger.debug({ name }, `registered cleanup '${name}'`);
  }
  unregisterCleanup(name) {
    if (this.cleanups.delete(name)) {
      this.logger.debug({ name }, `unregistered cleanup '${name}'`);
    }
  }
  _setupSignalHandlers() {
    if (this._signalHandlersSetup)
      return;
    this._boundUncaughtHandler = (err) => {
      this.logger.error({ error: err.message, stack: err.stack }, "uncaught exception");
      this._handleSignal("uncaughtException");
    };
    this._boundUnhandledHandler = (reason, promise2) => {
      this.logger.error({ reason, promise: String(promise2) }, "unhandled rejection");
      this._handleSignal("unhandledRejection");
    };
    bumpProcessMaxListeners(4);
    process.on("SIGTERM", this._boundSignalHandler);
    process.on("SIGINT", this._boundSignalHandler);
    process.on("uncaughtException", this._boundUncaughtHandler);
    process.on("unhandledRejection", this._boundUnhandledHandler);
    this._signalHandlersSetup = true;
    this.logger.debug("signal handlers registered (SIGTERM, SIGINT, uncaughtException, unhandledRejection)");
  }
  async _handleSignal(signal) {
    if (this.isShuttingDown) {
      this.logger.debug({ signal }, `shutdown already in progress, ignoring ${signal}`);
      return;
    }
    try {
      await this.shutdown();
      if (this.options.exitOnSignal) {
        process.exit(0);
      }
    } catch (err) {
      const error2 = err;
      this.logger.error({ error: error2.message, stack: error2.stack }, "error during shutdown");
      if (this.options.exitOnSignal) {
        process.exit(1);
      }
    }
  }
  async shutdown(options = {}) {
    if (this.isShuttingDown) {
      this.logger.debug("shutdown already in progress, waiting for completion...");
      return this.shutdownPromise;
    }
    this.isShuttingDown = true;
    const timeout = options.timeout || this.options.shutdownTimeout;
    this.shutdownPromise = this._performShutdown(timeout);
    return this.shutdownPromise;
  }
  async _performShutdown(timeout) {
    const startTime = Date.now();
    if (this.intervals.size > 0) {
      for (const [name, entry] of this.intervals.entries()) {
        if (entry.precise) {
          clearTimeout(entry.id);
        } else {
          clearInterval(entry.id);
        }
        this.logger.debug({ name }, `cleared interval '${name}'`);
      }
      this.intervals.clear();
    }
    if (this.timeouts.size > 0) {
      for (const [name, entry] of this.timeouts.entries()) {
        clearTimeout(entry.id);
        this.logger.debug({ name }, `cleared timeout '${name}'`);
      }
      this.timeouts.clear();
    }
    if (this.cleanups.size > 0) {
      const cleanupPromises = Array.from(this.cleanups.entries()).map(async ([name, cleanupFn]) => {
        try {
          const cleanupTimeout = new Promise((_, reject) => setTimeout(() => reject(new Error(`Cleanup '${name}' timed out`)), timeout));
          await Promise.race([
            cleanupFn(),
            cleanupTimeout
          ]);
          this.logger.debug({ name }, `cleanup '${name}' completed`);
        } catch (err) {
          const error2 = err;
          this.logger.error({ name, error: error2.message }, `cleanup '${name}' failed`);
        }
      });
      await Promise.allSettled(cleanupPromises);
      this.cleanups.clear();
    }
    const elapsed = Date.now() - startTime;
    this.logger.debug({ elapsed }, `shutdown completed in ${elapsed}ms`);
  }
  getStatus() {
    return {
      isShuttingDown: this.isShuttingDown,
      intervals: Array.from(this.intervals.keys()),
      timeouts: Array.from(this.timeouts.keys()),
      cleanups: Array.from(this.cleanups.keys()),
      counts: {
        intervals: this.intervals.size,
        timeouts: this.timeouts.size,
        cleanups: this.cleanups.size
      }
    };
  }
  removeSignalHandlers() {
    if (!this._signalHandlersSetup)
      return;
    process.removeListener("SIGTERM", this._boundSignalHandler);
    process.removeListener("SIGINT", this._boundSignalHandler);
    if (this._boundUncaughtHandler) {
      process.removeListener("uncaughtException", this._boundUncaughtHandler);
      this._boundUncaughtHandler = null;
    }
    if (this._boundUnhandledHandler) {
      process.removeListener("unhandledRejection", this._boundUnhandledHandler);
      this._boundUnhandledHandler = null;
    }
    this._signalHandlersSetup = false;
    bumpProcessMaxListeners(-4);
    this.logger.debug("signal handlers removed");
  }
};
var SafeEventEmitter = class extends import_events.default {
  options;
  logger;
  _signalHandlersSetup;
  _isDestroyed;
  _boundCleanupHandler;
  constructor(options = {}) {
    super();
    this.options = {
      logLevel: options.logLevel || "info",
      autoCleanup: options.autoCleanup !== false,
      maxListeners: options.maxListeners || 0
    };
    if (options.logger) {
      this.logger = options.logger;
    } else {
      this.logger = createLogger({ name: "SafeEventEmitter", level: this.options.logLevel });
    }
    this._signalHandlersSetup = false;
    this._isDestroyed = false;
    if (this.options.maxListeners > 0) {
      this.setMaxListeners(this.options.maxListeners);
    }
    if (this.options.autoCleanup) {
      this._setupSignalHandlers();
    }
    this.logger.debug({ autoCleanup: this.options.autoCleanup }, `Initialized with auto-cleanup: ${this.options.autoCleanup}`);
  }
  _setupSignalHandlers() {
    if (this._signalHandlersSetup)
      return;
    this._boundCleanupHandler = this._handleCleanup.bind(this);
    bumpProcessMaxListeners(3);
    process.once("SIGTERM", this._boundCleanupHandler);
    process.once("SIGINT", this._boundCleanupHandler);
    process.once("beforeExit", this._boundCleanupHandler);
    this._signalHandlersSetup = true;
    this.logger.debug("Signal handlers registered (SIGTERM, SIGINT, beforeExit)");
  }
  _handleCleanup(signal) {
    if (this._isDestroyed)
      return;
    this.logger.debug({ signal }, `Received ${signal}, cleaning up listeners...`);
    this.destroy();
  }
  on(eventName, listener) {
    try {
      super.on(eventName, listener);
    } catch (err) {
      this.handleError(err, "on");
    }
    return this;
  }
  once(eventName, listener) {
    try {
      super.once(eventName, listener);
    } catch (err) {
      this.handleError(err, "once");
    }
    return this;
  }
  emit(eventName, ...args) {
    try {
      return super.emit(eventName, ...args);
    } catch (err) {
      this.handleError(err, "emit");
      return false;
    }
  }
  handleError(err, method) {
    this.logger.error({ err, method }, `Error in SafeEventEmitter.${method}: ${err.message}`);
  }
  getListenerStats() {
    const stats2 = {};
    const events2 = this.eventNames();
    for (const event of events2) {
      stats2[String(event)] = this.listenerCount(event);
    }
    return stats2;
  }
  getTotalListenerCount() {
    return this.eventNames().reduce((total, event) => {
      return total + this.listenerCount(event);
    }, 0);
  }
  destroy() {
    if (this._isDestroyed)
      return;
    const totalListeners = this.getTotalListenerCount();
    this.logger.debug({ totalListeners }, `Destroying emitter (${totalListeners} listeners)...`);
    this.removeAllListeners();
    if (this._boundCleanupHandler && this._signalHandlersSetup) {
      process.removeListener("SIGTERM", this._boundCleanupHandler);
      process.removeListener("SIGINT", this._boundCleanupHandler);
      process.removeListener("beforeExit", this._boundCleanupHandler);
      this._signalHandlersSetup = false;
      bumpProcessMaxListeners(-3);
    }
    this._isDestroyed = true;
    this.logger.debug("Destroyed");
  }
  isDestroyed() {
    return this._isDestroyed;
  }
  removeSignalHandlers() {
    if (this._boundCleanupHandler && this._signalHandlersSetup) {
      process.removeListener("SIGTERM", this._boundCleanupHandler);
      process.removeListener("SIGINT", this._boundCleanupHandler);
      process.removeListener("beforeExit", this._boundCleanupHandler);
      this._signalHandlersSetup = false;
      bumpProcessMaxListeners(-3);
      this.logger.debug("Signal handlers removed");
    }
  }
};
var HOOK_EVENTS = [
  "beforeConnect",
  "afterConnect",
  "beforeCreateResource",
  "afterCreateResource",
  "beforeUploadMetadata",
  "afterUploadMetadata",
  "beforeDisconnect",
  "afterDisconnect",
  "resourceCreated",
  "resourceUpdated"
];
var DatabaseHooks = class {
  database;
  _hooks;
  _hookEvents;
  _hooksInstalled;
  _originalConnect;
  _originalCreateResource;
  _originalUploadMetadataFile;
  _originalDisconnect;
  constructor(database) {
    this.database = database;
    this._hooks = /* @__PURE__ */ new Map();
    this._hookEvents = [...HOOK_EVENTS];
    this._hooksInstalled = false;
    this._initHooks();
  }
  _initHooks() {
    this._hooks = /* @__PURE__ */ new Map();
    for (const event of this._hookEvents) {
      this._hooks.set(event, []);
    }
  }
  get hookEvents() {
    return [...this._hookEvents];
  }
  get isInstalled() {
    return this._hooksInstalled;
  }
  wrapMethods(connect2, createResource, uploadMetadataFile, disconnect) {
    if (this._hooksInstalled) {
      return {
        connect: connect2,
        createResource,
        uploadMetadataFile,
        disconnect
      };
    }
    this._originalConnect = connect2;
    this._originalCreateResource = createResource;
    this._originalUploadMetadataFile = uploadMetadataFile;
    this._originalDisconnect = disconnect;
    const wrappedConnect = async () => {
      await this.executeHooks("beforeConnect", {});
      const result = await this._originalConnect();
      await this.executeHooks("afterConnect", { result });
      return result;
    };
    const wrappedCreateResource = async (config) => {
      await this.executeHooks("beforeCreateResource", { config });
      const resource = await this._originalCreateResource(config);
      await this.executeHooks("afterCreateResource", { resource, config });
      return resource;
    };
    const wrappedUploadMetadataFile = async () => {
      await this.executeHooks("beforeUploadMetadata", {});
      const result = await this._originalUploadMetadataFile();
      await this.executeHooks("afterUploadMetadata", { result });
      return result;
    };
    const wrappedDisconnect = async () => {
      await this.executeHooks("beforeDisconnect", {});
      const result = await this._originalDisconnect();
      await this.executeHooks("afterDisconnect", { result });
      return result;
    };
    this._hooksInstalled = true;
    return {
      connect: wrappedConnect,
      createResource: wrappedCreateResource,
      uploadMetadataFile: wrappedUploadMetadataFile,
      disconnect: wrappedDisconnect
    };
  }
  addHook(event, fn) {
    if (!this._hooks.has(event)) {
      throw new DatabaseError(`Unknown hook event: ${event}`, {
        operation: "addHook",
        invalidEvent: event,
        availableEvents: this._hookEvents,
        suggestion: `Use one of the available hook events: ${this._hookEvents.join(", ")}`
      });
    }
    if (typeof fn !== "function") {
      throw new DatabaseError("Hook function must be a function", {
        operation: "addHook",
        event,
        receivedType: typeof fn,
        suggestion: "Provide a function that will be called when the hook event occurs"
      });
    }
    this._hooks.get(event).push(fn);
  }
  removeHook(event, fn) {
    if (!this._hooks.has(event))
      return;
    const hooks = this._hooks.get(event);
    const index = hooks.indexOf(fn);
    if (index > -1) {
      hooks.splice(index, 1);
    }
  }
  getHooks(event) {
    if (!this._hooks.has(event))
      return [];
    return [...this._hooks.get(event)];
  }
  clearHooks(event) {
    if (!this._hooks.has(event))
      return;
    this._hooks.get(event).length = 0;
  }
  async executeHooks(event, context = {}) {
    if (!this._hooks.has(event))
      return;
    const hooks = this._hooks.get(event);
    for (const hook of hooks) {
      const [ok, error2] = await tryFn$1(() => hook({ database: this.database, ...context }));
      if (!ok) {
        this.database.emit("hookError", { event, error: error2, context });
        if (this.database.strictHooks) {
          throw new DatabaseError(`Hook execution failed for event '${event}': ${error2.message}`, {
            event,
            originalError: error2,
            context
          });
        }
      }
    }
  }
};
var DatabaseCoordinators = class {
  database;
  _coordinators;
  constructor(database) {
    this.database = database;
    this._coordinators = /* @__PURE__ */ new Map();
  }
  get coordinators() {
    return this._coordinators;
  }
  async getGlobalCoordinator(namespace, options = {}) {
    if (!namespace) {
      throw new Error("Database.getGlobalCoordinator: namespace is required");
    }
    const { autoStart = false } = options;
    if (this._coordinators.has(namespace)) {
      return this._coordinators.get(namespace);
    }
    try {
      const { GlobalCoordinatorService: GlobalCoordinatorService2 } = await Promise.resolve().then(function() {
        return globalCoordinatorService_class;
      });
      const coordinatorConfig = options.config || {};
      const service = new GlobalCoordinatorService2({
        namespace,
        database: this.database,
        config: {
          heartbeatInterval: coordinatorConfig.heartbeatInterval ?? 5e3,
          heartbeatJitter: coordinatorConfig.heartbeatJitter ?? 1e3,
          leaseTimeout: coordinatorConfig.leaseTimeout ?? 15e3,
          workerTimeout: coordinatorConfig.workerTimeout ?? 2e4,
          diagnosticsEnabled: coordinatorConfig.diagnosticsEnabled ?? (this.database.logger.level === "debug" || this.database.logger.level === "trace")
        }
      });
      if (autoStart && this.database.isConnected()) {
        await service.start();
      }
      this._coordinators.set(namespace, service);
      return service;
    } catch (err) {
      throw new DatabaseError("Failed to initialize global coordinator service", {
        operation: "getGlobalCoordinator",
        namespace,
        cause: err?.message
      });
    }
  }
  async stopAll() {
    if (this._coordinators.size > 0) {
      for (const [, service] of this._coordinators) {
        try {
          if (service && typeof service.stop === "function") {
            await service.stop();
          }
        } catch {
        }
      }
      this._coordinators.clear();
    }
  }
  collectMemorySnapshot() {
    const usage = process.memoryUsage();
    const toMB = (bytes) => Math.round((bytes || 0) / (1024 * 1024));
    const snapshot = {
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      rssMB: toMB(usage.rss),
      heapUsedMB: toMB(usage.heapUsed),
      heapTotalMB: toMB(usage.heapTotal),
      externalMB: toMB(usage.external)
    };
    if (usage.arrayBuffers !== void 0) {
      snapshot.arrayBuffersMB = toMB(usage.arrayBuffers);
    }
    return snapshot;
  }
};
var ResourceIdsReader = class extends import_events.default {
  resource;
  client;
  stream;
  controller;
  continuationToken = null;
  closeNextIteration = false;
  constructor({ resource }) {
    super();
    this.resource = resource;
    this.client = resource.client;
    this.stream = new import_web.ReadableStream({
      start: this._start.bind(this),
      pull: this._pull.bind(this),
      cancel: this._cancel.bind(this)
    }, {
      highWaterMark: this.client.parallelism * 3
    });
  }
  build() {
    return this.stream.getReader();
  }
  async _start(controller) {
    this.controller = controller;
    this.continuationToken = null;
    this.closeNextIteration = false;
  }
  async _pull(_controller) {
    if (this.closeNextIteration) {
      this.controller.close();
      return;
    }
    const response2 = await this.client.listObjects({
      prefix: `resource=${this.resource.name}`,
      continuationToken: this.continuationToken
    });
    const keys2 = response2?.Contents.map((x4) => x4.Key).map((x4) => x4.replace(this.client.config.keyPrefix, "")).map((x4) => x4.startsWith("/") ? x4.replace(`/`, "") : x4).map((x4) => x4.replace(`resource=${this.resource.name}/id=`, ""));
    this.continuationToken = response2.NextContinuationToken || null;
    this.enqueue(keys2);
    if (!response2.IsTruncated)
      this.closeNextIteration = true;
  }
  enqueue(ids) {
    ids.forEach((key) => {
      this.controller.enqueue(key);
      this.emit("id", key);
    });
  }
  _cancel(_reason) {
  }
};
var ResourceIdsPageReader = class extends ResourceIdsReader {
  enqueue(ids) {
    this.controller.enqueue(ids);
    this.emit("page", ids);
  }
};
var ResourceReader = class extends import_events.default {
  resource;
  client;
  batchSize;
  concurrency;
  input;
  transform;
  constructor({ resource, batchSize = 10, concurrency = 5 }) {
    super();
    if (!resource) {
      throw new StreamError2("Resource is required for ResourceReader", {
        operation: "constructor",
        resource: resource?.name,
        suggestion: "Pass a valid Resource instance when creating ResourceReader"
      });
    }
    this.resource = resource;
    this.client = resource.client;
    this.batchSize = batchSize;
    this.concurrency = concurrency;
    this.input = new ResourceIdsPageReader({ resource: this.resource });
    this.transform = new import_stream.Transform({
      objectMode: true,
      transform: this._transform.bind(this)
    });
    this.input.on("data", (chunk2) => {
      this.transform.write(chunk2);
    });
    this.input.on("end", () => {
      this.transform.end();
    });
    this.input.on("error", (error2) => {
      this.emit("error", error2);
    });
    this.transform.on("data", (data2) => {
      this.emit("data", data2);
    });
    this.transform.on("end", () => {
      this.emit("end");
    });
    this.transform.on("error", (error2) => {
      this.emit("error", error2);
    });
  }
  build() {
    return this;
  }
  async _transform(chunk2, _encoding, callback) {
    const [, err] = await tryFn$1(async () => {
      await TasksPool.map(chunk2, async (id2) => {
        const data2 = await this.resource.get(id2);
        this.transform.push(data2);
        return data2;
      }, {
        concurrency: this.concurrency,
        onItemError: (error2, id2) => this.emit("error", error2, id2)
      });
    });
    callback(err);
  }
  resume() {
    this.input.emit("resume");
  }
};
var ResourceWriter = class extends import_events.default {
  resource;
  client;
  batchSize;
  concurrency;
  buffer;
  writing;
  ended;
  writable;
  constructor({ resource, batchSize = 10, concurrency = 5 }) {
    super();
    this.resource = resource;
    this.client = resource.client;
    this.batchSize = batchSize;
    this.concurrency = concurrency;
    this.buffer = [];
    this.writing = false;
    this.ended = false;
    this.writable = new import_stream.Writable({
      objectMode: true,
      write: this._write.bind(this)
    });
    this.writable.on("finish", () => {
      this.emit("finish");
    });
    this.writable.on("error", (error2) => {
      this.emit("error", error2);
    });
  }
  build() {
    return this;
  }
  write(chunk2) {
    this.buffer.push(chunk2);
    this._maybeWrite().catch((error2) => {
      this.emit("error", error2);
    });
    return true;
  }
  end() {
    this.ended = true;
    this._maybeWrite().catch((error2) => {
      this.emit("error", error2);
    });
  }
  async _maybeWrite() {
    if (this.writing)
      return;
    if (this.buffer.length === 0 && !this.ended)
      return;
    this.writing = true;
    while (this.buffer.length > 0) {
      const batch = this.buffer.splice(0, this.batchSize);
      const [ok, err] = await tryFn$1(async () => {
        await TasksPool.map(batch, async (item) => {
          const [insertOk, insertErr, result] = await tryFn$1(async () => {
            const res = await this.resource.insert(item);
            return res;
          });
          if (!insertOk) {
            this.emit("error", insertErr, item);
            return null;
          }
          return result;
        }, {
          concurrency: this.concurrency,
          onItemError: (error2, item) => this.emit("error", error2, item)
        });
      });
      if (!ok) {
        this.emit("error", err);
      }
    }
    this.writing = false;
    if (this.ended) {
      this.writable.emit("finish");
    }
  }
  _write(_chunk, _encoding, callback) {
    callback();
  }
};
function streamToString(stream) {
  return new Promise((resolve, reject) => {
    if (!stream) {
      return reject(new StreamError2("Stream is undefined", {
        operation: "streamToString",
        suggestion: "Ensure a valid stream is passed to streamToString()"
      }));
    }
    const chunks = [];
    stream.on("data", (chunk2) => chunks.push(chunk2));
    stream.on("error", reject);
    stream.on("end", () => resolve(Buffer.concat(chunks).toString("utf-8")));
  });
}
var DatabaseRecovery = class {
  database;
  constructor(database) {
    this.database = database;
  }
  async attemptJsonRecovery(content, healingLog) {
    if (!content || typeof content !== "string") {
      healingLog.push("Content is empty or not a string");
      return null;
    }
    const fixes = [
      () => content.replace(/,(\s*[}\]])/g, "$1"),
      () => content.replace(/([{,]\s*)([a-zA-Z_$][a-zA-Z0-9_$]*)\s*:/g, '$1"$2":'),
      () => {
        let openBraces = 0;
        let openBrackets = 0;
        let inString = false;
        let escaped = false;
        for (let i4 = 0; i4 < content.length; i4++) {
          const char = content[i4];
          if (escaped) {
            escaped = false;
            continue;
          }
          if (char === "\\") {
            escaped = true;
            continue;
          }
          if (char === '"') {
            inString = !inString;
            continue;
          }
          if (!inString) {
            if (char === "{")
              openBraces++;
            else if (char === "}")
              openBraces--;
            else if (char === "[")
              openBrackets++;
            else if (char === "]")
              openBrackets--;
          }
        }
        let fixed = content;
        while (openBrackets > 0) {
          fixed += "]";
          openBrackets--;
        }
        while (openBraces > 0) {
          fixed += "}";
          openBraces--;
        }
        return fixed;
      }
    ];
    for (const [index, fix] of fixes.entries()) {
      const [ok, , parsed] = tryFnSync(() => {
        const fixedContent = fix();
        return JSON.parse(fixedContent);
      });
      if (ok) {
        healingLog.push(`JSON recovery successful using fix #${index + 1}`);
        return parsed;
      }
    }
    healingLog.push("All JSON recovery attempts failed");
    return null;
  }
  async validateAndHealMetadata(metadata, healingLog) {
    if (!metadata || typeof metadata !== "object") {
      healingLog.push("Metadata is not an object - using blank structure");
      return this.database.blankMetadataStructure();
    }
    let healed = { ...metadata };
    let changed = false;
    if (!healed.version || typeof healed.version !== "string") {
      if (healed.version && typeof healed.version === "number") {
        healed.version = String(healed.version);
        healingLog.push("Converted version from number to string");
        changed = true;
      } else {
        healed.version = "1";
        healingLog.push("Added missing or invalid version field");
        changed = true;
      }
    }
    if (!healed.s3dbVersion || typeof healed.s3dbVersion !== "string") {
      if (healed.s3dbVersion && typeof healed.s3dbVersion !== "string") {
        healed.s3dbVersion = String(healed.s3dbVersion);
        healingLog.push("Converted s3dbVersion to string");
        changed = true;
      } else {
        healed.s3dbVersion = this.database.s3dbVersion;
        healingLog.push("Added missing s3dbVersion field");
        changed = true;
      }
    }
    if (!healed.resources || typeof healed.resources !== "object" || Array.isArray(healed.resources)) {
      healed.resources = {};
      healingLog.push("Fixed invalid resources field");
      changed = true;
    }
    if (!healed.lastUpdated) {
      healed.lastUpdated = (/* @__PURE__ */ new Date()).toISOString();
      healingLog.push("Added missing lastUpdated field");
      changed = true;
    }
    const validResources = {};
    for (const [name, resource] of Object.entries(healed.resources)) {
      const healedResource = this._healResourceStructure(name, resource, healingLog);
      if (healedResource) {
        validResources[name] = healedResource;
        if (healedResource !== resource) {
          changed = true;
        }
      } else {
        healingLog.push(`Removed invalid resource: ${name}`);
        changed = true;
      }
    }
    healed.resources = validResources;
    return changed ? healed : metadata;
  }
  _healResourceStructure(name, resource, healingLog) {
    if (!resource || typeof resource !== "object") {
      healingLog.push(`Resource ${name}: invalid structure`);
      return null;
    }
    let healed = { ...resource };
    let changed = false;
    if (!healed.currentVersion) {
      healed.currentVersion = "v1";
      healingLog.push(`Resource ${name}: added missing currentVersion`);
      changed = true;
    }
    if (!healed.versions || typeof healed.versions !== "object" || Array.isArray(healed.versions)) {
      healed.versions = {};
      healingLog.push(`Resource ${name}: fixed invalid versions object`);
      changed = true;
    }
    if (!healed.partitions || typeof healed.partitions !== "object" || Array.isArray(healed.partitions)) {
      healed.partitions = {};
      healingLog.push(`Resource ${name}: fixed invalid partitions object`);
      changed = true;
    }
    const currentVersion = healed.currentVersion;
    if (!healed.versions[currentVersion]) {
      const availableVersions = Object.keys(healed.versions);
      if (availableVersions.length > 0) {
        healed.currentVersion = availableVersions[0];
        healingLog.push(`Resource ${name}: changed currentVersion from ${currentVersion} to ${healed.currentVersion}`);
        changed = true;
      } else {
        healingLog.push(`Resource ${name}: no valid versions found - removing resource`);
        return null;
      }
    }
    const versionData = healed.versions[healed.currentVersion];
    if (!versionData || typeof versionData !== "object") {
      healingLog.push(`Resource ${name}: invalid version data - removing resource`);
      return null;
    }
    if (!versionData.attributes || typeof versionData.attributes !== "object") {
      healingLog.push(`Resource ${name}: missing or invalid attributes - removing resource`);
      return null;
    }
    if (versionData.hooks) {
      const healedHooks = this._healHooksStructure(versionData.hooks, name, healingLog);
      if (healedHooks !== versionData.hooks) {
        healed.versions[healed.currentVersion].hooks = healedHooks;
        changed = true;
      }
    }
    return changed ? healed : resource;
  }
  _healHooksStructure(hooks, resourceName, healingLog) {
    if (!hooks || typeof hooks !== "object") {
      healingLog.push(`Resource ${resourceName}: invalid hooks structure - using empty hooks`);
      return {};
    }
    const healed = {};
    let changed = false;
    for (const [event, hookData] of Object.entries(hooks)) {
      if (hookData && typeof hookData === "object" && Array.isArray(hookData.handlers)) {
        const validHandlers = hookData.handlers.filter((handler) => handler !== null && handler !== void 0 && handler !== "");
        healed[event] = {
          count: validHandlers.length,
          handlers: validHandlers
        };
        if (validHandlers.length !== hookData.handlers.length) {
          healingLog.push(`Resource ${resourceName}: cleaned invalid hooks for event ${event}`);
          changed = true;
        }
      } else {
        healingLog.push(`Resource ${resourceName}: hooks for event ${event} is invalid - removing`);
        changed = true;
      }
    }
    return changed ? healed : hooks;
  }
  async createCorruptedBackup(content = null) {
    const [ok] = await tryFn$1(async () => {
      const timestamp = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-");
      const backupKey = `s3db.json.corrupted.${timestamp}.backup`;
      if (!content) {
        const [readOk, , readData] = await tryFn$1(async () => {
          const request2 = await this.database.client.getObject("s3db.json");
          return await streamToString(request2?.Body);
        });
        content = readOk ? readData : "Unable to read corrupted file content";
      }
      await this.database.client.putObject({
        key: backupKey,
        body: content,
        contentType: "application/json"
      });
      this.database.logger.info({ backupKey }, `created backup of corrupted s3db.json as ${backupKey}`);
    });
    if (!ok) {
      this.database.logger.warn({}, "failed to create backup");
    }
  }
  async uploadHealedMetadata(metadata, healingLog) {
    const [ok, err] = await tryFn$1(async () => {
      if (healingLog.length > 0) {
        this.database.logger.warn({ healingOperations: healingLog }, "S3DB self-healing operations");
        healingLog.forEach((log) => this.database.logger.warn(`  - ${log}`));
      }
      metadata.lastUpdated = (/* @__PURE__ */ new Date()).toISOString();
      await this.database.client.putObject({
        key: "s3db.json",
        body: JSON.stringify(metadata, null, 2),
        contentType: "application/json"
      });
      this.database.emit("db:metadata-healed", { healingLog, metadata });
      this.database.logger.info("successfully uploaded healed metadata");
    });
    if (!ok) {
      this.database.logger.error({ error: err?.message }, "failed to upload healed metadata");
      throw err;
    }
  }
};
var alphabet = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
var base = alphabet.length;
var charToValue = Object.fromEntries([...alphabet].map((c4, i4) => [c4, i4]));
var encode2 = (n4) => {
  if (typeof n4 !== "number" || isNaN(n4))
    return "undefined";
  if (!isFinite(n4))
    return "undefined";
  if (n4 === 0)
    return alphabet[0];
  if (n4 < 0)
    return "-" + encode2(-Math.floor(n4));
  n4 = Math.floor(n4);
  let s4 = "";
  while (n4) {
    s4 = alphabet[n4 % base] + s4;
    n4 = Math.floor(n4 / base);
  }
  return s4;
};
var decode2 = (s4) => {
  if (typeof s4 !== "string")
    return NaN;
  if (s4 === "")
    return 0;
  let negative = false;
  let str = s4;
  if (str[0] === "-") {
    negative = true;
    str = str.slice(1);
  }
  let r4 = 0;
  for (let i4 = 0; i4 < str.length; i4++) {
    const idx = charToValue[str[i4]];
    if (idx === void 0)
      return NaN;
    r4 = r4 * base + idx;
  }
  return negative ? -r4 : r4;
};
var encodeDecimal = (n4) => {
  if (typeof n4 !== "number" || isNaN(n4))
    return "undefined";
  if (!isFinite(n4))
    return "undefined";
  const negative = n4 < 0;
  n4 = Math.abs(n4);
  const [intPart, decPart] = n4.toString().split(".");
  const encodedInt = encode2(Number(intPart));
  if (decPart) {
    return (negative ? "-" : "") + encodedInt + "." + decPart;
  }
  return (negative ? "-" : "") + encodedInt;
};
var decodeDecimal = (s4) => {
  if (typeof s4 !== "string")
    return NaN;
  let negative = false;
  let str = s4;
  if (str[0] === "-") {
    negative = true;
    str = str.slice(1);
  }
  const [intPart, decPart] = str.split(".");
  const decodedInt = decode2(intPart);
  if (isNaN(decodedInt))
    return NaN;
  const num = decPart ? Number(decodedInt + "." + decPart) : decodedInt;
  return negative ? -num : num;
};
var encodeFixedPoint = (n4, precision = 6) => {
  if (typeof n4 !== "number" || isNaN(n4))
    return "undefined";
  if (!isFinite(n4))
    return "undefined";
  const scale = Math.pow(10, precision);
  const scaled = Math.round(n4 * scale);
  if (scaled === 0)
    return "^0";
  const negative = scaled < 0;
  let num = Math.abs(scaled);
  let s4 = "";
  while (num > 0) {
    s4 = alphabet[num % base] + s4;
    num = Math.floor(num / base);
  }
  return "^" + (negative ? "-" : "") + s4;
};
var decodeFixedPoint = (s4, precision = 6) => {
  if (typeof s4 !== "string")
    return NaN;
  if (!s4.startsWith("^"))
    return NaN;
  let str = s4.slice(1);
  if (str === "0")
    return 0;
  let negative = false;
  if (str[0] === "-") {
    negative = true;
    str = str.slice(1);
  }
  let r4 = 0;
  for (let i4 = 0; i4 < str.length; i4++) {
    const idx = charToValue[str[i4]];
    if (idx === void 0)
      return NaN;
    r4 = r4 * base + idx;
  }
  const scale = Math.pow(10, precision);
  const scaled = negative ? -r4 : r4;
  return scaled / scale;
};
var encodeFixedPointBatch = (values, precision = 6) => {
  if (!Array.isArray(values))
    return "";
  if (values.length === 0)
    return "^[]";
  const scale = Math.pow(10, precision);
  const encoded = values.map((n4) => {
    if (typeof n4 !== "number" || isNaN(n4) || !isFinite(n4))
      return "";
    const scaled = Math.round(n4 * scale);
    if (scaled === 0)
      return "0";
    const negative = scaled < 0;
    let num = Math.abs(scaled);
    let s4 = "";
    while (num > 0) {
      s4 = alphabet[num % base] + s4;
      num = Math.floor(num / base);
    }
    return (negative ? "-" : "") + s4;
  });
  return "^[" + encoded.join(",") + "]";
};
var decodeFixedPointBatch = (s4, precision = 6) => {
  if (typeof s4 !== "string")
    return [];
  if (!s4.startsWith("^["))
    return [];
  const inner = s4.slice(2, -1);
  if (inner === "")
    return [];
  const parts = inner.split(",");
  const scale = Math.pow(10, precision);
  return parts.map((part) => {
    if (part === "0")
      return 0;
    if (part === "")
      return NaN;
    let negative = false;
    let str = part;
    if (str[0] === "-") {
      negative = true;
      str = str.slice(1);
    }
    let r4 = 0;
    for (let i4 = 0; i4 < str.length; i4++) {
      const idx = charToValue[str[i4]];
      if (idx === void 0)
        return NaN;
      r4 = r4 * base + idx;
    }
    const scaled = negative ? -r4 : r4;
    return scaled / scale;
  });
};
var utf8BytesMemory = /* @__PURE__ */ new Map();
var UTF8_MEMORY_MAX_SIZE = 1e4;
function calculateUTF8Bytes(str) {
  if (typeof str !== "string") {
    str = String(str);
  }
  const s4 = str;
  if (utf8BytesMemory.has(s4)) {
    return utf8BytesMemory.get(s4);
  }
  let bytes = 0;
  for (let i4 = 0; i4 < s4.length; i4++) {
    const codePoint = s4.codePointAt(i4);
    if (codePoint === void 0)
      continue;
    if (codePoint <= 127) {
      bytes += 1;
    } else if (codePoint <= 2047) {
      bytes += 2;
    } else if (codePoint <= 65535) {
      bytes += 3;
    } else if (codePoint <= 1114111) {
      bytes += 4;
      if (codePoint > 65535) {
        i4++;
      }
    }
  }
  if (utf8BytesMemory.size < UTF8_MEMORY_MAX_SIZE) {
    utf8BytesMemory.set(s4, bytes);
  } else if (utf8BytesMemory.size === UTF8_MEMORY_MAX_SIZE) {
    const entriesToDelete = Math.floor(UTF8_MEMORY_MAX_SIZE / 2);
    let deleted = 0;
    for (const key of utf8BytesMemory.keys()) {
      if (deleted >= entriesToDelete)
        break;
      utf8BytesMemory.delete(key);
      deleted++;
    }
    utf8BytesMemory.set(s4, bytes);
  }
  return bytes;
}
function calculateAttributeNamesSize(mappedObject) {
  let totalSize = 0;
  for (const key of Object.keys(mappedObject)) {
    totalSize += calculateUTF8Bytes(key);
  }
  return totalSize;
}
function transformValue(value) {
  if (value === null || value === void 0) {
    return "";
  }
  if (typeof value === "boolean") {
    return value ? "1" : "0";
  }
  if (typeof value === "number") {
    return String(value);
  }
  if (typeof value === "string") {
    return value;
  }
  if (Array.isArray(value)) {
    if (value.length === 0) {
      return "[]";
    }
    return value.map((item) => String(item)).join("|");
  }
  if (typeof value === "object") {
    return JSON.stringify(value);
  }
  return String(value);
}
function calculateAttributeSizes(mappedObject) {
  const sizes = {};
  for (const [key, value] of Object.entries(mappedObject)) {
    const transformedValue = transformValue(value);
    const byteSize = calculateUTF8Bytes(transformedValue);
    sizes[key] = byteSize;
  }
  return sizes;
}
function calculateTotalSize(mappedObject) {
  const valueSizes = calculateAttributeSizes(mappedObject);
  const valueTotal = Object.values(valueSizes).reduce((total, size) => total + size, 0);
  const namesSize = calculateAttributeNamesSize(mappedObject);
  return valueTotal + namesSize;
}
function calculateSystemOverhead(config = {}) {
  const { version = "1", timestamps = false, id: id2 = "" } = config;
  const systemFields = {
    "_v": String(version)
  };
  if (timestamps) {
    systemFields.createdAt = "2024-01-01T00:00:00.000Z";
    systemFields.updatedAt = "2024-01-01T00:00:00.000Z";
  }
  if (id2) {
    systemFields.id = id2;
  }
  const overheadObject = {};
  for (const [key, value] of Object.entries(systemFields)) {
    overheadObject[key] = value;
  }
  return calculateTotalSize(overheadObject);
}
function calculateEffectiveLimit(config = {}) {
  const { s3Limit = 2048, systemConfig = {} } = config;
  const overhead = calculateSystemOverhead(systemConfig);
  return s3Limit - overhead;
}
var LOCK_DEFAULTS = {
  ttl: 30,
  timeout: 0,
  retryDelay: 100,
  maxRetryDelay: 1e3,
  workerId: "unknown"
};
function computeBackoff(attempt, baseDelay, maxDelay) {
  const exponential = Math.min(baseDelay * Math.pow(2, Math.max(attempt - 1, 0)), maxDelay);
  const jitter = Math.floor(Math.random() * Math.max(baseDelay / 2, 1));
  return exponential + jitter;
}
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
function isPreconditionFailure(err) {
  const originalError = err?.original || err;
  const errorCode = originalError?.code || originalError?.Code || originalError?.name;
  const statusCode = originalError?.statusCode || originalError?.$metadata?.httpStatusCode;
  return errorCode === "PreconditionFailed" || statusCode === 412;
}
var DistributedLock = class {
  storage;
  keyGenerator;
  defaults;
  constructor(storage, options = {}) {
    if (!storage) {
      throw new Error("DistributedLock requires a storage adapter");
    }
    this.storage = storage;
    this.keyGenerator = options.keyGenerator || ((name) => `locks/${name}`);
    this.defaults = { ...LOCK_DEFAULTS, ...options.defaults };
  }
  async acquire(lockName, options = {}) {
    const opts = { ...this.defaults, ...options };
    const { ttl, timeout, workerId, retryDelay, maxRetryDelay } = opts;
    const key = this.keyGenerator(lockName);
    const token = idGenerator();
    const startTime = Date.now();
    let attempt = 0;
    while (true) {
      const payload2 = {
        workerId,
        token,
        acquiredAt: Date.now(),
        _expiresAt: Date.now() + ttl * 1e3
      };
      const [ok, err, putResponse] = await tryFn$1(() => this.storage.set(key, payload2, {
        ttl,
        behavior: "body-only",
        ifNoneMatch: "*"
      }));
      if (ok && putResponse) {
        return {
          name: lockName,
          key,
          token,
          workerId,
          expiresAt: payload2._expiresAt,
          etag: putResponse.ETag || null
        };
      }
      if (!isPreconditionFailure(err)) {
        throw err;
      }
      if (timeout !== void 0 && Date.now() - startTime >= timeout) {
        return null;
      }
      const current = await this.storage.get(key);
      if (!current) {
        continue;
      }
      if (current._expiresAt && Date.now() > current._expiresAt) {
        await tryFn$1(() => this.storage.delete(key));
        continue;
      }
      attempt += 1;
      const delay = computeBackoff(attempt, retryDelay, maxRetryDelay);
      await sleep(delay);
    }
  }
  async release(lock, token) {
    if (!lock)
      return;
    let key;
    let expectedToken = token;
    if (typeof lock === "object") {
      key = lock.key || this.keyGenerator(lock.name);
      expectedToken = lock.token ?? token;
    } else if (typeof lock === "string") {
      key = this.keyGenerator(lock);
      expectedToken = token;
    } else {
      throw new Error("release() expects a lock handle or lock name");
    }
    if (!expectedToken) {
      throw new Error("release() requires the lock token");
    }
    if (!key) {
      throw new Error("Invalid lock key");
    }
    const current = await this.storage.get(key);
    if (!current)
      return;
    if (current.token !== expectedToken) {
      return;
    }
    await this.storage.delete(key);
  }
  async withLock(lockName, options, callback) {
    if (typeof callback !== "function") {
      throw new Error("withLock() requires a callback function");
    }
    const lock = await this.acquire(lockName, options);
    if (!lock) {
      return null;
    }
    try {
      return await callback(lock);
    } finally {
      await tryFn$1(() => this.release(lock));
    }
  }
  async isLocked(lockName) {
    const key = this.keyGenerator(lockName);
    const lock = await this.storage.get(key);
    return lock !== null;
  }
  async getLockInfo(lockName) {
    const key = this.keyGenerator(lockName);
    return this.storage.get(key);
  }
};
var SEQUENCE_DEFAULTS = {
  initialValue: 1,
  increment: 1,
  lockTimeout: 5e3,
  lockTTL: 10
};
var DistributedSequence = class {
  storage;
  valueKeyGenerator;
  lockKeyGenerator;
  defaults;
  lock;
  constructor(storage, options = {}) {
    if (!storage) {
      throw new Error("DistributedSequence requires a storage adapter");
    }
    this.storage = storage;
    this.valueKeyGenerator = options.valueKeyGenerator || ((name) => `sequences/${name}/value`);
    this.lockKeyGenerator = options.lockKeyGenerator || ((name) => `sequences/${name}/lock`);
    this.defaults = { ...SEQUENCE_DEFAULTS, ...options.defaults };
    this.lock = new DistributedLock(storage, {
      keyGenerator: this.lockKeyGenerator,
      defaults: {
        ttl: this.defaults.lockTTL,
        timeout: this.defaults.lockTimeout
      }
    });
  }
  async next(name, options = {}) {
    const opts = { ...this.defaults, ...options };
    const { initialValue, increment, lockTimeout, lockTTL, metadata } = opts;
    const valueKey = this.valueKeyGenerator(name);
    const result = await this.lock.withLock(name, {
      timeout: lockTimeout,
      ttl: lockTTL
    }, async () => {
      const data2 = await this.storage.get(valueKey);
      if (!data2) {
        await this.storage.set(valueKey, {
          value: initialValue + increment,
          name,
          createdAt: Date.now(),
          ...metadata
        }, { behavior: "body-only" });
        return initialValue;
      }
      const currentValue = data2.value;
      await this.storage.set(valueKey, {
        ...data2,
        value: currentValue + increment,
        updatedAt: Date.now()
      }, { behavior: "body-only" });
      return currentValue;
    });
    if (result === null) {
      throw new Error(`Failed to acquire lock for sequence "${name}"`);
    }
    return result;
  }
  async get(name) {
    const valueKey = this.valueKeyGenerator(name);
    const data2 = await this.storage.get(valueKey);
    return data2?.value ?? null;
  }
  async getData(name) {
    const valueKey = this.valueKeyGenerator(name);
    return this.storage.get(valueKey);
  }
  async reset(name, value, options = {}) {
    const opts = { ...this.defaults, ...options };
    const { lockTimeout, lockTTL, metadata } = opts;
    const valueKey = this.valueKeyGenerator(name);
    const result = await this.lock.withLock(name, {
      timeout: lockTimeout,
      ttl: lockTTL
    }, async () => {
      const data2 = await this.storage.get(valueKey);
      await this.storage.set(valueKey, {
        value,
        name,
        createdAt: data2?.createdAt || Date.now(),
        updatedAt: Date.now(),
        resetAt: Date.now(),
        ...metadata
      }, { behavior: "body-only" });
      return true;
    });
    if (result === null) {
      throw new Error(`Failed to acquire lock for sequence "${name}"`);
    }
    return result;
  }
  async set(name, value, options = {}) {
    return this.reset(name, value, options);
  }
  async delete(name) {
    const valueKey = this.valueKeyGenerator(name);
    const lockKey = this.lockKeyGenerator(name);
    await this.storage.delete(valueKey);
    await tryFn$1(() => this.storage.delete(lockKey));
  }
  async exists(name) {
    const value = await this.get(name);
    return value !== null;
  }
  async increment(name, options = {}) {
    const opts = { ...this.defaults, ...options };
    const { increment } = opts;
    const preValue = await this.next(name, options);
    return preValue + increment;
  }
};
var S3_METADATA_LIMIT = 2047;
var PluginStorage = class {
  client;
  pluginSlug;
  _lock;
  _sequence;
  _now;
  constructor(client2, pluginSlug, options = {}) {
    if (!client2) {
      throw new PluginStorageError("PluginStorage requires a client instance", {
        operation: "constructor",
        pluginSlug,
        suggestion: "Pass a valid S3db Client instance when creating PluginStorage"
      });
    }
    if (!pluginSlug) {
      throw new PluginStorageError("PluginStorage requires a pluginSlug", {
        operation: "constructor",
        suggestion: 'Provide a plugin slug (e.g., "eventual-consistency", "cache", "audit")'
      });
    }
    this.client = client2;
    this.pluginSlug = pluginSlug;
    this._now = options.now ?? (() => Date.now());
    this._lock = new DistributedLock(this, {
      keyGenerator: (name) => this.getPluginKey(null, "locks", name)
    });
    this._sequence = new DistributedSequence(this, {
      valueKeyGenerator: (name) => this.getSequenceKey(null, name, "value"),
      lockKeyGenerator: (name) => this.getSequenceKey(null, name, "lock")
    });
  }
  getPluginKey(resourceName, ...parts) {
    if (resourceName) {
      return `resource=${resourceName}/plugin=${this.pluginSlug}/${parts.join("/")}`;
    }
    return `plugin=${this.pluginSlug}/${parts.join("/")}`;
  }
  getSequenceKey(resourceName, sequenceName, suffix) {
    if (resourceName) {
      return `resource=${resourceName}/plugin=${this.pluginSlug}/sequence=${sequenceName}/${suffix}`;
    }
    return `plugin=${this.pluginSlug}/sequence=${sequenceName}/${suffix}`;
  }
  async set(key, data2, options = {}) {
    const { ttl, behavior = "body-overflow", contentType = "application/json", ifMatch, ifNoneMatch } = options;
    const dataToSave = { ...data2 };
    if (ttl && typeof ttl === "number" && ttl > 0) {
      dataToSave._expiresAt = this._now() + ttl * 1e3;
    }
    const { metadata, body: body2 } = this._applyBehavior(dataToSave, behavior);
    const putParams = {
      key,
      metadata,
      contentType
    };
    if (body2 !== null) {
      putParams.body = JSON.stringify(body2);
    }
    if (ifMatch !== void 0) {
      putParams.ifMatch = ifMatch;
    }
    if (ifNoneMatch !== void 0) {
      putParams.ifNoneMatch = ifNoneMatch;
    }
    const [ok, err, response2] = await tryFn$1(() => this.client.putObject(putParams));
    if (!ok) {
      throw new PluginStorageError(`Failed to save plugin data`, {
        pluginSlug: this.pluginSlug,
        key,
        operation: "set",
        behavior,
        ttl,
        original: err,
        suggestion: "Check S3 permissions and key format"
      });
    }
    return response2;
  }
  async batchSet(items) {
    const promises2 = items.map(async (item) => {
      const [ok, error2] = await tryFn$1(() => this.set(item.key, item.data, item.options || {}));
      return { ok, key: item.key, error: ok ? void 0 : error2 };
    });
    return Promise.all(promises2);
  }
  async get(key) {
    const [ok, err, response2] = await tryFn$1(() => this.client.getObject(key));
    if (!ok || !response2) {
      const error2 = err;
      if (error2?.name === "NoSuchKey" || error2?.code === "NoSuchKey" || error2?.Code === "NoSuchKey" || error2?.statusCode === 404) {
        return null;
      }
      throw new PluginStorageError(`Failed to retrieve plugin data`, {
        pluginSlug: this.pluginSlug,
        key,
        operation: "get",
        original: err,
        suggestion: "Check if the key exists and S3 permissions are correct"
      });
    }
    const metadata = response2.Metadata || {};
    const parsedMetadata = this._parseMetadataValues(metadata);
    let data2 = parsedMetadata;
    if (response2.Body) {
      const [parseOk, parseErr, result] = await tryFn$1(async () => {
        const bodyContent = await this._readBodyAsString(response2.Body);
        if (bodyContent && bodyContent.trim()) {
          const body2 = JSON.parse(bodyContent);
          return { ...parsedMetadata, ...body2 };
        }
        return parsedMetadata;
      });
      if (!parseOk || !result) {
        throw new PluginStorageError(`Failed to parse JSON body`, {
          pluginSlug: this.pluginSlug,
          key,
          operation: "get",
          original: parseErr,
          suggestion: "Body content may be corrupted. Check S3 object integrity"
        });
      }
      data2 = result;
    }
    const expiresAt = data2._expiresat || data2._expiresAt;
    if (expiresAt) {
      if (this._now() > expiresAt) {
        await this.delete(key);
        return null;
      }
      delete data2._expiresat;
      delete data2._expiresAt;
    }
    return data2;
  }
  _parseMetadataValues(metadata) {
    const parsed = {};
    for (const [key, value] of Object.entries(metadata)) {
      if (typeof value === "string") {
        if (value.startsWith("{") && value.endsWith("}") || value.startsWith("[") && value.endsWith("]")) {
          try {
            parsed[key] = JSON.parse(value);
            continue;
          } catch {
          }
        }
        if (!isNaN(Number(value)) && value.trim() !== "") {
          parsed[key] = Number(value);
          continue;
        }
        if (value === "true") {
          parsed[key] = true;
          continue;
        }
        if (value === "false") {
          parsed[key] = false;
          continue;
        }
      }
      parsed[key] = value;
    }
    return parsed;
  }
  async _readBodyAsString(body2) {
    if (!body2) {
      return "";
    }
    const bodyAny = body2;
    if (typeof bodyAny.transformToString === "function") {
      return bodyAny.transformToString();
    }
    if (typeof bodyAny.transformToByteArray === "function") {
      const bytes = await bodyAny.transformToByteArray();
      return Buffer.from(bytes).toString("utf-8");
    }
    if (typeof body2 === "string") {
      return body2;
    }
    if (body2 instanceof Uint8Array) {
      return Buffer.from(body2).toString("utf-8");
    }
    if (body2 instanceof ArrayBuffer) {
      return Buffer.from(body2).toString("utf-8");
    }
    if (typeof bodyAny.on === "function") {
      return streamToString(bodyAny);
    }
    if (typeof bodyAny[Symbol.asyncIterator] === "function") {
      const chunks = [];
      for await (const chunk2 of bodyAny) {
        chunks.push(Buffer.isBuffer(chunk2) ? chunk2 : Buffer.from(chunk2));
      }
      return Buffer.concat(chunks).toString("utf-8");
    }
    return String(body2);
  }
  async list(prefix = "", options = {}) {
    const { limit } = options;
    const fullPrefix = prefix ? `plugin=${this.pluginSlug}/${prefix}` : `plugin=${this.pluginSlug}/`;
    const [ok, err, result] = await tryFn$1(() => this.client.listObjects({ prefix: fullPrefix, maxKeys: limit }));
    if (!ok || !result) {
      throw new PluginStorageError(`Failed to list plugin data`, {
        pluginSlug: this.pluginSlug,
        operation: "list",
        prefix,
        fullPrefix,
        limit,
        original: err,
        suggestion: "Check S3 permissions and bucket configuration"
      });
    }
    const keys2 = (result.Contents ?? []).map((item) => item.Key).filter((k4) => typeof k4 === "string");
    return this._removeKeyPrefix(keys2);
  }
  async listForResource(resourceName, subPrefix = "", options = {}) {
    const { limit } = options;
    const fullPrefix = subPrefix ? `resource=${resourceName}/plugin=${this.pluginSlug}/${subPrefix}` : `resource=${resourceName}/plugin=${this.pluginSlug}/`;
    const [ok, err, result] = await tryFn$1(() => this.client.listObjects({ prefix: fullPrefix, maxKeys: limit }));
    if (!ok || !result) {
      throw new PluginStorageError(`Failed to list resource data`, {
        pluginSlug: this.pluginSlug,
        operation: "listForResource",
        resourceName,
        subPrefix,
        fullPrefix,
        limit,
        original: err,
        suggestion: "Check resource name and S3 permissions"
      });
    }
    const keys2 = (result.Contents ?? []).map((item) => item.Key).filter((k4) => typeof k4 === "string");
    return this._removeKeyPrefix(keys2);
  }
  async listWithPrefix(prefix = "", options = {}) {
    const keys2 = await this.list(prefix, options);
    if (!keys2 || keys2.length === 0) {
      return [];
    }
    const results = await this.batchGet(keys2);
    return results.filter((item) => item.ok && item.data != null).map((item) => item.data);
  }
  _removeKeyPrefix(keys2) {
    const keyPrefix = this.client.config.keyPrefix;
    if (!keyPrefix)
      return keys2;
    return keys2.map((key) => key.replace(keyPrefix, "")).map((key) => key.startsWith("/") ? key.replace("/", "") : key);
  }
  async has(key) {
    const data2 = await this.get(key);
    return data2 !== null;
  }
  async isExpired(key) {
    const [ok, , response2] = await tryFn$1(() => this.client.getObject(key));
    if (!ok || !response2) {
      return true;
    }
    const metadata = response2.Metadata || {};
    const parsedMetadata = this._parseMetadataValues(metadata);
    let data2 = parsedMetadata;
    if (response2.Body) {
      const [parseOk, , result] = await tryFn$1(async () => {
        const bodyContent = await this._readBodyAsString(response2.Body);
        if (bodyContent && bodyContent.trim()) {
          const body2 = JSON.parse(bodyContent);
          return { ...parsedMetadata, ...body2 };
        }
        return parsedMetadata;
      });
      if (!parseOk || !result) {
        return true;
      }
      data2 = result;
    }
    const expiresAt = data2._expiresat || data2._expiresAt;
    if (!expiresAt) {
      return false;
    }
    return this._now() > expiresAt;
  }
  async getTTL(key) {
    const [ok, , response2] = await tryFn$1(() => this.client.getObject(key));
    if (!ok || !response2) {
      return null;
    }
    const metadata = response2.Metadata || {};
    const parsedMetadata = this._parseMetadataValues(metadata);
    let data2 = parsedMetadata;
    if (response2.Body) {
      const [parseOk, , result] = await tryFn$1(async () => {
        const bodyContent = await this._readBodyAsString(response2.Body);
        if (bodyContent && bodyContent.trim()) {
          const body2 = JSON.parse(bodyContent);
          return { ...parsedMetadata, ...body2 };
        }
        return parsedMetadata;
      });
      if (!parseOk || !result) {
        return null;
      }
      data2 = result;
    }
    const expiresAt = data2._expiresat || data2._expiresAt;
    if (!expiresAt) {
      return null;
    }
    const remaining = Math.max(0, expiresAt - this._now());
    return Math.floor(remaining / 1e3);
  }
  async touch(key, additionalSeconds) {
    const [ok, , response2] = await tryFn$1(() => this.client.headObject(key));
    if (!ok || !response2) {
      return false;
    }
    const metadata = response2.Metadata || {};
    const parsedMetadata = this._parseMetadataValues(metadata);
    const expiresAt = parsedMetadata._expiresat || parsedMetadata._expiresAt;
    if (!expiresAt) {
      return false;
    }
    parsedMetadata._expiresAt = expiresAt + additionalSeconds * 1e3;
    delete parsedMetadata._expiresat;
    const encodedMetadata = {};
    for (const [metaKey, metaValue] of Object.entries(parsedMetadata)) {
      const { encoded } = metadataEncode(metaValue);
      encodedMetadata[metaKey] = encoded;
    }
    const [copyOk] = await tryFn$1(() => this.client.copyObject({
      from: key,
      to: key,
      metadata: encodedMetadata,
      metadataDirective: "REPLACE",
      contentType: response2.ContentType || "application/json"
    }));
    return copyOk;
  }
  async delete(key) {
    const [ok, err] = await tryFn$1(() => this.client.deleteObject(key));
    if (!ok) {
      throw new PluginStorageError(`Failed to delete plugin data`, {
        pluginSlug: this.pluginSlug,
        key,
        operation: "delete",
        original: err,
        suggestion: "Check S3 delete permissions"
      });
    }
  }
  async deleteAll(resourceName = null) {
    let deleted = 0;
    if (resourceName) {
      const keys2 = await this.listForResource(resourceName);
      for (const key of keys2) {
        await this.delete(key);
        deleted++;
      }
    } else {
      const allKeys = await this.client.getAllKeys({});
      const pluginKeys = allKeys.filter((key) => key.includes(`plugin=${this.pluginSlug}/`));
      for (const key of pluginKeys) {
        await this.delete(key);
        deleted++;
      }
    }
    return deleted;
  }
  async batchPut(items) {
    const promises2 = items.map(async (item) => {
      const [ok, error2] = await tryFn$1(() => this.set(item.key, item.data, item.options));
      return { key: item.key, ok, error: ok ? void 0 : error2 };
    });
    return Promise.all(promises2);
  }
  async batchGet(keys2) {
    const promises2 = keys2.map(async (key) => {
      const [ok, error2, data2] = await tryFn$1(() => this.get(key));
      return { key, ok, data: data2, error: ok ? void 0 : error2 };
    });
    return Promise.all(promises2);
  }
  /**
   * Set data only if the key does not exist (conditional PUT).
   * Uses ifNoneMatch: '*' to ensure atomicity.
   * @returns The ETag (version) if set succeeded, null if key already exists.
   */
  async setIfNotExists(key, data2, options = {}) {
    const [ok, err, response2] = await tryFn$1(() => this.set(key, data2, { ...options, ifNoneMatch: "*" }));
    if (!ok) {
      const error2 = err;
      if (error2?.name === "PreconditionFailed" || error2?.code === "PreconditionFailed" || error2?.statusCode === 412) {
        return null;
      }
      throw err;
    }
    return response2?.ETag ?? null;
  }
  /**
   * Get data along with its version (ETag) for conditional updates.
   * @returns Object with data and version, or { data: null, version: null } if not found.
   */
  async getWithVersion(key) {
    const [ok, err, response2] = await tryFn$1(() => this.client.getObject(key));
    if (!ok || !response2) {
      const error2 = err;
      if (error2?.name === "NoSuchKey" || error2?.code === "NoSuchKey" || error2?.Code === "NoSuchKey" || error2?.statusCode === 404) {
        return { data: null, version: null };
      }
      throw new PluginStorageError(`Failed to retrieve plugin data with version`, {
        pluginSlug: this.pluginSlug,
        key,
        operation: "getWithVersion",
        original: err,
        suggestion: "Check if the key exists and S3 permissions are correct"
      });
    }
    const metadata = response2.Metadata || {};
    const parsedMetadata = this._parseMetadataValues(metadata);
    let data2 = parsedMetadata;
    if (response2.Body) {
      const [parseOk, parseErr, result] = await tryFn$1(async () => {
        const bodyContent = await this._readBodyAsString(response2.Body);
        if (bodyContent && bodyContent.trim()) {
          const body2 = JSON.parse(bodyContent);
          return { ...parsedMetadata, ...body2 };
        }
        return parsedMetadata;
      });
      if (!parseOk || !result) {
        throw new PluginStorageError(`Failed to parse JSON body`, {
          pluginSlug: this.pluginSlug,
          key,
          operation: "getWithVersion",
          original: parseErr,
          suggestion: "Body content may be corrupted"
        });
      }
      data2 = result;
    }
    const expiresAt = data2._expiresat || data2._expiresAt;
    if (expiresAt && this._now() > expiresAt) {
      await this.delete(key);
      return { data: null, version: null };
    }
    delete data2._expiresat;
    delete data2._expiresAt;
    const [headOk, , headResponse] = await tryFn$1(() => this.client.headObject(key));
    const version = headOk && headResponse ? headResponse.ETag ?? null : null;
    return { data: data2, version };
  }
  /**
   * Set data only if the current version matches (conditional PUT).
   * Uses ifMatch to ensure no concurrent modifications.
   * @returns The new ETag (version) if set succeeded, null if version mismatch.
   */
  async setIfVersion(key, data2, version, options = {}) {
    const [ok, err, response2] = await tryFn$1(() => this.set(key, data2, { ...options, ifMatch: version }));
    if (!ok) {
      const error2 = err;
      if (error2?.name === "PreconditionFailed" || error2?.code === "PreconditionFailed" || error2?.statusCode === 412) {
        return null;
      }
      throw err;
    }
    return response2?.ETag ?? null;
  }
  /**
   * Delete data only if the current version matches (conditional DELETE).
   * @returns true if deleted, false if version mismatch or key not found.
   */
  async deleteIfVersion(key, version) {
    const [headOk, , headResponse] = await tryFn$1(() => this.client.headObject(key));
    if (!headOk || !headResponse) {
      return false;
    }
    const currentVersion = headResponse.ETag;
    if (currentVersion !== version) {
      return false;
    }
    const [deleteOk] = await tryFn$1(() => this.client.deleteObject(key));
    return deleteOk;
  }
  async acquireLock(lockName, options = {}) {
    return this._lock.acquire(lockName, options);
  }
  async releaseLock(lock, token) {
    return this._lock.release(lock, token);
  }
  async withLock(lockName, options, callback) {
    return this._lock.withLock(lockName, options, callback);
  }
  async isLocked(lockName) {
    return this._lock.isLocked(lockName);
  }
  async increment(key, amount = 1, options = {}) {
    const [headOk, , headResponse] = await tryFn$1(() => this.client.headObject(key));
    if (headOk && headResponse?.Metadata) {
      const metadata = headResponse.Metadata || {};
      const parsedMetadata = this._parseMetadataValues(metadata);
      const currentValue = parsedMetadata.value || 0;
      const newValue = currentValue + amount;
      parsedMetadata.value = newValue;
      if (options.ttl) {
        parsedMetadata._expiresAt = this._now() + options.ttl * 1e3;
      }
      const encodedMetadata = {};
      for (const [metaKey, metaValue] of Object.entries(parsedMetadata)) {
        const { encoded } = metadataEncode(metaValue);
        encodedMetadata[metaKey] = encoded;
      }
      const [copyOk] = await tryFn$1(() => this.client.copyObject({
        from: key,
        to: key,
        metadata: encodedMetadata,
        metadataDirective: "REPLACE",
        contentType: headResponse.ContentType || "application/json"
      }));
      if (copyOk) {
        return newValue;
      }
    }
    const data2 = await this.get(key);
    const value = (data2?.value || 0) + amount;
    await this.set(key, { value }, options);
    return value;
  }
  async decrement(key, amount = 1, options = {}) {
    return this.increment(key, -amount, options);
  }
  async nextSequence(name, options = {}) {
    const { resourceName = null, initialValue = 1, increment = 1, lockTimeout = 5e3, lockTTL = 10 } = options;
    const valueKey = this.getSequenceKey(resourceName, name, "value");
    const lockKey = this.getSequenceKey(resourceName, name, "lock");
    const result = await this._withSequenceLock(lockKey, { timeout: lockTimeout, ttl: lockTTL }, async () => {
      const data2 = await this.get(valueKey);
      if (!data2) {
        await this.set(valueKey, {
          value: initialValue + increment,
          name,
          resourceName,
          createdAt: this._now()
        }, { behavior: "body-only" });
        return initialValue;
      }
      const currentValue = data2.value;
      await this.set(valueKey, {
        ...data2,
        value: currentValue + increment,
        updatedAt: this._now()
      }, { behavior: "body-only" });
      return currentValue;
    });
    if (result === null) {
      throw new PluginStorageError(`Failed to acquire lock for sequence "${name}"`, {
        pluginSlug: this.pluginSlug,
        operation: "nextSequence",
        sequenceName: name,
        resourceName,
        lockTimeout,
        suggestion: "Increase lockTimeout or check for deadlocks"
      });
    }
    return result;
  }
  async _withSequenceLock(lockKey, options, callback) {
    const { ttl = 30, timeout = 5e3 } = options;
    const token = idGenerator();
    const startTime = this._now();
    let attempt = 0;
    while (true) {
      const payload2 = {
        token,
        acquiredAt: this._now(),
        _expiresAt: this._now() + ttl * 1e3
      };
      const [ok, err] = await tryFn$1(() => this.set(lockKey, payload2, {
        behavior: "body-only",
        ifNoneMatch: "*"
      }));
      if (ok) {
        try {
          return await callback();
        } finally {
          const current2 = await this.get(lockKey);
          if (current2 && current2.token === token) {
            await tryFn$1(() => this.delete(lockKey));
          }
        }
      }
      if (!isPreconditionFailure(err)) {
        throw err;
      }
      if (timeout !== void 0 && this._now() - startTime >= timeout) {
        return null;
      }
      const current = await this.get(lockKey);
      if (!current)
        continue;
      if (current._expiresAt && this._now() > current._expiresAt) {
        await tryFn$1(() => this.delete(lockKey));
        continue;
      }
      attempt += 1;
      const delay = computeBackoff(attempt, 100, 1e3);
      await sleep(delay);
    }
  }
  async getSequence(name, options = {}) {
    const { resourceName = null } = options;
    const valueKey = this.getSequenceKey(resourceName, name, "value");
    const data2 = await this.get(valueKey);
    return data2?.value ?? null;
  }
  async resetSequence(name, value, options = {}) {
    const { resourceName = null, lockTimeout = 5e3, lockTTL = 10 } = options;
    const valueKey = this.getSequenceKey(resourceName, name, "value");
    const lockKey = this.getSequenceKey(resourceName, name, "lock");
    const result = await this._withSequenceLock(lockKey, { timeout: lockTimeout, ttl: lockTTL }, async () => {
      const data2 = await this.get(valueKey);
      await this.set(valueKey, {
        value,
        name,
        resourceName,
        createdAt: data2?.createdAt || this._now(),
        updatedAt: this._now(),
        resetAt: this._now()
      }, { behavior: "body-only" });
      return true;
    });
    if (result === null) {
      throw new PluginStorageError(`Failed to acquire lock for sequence "${name}"`, {
        pluginSlug: this.pluginSlug,
        operation: "resetSequence",
        sequenceName: name,
        resourceName,
        lockTimeout,
        suggestion: "Increase lockTimeout or check for deadlocks"
      });
    }
    return result;
  }
  async deleteSequence(name, options = {}) {
    const { resourceName = null } = options;
    const valueKey = this.getSequenceKey(resourceName, name, "value");
    const lockKey = this.getSequenceKey(resourceName, name, "lock");
    await this.delete(valueKey);
    await tryFn$1(() => this.delete(lockKey));
  }
  async listSequences(options = {}) {
    const { resourceName = null } = options;
    let prefix;
    if (resourceName) {
      prefix = `resource=${resourceName}/plugin=${this.pluginSlug}/sequence=`;
    } else {
      prefix = `plugin=${this.pluginSlug}/sequence=`;
    }
    const [ok, , result] = await tryFn$1(() => this.client.listObjects({ prefix }));
    if (!ok || !result)
      return [];
    const keys2 = (result.Contents ?? []).map((item) => item.Key).filter((k4) => typeof k4 === "string");
    const valueKeys = keys2.filter((k4) => k4.endsWith("/value"));
    const sequences = [];
    for (const key of valueKeys) {
      const data2 = await this.get(key);
      if (data2) {
        sequences.push(data2);
      }
    }
    return sequences;
  }
  _applyBehavior(data2, behavior) {
    const effectiveLimit = calculateEffectiveLimit({ s3Limit: S3_METADATA_LIMIT });
    let metadata = {};
    let body2 = null;
    switch (behavior) {
      case "body-overflow": {
        const entries = Object.entries(data2);
        const sorted = entries.map(([key, value]) => {
          const jsonValue = typeof value === "object" ? JSON.stringify(value) : value;
          const { encoded } = metadataEncode(jsonValue);
          const keySize = calculateUTF8Bytes(key);
          const valueSize = calculateUTF8Bytes(encoded);
          return { key, value, jsonValue, encoded, size: keySize + valueSize };
        }).sort((a4, b4) => a4.size - b4.size);
        let currentSize = 0;
        for (const item of sorted) {
          if (currentSize + item.size <= effectiveLimit) {
            metadata[item.key] = item.jsonValue;
            currentSize += item.size;
          } else {
            if (body2 === null)
              body2 = {};
            body2[item.key] = item.value;
          }
        }
        break;
      }
      case "body-only": {
        body2 = data2;
        break;
      }
      case "enforce-limits": {
        let currentSize = 0;
        for (const [key, value] of Object.entries(data2)) {
          const jsonValue = typeof value === "object" ? JSON.stringify(value) : value;
          const { encoded } = metadataEncode(jsonValue);
          const keySize = calculateUTF8Bytes(key);
          const valueSize = calculateUTF8Bytes(encoded);
          currentSize += keySize + valueSize;
          if (currentSize > effectiveLimit) {
            throw new MetadataLimitError(`Data exceeds metadata limit with enforce-limits behavior`, {
              totalSize: currentSize,
              effectiveLimit,
              absoluteLimit: S3_METADATA_LIMIT,
              excess: currentSize - effectiveLimit,
              operation: "PluginStorage.set",
              pluginSlug: this.pluginSlug,
              suggestion: "Use 'body-overflow' or 'body-only' behavior to handle large data"
            });
          }
          metadata[key] = jsonValue;
        }
        break;
      }
      default:
        throw new BehaviorError(`Unknown behavior: ${behavior}`, {
          behavior,
          availableBehaviors: ["body-overflow", "body-only", "enforce-limits"],
          operation: "PluginStorage._applyBehavior",
          pluginSlug: this.pluginSlug,
          suggestion: "Use 'body-overflow', 'body-only', or 'enforce-limits'"
        });
    }
    return { metadata, body: body2 };
  }
};
var DEFAULT_TTL_MS = 3e4;
var DEFAULT_NAMESPACE = "default";
var S3Mutex = class {
  storage;
  namespace;
  holderId;
  constructor(storage, namespace) {
    if (!storage) {
      throw new Error("S3Mutex: storage is required");
    }
    this.storage = storage;
    this.namespace = namespace || DEFAULT_NAMESPACE;
    this.holderId = this._generateHolderId();
  }
  async lock(key, ttlMs = DEFAULT_TTL_MS) {
    return this.tryLock(key, ttlMs);
  }
  async tryLock(key, ttlMs = DEFAULT_TTL_MS) {
    if (!key) {
      return {
        acquired: false,
        error: new Error("S3Mutex: key is required")
      };
    }
    const lockKey = this._getLockKey(key);
    const now = Date.now();
    const expiresAt = now + ttlMs;
    const lockId = this._generateLockId();
    const lockData = {
      lockId,
      holderId: this.holderId,
      acquiredAt: now,
      expiresAt
    };
    const version = await this.storage.setIfNotExists(lockKey, lockData, { ttl: Math.ceil(ttlMs / 1e3) + 60, behavior: "body-only" });
    if (version !== null) {
      return {
        acquired: true,
        lockId,
        expiresAt
      };
    }
    const existingResult = await this.storage.getWithVersion(lockKey);
    if (!existingResult.data) {
      return {
        acquired: false,
        error: new Error("Lock exists but could not be read")
      };
    }
    const existingLock = existingResult.data;
    if (existingLock.expiresAt <= now) {
      const newVersion = await this.storage.setIfVersion(lockKey, lockData, existingResult.version, { ttl: Math.ceil(ttlMs / 1e3) + 60, behavior: "body-only" });
      if (newVersion !== null) {
        return {
          acquired: true,
          lockId,
          expiresAt
        };
      }
      return {
        acquired: false,
        error: new Error("Lock was taken by another process during expired lock takeover")
      };
    }
    return {
      acquired: false,
      error: new Error(`Lock is held by ${existingLock.holderId} until ${new Date(existingLock.expiresAt).toISOString()}`)
    };
  }
  async unlock(key, lockId) {
    if (!key || !lockId) {
      return false;
    }
    const lockKey = this._getLockKey(key);
    const result = await this.storage.getWithVersion(lockKey);
    if (!result.data || !result.version) {
      return false;
    }
    const existingLock = result.data;
    if (existingLock.lockId !== lockId) {
      return false;
    }
    return await this.storage.deleteIfVersion(lockKey, result.version);
  }
  async isLocked(key) {
    if (!key) {
      return false;
    }
    const lockKey = this._getLockKey(key);
    const result = await this.storage.getWithVersion(lockKey);
    if (!result.data) {
      return false;
    }
    const lockData = result.data;
    const now = Date.now();
    return lockData.expiresAt > now;
  }
  async extend(key, lockId, ttlMs) {
    if (!key || !lockId || ttlMs <= 0) {
      return false;
    }
    const lockKey = this._getLockKey(key);
    const result = await this.storage.getWithVersion(lockKey);
    if (!result.data || !result.version) {
      return false;
    }
    const existingLock = result.data;
    const now = Date.now();
    if (existingLock.lockId !== lockId) {
      return false;
    }
    if (existingLock.expiresAt <= now) {
      return false;
    }
    const newExpiresAt = now + ttlMs;
    const updatedLock = {
      ...existingLock,
      expiresAt: newExpiresAt
    };
    const newVersion = await this.storage.setIfVersion(lockKey, updatedLock, result.version, { ttl: Math.ceil(ttlMs / 1e3) + 60, behavior: "body-only" });
    return newVersion !== null;
  }
  async getLockInfo(key) {
    if (!key) {
      return null;
    }
    const lockKey = this._getLockKey(key);
    const result = await this.storage.getWithVersion(lockKey);
    if (!result.data) {
      return null;
    }
    return result.data;
  }
  _getLockKey(key) {
    return this.storage.getPluginKey(null, "locks", `namespace=${this.namespace}`, `${key}.json`);
  }
  _generateLockId() {
    const timestamp = Date.now();
    const random2 = Math.random().toString(36).substring(2, 10);
    return `lock-${this.holderId}-${timestamp}-${random2}`;
  }
  _generateHolderId() {
    if (typeof process !== "undefined" && process.env) {
      if (process.env.POD_NAME) {
        return `holder-${process.env.POD_NAME}`;
      }
      if (process.env.HOSTNAME) {
        return `holder-${process.env.HOSTNAME}`;
      }
    }
    return `holder-${Date.now()}-${Math.random().toString(36).substring(2, 8)}`;
  }
};
var DatabaseMetadata = class {
  database;
  _metadataUploadPending;
  _metadataUploadDebounce;
  _pluginStorage;
  _mutex;
  constructor(database) {
    this.database = database;
    this._metadataUploadPending = false;
    this._metadataUploadDebounce = null;
    this._pluginStorage = null;
    this._mutex = null;
  }
  _getPluginStorage() {
    if (!this._pluginStorage) {
      this._pluginStorage = new PluginStorage(this.database.client, "s3db-core");
    }
    return this._pluginStorage;
  }
  _requiresDistributedLock() {
    const client2 = this.database.client;
    if (!client2)
      return false;
    const connStr = client2.connectionString || "";
    if (connStr.startsWith("file://") || connStr.startsWith("memory://")) {
      return false;
    }
    const endpoint = client2.config?.endpoint || "";
    if (endpoint.startsWith("mock://")) {
      return false;
    }
    return connStr.length > 0;
  }
  _getMutex() {
    if (!this._requiresDistributedLock()) {
      return null;
    }
    if (!this._mutex) {
      this._mutex = new S3Mutex(this._getPluginStorage(), "metadata");
    }
    return this._mutex;
  }
  get uploadPending() {
    return this._metadataUploadPending;
  }
  blankMetadataStructure() {
    return {
      version: "1",
      s3dbVersion: this.database.s3dbVersion,
      lastUpdated: (/* @__PURE__ */ new Date()).toISOString(),
      resources: {}
    };
  }
  generateDefinitionHash(definition, behavior) {
    const attributes = definition.attributes;
    const stableAttributes = { ...attributes };
    if (definition.timestamps) {
      delete stableAttributes.createdAt;
      delete stableAttributes.updatedAt;
    }
    const hashObj = {
      attributes: stableAttributes,
      behavior: behavior || definition.behavior || "user-managed",
      partitions: definition.partitions || {}
    };
    const stableString = (0, import_json_stable_stringify.default)(hashObj);
    return `sha256:${(0, import_crypto.createHash)("sha256").update(stableString).digest("hex")}`;
  }
  getNextVersion(versions = {}) {
    const versionNumbers = Object.keys(versions).filter((v4) => v4.startsWith("v")).map((v4) => parseInt(v4.substring(1))).filter((n4) => !isNaN(n4));
    const maxVersion = versionNumbers.length > 0 ? Math.max(...versionNumbers) : 0;
    return `v${maxVersion + 1}`;
  }
  detectDefinitionChanges(savedMetadata) {
    const changes = [];
    for (const [name, currentResource] of Object.entries(this.database.resources)) {
      const currentHash = this.generateDefinitionHash(currentResource.export());
      const savedResource = savedMetadata.resources?.[name];
      if (!savedResource) {
        changes.push({
          type: "new",
          resourceName: name,
          currentHash,
          savedHash: null
        });
      } else {
        const currentVersion = savedResource.currentVersion || "v1";
        const versionData = savedResource.versions?.[currentVersion];
        const savedHash = versionData?.hash;
        if (savedHash !== currentHash) {
          changes.push({
            type: "changed",
            resourceName: name,
            currentHash,
            savedHash: savedHash || null,
            fromVersion: currentVersion,
            toVersion: this.getNextVersion(savedResource.versions)
          });
        }
      }
    }
    for (const [name, savedResource] of Object.entries(savedMetadata.resources || {})) {
      if (!this.database._resourcesMap[name]) {
        const currentVersion = savedResource.currentVersion || "v1";
        const versionData = savedResource.versions?.[currentVersion];
        changes.push({
          type: "deleted",
          resourceName: name,
          currentHash: null,
          savedHash: versionData?.hash || null,
          deletedVersion: currentVersion
        });
      }
    }
    return changes;
  }
  _sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
  async _readFreshMetadata() {
    const [ok, , response2] = await tryFn$1(async () => {
      const request2 = await this.database.client.getObject("s3db.json");
      return streamToString(request2?.Body);
    });
    if (!ok || !response2) {
      return null;
    }
    try {
      return JSON.parse(response2);
    } catch {
      return null;
    }
  }
  _mergeSchemaRegistry(fresh, local) {
    if (!fresh && !local)
      return void 0;
    if (!fresh)
      return local;
    if (!local)
      return fresh;
    const mergedNextIndex = Math.max(fresh.nextIndex, local.nextIndex);
    const mergedMapping = { ...fresh.mapping };
    for (const [attr, index] of Object.entries(local.mapping)) {
      const existingIndex = mergedMapping[attr];
      if (existingIndex === void 0) {
        mergedMapping[attr] = index;
      } else if (existingIndex !== index) {
        mergedMapping[attr] = Math.max(existingIndex, index);
      }
    }
    const burnedByIndex = /* @__PURE__ */ new Map();
    for (const entry of fresh.burned) {
      burnedByIndex.set(entry.index, entry);
    }
    for (const entry of local.burned) {
      if (!burnedByIndex.has(entry.index)) {
        burnedByIndex.set(entry.index, entry);
      }
    }
    return {
      nextIndex: mergedNextIndex,
      mapping: mergedMapping,
      burned: Array.from(burnedByIndex.values())
    };
  }
  _mergePluginSchemaRegistry(fresh, local) {
    if (!fresh && !local)
      return void 0;
    if (!fresh)
      return this._convertToPluginRegistries(local);
    if (!local)
      return this._convertToPluginRegistries(fresh);
    const merged = {};
    const allPlugins = /* @__PURE__ */ new Set([...Object.keys(fresh), ...Object.keys(local)]);
    for (const pluginName of allPlugins) {
      const freshReg = fresh[pluginName];
      const localReg = local[pluginName];
      if (!freshReg && localReg) {
        merged[pluginName] = this._toPluginRegistry(localReg, pluginName);
      } else if (freshReg && !localReg) {
        merged[pluginName] = this._toPluginRegistry(freshReg, pluginName);
      } else if (freshReg && localReg) {
        merged[pluginName] = this._mergeSinglePluginRegistry(pluginName, freshReg, localReg);
      }
    }
    return merged;
  }
  _convertToPluginRegistries(registries) {
    if (!registries)
      return void 0;
    const result = {};
    for (const [name, reg] of Object.entries(registries)) {
      result[name] = this._toPluginRegistry(reg, name);
    }
    return result;
  }
  _toPluginRegistry(registry, pluginName) {
    if (!("nextIndex" in registry)) {
      return registry;
    }
    const numericReg = registry;
    const result = { mapping: {}, burned: [] };
    for (const [attr, index] of Object.entries(numericReg.mapping)) {
      result.mapping[attr] = this._legacyPluginKey(pluginName, index);
    }
    for (const burned of numericReg.burned) {
      result.burned.push({
        key: this._legacyPluginKey(pluginName, burned.index),
        attribute: burned.attribute,
        burnedAt: burned.burnedAt,
        reason: burned.reason
      });
    }
    return result;
  }
  _mergeSinglePluginRegistry(pluginName, fresh, local) {
    const freshPlugin = this._toPluginRegistry(fresh, pluginName);
    const localPlugin = this._toPluginRegistry(local, pluginName);
    const mergedMapping = { ...freshPlugin.mapping };
    for (const [attr, key] of Object.entries(localPlugin.mapping)) {
      if (!(attr in mergedMapping)) {
        mergedMapping[attr] = key;
      }
    }
    const burnedByKey = /* @__PURE__ */ new Map();
    for (const entry of freshPlugin.burned) {
      burnedByKey.set(entry.key, entry);
    }
    for (const entry of localPlugin.burned) {
      if (!burnedByKey.has(entry.key)) {
        burnedByKey.set(entry.key, entry);
      }
    }
    return {
      mapping: mergedMapping,
      burned: Array.from(burnedByKey.values())
    };
  }
  _legacyPluginKey(pluginName, index) {
    const prefix = pluginName.substring(0, 2);
    return `p${prefix}${encode2(index)}`;
  }
  _buildLocalMetadata() {
    const metadata = {
      version: this.database.version,
      s3dbVersion: this.database.s3dbVersion,
      lastUpdated: (/* @__PURE__ */ new Date()).toISOString(),
      resources: {}
    };
    Object.entries(this.database.resources).forEach(([name, resource]) => {
      const resourceDef = resource.export();
      const serializableDef = this._buildMetadataDefinition(resourceDef);
      const definitionHash = this.generateDefinitionHash(serializableDef);
      const existingResource = this.database.savedMetadata?.resources?.[name];
      const currentVersion = existingResource?.currentVersion || "v1";
      const existingVersionData = existingResource?.versions?.[currentVersion];
      let version;
      let isNewVersion;
      if (!existingVersionData || existingVersionData.hash !== definitionHash) {
        version = this.getNextVersion(existingResource?.versions);
        isNewVersion = true;
      } else {
        version = currentVersion;
        isNewVersion = false;
      }
      const idGeneratorValue = typeof resource.idGeneratorType === "function" ? "custom" : resource.idGeneratorType;
      const newVersionData = {
        hash: definitionHash,
        attributes: serializableDef.attributes,
        behavior: serializableDef.behavior || "user-managed",
        timestamps: serializableDef.timestamps,
        partitions: serializableDef.partitions,
        paranoid: serializableDef.paranoid,
        allNestedObjectsOptional: serializableDef.allNestedObjectsOptional,
        autoDecrypt: serializableDef.autoDecrypt,
        cache: serializableDef.cache,
        asyncEvents: serializableDef.asyncEvents,
        asyncPartitions: serializableDef.asyncPartitions,
        hooks: serializableDef.hooks,
        idSize: resource.idSize,
        idGenerator: idGeneratorValue,
        createdAt: isNewVersion ? (/* @__PURE__ */ new Date()).toISOString() : existingVersionData?.createdAt
      };
      const schema = resource.schema;
      let schemaRegistry = schema?.getSchemaRegistry?.();
      let pluginSchemaRegistry = schema?.getPluginSchemaRegistry?.();
      if (!schemaRegistry && existingResource?.schemaRegistry) {
        schemaRegistry = existingResource.schemaRegistry;
      }
      if (!pluginSchemaRegistry && existingResource?.pluginSchemaRegistry) {
        pluginSchemaRegistry = existingResource.pluginSchemaRegistry;
      }
      if (!schemaRegistry && schema) {
        const initial = schema.generateInitialRegistry?.();
        if (initial) {
          schemaRegistry = initial.schemaRegistry;
          pluginSchemaRegistry = initial.pluginSchemaRegistry;
        }
      }
      metadata.resources[name] = {
        currentVersion: version,
        partitions: resource.config.partitions || {},
        createdBy: existingResource?.createdBy || resource.config.createdBy || "user",
        versions: {
          ...existingResource?.versions,
          [version]: newVersionData
        },
        schemaRegistry,
        pluginSchemaRegistry
      };
      if (resource.version !== version) {
        resource.version = version;
        resource.emit("versionUpdated", { oldVersion: currentVersion, newVersion: version });
      }
    });
    return metadata;
  }
  _mergeMetadata(fresh, local) {
    const merged = {
      version: local.version,
      s3dbVersion: local.s3dbVersion,
      lastUpdated: local.lastUpdated,
      resources: { ...fresh.resources }
    };
    for (const [name, localResource] of Object.entries(local.resources)) {
      const freshResource = fresh.resources[name];
      if (!freshResource) {
        merged.resources[name] = localResource;
        continue;
      }
      merged.resources[name] = {
        ...localResource,
        schemaRegistry: this._mergeSchemaRegistry(freshResource.schemaRegistry, localResource.schemaRegistry),
        pluginSchemaRegistry: this._mergePluginSchemaRegistry(freshResource.pluginSchemaRegistry, localResource.pluginSchemaRegistry)
      };
    }
    return merged;
  }
  scheduleMetadataUpload() {
    if (!this.database.deferMetadataWrites) {
      return this.uploadMetadataFile();
    }
    if (this._metadataUploadDebounce) {
      clearTimeout(this._metadataUploadDebounce);
    }
    this._metadataUploadPending = true;
    this._metadataUploadDebounce = setTimeout(() => {
      if (this._metadataUploadPending) {
        this.uploadMetadataFile().then(() => {
          this._metadataUploadPending = false;
        }).catch((err) => {
          this.database.logger.error({ error: err.message }, "metadata upload failed");
          this._metadataUploadPending = false;
        });
      }
    }, this.database.metadataWriteDelay);
    return Promise.resolve();
  }
  async flushMetadata() {
    if (this._metadataUploadDebounce) {
      clearTimeout(this._metadataUploadDebounce);
      this._metadataUploadDebounce = null;
    }
    if (this._metadataUploadPending) {
      await this.uploadMetadataFile();
      this._metadataUploadPending = false;
    }
  }
  async uploadMetadataFile() {
    const mutex = this._getMutex();
    if (!mutex) {
      await this._uploadMetadataWithoutLock();
      return;
    }
    await this._uploadMetadataWithLock(mutex);
  }
  async _uploadMetadataWithoutLock() {
    const localMetadata = this._buildLocalMetadata();
    await this.database.client.putObject({
      key: "s3db.json",
      body: JSON.stringify(localMetadata, null, 2),
      contentType: "application/json"
    });
    this.database.savedMetadata = localMetadata;
    this.database.emit("db:metadata-uploaded", localMetadata);
  }
  async _uploadMetadataWithLock(mutex) {
    const maxRetries = 3;
    const lockTtl = 3e4;
    let attempt = 0;
    while (attempt < maxRetries) {
      const lock = await mutex.tryLock("s3db-metadata", lockTtl);
      if (!lock.acquired) {
        attempt++;
        this.database.logger.debug({ attempt, maxRetries, error: lock.error?.message }, "failed to acquire metadata lock, retrying");
        if (attempt >= maxRetries) {
          throw new Error(`Failed to acquire metadata lock after ${maxRetries} attempts: ${lock.error?.message}`);
        }
        await this._sleep(100 * Math.pow(2, attempt - 1));
        continue;
      }
      try {
        const freshMetadata = await this._readFreshMetadata();
        const localMetadata = this._buildLocalMetadata();
        const finalMetadata = freshMetadata ? this._mergeMetadata(freshMetadata, localMetadata) : localMetadata;
        await this.database.client.putObject({
          key: "s3db.json",
          body: JSON.stringify(finalMetadata, null, 2),
          contentType: "application/json"
        });
        this.database.savedMetadata = finalMetadata;
        this.database.emit("db:metadata-uploaded", finalMetadata);
        return;
      } finally {
        await mutex.unlock("s3db-metadata", lock.lockId);
      }
    }
  }
  _buildMetadataDefinition(resourceDef) {
    const { hooks, ...rest } = resourceDef || {};
    const serializable = { ...rest };
    if (hooks) {
      serializable.hooks = this._summarizeHooks(hooks);
    } else {
      serializable.hooks = {};
    }
    return serializable;
  }
  _summarizeHooks(hooks) {
    if (!hooks || typeof hooks !== "object") {
      return {};
    }
    const summary = {};
    for (const [event, handlers] of Object.entries(hooks)) {
      if (!Array.isArray(handlers) || handlers.length === 0) {
        continue;
      }
      summary[event] = {
        count: handlers.length,
        handlers: handlers.map((handler) => {
          if (typeof handler !== "function") {
            return { name: null, length: null, type: typeof handler };
          }
          return {
            name: handler.name || null,
            length: handler.length ?? null,
            type: "function"
          };
        })
      };
    }
    return summary;
  }
};
var DatabasePlugins = class {
  database;
  coordinators;
  constructor(database, coordinators) {
    this.database = database;
    this.coordinators = coordinators;
  }
  async startPlugins() {
    const db = this.database;
    if (!isEmpty_default(db.pluginList)) {
      const plugins = [];
      for (const p4 of db.pluginList) {
        try {
          const plugin = isFunction_default(p4) ? new p4(db) : p4;
          plugins.push(plugin);
        } catch (error2) {
          const pluginName = p4.name || p4.constructor?.name || "Unknown";
          throw new DatabaseError(`Failed to instantiate plugin '${pluginName}': ${error2.message}`, {
            operation: "startPlugins.instantiate",
            pluginName,
            original: error2
          });
        }
      }
      const concurrency = Math.max(1, Number.isFinite(db.executorPool?.concurrency) ? db.executorPool.concurrency : 5);
      const installResult = await TasksPool.map(plugins, async (plugin) => {
        const pluginName = this._getPluginName(plugin);
        if (typeof plugin.setInstanceName === "function") {
          plugin.setInstanceName(pluginName);
        } else {
          plugin.instanceName = pluginName;
        }
        await plugin.install(db);
        db.emit("db:plugin:metrics", {
          stage: "install",
          plugin: pluginName,
          ...this.coordinators.collectMemorySnapshot()
        });
        db.pluginRegistry[pluginName] = plugin;
        return pluginName;
      }, { concurrency });
      if (installResult.errors.length > 0) {
        const errorInfo = installResult.errors[0];
        const failedPlugin = errorInfo.item;
        const error2 = errorInfo.error;
        const failedName = this._getPluginName(failedPlugin);
        throw new DatabaseError(`Failed to install plugin '${failedName}': ${error2?.message || error2}`, {
          operation: "startPlugins.install",
          pluginName: failedName,
          original: error2
        });
      }
      const startResult = await TasksPool.map(plugins, async (plugin) => {
        const pluginName = this._getPluginName(plugin);
        await plugin.start();
        db.emit("db:plugin:metrics", {
          stage: "start",
          plugin: pluginName,
          ...this.coordinators.collectMemorySnapshot()
        });
        return plugin;
      }, { concurrency });
      if (startResult.errors.length > 0) {
        const errorInfo = startResult.errors[0];
        const failedPlugin = errorInfo.item;
        const error2 = errorInfo.error;
        const failedName = this._getPluginName(failedPlugin);
        throw new DatabaseError(`Failed to start plugin '${failedName}': ${error2?.message || error2}`, {
          operation: "startPlugins.start",
          pluginName: failedName,
          original: error2
        });
      }
    }
  }
  async usePlugin(plugin, name = null) {
    const db = this.database;
    const pluginName = this._getPluginName(plugin, name);
    if (typeof plugin.setInstanceName === "function") {
      plugin.setInstanceName(pluginName);
    } else {
      plugin.instanceName = pluginName;
    }
    if (!plugin.processManager) {
      plugin.processManager = db.processManager;
    }
    if (!plugin.cronManager) {
      plugin.cronManager = db.cronManager;
    }
    if (!plugin.logger && db.logger) {
      plugin.logger = db.getChildLogger(`Plugin:${pluginName}`, { plugin: pluginName });
    }
    db.plugins[pluginName] = plugin;
    if (db.isConnected()) {
      await plugin.install(db);
      await plugin.start();
    }
    return plugin;
  }
  async uninstallPlugin(name, options = {}) {
    const db = this.database;
    const pluginName = name.toLowerCase().replace("plugin", "");
    const plugin = db.plugins[pluginName] || db.pluginRegistry[pluginName];
    if (!plugin) {
      throw new DatabaseError(`Plugin '${name}' not found`, {
        operation: "uninstallPlugin",
        pluginName: name,
        availablePlugins: Object.keys(db.pluginRegistry),
        suggestion: "Check plugin name or list available plugins using Object.keys(db.pluginRegistry)"
      });
    }
    if (plugin.stop) {
      await plugin.stop();
    }
    if (plugin.uninstall) {
      await plugin.uninstall(options);
    }
    delete db.plugins[pluginName];
    delete db.pluginRegistry[pluginName];
    const index = db.pluginList.indexOf(plugin);
    if (index > -1) {
      db.pluginList.splice(index, 1);
    }
    db.emit("db:plugin:uninstalled", { name: pluginName, plugin });
  }
  _getPluginName(plugin, customName = null) {
    return customName || plugin.constructor.name.replace("Plugin", "").toLowerCase();
  }
};
var AsyncEventEmitter = class extends import_events.default {
  _asyncMode;
  logLevel;
  logger;
  constructor(options = {}) {
    super();
    this._asyncMode = true;
    this.logLevel = options.logLevel || "info";
    if (options.logger) {
      this.logger = options.logger;
    } else {
      this.logger = createLogger({ name: "AsyncEventEmitter", level: this.logLevel });
    }
  }
  emit(event, ...args) {
    if (!this._asyncMode) {
      return super.emit(event, ...args);
    }
    const listeners = this.listeners(event);
    if (listeners.length === 0) {
      return false;
    }
    setImmediate(async () => {
      for (const listener of listeners) {
        try {
          await listener(...args);
        } catch (error2) {
          if (event !== "error") {
            this.emit("error", error2);
          } else {
            const err = error2;
            this.logger.error({ error: err.message, stack: err.stack }, "Error in error handler");
          }
        }
      }
    });
    return true;
  }
  emitSync(event, ...args) {
    return super.emit(event, ...args);
  }
  setAsyncMode(enabled) {
    this._asyncMode = enabled;
  }
};
function flatten(obj, options = {}) {
  const { safe = false } = options;
  const result = {};
  function recurse(current, path3 = "") {
    if (current === null || current === void 0) {
      result[path3] = current;
      return;
    }
    if (safe && Array.isArray(current)) {
      result[path3] = current;
      return;
    }
    if (typeof current !== "object" || current instanceof Date) {
      result[path3] = current;
      return;
    }
    if (Array.isArray(current)) {
      if (current.length === 0) {
        result[path3] = [];
      } else {
        current.forEach((item, index) => {
          const newPath = path3 ? `${path3}.${index}` : `${index}`;
          recurse(item, newPath);
        });
      }
      return;
    }
    const keys2 = Object.keys(current);
    if (keys2.length === 0) {
      result[path3] = {};
    } else {
      keys2.forEach((key) => {
        const newPath = path3 ? `${path3}.${key}` : key;
        recurse(current[key], newPath);
      });
    }
  }
  recurse(obj);
  return result;
}
function unflatten(obj, _options = {}) {
  const result = {};
  for (const [key, value] of Object.entries(obj)) {
    const parts = key.split(".");
    let current = result;
    for (let i4 = 0; i4 < parts.length; i4++) {
      const part = parts[i4];
      const isLast = i4 === parts.length - 1;
      if (isLast) {
        current[part] = value;
      } else {
        const nextPart = parts[i4 + 1];
        const isNextNumeric = /^\d+$/.test(nextPart);
        if (isNextNumeric) {
          current[part] = current[part] || [];
        } else {
          current[part] = current[part] || {};
        }
        current = current[part];
      }
    }
  }
  return result;
}
var bcryptModule = null;
async function getBcrypt() {
  if (bcryptModule) {
    return bcryptModule;
  }
  try {
    const module2 = await Promise.resolve().then(() => __toESM(require_bcrypt(), 1));
    bcryptModule = module2.default || module2;
    return bcryptModule;
  } catch {
    throw new ValidationError2("bcrypt is not installed", {
      field: "bcrypt",
      statusCode: 500,
      retriable: false,
      suggestion: "Install bcrypt with: pnpm add bcrypt"
    });
  }
}
async function hashPassword(password, rounds = 10) {
  if (!password || typeof password !== "string") {
    throw new ValidationError2("Password must be a non-empty string", {
      field: "password",
      statusCode: 400,
      retriable: false,
      suggestion: "Provide a non-empty string before calling hashPassword()."
    });
  }
  if (rounds < 4 || rounds > 31) {
    throw new ValidationError2("Bcrypt rounds must be between 4 and 31", {
      field: "rounds",
      statusCode: 400,
      retriable: false,
      suggestion: "Configure bcrypt rounds between 4 and 31 (inclusive)."
    });
  }
  const bcrypt = await getBcrypt();
  const hashed = await bcrypt.hash(password, rounds);
  return hashed;
}
function compactHash(bcryptHash) {
  if (!bcryptHash || typeof bcryptHash !== "string") {
    throw new ValidationError2("Invalid bcrypt hash", {
      field: "bcryptHash",
      statusCode: 400,
      retriable: false,
      suggestion: "Provide a valid bcrypt hash generated by hashPassword()."
    });
  }
  if (!bcryptHash.startsWith("$2")) {
    throw new ValidationError2("Not a valid bcrypt hash", {
      field: "bcryptHash",
      statusCode: 400,
      retriable: false,
      suggestion: 'Ensure the hash starts with "$2" and was produced by bcrypt.'
    });
  }
  const parts = bcryptHash.split("$");
  if (parts.length !== 4) {
    throw new ValidationError2("Invalid bcrypt hash format", {
      field: "bcryptHash",
      statusCode: 400,
      retriable: false,
      suggestion: 'Provide a complete bcrypt hash (e.g., "$2b$10$...").'
    });
  }
  return parts[3];
}
var FastestValidator = FastestValidatorModule.default;
async function secretHandler(actual, errors2, _schema, field) {
  if (!this.passphrase) {
    errors2.push(new ValidationError2("Missing configuration for secrets encryption.", {
      actual,
      field,
      type: "encryptionKeyMissing",
      suggestion: "Provide a passphrase for secret encryption."
    }));
    return actual;
  }
  const [ok, err, res] = await tryFn$1(() => encrypt(String(actual), this.passphrase));
  if (ok)
    return res;
  errors2.push(new ValidationError2("Problem encrypting secret.", {
    actual,
    field,
    type: "encryptionProblem",
    error: err,
    suggestion: "Check the passphrase and input value."
  }));
  return actual;
}
async function passwordHandler(actual, errors2, _schema, field) {
  if (!this.bcryptRounds) {
    errors2.push(new ValidationError2("Missing bcrypt rounds configuration.", {
      actual,
      field,
      type: "bcryptRoundsMissing",
      suggestion: "Provide bcryptRounds in database configuration."
    }));
    return actual;
  }
  const [okHash, errHash, hash] = await tryFn$1(() => hashPassword(String(actual), this.bcryptRounds));
  if (!okHash) {
    errors2.push(new ValidationError2("Problem hashing password.", {
      actual,
      field,
      type: "passwordHashingProblem",
      error: errHash,
      suggestion: "Check the bcryptRounds configuration and password value."
    }));
    return actual;
  }
  const [okCompact, errCompact, compacted] = tryFnSync(() => compactHash(hash));
  if (!okCompact) {
    errors2.push(new ValidationError2("Problem compacting password hash.", {
      actual,
      field,
      type: "hashCompactionProblem",
      error: errCompact,
      suggestion: "Bcrypt hash format may be invalid."
    }));
    return hash;
  }
  return compacted;
}
function jsonHandler(actual, errors2, _schema, field) {
  if (isString_default(actual))
    return actual;
  const [ok, err, json] = tryFnSync(() => JSON.stringify(actual));
  if (!ok)
    throw new ValidationError2("Failed to stringify JSON", { original: err, input: actual, field });
  return json;
}
var Validator = class extends FastestValidator {
  passphrase;
  bcryptRounds;
  autoEncrypt;
  autoHash;
  constructor({ options, passphrase, bcryptRounds = 10, autoEncrypt = true, autoHash = true } = {}) {
    super(merge_default({}, {
      useNewCustomCheckerFunction: true,
      messages: {
        encryptionKeyMissing: "Missing configuration for secrets encryption.",
        encryptionProblem: "Problem encrypting secret. Actual: {actual}. Error: {error}",
        bcryptRoundsMissing: "Missing bcrypt rounds configuration for password hashing.",
        passwordHashingProblem: "Problem hashing password. Error: {error}"
      },
      defaults: {
        string: {
          trim: true
        },
        object: {
          strict: "remove"
        },
        number: {
          convert: true
        }
      }
    }, options));
    this.passphrase = passphrase;
    this.bcryptRounds = bcryptRounds;
    this.autoEncrypt = autoEncrypt;
    this.autoHash = autoHash;
    this.alias("secret", {
      type: "string",
      custom: this.autoEncrypt ? secretHandler : void 0,
      messages: {
        string: "The '{field}' field must be a string.",
        stringMin: "This secret '{field}' field length must be at least {expected} long."
      }
    });
    this.alias("secretAny", {
      type: "any",
      custom: this.autoEncrypt ? secretHandler : void 0
    });
    this.alias("secretNumber", {
      type: "number",
      custom: this.autoEncrypt ? secretHandler : void 0
    });
    this.alias("password", {
      type: "string",
      custom: this.autoHash ? passwordHandler : void 0,
      messages: {
        string: "The '{field}' field must be a string.",
        stringMin: "This password '{field}' field length must be at least {expected} long."
      }
    });
    this.alias("json", {
      type: "any",
      custom: this.autoEncrypt ? jsonHandler : void 0
    });
    this.alias("embedding", {
      type: "array",
      items: "number",
      empty: false
    });
  }
};
var ValidatorManager = Validator;
function isValidIPv4(ip) {
  if (typeof ip !== "string")
    return false;
  const ipv4Regex = /^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/;
  const match = ip.match(ipv4Regex);
  if (!match)
    return false;
  for (let i4 = 1; i4 <= 4; i4++) {
    const octet = parseInt(match[i4], 10);
    if (octet < 0 || octet > 255)
      return false;
  }
  return true;
}
function isValidIPv6(ip) {
  if (typeof ip !== "string")
    return false;
  const ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]+|::(ffff(:0{1,4})?:)?((25[0-5]|(2[0-4]|1?[0-9])?[0-9])\.){3}(25[0-5]|(2[0-4]|1?[0-9])?[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1?[0-9])?[0-9])\.){3}(25[0-5]|(2[0-4]|1?[0-9])?[0-9]))$/;
  return ipv6Regex.test(ip);
}
function encodeIPv4(ip) {
  if (!isValidIPv4(ip)) {
    throw new ValidationError2("Invalid IPv4 address", {
      field: "ip",
      value: ip,
      retriable: false,
      suggestion: 'Provide a valid IPv4 address (e.g., "192.168.0.1").'
    });
  }
  const octets = ip.split(".").map((octet) => parseInt(octet, 10));
  const buffer = Buffer.from(octets);
  return buffer.toString("base64");
}
function decodeIPv4(encoded) {
  if (typeof encoded !== "string") {
    throw new ValidationError2("Encoded IPv4 must be a string", {
      field: "encoded",
      retriable: false,
      suggestion: "Pass the base64-encoded IPv4 string returned by encodeIPv4()."
    });
  }
  const [ok, err, result] = tryFnSync(() => {
    const buffer = Buffer.from(encoded, "base64");
    if (buffer.length !== 4) {
      throw new ValidationError2("Invalid encoded IPv4 length", {
        field: "encoded",
        value: encoded,
        retriable: false,
        suggestion: "Ensure the encoded IPv4 string was produced by encodeIPv4()."
      });
    }
    return Array.from(buffer).join(".");
  });
  if (!ok) {
    if (err instanceof ValidationError2) {
      throw err;
    }
    throw new ValidationError2("Failed to decode IPv4", {
      field: "encoded",
      retriable: false,
      suggestion: "Confirm the value is a base64-encoded IPv4 string generated by encodeIPv4().",
      original: err
    });
  }
  return result;
}
function expandIPv6(ip) {
  if (!isValidIPv6(ip)) {
    throw new ValidationError2("Invalid IPv6 address", {
      field: "ip",
      value: ip,
      retriable: false,
      suggestion: 'Provide a valid IPv6 address (e.g., "2001:db8::1").'
    });
  }
  let expanded = ip;
  if (expanded === "::") {
    return "0000:0000:0000:0000:0000:0000:0000:0000";
  }
  if (expanded.includes("::")) {
    const parts = expanded.split("::");
    const leftParts = parts[0] ? parts[0].split(":") : [];
    const rightParts = parts[1] ? parts[1].split(":") : [];
    const missingGroups = 8 - leftParts.length - rightParts.length;
    const middleParts = Array(missingGroups).fill("0");
    expanded = [...leftParts, ...middleParts, ...rightParts].join(":");
  }
  const groups = expanded.split(":");
  const paddedGroups = groups.map((group) => group.padStart(4, "0"));
  return paddedGroups.join(":");
}
function compressIPv6(ip) {
  let compressed = ip.split(":").map((group) => {
    return parseInt(group, 16).toString(16);
  }).join(":");
  const zeroSequences = [];
  let currentSequence = { start: -1, length: 0 };
  compressed.split(":").forEach((group, index) => {
    if (group === "0") {
      if (currentSequence.start === -1) {
        currentSequence.start = index;
        currentSequence.length = 1;
      } else {
        currentSequence.length++;
      }
    } else {
      if (currentSequence.length > 0) {
        zeroSequences.push({ ...currentSequence });
        currentSequence = { start: -1, length: 0 };
      }
    }
  });
  if (currentSequence.length > 0) {
    zeroSequences.push(currentSequence);
  }
  const longestSequence = zeroSequences.filter((seq) => seq.length >= 2).sort((a4, b4) => b4.length - a4.length)[0];
  if (longestSequence) {
    const parts = compressed.split(":");
    const before = parts.slice(0, longestSequence.start).join(":");
    const after = parts.slice(longestSequence.start + longestSequence.length).join(":");
    if (before && after) {
      compressed = `${before}::${after}`;
    } else if (before) {
      compressed = `${before}::`;
    } else if (after) {
      compressed = `::${after}`;
    } else {
      compressed = "::";
    }
  }
  return compressed;
}
function encodeIPv6(ip) {
  if (!isValidIPv6(ip)) {
    throw new ValidationError2("Invalid IPv6 address", {
      field: "ip",
      value: ip,
      retriable: false,
      suggestion: 'Provide a valid IPv6 address (e.g., "2001:db8::1").'
    });
  }
  const expanded = expandIPv6(ip);
  const groups = expanded.split(":");
  const bytes = [];
  for (const group of groups) {
    const value = parseInt(group, 16);
    bytes.push(value >> 8 & 255);
    bytes.push(value & 255);
  }
  const buffer = Buffer.from(bytes);
  return buffer.toString("base64");
}
function decodeIPv6(encoded, compress2 = true) {
  if (typeof encoded !== "string") {
    throw new ValidationError2("Encoded IPv6 must be a string", {
      field: "encoded",
      retriable: false,
      suggestion: "Pass the base64-encoded IPv6 string returned by encodeIPv6()."
    });
  }
  if (encoded.length !== 24 && isValidIPv6(encoded)) {
    return compress2 ? encoded : expandIPv6(encoded);
  }
  const [ok, err, result] = tryFnSync(() => {
    const buffer = Buffer.from(encoded, "base64");
    if (buffer.length !== 16) {
      throw new ValidationError2("Invalid encoded IPv6 length", {
        field: "encoded",
        value: encoded,
        retriable: false,
        suggestion: "Ensure the encoded IPv6 string was produced by encodeIPv6()."
      });
    }
    const groups = [];
    for (let i4 = 0; i4 < 16; i4 += 2) {
      const value = buffer[i4] << 8 | buffer[i4 + 1];
      groups.push(value.toString(16).padStart(4, "0"));
    }
    const fullAddress = groups.join(":");
    return compress2 ? compressIPv6(fullAddress) : fullAddress;
  });
  if (!ok) {
    if (err instanceof ValidationError2) {
      throw err;
    }
    throw new ValidationError2("Failed to decode IPv6", {
      field: "encoded",
      retriable: false,
      suggestion: "Confirm the value is a base64-encoded IPv6 string generated by encodeIPv6().",
      original: err
    });
  }
  return result;
}
function encodeBuffer(buffer) {
  if (buffer === null || buffer === void 0) {
    return null;
  }
  if (!Buffer.isBuffer(buffer) && !(buffer instanceof Uint8Array)) {
    throw new ValidationError2("Value must be a Buffer or Uint8Array", {
      field: "buffer",
      value: typeof buffer,
      retriable: false,
      suggestion: "Pass a Buffer or Uint8Array instance."
    });
  }
  const buf = Buffer.isBuffer(buffer) ? buffer : Buffer.from(buffer);
  return buf.toString("base64");
}
function decodeBuffer(encoded) {
  if (encoded === null || encoded === void 0) {
    return null;
  }
  if (typeof encoded !== "string") {
    throw new ValidationError2("Encoded buffer must be a string", {
      field: "encoded",
      value: typeof encoded,
      retriable: false,
      suggestion: "Pass the base64-encoded string returned by encodeBuffer()."
    });
  }
  return Buffer.from(encoded, "base64");
}
function encodeBits(buffer, expectedBits = null, skipValidation = false) {
  if (skipValidation) {
    return buffer.toString("base64");
  }
  if (buffer === null || buffer === void 0) {
    return null;
  }
  if (!Buffer.isBuffer(buffer) && !(buffer instanceof Uint8Array)) {
    throw new ValidationError2("Bitmap must be a Buffer or Uint8Array", {
      field: "bits",
      value: typeof buffer,
      retriable: false,
      suggestion: "Pass a Buffer or Uint8Array instance."
    });
  }
  const buf = Buffer.isBuffer(buffer) ? buffer : Buffer.from(buffer);
  if (expectedBits !== null) {
    const expectedBytes = expectedBits + 7 >> 3;
    if (buf.length !== expectedBytes) {
      throw new ValidationError2(`Bitmap size mismatch: expected ${expectedBytes} bytes (${expectedBits} bits), got ${buf.length} bytes`, {
        field: "bits",
        expectedBits,
        expectedBytes,
        actualBytes: buf.length,
        retriable: false,
        suggestion: `Use Buffer.alloc(${expectedBytes}) to create a bitmap with ${expectedBits} bits.`
      });
    }
  }
  return buf.toString("base64");
}
function decodeBits(encoded, expectedBits = null, skipValidation = false) {
  if (skipValidation) {
    return Buffer.from(encoded, "base64");
  }
  if (encoded === null || encoded === void 0) {
    return null;
  }
  if (typeof encoded !== "string") {
    throw new ValidationError2("Encoded bits must be a string", {
      field: "encoded",
      value: typeof encoded,
      retriable: false,
      suggestion: "Pass the base64-encoded string returned by encodeBits()."
    });
  }
  const buffer = Buffer.from(encoded, "base64");
  if (expectedBits !== null) {
    const expectedBytes = expectedBits + 7 >> 3;
    if (buffer.length !== expectedBytes) {
      throw new ValidationError2(`Decoded bitmap size mismatch: expected ${expectedBytes} bytes (${expectedBits} bits), got ${buffer.length} bytes`, {
        field: "bits",
        expectedBits,
        expectedBytes,
        actualBytes: buffer.length,
        retriable: false,
        suggestion: "Ensure the encoded string was produced by encodeBits() with the same bit count."
      });
    }
  }
  return buffer;
}
var POPCOUNT_TABLE = new Uint8Array(256);
for (let i4 = 0; i4 < 256; i4++) {
  let count = 0;
  let n4 = i4;
  while (n4) {
    count += n4 & 1;
    n4 >>= 1;
  }
  POPCOUNT_TABLE[i4] = count;
}
function encodeGeoLat(lat, precision = 6) {
  if (lat === null || lat === void 0)
    return lat;
  if (typeof lat !== "number" || isNaN(lat))
    return lat;
  if (!isFinite(lat))
    return lat;
  if (lat < -90 || lat > 90) {
    throw new ValidationError2("Latitude out of range", {
      field: "lat",
      value: lat,
      min: -90,
      max: 90,
      statusCode: 400,
      retriable: false,
      suggestion: "Provide a latitude between -90 and +90 degrees."
    });
  }
  const normalized = lat + 90;
  const scale = Math.pow(10, precision);
  const scaled = Math.round(normalized * scale);
  return "~" + encode2(scaled);
}
function decodeGeoLat(encoded, precision = 6) {
  if (typeof encoded !== "string")
    return encoded;
  if (!encoded.startsWith("~"))
    return encoded;
  const scaled = decode2(encoded.slice(1));
  if (isNaN(scaled))
    return NaN;
  const scale = Math.pow(10, precision);
  const normalized = scaled / scale;
  return normalized - 90;
}
function encodeGeoLon(lon, precision = 6) {
  if (lon === null || lon === void 0)
    return lon;
  if (typeof lon !== "number" || isNaN(lon))
    return lon;
  if (!isFinite(lon))
    return lon;
  if (lon < -180 || lon > 180) {
    throw new ValidationError2("Longitude out of range", {
      field: "lon",
      value: lon,
      min: -180,
      max: 180,
      statusCode: 400,
      retriable: false,
      suggestion: "Provide a longitude between -180 and +180 degrees."
    });
  }
  const normalized = lon + 180;
  const scale = Math.pow(10, precision);
  const scaled = Math.round(normalized * scale);
  return "~" + encode2(scaled);
}
function decodeGeoLon(encoded, precision = 6) {
  if (typeof encoded !== "string")
    return encoded;
  if (!encoded.startsWith("~"))
    return encoded;
  const scaled = decode2(encoded.slice(1));
  if (isNaN(scaled))
    return NaN;
  const scale = Math.pow(10, precision);
  const normalized = scaled / scale;
  return normalized - 180;
}
function encodeGeoPoint(lat, lon, precision = 6) {
  const latEncoded = encodeGeoLat(lat, precision);
  const lonEncoded = encodeGeoLon(lon, precision);
  return String(latEncoded) + String(lonEncoded);
}
function decodeGeoPoint(encoded, precision = 6) {
  if (typeof encoded !== "string")
    return { latitude: NaN, longitude: NaN };
  const parts = encoded.split("~").filter((p4) => p4.length > 0);
  if (parts.length !== 2) {
    return { latitude: NaN, longitude: NaN };
  }
  const latitude = decodeGeoLat("~" + parts[0], precision);
  const longitude = decodeGeoLon("~" + parts[1], precision);
  return { latitude, longitude };
}
var validatorCache = /* @__PURE__ */ new Map();
var cacheHits = 0;
var cacheMisses = 0;
function generateSchemaFingerprint(attributes, options = {}) {
  const normalized = {
    attributes: JSON.stringify(attributes, Object.keys(attributes).sort()),
    passphrase: options.passphrase || "secret",
    bcryptRounds: options.bcryptRounds || 10,
    allNestedObjectsOptional: options.allNestedObjectsOptional ?? false
  };
  const serialized = JSON.stringify(normalized);
  return (0, import_crypto.createHash)("sha256").update(serialized).digest("hex");
}
function getCachedValidator(fingerprint) {
  const cached = validatorCache.get(fingerprint);
  if (cached) {
    cached.refCount++;
    cached.lastAccessedAt = Date.now();
    cacheHits++;
    return cached.validator;
  }
  cacheMisses++;
  return null;
}
function cacheValidator(fingerprint, validator) {
  if (validatorCache.has(fingerprint)) {
    validatorCache.get(fingerprint).refCount++;
    return;
  }
  validatorCache.set(fingerprint, {
    validator,
    refCount: 1,
    createdAt: Date.now(),
    lastAccessedAt: Date.now()
  });
}
function releaseValidator(fingerprint) {
  const cached = validatorCache.get(fingerprint);
  if (!cached)
    return;
  cached.refCount = Math.max(0, cached.refCount - 1);
}
function evictUnusedValidators(maxAgeMs = 5 * 60 * 1e3) {
  const now = Date.now();
  let evicted = 0;
  for (const [fingerprint, cached] of validatorCache.entries()) {
    if (cached.refCount === 0 && now - cached.lastAccessedAt >= maxAgeMs) {
      validatorCache.delete(fingerprint);
      evicted++;
    }
  }
  return evicted;
}
function getCacheStats() {
  let totalRefCount = 0;
  let zeroRefCount = 0;
  for (const cached of validatorCache.values()) {
    totalRefCount += cached.refCount;
    if (cached.refCount === 0)
      zeroRefCount++;
  }
  return {
    size: validatorCache.size,
    totalReferences: totalRefCount,
    zeroRefValidators: zeroRefCount,
    cacheHits,
    cacheMisses,
    hitRate: cacheHits + cacheMisses > 0 ? cacheHits / (cacheHits + cacheMisses) : 0
  };
}
function getCacheMemoryUsage() {
  const VALIDATOR_SIZE_KB = 50;
  return {
    estimatedKB: validatorCache.size * VALIDATOR_SIZE_KB,
    estimatedMB: validatorCache.size * VALIDATOR_SIZE_KB / 1024,
    validatorCount: validatorCache.size
  };
}
function generateBase62Mapping(keys2) {
  const mapping = {};
  const reversedMapping = {};
  keys2.forEach((key, index) => {
    const base62Key = encode2(index);
    mapping[key] = base62Key;
    reversedMapping[base62Key] = key;
  });
  return { mapping, reversedMapping };
}
function generatePluginAttributeHash(pluginName, attributeName) {
  const input = `${pluginName}:${attributeName}`;
  const hash = (0, import_crypto.createHash)("sha256").update(input).digest();
  const num = hash.readUInt32BE(0);
  const base62Hash = encode2(num);
  const paddedHash = base62Hash.padStart(3, "0").substring(0, 3);
  return "p" + paddedHash.toLowerCase();
}
function generateLegacyPluginIndexKey(pluginName, index) {
  const prefix = pluginName.substring(0, 2);
  return `p${prefix}${encode2(index)}`;
}
function generatePluginMapping(attributes) {
  const mapping = {};
  const reversedMapping = {};
  const usedHashes = /* @__PURE__ */ new Set();
  for (const { key, pluginName } of attributes) {
    let hash = generatePluginAttributeHash(pluginName, key);
    let counter = 1;
    let finalHash = hash;
    while (usedHashes.has(finalHash)) {
      finalHash = `${hash}${counter}`;
      counter++;
    }
    usedHashes.add(finalHash);
    mapping[key] = finalHash;
    reversedMapping[finalHash] = key;
  }
  return { mapping, reversedMapping };
}
function generateMappingFromRegistry(keys2, existingRegistry) {
  const now = (/* @__PURE__ */ new Date()).toISOString();
  const registry = existingRegistry ? {
    nextIndex: existingRegistry.nextIndex,
    mapping: { ...existingRegistry.mapping },
    burned: [...existingRegistry.burned]
  } : { nextIndex: 0, mapping: {}, burned: [] };
  const mapping = {};
  const reversedMapping = {};
  let changed = false;
  const mappedIndices = Object.values(registry.mapping).filter((value) => Number.isFinite(value));
  const burnedIndices = registry.burned.map((burned) => burned.index).filter((value) => Number.isFinite(value));
  const maxIndex = Math.max(-1, ...mappedIndices, ...burnedIndices);
  if (registry.nextIndex <= maxIndex) {
    registry.nextIndex = maxIndex + 1;
    changed = true;
  }
  for (const key of keys2) {
    if (key in registry.mapping && registry.mapping[key] !== void 0) {
      const index = registry.mapping[key];
      const base62Key = encode2(index);
      mapping[key] = base62Key;
      reversedMapping[base62Key] = key;
    } else {
      const index = registry.nextIndex++;
      registry.mapping[key] = index;
      const base62Key = encode2(index);
      mapping[key] = base62Key;
      reversedMapping[base62Key] = key;
      changed = true;
    }
  }
  const currentKeys = new Set(keys2);
  for (const [attr, index] of Object.entries(registry.mapping)) {
    if (!currentKeys.has(attr)) {
      const alreadyBurned = registry.burned.some((b4) => b4.index === index);
      if (!alreadyBurned) {
        registry.burned.push({
          index,
          attribute: attr,
          burnedAt: now,
          reason: "removed"
        });
        changed = true;
      }
      delete registry.mapping[attr];
    }
  }
  return { mapping, reversedMapping, registry, changed };
}
function generatePluginMappingFromRegistry(attributes, existingRegistries) {
  const now = (/* @__PURE__ */ new Date()).toISOString();
  const registries = {};
  const mapping = {};
  const reversedMapping = {};
  let changed = false;
  const byPlugin = /* @__PURE__ */ new Map();
  for (const { key, pluginName } of attributes) {
    if (!byPlugin.has(pluginName))
      byPlugin.set(pluginName, []);
    byPlugin.get(pluginName).push(key);
  }
  const globalUsedKeys = /* @__PURE__ */ new Set();
  for (const [pluginName, keys2] of byPlugin) {
    const existing = existingRegistries?.[pluginName];
    const registry = { mapping: {}, burned: [] };
    if (existing) {
      if (isLegacyNumericRegistry(existing)) {
        for (const [attr, index] of Object.entries(existing.mapping)) {
          const legacyKey = generateLegacyPluginIndexKey(pluginName, index);
          registry.mapping[attr] = legacyKey;
          globalUsedKeys.add(legacyKey);
        }
        for (const burned of existing.burned) {
          const legacyKey = generateLegacyPluginIndexKey(pluginName, burned.index);
          registry.burned.push({
            key: legacyKey,
            attribute: burned.attribute,
            burnedAt: burned.burnedAt,
            reason: burned.reason
          });
          globalUsedKeys.add(legacyKey);
        }
        changed = true;
      } else {
        registry.mapping = { ...existing.mapping };
        registry.burned = [...existing.burned];
        for (const key of Object.values(existing.mapping)) {
          globalUsedKeys.add(key);
        }
        for (const burned of existing.burned) {
          globalUsedKeys.add(burned.key);
        }
      }
    }
    for (const attrName of keys2) {
      const existingKey = registry.mapping[attrName];
      if (existingKey) {
        mapping[attrName] = existingKey;
        reversedMapping[existingKey] = attrName;
      } else {
        let hashKey = generatePluginAttributeHash(pluginName, attrName);
        let counter = 1;
        while (globalUsedKeys.has(hashKey)) {
          hashKey = `${generatePluginAttributeHash(pluginName, attrName)}${counter}`;
          counter++;
        }
        globalUsedKeys.add(hashKey);
        registry.mapping[attrName] = hashKey;
        mapping[attrName] = hashKey;
        reversedMapping[hashKey] = attrName;
        changed = true;
      }
    }
    const currentKeys = new Set(keys2);
    for (const [attr, key] of Object.entries(registry.mapping)) {
      if (!currentKeys.has(attr)) {
        const alreadyBurned = registry.burned.some((b4) => b4.key === key);
        if (!alreadyBurned) {
          registry.burned.push({
            key,
            attribute: attr,
            burnedAt: now,
            reason: "removed"
          });
          changed = true;
        }
        delete registry.mapping[attr];
      }
    }
    registries[pluginName] = registry;
  }
  return { mapping, reversedMapping, registries, changed };
}
function isLegacyNumericRegistry(registry) {
  if ("nextIndex" in registry)
    return true;
  const values = Object.values(registry.mapping);
  if (values.length === 0)
    return false;
  return typeof values[0] === "number";
}
var SchemaActions = {
  trim: (value) => value == null ? value : String(value).trim(),
  encrypt: async (value, { passphrase }) => {
    if (value === null || value === void 0)
      return value;
    const [ok, , res] = await tryFn$1(() => encrypt(value, passphrase));
    return ok ? res : value;
  },
  decrypt: async (value, { passphrase }) => {
    if (value === null || value === void 0)
      return value;
    const [ok, , raw] = await tryFn$1(() => decrypt(value, passphrase));
    if (!ok)
      return value;
    if (raw === "null")
      return null;
    if (raw === "undefined")
      return void 0;
    return raw;
  },
  hashPassword: async (value, { bcryptRounds = 10 }) => {
    if (value === null || value === void 0)
      return value;
    const [okHash, , hash] = await tryFn$1(() => hashPassword(String(value), bcryptRounds));
    if (!okHash)
      return value;
    const [okCompact, , compacted] = tryFnSync(() => compactHash(hash));
    return okCompact ? compacted : hash;
  },
  toString: (value) => value == null ? value : String(value),
  fromArray: (value, { separator }) => {
    if (value === null || value === void 0 || !Array.isArray(value)) {
      return value;
    }
    if (value.length === 0) {
      return "";
    }
    const escapedItems = value.map((item) => {
      if (typeof item === "string") {
        return item.replace(/\\/g, "\\\\").replace(new RegExp(`\\${separator}`, "g"), `\\${separator}`);
      }
      return String(item);
    });
    return escapedItems.join(separator);
  },
  toArray: (value, { separator }) => {
    if (Array.isArray(value)) {
      return value;
    }
    if (value === null || value === void 0) {
      return value;
    }
    if (value === "") {
      return [];
    }
    const items = [];
    let current = "";
    let i4 = 0;
    const str = String(value);
    while (i4 < str.length) {
      if (str[i4] === "\\" && i4 + 1 < str.length) {
        current += str[i4 + 1];
        i4 += 2;
      } else if (str[i4] === separator) {
        items.push(current);
        current = "";
        i4++;
      } else {
        current += str[i4];
        i4++;
      }
    }
    items.push(current);
    return items;
  },
  toJSON: (value) => {
    if (value === null)
      return null;
    if (value === void 0)
      return void 0;
    if (typeof value === "string") {
      const [ok2, , parsed] = tryFnSync(() => JSON.parse(value));
      if (ok2 && typeof parsed === "object")
        return value;
      return value;
    }
    const [ok, , json] = tryFnSync(() => JSON.stringify(value));
    return ok ? json : value;
  },
  fromJSON: (value) => {
    if (value === null)
      return null;
    if (value === void 0)
      return void 0;
    if (typeof value !== "string")
      return value;
    if (value === "")
      return "";
    const [ok, , parsed] = tryFnSync(() => JSON.parse(value));
    return ok ? parsed : value;
  },
  toNumber: (value) => isString_default(value) ? value.includes(".") ? parseFloat(value) : parseInt(value) : value,
  toBool: (value) => [true, 1, "true", "1", "yes", "y"].includes(value),
  fromBool: (value) => [true, 1, "true", "1", "yes", "y"].includes(value) ? "1" : "0",
  fromBase62: (value) => {
    if (value === null || value === void 0 || value === "")
      return value;
    if (typeof value === "number")
      return value;
    if (typeof value === "string") {
      const n4 = decode2(value);
      return isNaN(n4) ? void 0 : n4;
    }
    return void 0;
  },
  toBase62: (value) => {
    if (value === null || value === void 0 || value === "")
      return value;
    if (typeof value === "number") {
      return encode2(value);
    }
    if (typeof value === "string") {
      const n4 = Number(value);
      return isNaN(n4) ? value : encode2(n4);
    }
    return value;
  },
  fromBase62Decimal: (value) => {
    if (value === null || value === void 0 || value === "")
      return value;
    if (typeof value === "number")
      return value;
    if (typeof value === "string") {
      const n4 = decodeDecimal(value);
      return isNaN(n4) ? void 0 : n4;
    }
    return void 0;
  },
  toBase62Decimal: (value) => {
    if (value === null || value === void 0 || value === "")
      return value;
    if (typeof value === "number") {
      return encodeDecimal(value);
    }
    if (typeof value === "string") {
      const n4 = Number(value);
      return isNaN(n4) ? value : encodeDecimal(n4);
    }
    return value;
  },
  fromArrayOfNumbers: (value, { separator }) => {
    if (value === null || value === void 0 || !Array.isArray(value)) {
      return value;
    }
    if (value.length === 0) {
      return "";
    }
    const base62Items = value.map((item) => {
      if (typeof item === "number" && !isNaN(item)) {
        return encode2(item);
      }
      const n4 = Number(item);
      return isNaN(n4) ? "" : encode2(n4);
    });
    return base62Items.join(separator);
  },
  toArrayOfNumbers: (value, { separator }) => {
    if (Array.isArray(value)) {
      return value.map((v4) => typeof v4 === "number" ? v4 : decode2(v4));
    }
    if (value === null || value === void 0) {
      return value;
    }
    if (value === "") {
      return [];
    }
    const str = String(value);
    const items = [];
    let current = "";
    let i4 = 0;
    while (i4 < str.length) {
      if (str[i4] === "\\" && i4 + 1 < str.length) {
        current += str[i4 + 1];
        i4 += 2;
      } else if (str[i4] === separator) {
        items.push(current);
        current = "";
        i4++;
      } else {
        current += str[i4];
        i4++;
      }
    }
    items.push(current);
    return items.map((v4) => {
      if (typeof v4 === "number")
        return v4;
      if (typeof v4 === "string" && v4 !== "") {
        const n4 = decode2(v4);
        return isNaN(n4) ? NaN : n4;
      }
      return NaN;
    });
  },
  fromArrayOfDecimals: (value, { separator }) => {
    if (value === null || value === void 0 || !Array.isArray(value)) {
      return value;
    }
    if (value.length === 0) {
      return "";
    }
    const base62Items = value.map((item) => {
      if (typeof item === "number" && !isNaN(item)) {
        return encodeDecimal(item);
      }
      const n4 = Number(item);
      return isNaN(n4) ? "" : encodeDecimal(n4);
    });
    return base62Items.join(separator);
  },
  toArrayOfDecimals: (value, { separator }) => {
    if (Array.isArray(value)) {
      return value.map((v4) => typeof v4 === "number" ? v4 : decodeDecimal(v4));
    }
    if (value === null || value === void 0) {
      return value;
    }
    if (value === "") {
      return [];
    }
    const str = String(value);
    const items = [];
    let current = "";
    let i4 = 0;
    while (i4 < str.length) {
      if (str[i4] === "\\" && i4 + 1 < str.length) {
        current += str[i4 + 1];
        i4 += 2;
      } else if (str[i4] === separator) {
        items.push(current);
        current = "";
        i4++;
      } else {
        current += str[i4];
        i4++;
      }
    }
    items.push(current);
    return items.map((v4) => {
      if (typeof v4 === "number")
        return v4;
      if (typeof v4 === "string" && v4 !== "") {
        const n4 = decodeDecimal(v4);
        return isNaN(n4) ? NaN : n4;
      }
      return NaN;
    });
  },
  fromArrayOfEmbeddings: (value, { precision = 6 }) => {
    if (value === null || value === void 0 || !Array.isArray(value)) {
      return value;
    }
    if (value.length === 0) {
      return "^[]";
    }
    return encodeFixedPointBatch(value, precision);
  },
  toArrayOfEmbeddings: (value, { separator, precision = 6 }) => {
    if (Array.isArray(value)) {
      return value;
    }
    if (value === null || value === void 0) {
      return value;
    }
    if (value === "" || value === "^[]") {
      return [];
    }
    const str = String(value);
    if (str.startsWith("^[")) {
      return decodeFixedPointBatch(str, precision);
    }
    const items = [];
    let current = "";
    let i4 = 0;
    while (i4 < str.length) {
      if (str[i4] === "\\" && i4 + 1 < str.length) {
        current += str[i4 + 1];
        i4 += 2;
      } else if (str[i4] === separator) {
        items.push(current);
        current = "";
        i4++;
      } else {
        current += str[i4];
        i4++;
      }
    }
    items.push(current);
    return items.map((v4) => {
      if (typeof v4 === "number")
        return v4;
      if (typeof v4 === "string" && v4 !== "") {
        const n4 = decodeFixedPoint(v4, precision);
        return isNaN(n4) ? NaN : n4;
      }
      return NaN;
    });
  },
  encodeIPv4: (value) => {
    if (value === null || value === void 0)
      return value;
    if (typeof value !== "string")
      return value;
    if (!isValidIPv4(value))
      return value;
    const [ok, , encoded] = tryFnSync(() => encodeIPv4(value));
    return ok ? encoded : value;
  },
  decodeIPv4: (value) => {
    if (value === null || value === void 0)
      return value;
    if (typeof value !== "string")
      return value;
    const [ok, , decoded] = tryFnSync(() => decodeIPv4(value));
    return ok ? decoded : value;
  },
  encodeIPv6: (value) => {
    if (value === null || value === void 0)
      return value;
    if (typeof value !== "string")
      return value;
    if (!isValidIPv6(value))
      return value;
    const [ok, , encoded] = tryFnSync(() => encodeIPv6(value));
    return ok ? encoded : value;
  },
  decodeIPv6: (value) => {
    if (value === null || value === void 0)
      return value;
    if (typeof value !== "string")
      return value;
    const [ok, , decoded] = tryFnSync(() => decodeIPv6(value));
    return ok ? decoded : value;
  },
  encodeBuffer: (value) => {
    if (value === null || value === void 0)
      return value;
    if (!Buffer.isBuffer(value) && !(value instanceof Uint8Array))
      return value;
    const [ok, , encoded] = tryFnSync(() => encodeBuffer(value));
    return ok ? encoded : value;
  },
  decodeBuffer: (value) => {
    if (value === null || value === void 0)
      return value;
    if (typeof value !== "string")
      return value;
    const [ok, , decoded] = tryFnSync(() => decodeBuffer(value));
    return ok ? decoded : value;
  },
  encodeBits: (value, { bitCount = null } = {}) => {
    if (value === null || value === void 0)
      return value;
    if (!Buffer.isBuffer(value) && !(value instanceof Uint8Array))
      return value;
    const [ok, , encoded] = tryFnSync(() => encodeBits(value, bitCount));
    return ok ? encoded : value;
  },
  decodeBits: (value, { bitCount = null } = {}) => {
    if (value === null || value === void 0)
      return value;
    if (typeof value !== "string")
      return value;
    const [ok, , decoded] = tryFnSync(() => decodeBits(value, bitCount));
    return ok ? decoded : value;
  },
  encodeMoney: (value, { decimals = 2 } = {}) => {
    if (value === null || value === void 0)
      return value;
    if (typeof value !== "number")
      return value;
    const multiplier = Math.pow(10, decimals);
    const integerValue = Math.round(value * multiplier);
    const [ok, , encoded] = tryFnSync(() => "$" + encode2(integerValue));
    return ok ? encoded : value;
  },
  decodeMoney: (value, { decimals = 2 } = {}) => {
    if (value === null || value === void 0)
      return value;
    if (typeof value !== "string")
      return value;
    if (!value.startsWith("$"))
      return value;
    const [ok, , integerValue] = tryFnSync(() => decode2(value.slice(1)));
    if (!ok || isNaN(integerValue))
      return value;
    const divisor = Math.pow(10, decimals);
    return integerValue / divisor;
  },
  encodeDecimalFixed: (value, { precision = 2 } = {}) => {
    if (value === null || value === void 0)
      return value;
    if (typeof value !== "number")
      return value;
    const [ok, , encoded] = tryFnSync(() => encodeFixedPoint(value, precision));
    return ok ? encoded : value;
  },
  decodeDecimalFixed: (value, { precision = 2 } = {}) => {
    if (value === null || value === void 0)
      return value;
    if (typeof value !== "string")
      return value;
    const [ok, , decoded] = tryFnSync(() => decodeFixedPoint(value, precision));
    return ok ? decoded : value;
  },
  encodeGeoLatitude: (value, { precision = 6 } = {}) => {
    if (value === null || value === void 0)
      return value;
    if (typeof value !== "number")
      return value;
    const [ok, , encoded] = tryFnSync(() => encodeGeoLat(value, precision));
    return ok ? encoded : value;
  },
  decodeGeoLatitude: (value, { precision = 6 } = {}) => {
    if (value === null || value === void 0)
      return value;
    if (typeof value !== "string")
      return value;
    const [ok, , decoded] = tryFnSync(() => decodeGeoLat(value, precision));
    return ok ? decoded : value;
  },
  encodeGeoLongitude: (value, { precision = 6 } = {}) => {
    if (value === null || value === void 0)
      return value;
    if (typeof value !== "number")
      return value;
    const [ok, , encoded] = tryFnSync(() => encodeGeoLon(value, precision));
    return ok ? encoded : value;
  },
  decodeGeoLongitude: (value, { precision = 6 } = {}) => {
    if (value === null || value === void 0)
      return value;
    if (typeof value !== "string")
      return value;
    const [ok, , decoded] = tryFnSync(() => decodeGeoLon(value, precision));
    return ok ? decoded : value;
  },
  encodeGeoPointPair: (value, { precision = 6 } = {}) => {
    if (value === null || value === void 0)
      return value;
    if (Array.isArray(value) && value.length === 2) {
      const [ok, , encoded] = tryFnSync(() => encodeGeoPoint(value[0], value[1], precision));
      return ok ? encoded : value;
    }
    if (typeof value === "object" && value !== null) {
      const obj = value;
      if (obj.lat !== void 0 && obj.lon !== void 0) {
        const [ok, , encoded] = tryFnSync(() => encodeGeoPoint(obj.lat, obj.lon, precision));
        return ok ? encoded : value;
      }
      if (obj.latitude !== void 0 && obj.longitude !== void 0) {
        const [ok, , encoded] = tryFnSync(() => encodeGeoPoint(obj.latitude, obj.longitude, precision));
        return ok ? encoded : value;
      }
    }
    return value;
  },
  decodeGeoPointPair: (value, { precision = 6 } = {}) => {
    if (value === null || value === void 0)
      return value;
    if (typeof value !== "string")
      return value;
    const [ok, , decoded] = tryFnSync(() => decodeGeoPoint(value, precision));
    return ok ? decoded : value;
  }
};
var Schema2 = class _Schema {
  name;
  version;
  attributes;
  passphrase;
  bcryptRounds;
  options;
  allNestedObjectsOptional;
  _pluginAttributeMetadata;
  _pluginAttributes;
  _schemaFingerprint;
  validator;
  map;
  reversedMap;
  pluginMap;
  reversedPluginMap;
  /** Updated schema registry - should be persisted to s3db.json */
  _schemaRegistry;
  /** Updated plugin schema registries - should be persisted to s3db.json */
  _pluginSchemaRegistry;
  /** Whether the registry was modified and needs persistence */
  _registryChanged = false;
  constructor(args) {
    const { map: map2, pluginMap, name, attributes, passphrase, bcryptRounds, version = 1, options = {}, _pluginAttributeMetadata, _pluginAttributes, schemaRegistry, pluginSchemaRegistry } = args;
    this.name = name;
    this.version = version;
    this.attributes = attributes || {};
    this.passphrase = passphrase ?? "secret";
    this.bcryptRounds = bcryptRounds ?? 10;
    this.options = merge_default({}, this.defaultOptions(), options);
    this.allNestedObjectsOptional = this.options.allNestedObjectsOptional ?? false;
    this._pluginAttributeMetadata = _pluginAttributeMetadata || {};
    this._pluginAttributes = _pluginAttributes || {};
    const processedAttributes = this.preprocessAttributesForValidation(this.attributes);
    this._schemaFingerprint = generateSchemaFingerprint(processedAttributes, {
      passphrase: this.passphrase,
      bcryptRounds: this.bcryptRounds,
      allNestedObjectsOptional: this.allNestedObjectsOptional
    });
    const cachedValidator = getCachedValidator(this._schemaFingerprint);
    if (cachedValidator) {
      this.validator = cachedValidator;
    } else {
      this.validator = new ValidatorManager({
        autoEncrypt: false,
        passphrase: this.passphrase,
        bcryptRounds: this.bcryptRounds
      }).compile(merge_default({ $$async: true, $$strict: false }, processedAttributes));
      cacheValidator(this._schemaFingerprint, this.validator);
    }
    if (this.options.generateAutoHooks)
      this.generateAutoHooks();
    const flatAttrs = flatten(this.attributes, { safe: true });
    const leafKeys = Object.keys(flatAttrs).filter((k4) => !k4.includes("$$"));
    const objectKeys = this.extractObjectKeys(this.attributes);
    const allKeys = [.../* @__PURE__ */ new Set([...leafKeys, ...objectKeys])];
    const userKeys = [];
    const pluginAttributes = [];
    for (const key of allKeys) {
      const attrDef = this.getAttributeDefinition(key);
      if (typeof attrDef === "object" && attrDef !== null && attrDef.__plugin__) {
        pluginAttributes.push({ key, pluginName: attrDef.__plugin__ });
      } else if (typeof attrDef === "string" && this._pluginAttributeMetadata && this._pluginAttributeMetadata[key]) {
        const pluginName = this._pluginAttributeMetadata[key].__plugin__;
        pluginAttributes.push({ key, pluginName });
      } else {
        userKeys.push(key);
      }
    }
    if (!isEmpty_default(map2)) {
      this.map = { ...map2 };
      this.reversedMap = invert_default(this.map);
      if (schemaRegistry) {
        const registryFromMap = this._buildRegistryFromMap(map2, schemaRegistry);
        const result = generateMappingFromRegistry(userKeys, registryFromMap);
        for (const key of userKeys) {
          if (!(key in this.map)) {
            const mappedKey = result.mapping[key];
            if (mappedKey) {
              this.map[key] = mappedKey;
              this.reversedMap[mappedKey] = key;
            }
          }
        }
        this._schemaRegistry = result.registry;
        if (result.changed)
          this._registryChanged = true;
      }
    } else {
      if (schemaRegistry) {
        const result = generateMappingFromRegistry(userKeys, schemaRegistry);
        this.map = result.mapping;
        this.reversedMap = result.reversedMapping;
        this._schemaRegistry = result.registry;
        if (result.changed)
          this._registryChanged = true;
      } else {
        const { mapping, reversedMapping } = generateBase62Mapping(userKeys);
        this.map = mapping;
        this.reversedMap = reversedMapping;
      }
    }
    if (pluginSchemaRegistry) {
      const result = generatePluginMappingFromRegistry(pluginAttributes, pluginSchemaRegistry);
      this.pluginMap = result.mapping;
      this.reversedPluginMap = result.reversedMapping;
      this._pluginSchemaRegistry = result.registries;
      if (result.changed)
        this._registryChanged = true;
    } else {
      const { mapping: pMapping, reversedMapping: pReversedMapping } = generatePluginMapping(pluginAttributes);
      this.pluginMap = pMapping;
      this.reversedPluginMap = pReversedMapping;
    }
    this._pluginAttributes = {};
    for (const { key, pluginName } of pluginAttributes) {
      if (!this._pluginAttributes[pluginName]) {
        this._pluginAttributes[pluginName] = [];
      }
      this._pluginAttributes[pluginName].push(key);
    }
    if (!isEmpty_default(pluginMap)) {
      this.pluginMap = pluginMap;
      this.reversedPluginMap = invert_default(pluginMap);
    }
    if (!this.pluginMap) {
      this.pluginMap = {};
      this.reversedPluginMap = {};
    }
    if (!this._pluginAttributes) {
      this._pluginAttributes = {};
    }
  }
  defaultOptions() {
    return {
      autoEncrypt: true,
      autoDecrypt: true,
      arraySeparator: "|",
      generateAutoHooks: true,
      hooks: {
        beforeMap: {},
        afterMap: {},
        beforeUnmap: {},
        afterUnmap: {}
      }
    };
  }
  _buildRegistryFromMap(legacyMap, existingRegistry) {
    const registry = {
      nextIndex: existingRegistry?.nextIndex ?? 0,
      mapping: { ...existingRegistry?.mapping },
      burned: existingRegistry?.burned ? [...existingRegistry.burned] : []
    };
    let maxIndex = registry.nextIndex - 1;
    for (const [attr, base62Key] of Object.entries(legacyMap)) {
      const index = decode2(base62Key);
      if (!(attr in registry.mapping)) {
        registry.mapping[attr] = index;
      }
      if (Number.isFinite(index)) {
        maxIndex = Math.max(maxIndex, index);
      }
    }
    for (const burned of registry.burned) {
      maxIndex = Math.max(maxIndex, burned.index);
    }
    registry.nextIndex = Math.max(registry.nextIndex, maxIndex + 1);
    return registry;
  }
  /**
   * Generate initial schema registry from current mapping.
   * Used for migrating existing databases that don't have a registry yet.
   * This "freezes" the current mapping as the source of truth.
   */
  generateInitialRegistry() {
    const schemaRegistry = {
      nextIndex: 0,
      mapping: {},
      burned: []
    };
    let maxIndex = -1;
    for (const [attr, base62Key] of Object.entries(this.map)) {
      const index = decode2(base62Key);
      schemaRegistry.mapping[attr] = index;
      if (Number.isFinite(index)) {
        maxIndex = Math.max(maxIndex, index);
      }
    }
    schemaRegistry.nextIndex = maxIndex + 1;
    const pluginSchemaRegistry = {};
    for (const [pluginName, attrs] of Object.entries(this._pluginAttributes)) {
      const registry = {
        mapping: {},
        burned: []
      };
      for (const attr of attrs) {
        const key = this.pluginMap[attr];
        if (key) {
          registry.mapping[attr] = key;
        }
      }
      pluginSchemaRegistry[pluginName] = registry;
    }
    return { schemaRegistry, pluginSchemaRegistry };
  }
  /**
   * Check if the schema registry needs to be persisted.
   */
  needsRegistryPersistence() {
    return this._registryChanged;
  }
  /**
   * Get the updated schema registry for persistence.
   */
  getSchemaRegistry() {
    return this._schemaRegistry;
  }
  /**
   * Get the updated plugin schema registries for persistence.
   */
  getPluginSchemaRegistry() {
    return this._pluginSchemaRegistry;
  }
  addHook(hook, attribute, action, params = {}) {
    if (!this.options.hooks[hook][attribute])
      this.options.hooks[hook][attribute] = [];
    const hookEntry = Object.keys(params).length > 0 ? { action, params } : action;
    this.options.hooks[hook][attribute] = uniq_default([...this.options.hooks[hook][attribute], hookEntry]);
  }
  extractObjectKeys(obj, prefix = "") {
    const objectKeys = [];
    for (const [key, value] of Object.entries(obj)) {
      if (key.startsWith("$$"))
        continue;
      const fullKey = prefix ? `${prefix}.${key}` : key;
      if (typeof value === "object" && value !== null && !Array.isArray(value)) {
        objectKeys.push(fullKey);
        if (value.$$type === "object") {
          objectKeys.push(...this.extractObjectKeys(value, fullKey));
        }
      }
    }
    return objectKeys;
  }
  _generateHooksFromOriginalAttributes(attributes, prefix = "") {
    for (const [key, value] of Object.entries(attributes)) {
      if (key.startsWith("$$"))
        continue;
      const fullKey = prefix ? `${prefix}.${key}` : key;
      if (typeof value === "object" && value !== null && !Array.isArray(value) && value.type) {
        const typedValue = value;
        if (typedValue.type === "array" && typedValue.items) {
          const itemsType = typedValue.items;
          const arrayLength = typeof typedValue.length === "number" ? typedValue.length : null;
          if (itemsType === "string" || typeof itemsType === "string" && itemsType.includes("string")) {
            this.addHook("beforeMap", fullKey, "fromArray");
            this.addHook("afterUnmap", fullKey, "toArray");
          } else if (itemsType === "number" || typeof itemsType === "string" && itemsType.includes("number")) {
            const isIntegerArray = typeof itemsType === "string" && itemsType.includes("integer");
            const isEmbedding = !isIntegerArray && arrayLength !== null && arrayLength >= 256;
            if (isIntegerArray) {
              this.addHook("beforeMap", fullKey, "fromArrayOfNumbers");
              this.addHook("afterUnmap", fullKey, "toArrayOfNumbers");
            } else if (isEmbedding) {
              this.addHook("beforeMap", fullKey, "fromArrayOfEmbeddings");
              this.addHook("afterUnmap", fullKey, "toArrayOfEmbeddings");
            } else {
              this.addHook("beforeMap", fullKey, "fromArrayOfDecimals");
              this.addHook("afterUnmap", fullKey, "toArrayOfDecimals");
            }
          }
        }
      } else if (typeof value === "object" && value !== null && !Array.isArray(value) && !value.type) {
        this._generateHooksFromOriginalAttributes(value, fullKey);
      }
    }
  }
  generateAutoHooks() {
    this._generateHooksFromOriginalAttributes(this.attributes);
    const schema = flatten(cloneDeep_default(this.attributes), { safe: true });
    for (const [name, definition] of Object.entries(schema)) {
      if (name.includes("$$"))
        continue;
      if (this.options.hooks.beforeMap[name] || this.options.hooks.afterUnmap[name]) {
        continue;
      }
      const defStr = typeof definition === "string" ? definition : "";
      const defType = typeof definition === "object" && definition !== null ? definition.type : null;
      const isEmbeddingType = defStr.includes("embedding") || defType === "embedding";
      if (isEmbeddingType) {
        this.addHook("beforeMap", name, "fromArrayOfEmbeddings");
        this.addHook("afterUnmap", name, "toArrayOfEmbeddings");
        continue;
      }
      const isArray2 = defStr.includes("array") || defType === "array";
      if (isArray2) {
        let itemsType = null;
        if (typeof definition === "object" && definition !== null && definition.items) {
          itemsType = definition.items;
        } else if (defStr.includes("items:string")) {
          itemsType = "string";
        } else if (defStr.includes("items:number")) {
          itemsType = "number";
        }
        if (itemsType === "string" || typeof itemsType === "string" && itemsType.includes("string")) {
          this.addHook("beforeMap", name, "fromArray");
          this.addHook("afterUnmap", name, "toArray");
        } else if (itemsType === "number" || typeof itemsType === "string" && itemsType.includes("number")) {
          const isIntegerArray = defStr.includes("integer:true") || defStr.includes("|integer:") || defStr.includes("|integer") || typeof itemsType === "string" && itemsType.includes("integer");
          let arrayLength = null;
          if (typeof definition === "object" && definition !== null && typeof definition.length === "number") {
            arrayLength = definition.length;
          } else if (defStr.includes("length:")) {
            const match = defStr.match(/length:(\d+)/);
            if (match)
              arrayLength = parseInt(match[1], 10);
          }
          const isEmbedding = !isIntegerArray && arrayLength !== null && arrayLength >= 256;
          if (isIntegerArray) {
            this.addHook("beforeMap", name, "fromArrayOfNumbers");
            this.addHook("afterUnmap", name, "toArrayOfNumbers");
          } else if (isEmbedding) {
            this.addHook("beforeMap", name, "fromArrayOfEmbeddings");
            this.addHook("afterUnmap", name, "toArrayOfEmbeddings");
          } else {
            this.addHook("beforeMap", name, "fromArrayOfDecimals");
            this.addHook("afterUnmap", name, "toArrayOfDecimals");
          }
        }
        continue;
      }
      if (defStr.includes("secret") || defType === "secret") {
        if (this.options.autoEncrypt) {
          this.addHook("beforeMap", name, "encrypt");
        }
        if (this.options.autoDecrypt) {
          this.addHook("afterUnmap", name, "decrypt");
        }
        continue;
      }
      if (defStr.includes("password") || defType === "password") {
        continue;
      }
      if (defStr.includes("ip4") || defType === "ip4") {
        this.addHook("beforeMap", name, "encodeIPv4");
        this.addHook("afterUnmap", name, "decodeIPv4");
        continue;
      }
      if (defStr.includes("ip6") || defType === "ip6") {
        this.addHook("beforeMap", name, "encodeIPv6");
        this.addHook("afterUnmap", name, "decodeIPv6");
        continue;
      }
      if (defStr.includes("buffer") || defType === "buffer") {
        this.addHook("beforeMap", name, "encodeBuffer");
        this.addHook("afterUnmap", name, "decodeBuffer");
        continue;
      }
      if (defStr.includes("bits") || defType === "bits") {
        let bitCount = null;
        const bitsMatch = defStr.match(/bits:(\d+)/);
        if (bitsMatch) {
          bitCount = parseInt(bitsMatch[1], 10);
        }
        this.addHook("beforeMap", name, "encodeBits", { bitCount });
        this.addHook("afterUnmap", name, "decodeBits", { bitCount });
        continue;
      }
      if (defStr.includes("money") || defType === "money" || defStr.includes("crypto") || defType === "crypto") {
        let decimals = 2;
        if (defStr.includes("crypto") || defType === "crypto") {
          decimals = 8;
        }
        const decimalsMatch = defStr.match(/(?:money|crypto):(\d+)/i);
        if (decimalsMatch) {
          decimals = parseInt(decimalsMatch[1], 10);
        }
        this.addHook("beforeMap", name, "encodeMoney", { decimals });
        this.addHook("afterUnmap", name, "decodeMoney", { decimals });
        continue;
      }
      if (defStr.includes("decimal") || defType === "decimal") {
        let precision = 2;
        const precisionMatch = defStr.match(/decimal:(\d+)/);
        if (precisionMatch) {
          precision = parseInt(precisionMatch[1], 10);
        }
        this.addHook("beforeMap", name, "encodeDecimalFixed", { precision });
        this.addHook("afterUnmap", name, "decodeDecimalFixed", { precision });
        continue;
      }
      if (defStr.includes("geo:lat") || defType === "geo" && defStr.includes("lat")) {
        let precision = 6;
        const precisionMatch = defStr.match(/geo:lat:(\d+)/);
        if (precisionMatch) {
          precision = parseInt(precisionMatch[1], 10);
        }
        this.addHook("beforeMap", name, "encodeGeoLatitude", { precision });
        this.addHook("afterUnmap", name, "decodeGeoLatitude", { precision });
        continue;
      }
      if (defStr.includes("geo:lon") || defType === "geo" && defStr.includes("lon")) {
        let precision = 6;
        const precisionMatch = defStr.match(/geo:lon:(\d+)/);
        if (precisionMatch) {
          precision = parseInt(precisionMatch[1], 10);
        }
        this.addHook("beforeMap", name, "encodeGeoLongitude", { precision });
        this.addHook("afterUnmap", name, "decodeGeoLongitude", { precision });
        continue;
      }
      if (defStr.includes("geo:point") || defType === "geo:point") {
        let precision = 6;
        const precisionMatch = defStr.match(/geo:point:(\d+)/);
        if (precisionMatch) {
          precision = parseInt(precisionMatch[1], 10);
        }
        this.addHook("beforeMap", name, "encodeGeoPointPair", { precision });
        this.addHook("afterUnmap", name, "decodeGeoPointPair", { precision });
        continue;
      }
      if (defStr.includes("number") || defType === "number") {
        const isInteger = defStr.includes("integer:true") || defStr.includes("|integer:") || defStr.includes("|integer");
        if (isInteger) {
          this.addHook("beforeMap", name, "toBase62");
          this.addHook("afterUnmap", name, "fromBase62");
        } else {
          this.addHook("beforeMap", name, "toBase62Decimal");
          this.addHook("afterUnmap", name, "fromBase62Decimal");
        }
        continue;
      }
      if (defStr.includes("boolean") || defType === "boolean") {
        this.addHook("beforeMap", name, "fromBool");
        this.addHook("afterUnmap", name, "toBool");
        continue;
      }
      if (defStr.includes("json") || defType === "json") {
        this.addHook("beforeMap", name, "toJSON");
        this.addHook("afterUnmap", name, "fromJSON");
        continue;
      }
      if (definition === "object" || defStr.includes("object") || defType === "object") {
        this.addHook("beforeMap", name, "toJSON");
        this.addHook("afterUnmap", name, "fromJSON");
        continue;
      }
    }
  }
  static import(data2) {
    let { map: map2, pluginMap, _pluginAttributeMetadata, name, options, version, attributes } = isString_default(data2) ? JSON.parse(data2) : data2;
    const [ok, err, attrs] = tryFnSync(() => _Schema._importAttributes(attributes));
    if (!ok)
      throw new SchemaError("Failed to import schema attributes", { original: err, input: attributes });
    attributes = attrs;
    const schema = new _Schema({
      map: map2,
      pluginMap: pluginMap || {},
      name,
      options,
      version,
      attributes
    });
    if (_pluginAttributeMetadata) {
      schema._pluginAttributeMetadata = _pluginAttributeMetadata;
    }
    return schema;
  }
  static _importAttributes(attrs) {
    if (typeof attrs === "string") {
      const [ok, , parsed] = tryFnSync(() => JSON.parse(attrs));
      if (ok && typeof parsed === "object" && parsed !== null) {
        const [okNested, errNested, nested] = tryFnSync(() => _Schema._importAttributes(parsed));
        if (!okNested)
          throw new SchemaError("Failed to parse nested schema attribute", { original: errNested, input: attrs });
        return nested;
      }
      return attrs;
    }
    if (Array.isArray(attrs)) {
      const [okArr, errArr, arr] = tryFnSync(() => attrs.map((a4) => _Schema._importAttributes(a4)));
      if (!okArr)
        throw new SchemaError("Failed to import array schema attributes", { original: errArr, input: attrs });
      return arr;
    }
    if (typeof attrs === "object" && attrs !== null) {
      const out = {};
      for (const [k4, v4] of Object.entries(attrs)) {
        const [okObj, errObj, val] = tryFnSync(() => _Schema._importAttributes(v4));
        if (!okObj)
          throw new SchemaError("Failed to import object schema attribute", { original: errObj, key: k4, input: v4 });
        out[k4] = val;
      }
      return out;
    }
    return attrs;
  }
  export() {
    const data2 = {
      version: this.version,
      name: this.name,
      options: this.options,
      attributes: this._exportAttributes(this.attributes),
      map: this.map,
      pluginMap: this.pluginMap || {},
      _pluginAttributeMetadata: this._pluginAttributeMetadata || {},
      _pluginAttributes: this._pluginAttributes || {}
    };
    return data2;
  }
  _exportAttributes(attrs) {
    if (typeof attrs === "string") {
      return attrs;
    }
    if (Array.isArray(attrs)) {
      return attrs.map((a4) => this._exportAttributes(a4));
    }
    if (typeof attrs === "object" && attrs !== null) {
      const out = {};
      for (const [k4, v4] of Object.entries(attrs)) {
        out[k4] = this._exportAttributes(v4);
      }
      return out;
    }
    return attrs;
  }
  async applyHooksActions(resourceItem, hook) {
    const cloned = cloneDeep_default(resourceItem);
    for (const [attribute, actions] of Object.entries(this.options.hooks[hook])) {
      for (const actionEntry of actions) {
        const actionName = typeof actionEntry === "string" ? actionEntry : actionEntry.action;
        const actionParams = typeof actionEntry === "object" ? actionEntry.params : {};
        const value = get_default(cloned, attribute);
        const actionFn = SchemaActions[actionName];
        if (value !== void 0 && typeof actionFn === "function") {
          set_default(cloned, attribute, await actionFn(value, {
            passphrase: this.passphrase,
            bcryptRounds: this.bcryptRounds,
            separator: this.options.arraySeparator,
            ...actionParams
          }));
        }
      }
    }
    return cloned;
  }
  async validate(resourceItem, { mutateOriginal = false } = {}) {
    if (process.env.NODE_ENV === "development") {
      console.warn("[DEPRECATION] Schema.validate() is deprecated. Use ResourceValidator.validate() instead.");
    }
    const data2 = mutateOriginal ? resourceItem : cloneDeep_default(resourceItem);
    const result = await this.validator(data2);
    return result;
  }
  async mapper(resourceItem) {
    let obj = cloneDeep_default(resourceItem);
    obj = await this.applyHooksActions(obj, "beforeMap");
    const flattenedObj = flatten(obj, { safe: true });
    const rest = { "_v": this.version + "" };
    for (const [key, value] of Object.entries(flattenedObj)) {
      const mappedKey = this.pluginMap[key] || this.map[key] || key;
      const attrDef = this.getAttributeDefinition(key);
      if (typeof value === "number" && typeof attrDef === "string" && attrDef.includes("number")) {
        rest[mappedKey] = encode2(value);
      } else if (typeof value === "string") {
        if (value === "[object Object]") {
          rest[mappedKey] = "{}";
        } else if (value.startsWith("{") || value.startsWith("[")) {
          rest[mappedKey] = value;
        } else {
          rest[mappedKey] = value;
        }
      } else if (Array.isArray(value) || typeof value === "object" && value !== null) {
        rest[mappedKey] = JSON.stringify(value);
      } else {
        rest[mappedKey] = value;
      }
    }
    await this.applyHooksActions(rest, "afterMap");
    return rest;
  }
  async unmapper(mappedResourceItem, mapOverride, pluginMapOverride) {
    let obj = cloneDeep_default(mappedResourceItem);
    delete obj._v;
    obj = await this.applyHooksActions(obj, "beforeUnmap");
    const reversedMap = mapOverride ? invert_default(mapOverride) : this.reversedMap;
    const reversedPluginMap = pluginMapOverride ? invert_default(pluginMapOverride) : this.reversedPluginMap;
    const rest = {};
    for (const [key, value] of Object.entries(obj)) {
      let originalKey = reversedPluginMap[key] || reversedMap[key] || key;
      if (!originalKey) {
        originalKey = key;
      }
      let parsedValue = value;
      const attrDef = this.getAttributeDefinition(originalKey);
      const hasAfterUnmapHook = this.options.hooks?.afterUnmap?.[originalKey];
      if (!hasAfterUnmapHook && typeof attrDef === "string" && attrDef.includes("number") && !attrDef.includes("array") && !attrDef.includes("decimal")) {
        if (typeof parsedValue === "string" && parsedValue !== "") {
          parsedValue = decode2(parsedValue);
        } else if (typeof parsedValue === "number") ;
        else {
          parsedValue = void 0;
        }
      } else if (typeof value === "string") {
        if (value === "[object Object]") {
          parsedValue = {};
        } else if (value.startsWith("{") || value.startsWith("[")) {
          const [ok, , parsed] = tryFnSync(() => JSON.parse(value));
          if (ok)
            parsedValue = parsed;
        }
      }
      if (this.attributes) {
        if (typeof attrDef === "string" && attrDef.includes("array")) {
          if (!hasAfterUnmapHook) {
            if (Array.isArray(parsedValue)) ;
            else if (typeof parsedValue === "string" && parsedValue.trim().startsWith("[")) {
              const [okArr, , arr] = tryFnSync(() => JSON.parse(parsedValue));
              if (okArr && Array.isArray(arr)) {
                parsedValue = arr;
              }
            } else {
              parsedValue = SchemaActions.toArray(parsedValue, { separator: this.options.arraySeparator });
            }
          }
        }
      }
      const afterUnmapHooks = this.options.hooks?.afterUnmap?.[originalKey];
      if (afterUnmapHooks) {
        for (const actionEntry of afterUnmapHooks) {
          const actionName = typeof actionEntry === "string" ? actionEntry : actionEntry.action;
          const actionParams = typeof actionEntry === "object" ? actionEntry.params : {};
          const actionFn = SchemaActions[actionName];
          if (typeof actionFn === "function") {
            parsedValue = await actionFn(parsedValue, {
              passphrase: this.passphrase,
              bcryptRounds: this.bcryptRounds,
              separator: this.options.arraySeparator,
              ...actionParams
            });
          }
        }
      }
      rest[originalKey] = parsedValue;
    }
    await this.applyHooksActions(rest, "afterUnmap");
    const result = unflatten(rest);
    for (const [key, value] of Object.entries(mappedResourceItem)) {
      if (key.startsWith("$")) {
        result[key] = value;
      }
    }
    return result;
  }
  getAttributeDefinition(key) {
    const parts = key.split(".");
    let def = this.attributes;
    for (const part of parts) {
      if (!def)
        return void 0;
      def = def[part];
    }
    return def;
  }
  regeneratePluginMapping() {
    const flatAttrs = flatten(this.attributes, { safe: true });
    const leafKeys = Object.keys(flatAttrs).filter((k4) => !k4.includes("$$"));
    const objectKeys = this.extractObjectKeys(this.attributes);
    const allKeys = [.../* @__PURE__ */ new Set([...leafKeys, ...objectKeys])];
    const pluginAttributes = [];
    for (const key of allKeys) {
      const attrDef = this.getAttributeDefinition(key);
      if (typeof attrDef === "object" && attrDef !== null && attrDef.__plugin__) {
        pluginAttributes.push({ key, pluginName: attrDef.__plugin__ });
      } else if (typeof attrDef === "string" && this._pluginAttributeMetadata && this._pluginAttributeMetadata[key]) {
        const pluginName = this._pluginAttributeMetadata[key].__plugin__;
        pluginAttributes.push({ key, pluginName });
      }
    }
    const { mapping, reversedMapping } = generatePluginMapping(pluginAttributes);
    this.pluginMap = mapping;
    this.reversedPluginMap = reversedMapping;
    this._pluginAttributes = {};
    for (const { key, pluginName } of pluginAttributes) {
      if (!this._pluginAttributes[pluginName]) {
        this._pluginAttributes[pluginName] = [];
      }
      this._pluginAttributes[pluginName].push(key);
    }
  }
  preprocessAttributesForValidation(attributes) {
    const processed = {};
    for (const [key, value] of Object.entries(attributes)) {
      if (typeof value === "string") {
        if (value === "ip4" || value.startsWith("ip4|")) {
          processed[key] = value.replace(/^ip4/, "string");
          continue;
        }
        if (value === "ip6" || value.startsWith("ip6|")) {
          processed[key] = value.replace(/^ip6/, "string");
          continue;
        }
        if (value === "buffer" || value.startsWith("buffer|")) {
          processed[key] = "any";
          continue;
        }
        if (value === "bits" || value.startsWith("bits:") || value.startsWith("bits|")) {
          processed[key] = "any";
          continue;
        }
        if (value === "money" || value.startsWith("money:") || value.startsWith("money|") || value === "crypto" || value.startsWith("crypto:") || value.startsWith("crypto|")) {
          const rest = value.replace(/^(?:money|crypto)(?::\d+)?/, "");
          const hasMin = rest.includes("min:");
          processed[key] = hasMin ? `number${rest}` : `number|min:0${rest}`;
          continue;
        }
        if (value === "decimal" || value.startsWith("decimal:") || value.startsWith("decimal|")) {
          const rest = value.replace(/^decimal(:\d+)?/, "");
          processed[key] = `number${rest}`;
          continue;
        }
        if (value.startsWith("geo:lat")) {
          const rest = value.replace(/^geo:lat(:\d+)?/, "");
          const hasMin = rest.includes("min:");
          const hasMax = rest.includes("max:");
          let validation = "number";
          if (!hasMin)
            validation += "|min:-90";
          if (!hasMax)
            validation += "|max:90";
          processed[key] = validation + rest;
          continue;
        }
        if (value.startsWith("geo:lon")) {
          const rest = value.replace(/^geo:lon(:\d+)?/, "");
          const hasMin = rest.includes("min:");
          const hasMax = rest.includes("max:");
          let validation = "number";
          if (!hasMin)
            validation += "|min:-180";
          if (!hasMax)
            validation += "|max:180";
          processed[key] = validation + rest;
          continue;
        }
        if (value.startsWith("geo:point")) {
          processed[key] = "any";
          continue;
        }
        if (value.startsWith("embedding:")) {
          const lengthMatch = value.match(/embedding:(\d+)/);
          if (lengthMatch) {
            const length = lengthMatch[1];
            const rest = value.substring(`embedding:${length}`.length);
            processed[key] = `array|items:number|length:${length}|empty:false${rest}`;
            continue;
          }
        }
        if (value.startsWith("embedding|") || value === "embedding") {
          processed[key] = value.replace(/^embedding/, "array|items:number|empty:false");
          continue;
        }
        if (value.includes("|")) {
          const parts = value.split("|");
          const baseType = parts[0];
          const config = { type: baseType };
          for (let i4 = 1; i4 < parts.length; i4++) {
            const part = parts[i4];
            if (part === "optional") {
              config.optional = true;
            } else if (part === "required") ;
            else if (part.includes(":")) {
              const [modifier, val] = part.split(":");
              if (val === "true") {
                config[modifier] = true;
              } else if (val === "false") {
                config[modifier] = false;
              } else {
                const numVal = Number(val);
                config[modifier] = Number.isNaN(numVal) ? val : numVal;
              }
            } else {
              config[part] = true;
            }
          }
          processed[key] = config;
          continue;
        }
        processed[key] = value;
      } else if (typeof value === "object" && value !== null && !Array.isArray(value)) {
        const validatorTypes = ["string", "number", "boolean", "any", "object", "array", "date", "email", "url", "uuid", "enum", "custom", "ip4", "ip6", "buffer", "bits", "money", "crypto", "decimal", "geo:lat", "geo:lon", "geo:point", "geo-lat", "geo-lon", "geo-point", "secret", "password", "embedding"];
        const typeValue = value.type;
        const isValidValidatorType = typeof typeValue === "string" && !typeValue.includes("|") && (validatorTypes.includes(typeValue) || typeValue.startsWith("bits:") || typeValue.startsWith("embedding:"));
        const hasValidatorType = isValidValidatorType && key !== "$$type";
        if (hasValidatorType) {
          const { __plugin__, __pluginCreated__, ...cleanValue } = value;
          if (cleanValue.type === "ip4") {
            processed[key] = { ...cleanValue, type: "string" };
          } else if (cleanValue.type === "ip6") {
            processed[key] = { ...cleanValue, type: "string" };
          } else if (cleanValue.type === "buffer") {
            processed[key] = { ...cleanValue, type: "any" };
          } else if (cleanValue.type === "bits" || cleanValue.type?.startsWith("bits:")) {
            processed[key] = { ...cleanValue, type: "any" };
          } else if (cleanValue.type === "money" || cleanValue.type === "crypto") {
            processed[key] = { ...cleanValue, type: "number", min: cleanValue.min !== void 0 ? cleanValue.min : 0 };
          } else if (cleanValue.type === "decimal") {
            processed[key] = { ...cleanValue, type: "number" };
          } else if (cleanValue.type === "geo:lat" || cleanValue.type === "geo-lat") {
            processed[key] = {
              ...cleanValue,
              type: "number",
              min: cleanValue.min !== void 0 ? cleanValue.min : -90,
              max: cleanValue.max !== void 0 ? cleanValue.max : 90
            };
          } else if (cleanValue.type === "geo:lon" || cleanValue.type === "geo-lon") {
            processed[key] = {
              ...cleanValue,
              type: "number",
              min: cleanValue.min !== void 0 ? cleanValue.min : -180,
              max: cleanValue.max !== void 0 ? cleanValue.max : 180
            };
          } else if (cleanValue.type === "geo:point" || cleanValue.type === "geo-point") {
            processed[key] = { ...cleanValue, type: "any" };
          } else if (cleanValue.type === "object" && cleanValue.properties) {
            processed[key] = {
              ...cleanValue,
              properties: this.preprocessAttributesForValidation(cleanValue.properties)
            };
          } else if (cleanValue.type === "object" && cleanValue.props) {
            processed[key] = {
              ...cleanValue,
              props: this.preprocessAttributesForValidation(cleanValue.props)
            };
          } else {
            processed[key] = cleanValue;
          }
        } else {
          const isExplicitRequired = value.$$type && value.$$type.includes("required");
          const isExplicitOptional = value.$$type && value.$$type.includes("optional");
          const objectConfig = {
            type: "object",
            props: this.preprocessAttributesForValidation(value),
            strict: false
          };
          if (isExplicitRequired) ;
          else if (isExplicitOptional || this.allNestedObjectsOptional) {
            objectConfig.optional = true;
          }
          processed[key] = objectConfig;
        }
      } else {
        processed[key] = value;
      }
    }
    return processed;
  }
  dispose() {
    if (this._schemaFingerprint) {
      releaseValidator(this._schemaFingerprint);
    }
  }
  static getValidatorCacheStats() {
    return getCacheStats();
  }
  static getValidatorCacheMemoryUsage() {
    return getCacheMemoryUsage();
  }
  static evictUnusedValidators(maxAgeMs) {
    return evictUnusedValidators(maxAgeMs);
  }
};
var ResourceValidator = class {
  attributes;
  strictValidation;
  allNestedObjectsOptional;
  passphrase;
  bcryptRounds;
  autoEncrypt;
  autoDecrypt;
  validatorManager;
  validateFn;
  constructor(config = {}) {
    this.attributes = config.attributes || {};
    this.strictValidation = config.strictValidation !== false;
    this.allNestedObjectsOptional = config.allNestedObjectsOptional || false;
    this.passphrase = config.passphrase;
    this.bcryptRounds = config.bcryptRounds;
    this.autoEncrypt = config.autoEncrypt !== false;
    this.autoDecrypt = config.autoDecrypt !== false;
    this.validatorManager = new ValidatorManager({
      autoEncrypt: this.autoEncrypt,
      passphrase: this.passphrase,
      bcryptRounds: this.bcryptRounds
    });
    this.compileValidator();
  }
  compileValidator() {
    const processedAttributes = this.preprocessAttributesForValidation(this.attributes);
    this.validateFn = this.validatorManager.compile(merge_default({ $$async: true, $$strict: false }, processedAttributes));
  }
  updateSchema(newAttributes) {
    this.attributes = newAttributes;
    this.compileValidator();
  }
  async validate(data2, options = {}) {
    const { throwOnError = false, includeId = false, mutateOriginal = false } = options;
    const dataToValidate = mutateOriginal ? data2 : cloneDeep_default(data2);
    if (!includeId && dataToValidate.id) {
      delete dataToValidate.id;
    }
    const result = {
      isValid: false,
      errors: [],
      data: dataToValidate
    };
    try {
      const check = await this.validateFn(dataToValidate);
      if (check === true) {
        result.isValid = true;
      } else {
        result.errors = Array.isArray(check) ? check : [check];
        result.isValid = false;
        if (throwOnError) {
          const error2 = new Error("Validation failed");
          error2.validationErrors = result.errors;
          error2.invalidData = data2;
          throw error2;
        }
      }
    } catch (err) {
      if (!throwOnError) {
        result.errors = [{ message: err.message, error: err }];
        result.isValid = false;
      } else {
        throw err;
      }
    }
    return result;
  }
  preprocessAttributesForValidation(attributes) {
    const processed = {};
    for (const [key, value] of Object.entries(attributes)) {
      if (typeof value === "string") {
        if (value === "ip4" || value.startsWith("ip4|")) {
          processed[key] = value.replace(/^ip4/, "string");
          continue;
        }
        if (value === "ip6" || value.startsWith("ip6|")) {
          processed[key] = value.replace(/^ip6/, "string");
          continue;
        }
        if (value === "buffer" || value.startsWith("buffer|")) {
          processed[key] = "any";
          continue;
        }
        if (value === "bits" || value.startsWith("bits:") || value.startsWith("bits|")) {
          processed[key] = "any";
          continue;
        }
        if (value === "money" || value.startsWith("money:") || value.startsWith("money|") || value === "crypto" || value.startsWith("crypto:") || value.startsWith("crypto|")) {
          const rest = value.replace(/^(?:money|crypto)(?::\d+)?/, "");
          const hasMin = rest.includes("min:");
          processed[key] = hasMin ? `number${rest}` : `number|min:0${rest}`;
          continue;
        }
        if (value === "decimal" || value.startsWith("decimal:") || value.startsWith("decimal|")) {
          const rest = value.replace(/^decimal(:\d+)?/, "");
          processed[key] = `number${rest}`;
          continue;
        }
        if (value.startsWith("geo:lat")) {
          const rest = value.replace(/^geo:lat(:\d+)?/, "");
          const hasMin = rest.includes("min:");
          const hasMax = rest.includes("max:");
          let validation = "number";
          if (!hasMin)
            validation += "|min:-90";
          if (!hasMax)
            validation += "|max:90";
          processed[key] = validation + rest;
          continue;
        }
        if (value.startsWith("geo:lon")) {
          const rest = value.replace(/^geo:lon(:\d+)?/, "");
          const hasMin = rest.includes("min:");
          const hasMax = rest.includes("max:");
          let validation = "number";
          if (!hasMin)
            validation += "|min:-180";
          if (!hasMax)
            validation += "|max:180";
          processed[key] = validation + rest;
          continue;
        }
        if (value.startsWith("geo:point")) {
          processed[key] = "any";
          continue;
        }
        if (value.startsWith("embedding:")) {
          const lengthMatch = value.match(/embedding:(\d+)/);
          if (lengthMatch) {
            const length = lengthMatch[1];
            const rest = value.substring(`embedding:${length}`.length);
            processed[key] = `array|items:number|length:${length}|empty:false${rest}`;
            continue;
          }
        }
        if (value.startsWith("embedding|") || value === "embedding") {
          processed[key] = value.replace(/^embedding/, "array|items:number|empty:false");
          continue;
        }
        if (value.includes("|")) {
          const parts = value.split("|");
          const baseType = parts[0];
          const config = { type: baseType };
          for (let i4 = 1; i4 < parts.length; i4++) {
            const part = parts[i4];
            if (part === "optional") {
              config.optional = true;
            } else if (part === "required") ;
            else if (part.includes(":")) {
              const [modifier, val] = part.split(":");
              if (val === "true") {
                config[modifier] = true;
              } else if (val === "false") {
                config[modifier] = false;
              } else {
                const numVal = Number(val);
                config[modifier] = Number.isNaN(numVal) ? val : numVal;
              }
            } else {
              config[part] = true;
            }
          }
          processed[key] = config;
          continue;
        }
        processed[key] = value;
      } else if (typeof value === "object" && value !== null && !Array.isArray(value)) {
        const validatorTypes = [
          "string",
          "number",
          "boolean",
          "any",
          "object",
          "array",
          "date",
          "email",
          "url",
          "uuid",
          "enum",
          "custom",
          "ip4",
          "ip6",
          "buffer",
          "bits",
          "money",
          "crypto",
          "decimal",
          "geo:lat",
          "geo:lon",
          "geo:point",
          "geo-lat",
          "geo-lon",
          "geo-point",
          "secret",
          "password",
          "embedding"
        ];
        const objValue = value;
        const typeValue = objValue.type;
        const isValidValidatorType = typeof typeValue === "string" && !typeValue.includes("|") && (validatorTypes.includes(typeValue) || typeValue.startsWith("bits:") || typeValue.startsWith("embedding:"));
        const hasValidatorType = isValidValidatorType && key !== "$$type";
        if (hasValidatorType) {
          const { __plugin__, __pluginCreated__, ...cleanValue } = objValue;
          if (cleanValue.type === "ip4") {
            processed[key] = { ...cleanValue, type: "string" };
          } else if (cleanValue.type === "ip6") {
            processed[key] = { ...cleanValue, type: "string" };
          } else if (cleanValue.type === "buffer") {
            processed[key] = { ...cleanValue, type: "any" };
          } else if (cleanValue.type === "bits" || cleanValue.type?.startsWith("bits:")) {
            processed[key] = { ...cleanValue, type: "any" };
          } else if (cleanValue.type === "money" || cleanValue.type === "crypto") {
            processed[key] = { ...cleanValue, type: "number", min: cleanValue.min !== void 0 ? cleanValue.min : 0 };
          } else if (cleanValue.type === "decimal") {
            processed[key] = { ...cleanValue, type: "number" };
          } else if (cleanValue.type === "geo:lat" || cleanValue.type === "geo-lat") {
            processed[key] = {
              ...cleanValue,
              type: "number",
              min: cleanValue.min !== void 0 ? cleanValue.min : -90,
              max: cleanValue.max !== void 0 ? cleanValue.max : 90
            };
          } else if (cleanValue.type === "geo:lon" || cleanValue.type === "geo-lon") {
            processed[key] = {
              ...cleanValue,
              type: "number",
              min: cleanValue.min !== void 0 ? cleanValue.min : -180,
              max: cleanValue.max !== void 0 ? cleanValue.max : 180
            };
          } else if (cleanValue.type === "geo:point" || cleanValue.type === "geo-point") {
            processed[key] = { ...cleanValue, type: "any" };
          } else if (cleanValue.type === "object" && cleanValue.properties) {
            processed[key] = {
              ...cleanValue,
              properties: this.preprocessAttributesForValidation(cleanValue.properties)
            };
          } else if (cleanValue.type === "object" && cleanValue.props) {
            processed[key] = {
              ...cleanValue,
              props: this.preprocessAttributesForValidation(cleanValue.props)
            };
          } else {
            processed[key] = cleanValue;
          }
        } else {
          const nestedObj = value;
          const isExplicitRequired = nestedObj.$$type && nestedObj.$$type.includes("required");
          const isExplicitOptional = nestedObj.$$type && nestedObj.$$type.includes("optional");
          const objectConfig = {
            type: "object",
            props: this.preprocessAttributesForValidation(nestedObj),
            strict: false
          };
          if (isExplicitRequired) ;
          else if (isExplicitOptional || this.allNestedObjectsOptional) {
            objectConfig.optional = true;
          }
          processed[key] = objectConfig;
        }
      } else {
        processed[key] = value;
      }
    }
    return processed;
  }
  applyDefaults(data2) {
    const out = { ...data2 };
    for (const [key, def] of Object.entries(this.attributes)) {
      if (out[key] === void 0) {
        if (typeof def === "string" && def.includes("default:")) {
          const match = def.match(/default:([^|]+)/);
          if (match) {
            let val = match[1];
            if (def.includes("boolean"))
              val = val === "true";
            else if (def.includes("number"))
              val = Number(val);
            out[key] = val;
          }
        }
      }
    }
    return out;
  }
};
var INCREMENTAL_DEFAULTS = {
  type: "incremental",
  start: 1,
  increment: 1,
  mode: "standard",
  batchSize: 100,
  prefix: "",
  padding: 0
};
var VALIDATION_LIMITS = {
  maxPrefix: 20,
  maxPadding: 20,
  minBatchSize: 1,
  maxBatchSize: 1e5,
  maxStartValue: Number.MAX_SAFE_INTEGER,
  minStartValue: Number.MIN_SAFE_INTEGER
};
var IncrementalConfigError = class extends Error {
  field;
  value;
  constructor(message, field, value) {
    super(message);
    this.name = "IncrementalConfigError";
    this.field = field;
    this.value = value;
  }
};
function validateIncrementalConfig(config, options = {}) {
  const { throwOnError = true } = options;
  const errors2 = [];
  if (config.start !== void 0) {
    if (typeof config.start !== "number" || !Number.isFinite(config.start)) {
      errors2.push({
        field: "start",
        message: "start must be a finite number",
        value: config.start
      });
    } else if (!Number.isInteger(config.start)) {
      errors2.push({
        field: "start",
        message: "start must be an integer",
        value: config.start
      });
    } else if (config.start > VALIDATION_LIMITS.maxStartValue || config.start < VALIDATION_LIMITS.minStartValue) {
      errors2.push({
        field: "start",
        message: `start must be between ${VALIDATION_LIMITS.minStartValue} and ${VALIDATION_LIMITS.maxStartValue}`,
        value: config.start
      });
    }
  }
  if (config.increment !== void 0) {
    if (typeof config.increment !== "number" || !Number.isFinite(config.increment)) {
      errors2.push({
        field: "increment",
        message: "increment must be a finite number",
        value: config.increment
      });
    } else if (!Number.isInteger(config.increment)) {
      errors2.push({
        field: "increment",
        message: "increment must be an integer",
        value: config.increment
      });
    } else if (config.increment === 0) {
      errors2.push({
        field: "increment",
        message: "increment cannot be zero",
        value: config.increment
      });
    }
  }
  if (config.mode !== void 0) {
    const validModes = ["standard", "fast"];
    if (!validModes.includes(config.mode)) {
      errors2.push({
        field: "mode",
        message: `mode must be one of: ${validModes.join(", ")}`,
        value: config.mode
      });
    }
  }
  if (config.batchSize !== void 0) {
    if (typeof config.batchSize !== "number" || !Number.isFinite(config.batchSize)) {
      errors2.push({
        field: "batchSize",
        message: "batchSize must be a finite number",
        value: config.batchSize
      });
    } else if (!Number.isInteger(config.batchSize)) {
      errors2.push({
        field: "batchSize",
        message: "batchSize must be an integer",
        value: config.batchSize
      });
    } else if (config.batchSize < VALIDATION_LIMITS.minBatchSize || config.batchSize > VALIDATION_LIMITS.maxBatchSize) {
      errors2.push({
        field: "batchSize",
        message: `batchSize must be between ${VALIDATION_LIMITS.minBatchSize} and ${VALIDATION_LIMITS.maxBatchSize}`,
        value: config.batchSize
      });
    }
  }
  if (config.prefix !== void 0) {
    if (typeof config.prefix !== "string") {
      errors2.push({
        field: "prefix",
        message: "prefix must be a string",
        value: config.prefix
      });
    } else if (config.prefix.length > VALIDATION_LIMITS.maxPrefix) {
      errors2.push({
        field: "prefix",
        message: `prefix must be at most ${VALIDATION_LIMITS.maxPrefix} characters`,
        value: config.prefix
      });
    } else if (config.prefix && !/^[A-Za-z0-9_-]+$/.test(config.prefix)) {
      errors2.push({
        field: "prefix",
        message: "prefix must contain only alphanumeric characters, hyphens, and underscores",
        value: config.prefix
      });
    }
  }
  if (config.padding !== void 0) {
    if (typeof config.padding !== "number" || !Number.isFinite(config.padding)) {
      errors2.push({
        field: "padding",
        message: "padding must be a finite number",
        value: config.padding
      });
    } else if (!Number.isInteger(config.padding)) {
      errors2.push({
        field: "padding",
        message: "padding must be an integer",
        value: config.padding
      });
    } else if (config.padding < 0 || config.padding > VALIDATION_LIMITS.maxPadding) {
      errors2.push({
        field: "padding",
        message: `padding must be between 0 and ${VALIDATION_LIMITS.maxPadding}`,
        value: config.padding
      });
    }
  }
  const result = {
    valid: errors2.length === 0,
    errors: errors2
  };
  if (throwOnError && !result.valid && errors2.length > 0) {
    const firstError = errors2[0];
    throw new IncrementalConfigError(`Invalid incremental config: ${firstError.message}`, firstError.field, firstError.value);
  }
  return result;
}
function parseIncrementalSuffix(suffix, defaults) {
  const result = { ...defaults };
  if (suffix === "fast") {
    result.mode = "fast";
    return result;
  }
  if (suffix.startsWith("fast:")) {
    result.mode = "fast";
    suffix = suffix.slice("fast:".length);
  }
  const numValue = parseInt(suffix, 10);
  if (!isNaN(numValue) && String(numValue) === suffix) {
    result.start = numValue;
    return result;
  }
  const prefixMatch = suffix.match(/^([A-Za-z]+-?)(\d+)$/);
  if (prefixMatch && prefixMatch[1] && prefixMatch[2]) {
    const prefix = prefixMatch[1];
    const numPart = prefixMatch[2];
    result.prefix = prefix;
    result.start = parseInt(numPart, 10);
    result.padding = numPart.length;
    return result;
  }
  return result;
}
function parseIncrementalConfig(config, options = {}) {
  const { validate = false } = options;
  let parsed;
  if (typeof config === "object" && config !== null) {
    parsed = {
      ...INCREMENTAL_DEFAULTS,
      ...config,
      type: "incremental"
    };
  } else if (typeof config === "string") {
    if (config === "incremental") {
      parsed = { ...INCREMENTAL_DEFAULTS };
    } else if (config.startsWith("incremental:")) {
      const rest = config.slice("incremental:".length);
      parsed = parseIncrementalSuffix(rest, INCREMENTAL_DEFAULTS);
    } else {
      parsed = { ...INCREMENTAL_DEFAULTS };
    }
  } else {
    parsed = { ...INCREMENTAL_DEFAULTS };
  }
  if (validate) {
    validateIncrementalConfig(parsed);
  }
  return parsed;
}
function formatIncrementalValue(value, options = {}) {
  const { prefix = "", padding = 0 } = options;
  const numStr = padding > 0 ? String(value).padStart(padding, "0") : String(value);
  return prefix ? `${prefix}${numStr}` : numStr;
}
var SequenceStorage = class {
  client;
  resourceName;
  _lock;
  constructor(client2, resourceName) {
    this.client = client2;
    this.resourceName = resourceName;
    this._lock = new DistributedLock(this, {
      keyGenerator: (fieldName) => this.getLockKey(fieldName)
    });
  }
  getKey(fieldName, suffix) {
    return `resource=${this.resourceName}/sequence=${fieldName}/${suffix}`;
  }
  getLockKey(fieldName) {
    return this.getKey(fieldName, "lock");
  }
  getValueKey(fieldName) {
    return this.getKey(fieldName, "value");
  }
  async get(key) {
    const [ok, err, response2] = await tryFn$1(() => this.client.getObject(key));
    if (!ok || !response2) {
      const error2 = err;
      if (error2?.name === "NoSuchKey" || error2?.code === "NoSuchKey" || error2?.Code === "NoSuchKey" || error2?.statusCode === 404) {
        return null;
      }
      throw err;
    }
    if (response2.Body) {
      const bodyContent = await response2.Body.transformToString();
      if (bodyContent && bodyContent.trim()) {
        return JSON.parse(bodyContent);
      }
    }
    return null;
  }
  async set(key, data2, options = {}) {
    const { ttl, ifNoneMatch } = options;
    const dataToSave = { ...data2 };
    if (ttl && typeof ttl === "number" && ttl > 0) {
      dataToSave._expiresAt = Date.now() + ttl * 1e3;
    }
    const putParams = {
      key,
      body: JSON.stringify(dataToSave),
      contentType: "application/json"
    };
    if (ifNoneMatch !== void 0) {
      putParams.ifNoneMatch = ifNoneMatch;
    }
    const [ok, err, response2] = await tryFn$1(() => this.client.putObject(putParams));
    if (!ok || !response2)
      throw err ?? new Error("Put object returned no response");
    return response2;
  }
  async delete(key) {
    await tryFn$1(() => this.client.deleteObject(key));
  }
  async acquireLock(fieldName, options = {}) {
    return this._lock.acquire(fieldName, options);
  }
  async releaseLock(lock) {
    if (!lock)
      return;
    return this._lock.release(lock);
  }
  async withLock(fieldName, options, callback) {
    return this._lock.withLock(fieldName, options, callback);
  }
  async nextSequence(fieldName, options = {}) {
    const { initialValue = 1, increment = 1, lockTimeout = 5e3, lockTTL = 10 } = options;
    const valueKey = this.getValueKey(fieldName);
    const result = await this.withLock(fieldName, { timeout: lockTimeout, ttl: lockTTL }, async () => {
      const data2 = await this.get(valueKey);
      if (!data2) {
        await this.set(valueKey, {
          value: initialValue + increment,
          name: fieldName,
          createdAt: Date.now()
        });
        return initialValue;
      }
      const currentValue = data2.value;
      await this.set(valueKey, {
        ...data2,
        value: currentValue + increment,
        updatedAt: Date.now()
      });
      return currentValue;
    });
    if (result === null) {
      throw new Error(`Failed to acquire lock for sequence "${fieldName}"`);
    }
    return result;
  }
  async getSequence(fieldName) {
    const valueKey = this.getValueKey(fieldName);
    const data2 = await this.get(valueKey);
    return data2?.value ?? null;
  }
  async resetSequence(fieldName, value, options = {}) {
    const { lockTimeout = 5e3, lockTTL = 10 } = options;
    const valueKey = this.getValueKey(fieldName);
    const result = await this.withLock(fieldName, { timeout: lockTimeout, ttl: lockTTL }, async () => {
      const data2 = await this.get(valueKey);
      await this.set(valueKey, {
        value,
        name: fieldName,
        createdAt: data2?.createdAt || Date.now(),
        updatedAt: Date.now(),
        resetAt: Date.now()
      });
      return true;
    });
    if (result === null) {
      throw new Error(`Failed to acquire lock for sequence "${fieldName}"`);
    }
    return result;
  }
  async listSequences() {
    const prefix = `resource=${this.resourceName}/sequence=`;
    const [ok, err, result] = await tryFn$1(() => this.client.listObjects({ prefix }));
    if (!ok || !result)
      return [];
    const keys2 = (result.Contents ?? []).map((item) => item.Key);
    const valueKeys = keys2.filter((k4) => typeof k4 === "string" && k4.endsWith("/value"));
    const sequences = [];
    for (const key of valueKeys) {
      const data2 = await this.get(key);
      if (data2) {
        sequences.push(data2);
      }
    }
    return sequences;
  }
};
var IncrementalSequence = class {
  client;
  resourceName;
  config;
  logger;
  storage;
  localBatches;
  constructor(options) {
    this.client = options.client;
    this.resourceName = options.resourceName;
    this.config = options.config;
    this.logger = options.logger || console;
    this.storage = new SequenceStorage(options.client, options.resourceName);
    this.localBatches = /* @__PURE__ */ new Map();
  }
  async nextValue(fieldName = "id") {
    const { start, increment, prefix, padding } = this.config;
    const value = await this.storage.nextSequence(fieldName, {
      initialValue: start,
      increment
    });
    return formatIncrementalValue(value, { prefix, padding });
  }
  async nextValueFast(fieldName = "id") {
    const batchKey = fieldName;
    let batch = this.localBatches.get(batchKey);
    if (!batch || batch.current >= batch.end) {
      batch = await this.reserveBatch(fieldName);
      this.localBatches.set(batchKey, batch);
    }
    const value = batch.current++;
    const { prefix, padding } = this.config;
    return formatIncrementalValue(value, { prefix, padding });
  }
  async reserveBatch(fieldName = "id", count) {
    const batchSize = count || this.config.batchSize;
    const { start: initialValue } = this.config;
    const batchStart = await this.storage.nextSequence(fieldName, {
      initialValue,
      increment: batchSize
    });
    const batch = {
      start: batchStart,
      end: batchStart + batchSize,
      current: batchStart,
      reservedAt: Date.now()
    };
    return batch;
  }
  async next(fieldName = "id") {
    if (this.config.mode === "fast") {
      return this.nextValueFast(fieldName);
    }
    return this.nextValue(fieldName);
  }
  async getValue(fieldName = "id") {
    return this.storage.getSequence(fieldName);
  }
  async reset(fieldName, value) {
    this.localBatches.delete(fieldName);
    return this.storage.resetSequence(fieldName, value);
  }
  async list() {
    return this.storage.listSequences();
  }
  getBatchStatus(fieldName = "id") {
    const batch = this.localBatches.get(fieldName);
    if (!batch)
      return null;
    return {
      start: batch.start,
      end: batch.end,
      current: batch.current,
      remaining: batch.end - batch.current,
      reservedAt: batch.reservedAt
    };
  }
  releaseBatch(fieldName = "id") {
    const batch = this.localBatches.get(fieldName);
    if (batch) {
      const unused = batch.end - batch.current;
      this.logger.debug?.({ fieldName, unused }, "Releasing batch with unused IDs");
      this.localBatches.delete(fieldName);
    }
  }
};
function createIncrementalIdGenerator(options) {
  const parsedConfig = parseIncrementalConfig(options.config);
  const sequence = new IncrementalSequence({
    client: options.client,
    resourceName: options.resourceName,
    config: parsedConfig,
    logger: options.logger
  });
  const generator = async () => {
    return sequence.next("id");
  };
  generator._sequence = sequence;
  generator._config = parsedConfig;
  return generator;
}
var ResourceIdGenerator = class {
  resource;
  idSize;
  _incrementalConfig;
  _asyncIdGenerator;
  _generator;
  constructor(resource, config = {}) {
    this.resource = resource;
    const customIdGenerator = config.idGenerator;
    if (typeof customIdGenerator === "number" && customIdGenerator > 0) {
      this.idSize = customIdGenerator;
    } else if (typeof config.idSize === "number" && config.idSize > 0) {
      this.idSize = config.idSize;
    } else {
      this.idSize = 22;
    }
    this._incrementalConfig = null;
    this._asyncIdGenerator = false;
    this._generator = null;
    this._generator = this._configureGenerator(customIdGenerator, this.idSize);
  }
  _configureGenerator(customIdGenerator, idSize) {
    if (typeof customIdGenerator === "function") {
      return ((data2) => String(customIdGenerator(data2)));
    }
    const isIncrementalString = typeof customIdGenerator === "string" && (customIdGenerator === "incremental" || customIdGenerator.startsWith("incremental:"));
    const isIncrementalObject = typeof customIdGenerator === "object" && customIdGenerator !== null && customIdGenerator.type === "incremental";
    if (isIncrementalString || isIncrementalObject) {
      this._incrementalConfig = customIdGenerator;
      return null;
    }
    if (typeof customIdGenerator === "number" && customIdGenerator > 0) {
      return createCustomGenerator(getUrlAlphabet(), customIdGenerator);
    }
    if (typeof idSize === "number" && idSize > 0 && idSize !== 22) {
      return createCustomGenerator(getUrlAlphabet(), idSize);
    }
    return idGenerator;
  }
  initIncremental() {
    if (!this._incrementalConfig || this._generator !== null) {
      return;
    }
    const incrementalGen = createIncrementalIdGenerator({
      client: this.resource.client,
      resourceName: this.resource.name,
      config: this._incrementalConfig,
      logger: this.resource.logger
    });
    this._generator = incrementalGen;
    this._asyncIdGenerator = true;
  }
  isAsync() {
    return this._asyncIdGenerator === true;
  }
  getGenerator() {
    return this._generator;
  }
  generate(data2) {
    if (!this._generator) {
      throw new Error("ID generator not initialized. Call initIncremental() first for incremental generators.");
    }
    return this._generator(data2);
  }
  getType(customIdGenerator, idSize) {
    if (typeof customIdGenerator === "function") {
      return "custom";
    }
    if (this._incrementalConfig) {
      return "incremental";
    }
    return "nanoid";
  }
  async getSequenceValue(fieldName = "id") {
    if (!this._generator?._sequence) {
      return null;
    }
    return this._generator._sequence.getValue(fieldName);
  }
  async resetSequence(fieldName, value) {
    if (!this._generator?._sequence) {
      this.resource.logger?.warn("resetSequence called on non-incremental resource");
      return false;
    }
    return this._generator._sequence.reset(fieldName, value);
  }
  async listSequences() {
    if (!this._generator?._sequence) {
      return null;
    }
    return this._generator._sequence.list();
  }
  async reserveIdBatch(count = 100) {
    if (!this._generator?._sequence) {
      return null;
    }
    return this._generator._sequence.reserveBatch("id", count);
  }
  getBatchStatus(fieldName = "id") {
    if (!this._generator?._sequence) {
      return null;
    }
    return this._generator._sequence.getBatchStatus(fieldName);
  }
  releaseBatch(fieldName = "id") {
    if (this._generator?._sequence) {
      this._generator._sequence.releaseBatch(fieldName);
    }
  }
};
var ResourceEvents = class {
  resource;
  disabled;
  _emitterProto;
  _pendingListeners;
  _wired;
  constructor(resource, config = {}) {
    this.resource = resource;
    this._emitterProto = AsyncEventEmitter.prototype;
    this.disabled = config.disableEvents === true || config.disableResourceEvents === true;
    const events2 = config.events || {};
    this._pendingListeners = !this.disabled && events2 && Object.keys(events2).length > 0 ? events2 : null;
    this._wired = this.disabled || !this._pendingListeners;
  }
  isDisabled() {
    return this.disabled;
  }
  isWired() {
    return this._wired;
  }
  ensureWired() {
    if (this.disabled || this._wired) {
      return;
    }
    if (!this._pendingListeners) {
      this._wired = true;
      return;
    }
    for (const [eventName, listeners] of Object.entries(this._pendingListeners)) {
      if (Array.isArray(listeners)) {
        for (const listener of listeners) {
          if (typeof listener === "function") {
            this._emitterProto.on.call(this.resource, eventName, listener.bind(this.resource));
          }
        }
      } else if (typeof listeners === "function") {
        this._emitterProto.on.call(this.resource, eventName, listeners.bind(this.resource));
      }
    }
    this._pendingListeners = null;
    this._wired = true;
  }
  emitStandardized(event, payload2, id2 = null) {
    if (this.disabled) {
      return;
    }
    this.ensureWired();
    this._emitterProto.emit.call(this.resource, event, payload2);
    if (id2) {
      this._emitterProto.emit.call(this.resource, `${event}:${id2}`, payload2);
    }
  }
  on(eventName, listener) {
    if (this.disabled) {
      return this.resource;
    }
    this.ensureWired();
    this._emitterProto.on.call(this.resource, eventName, listener);
    return this.resource;
  }
  once(eventName, listener) {
    if (this.disabled) {
      return this.resource;
    }
    this.ensureWired();
    this._emitterProto.once.call(this.resource, eventName, listener);
    return this.resource;
  }
  emit(eventName, ...args) {
    if (this.disabled) {
      return false;
    }
    this.ensureWired();
    return this._emitterProto.emit.call(this.resource, eventName, ...args);
  }
};
var ResourceHooks = class _ResourceHooks {
  static HOOK_EVENTS = [
    "beforeInsert",
    "afterInsert",
    "beforeUpdate",
    "afterUpdate",
    "beforeDelete",
    "afterDelete",
    "beforeGet",
    "afterGet",
    "beforeList",
    "afterList",
    "beforeQuery",
    "afterQuery",
    "beforePatch",
    "afterPatch",
    "beforeReplace",
    "afterReplace",
    "beforeExists",
    "afterExists",
    "beforeCount",
    "afterCount",
    "beforeGetMany",
    "afterGetMany",
    "beforeDeleteMany",
    "afterDeleteMany"
  ];
  resource;
  _hooks;
  constructor(resource, config = {}) {
    this.resource = resource;
    this._hooks = {};
    for (const event of _ResourceHooks.HOOK_EVENTS) {
      this._hooks[event] = [];
    }
    const configHooks = config.hooks || {};
    for (const [event, hooksArr] of Object.entries(configHooks)) {
      if (Array.isArray(hooksArr) && this._hooks[event]) {
        for (const fn of hooksArr) {
          const bound = this._bindHook(fn);
          if (bound) {
            this._hooks[event].push(bound);
          }
        }
      }
    }
  }
  getHooks() {
    return this._hooks;
  }
  getHooksForEvent(event) {
    return this._hooks[event] || [];
  }
  addHook(event, fn) {
    if (!this._hooks[event]) {
      return false;
    }
    const bound = this._bindHook(fn);
    if (bound) {
      this._hooks[event].push(bound);
      return true;
    }
    return false;
  }
  async executeHooks(event, data2) {
    const hooks = this._hooks[event];
    if (!hooks || hooks.length === 0) {
      return data2;
    }
    let result = data2;
    for (const hook of hooks) {
      result = await hook(result);
    }
    return result;
  }
  _bindHook(fn) {
    if (typeof fn !== "function") {
      return null;
    }
    const hookFn = fn;
    const original = hookFn.__s3db_original || hookFn;
    const bound = original.bind(this.resource);
    try {
      Object.defineProperty(bound, "__s3db_original", {
        value: original,
        enumerable: false,
        configurable: true
      });
    } catch (_) {
      bound.__s3db_original = original;
    }
    return bound;
  }
  hasHooks(event) {
    const hooks = this._hooks[event];
    return hooks !== void 0 && hooks.length > 0;
  }
  getHookCount(event) {
    const hooks = this._hooks[event];
    return hooks ? hooks.length : 0;
  }
  clearHooks(event) {
    if (this._hooks[event]) {
      this._hooks[event] = [];
    }
  }
  clearAllHooks() {
    for (const event of _ResourceHooks.HOOK_EVENTS) {
      this._hooks[event] = [];
    }
  }
};
var ResourceGuards = class {
  resource;
  _guard;
  constructor(resource, config = {}) {
    this.resource = resource;
    this._guard = this._normalize(config.guard);
  }
  getGuard() {
    return this._guard;
  }
  _normalize(guard) {
    if (!guard)
      return null;
    if (Array.isArray(guard)) {
      return { "*": guard };
    }
    return guard;
  }
  async execute(operation2, context, record = null) {
    if (!this._guard)
      return true;
    let guardFn = this._guard[operation2];
    if (!guardFn) {
      guardFn = this._guard["*"];
    }
    if (!guardFn)
      return true;
    if (typeof guardFn === "boolean") {
      return guardFn;
    }
    if (Array.isArray(guardFn)) {
      return this._checkRolesScopes(guardFn, context.user);
    }
    if (typeof guardFn === "function") {
      try {
        const result = await guardFn(context, record);
        return result === true;
      } catch (err) {
        this.resource.logger?.error({ operation: operation2, error: err.message, stack: err.stack }, `guard error for ${operation2}`);
        return false;
      }
    }
    return false;
  }
  _checkRolesScopes(requiredRolesScopes, user) {
    if (!user)
      return false;
    const userScopes = user.scope?.split(" ") || [];
    const clientId = user.azp || process.env.CLIENT_ID || "default";
    const clientRoles = user.resource_access?.[clientId]?.roles || [];
    const realmRoles = user.realm_access?.roles || [];
    const azureRoles = user.roles || [];
    const userRoles = [...clientRoles, ...realmRoles, ...azureRoles];
    return requiredRolesScopes.some((required) => {
      return userScopes.includes(required) || userRoles.includes(required);
    });
  }
  hasGuard(operation2) {
    if (!this._guard)
      return false;
    return this._guard[operation2] !== void 0 || this._guard["*"] !== void 0;
  }
  setGuard(guard) {
    this._guard = this._normalize(guard);
  }
};
var ResourceMiddleware = class _ResourceMiddleware {
  static SUPPORTED_METHODS = [
    "get",
    "list",
    "listIds",
    "getAll",
    "count",
    "page",
    "insert",
    "update",
    "delete",
    "deleteMany",
    "exists",
    "getMany",
    "content",
    "hasContent",
    "query",
    "getFromPartition",
    "setContent",
    "deleteContent",
    "replace"
  ];
  resource;
  _middlewares;
  _originalMethods;
  _initialized;
  constructor(resource) {
    this.resource = resource;
    this._middlewares = /* @__PURE__ */ new Map();
    this._originalMethods = /* @__PURE__ */ new Map();
    this._initialized = false;
  }
  init() {
    if (this._initialized)
      return;
    for (const method of _ResourceMiddleware.SUPPORTED_METHODS) {
      this._middlewares.set(method, []);
      if (!this._originalMethods.has(method) && typeof this.resource[method] === "function") {
        const originalMethod = this.resource[method];
        this._originalMethods.set(method, originalMethod.bind(this.resource));
        this.resource[method] = this._createDispatcher(method);
      }
    }
    this._initialized = true;
  }
  _createDispatcher(method) {
    const self2 = this;
    return async function(...args) {
      const ctx = { resource: self2.resource, args, method };
      let idx = -1;
      const stack = self2._middlewares.get(method);
      const dispatch = async (i4) => {
        if (i4 <= idx) {
          throw new ResourceError("Resource middleware next() called multiple times", {
            resourceName: self2.resource.name,
            operation: method,
            statusCode: 500,
            retriable: false,
            suggestion: "Ensure each middleware awaits next() at most once."
          });
        }
        idx = i4;
        if (i4 < stack.length) {
          return await stack[i4](ctx, () => dispatch(i4 + 1));
        } else {
          return await self2._originalMethods.get(method)(...ctx.args);
        }
      };
      return await dispatch(0);
    };
  }
  use(method, fn) {
    if (!this._initialized) {
      this.init();
    }
    if (!this._middlewares.has(method)) {
      throw new ResourceError(`No such method for middleware: ${method}`, {
        operation: "useMiddleware",
        method,
        supportedMethods: _ResourceMiddleware.SUPPORTED_METHODS
      });
    }
    this._middlewares.get(method).push(fn);
  }
  getMiddlewares(method) {
    return this._middlewares.get(method) || [];
  }
  isInitialized() {
    return this._initialized;
  }
  getMiddlewareCount(method) {
    const stack = this._middlewares.get(method);
    return stack ? stack.length : 0;
  }
  clearMiddlewares(method) {
    if (this._middlewares.has(method)) {
      this._middlewares.set(method, []);
    }
  }
  clearAllMiddlewares() {
    for (const method of _ResourceMiddleware.SUPPORTED_METHODS) {
      if (this._middlewares.has(method)) {
        this._middlewares.set(method, []);
      }
    }
  }
};
var UNSAFE_KEY_CHARS = /[\\\/=%]/;
function isValidS3KeySegment(value) {
  return !UNSAFE_KEY_CHARS.test(value);
}
function validateS3KeySegment(value, context) {
  const strValue = String(value);
  if (UNSAFE_KEY_CHARS.test(strValue)) {
    const invalidChars = strValue.match(UNSAFE_KEY_CHARS);
    throw new ValidationError2(`Invalid ${context}: contains unsafe character '${invalidChars?.[0]}'`, {
      field: context,
      value: strValue,
      constraint: "url-safe",
      statusCode: 400,
      suggestion: "IDs and partition values must be URL-friendly (no /, \\, =, or %). Use alphanumeric characters, hyphens, or underscores."
    });
  }
}
var ResourcePartitions = class {
  resource;
  _strictValidation;
  constructor(resource, config = {}) {
    this.resource = resource;
    this._strictValidation = config.strictValidation !== false;
  }
  getPartitions() {
    return this.resource.config?.partitions || {};
  }
  hasPartitions() {
    const partitions = this.getPartitions();
    return partitions && Object.keys(partitions).length > 0;
  }
  setupHooks(hooksModule) {
    if (!this.hasPartitions()) {
      return;
    }
    const hooks = hooksModule.getHooks();
    if (!hooks.afterInsert) {
      hooks.afterInsert = [];
    }
    hooks.afterInsert.push(async (data2) => {
      await this.createReferences(data2);
      return data2;
    });
    if (!hooks.afterDelete) {
      hooks.afterDelete = [];
    }
    hooks.afterDelete.push(async (data2) => {
      await this.deleteReferences(data2);
      return data2;
    });
  }
  validate() {
    if (!this._strictValidation) {
      return;
    }
    const partitions = this.getPartitions();
    if (!partitions || Object.keys(partitions).length === 0) {
      return;
    }
    const currentAttributes = Object.keys(this.resource.attributes || {});
    for (const [partitionName, partitionDef] of Object.entries(partitions)) {
      if (!partitionDef.fields) {
        continue;
      }
      for (const fieldName of Object.keys(partitionDef.fields)) {
        if (!this.fieldExistsInAttributes(fieldName)) {
          throw new PartitionError(`Partition '${partitionName}' uses field '${fieldName}' which does not exist in resource attributes. Available fields: ${currentAttributes.join(", ")}.`, {
            resourceName: this.resource.name,
            partitionName,
            fieldName,
            availableFields: currentAttributes,
            operation: "validatePartitions"
          });
        }
      }
    }
  }
  fieldExistsInAttributes(fieldName) {
    if (fieldName.startsWith("_")) {
      return true;
    }
    if (!fieldName.includes(".")) {
      return Object.keys(this.resource.attributes || {}).includes(fieldName);
    }
    const keys2 = fieldName.split(".");
    let currentLevel = this.resource.attributes || {};
    for (const key of keys2) {
      if (!currentLevel || typeof currentLevel !== "object" || !(key in currentLevel)) {
        return false;
      }
      currentLevel = currentLevel[key];
    }
    return true;
  }
  findOrphaned() {
    const orphaned = {};
    const partitions = this.getPartitions();
    if (!partitions) {
      return orphaned;
    }
    for (const [partitionName, partitionDef] of Object.entries(partitions)) {
      if (!partitionDef.fields) {
        continue;
      }
      const missingFields = [];
      for (const fieldName of Object.keys(partitionDef.fields)) {
        if (!this.fieldExistsInAttributes(fieldName)) {
          missingFields.push(fieldName);
        }
      }
      if (missingFields.length > 0) {
        orphaned[partitionName] = {
          missingFields,
          definition: partitionDef,
          allFields: Object.keys(partitionDef.fields)
        };
      }
    }
    return orphaned;
  }
  removeOrphaned({ dryRun = false } = {}) {
    const orphaned = this.findOrphaned();
    if (Object.keys(orphaned).length === 0) {
      return {};
    }
    if (dryRun) {
      return orphaned;
    }
    for (const partitionName of Object.keys(orphaned)) {
      delete this.resource.config.partitions[partitionName];
    }
    this.resource.emit("orphanedPartitionsRemoved", {
      resourceName: this.resource.name,
      removed: orphaned,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
    return orphaned;
  }
  applyRule(value, rule) {
    if (value === void 0 || value === null) {
      return value;
    }
    let transformedValue = value;
    if (typeof rule === "string" && rule.includes("maxlength:")) {
      const maxLengthMatch = rule.match(/maxlength:(\d+)/);
      if (maxLengthMatch) {
        const maxLength = parseInt(maxLengthMatch[1], 10);
        if (typeof transformedValue === "string" && transformedValue.length > maxLength) {
          transformedValue = transformedValue.substring(0, maxLength);
        }
      }
    }
    if (rule.includes("date")) {
      if (transformedValue instanceof Date) {
        transformedValue = transformedValue.toISOString().split("T")[0];
      } else if (typeof transformedValue === "string") {
        if (transformedValue.includes("T") && transformedValue.includes("Z")) {
          transformedValue = transformedValue.split("T")[0];
        } else {
          const date3 = new Date(transformedValue);
          if (!isNaN(date3.getTime())) {
            transformedValue = date3.toISOString().split("T")[0];
          }
        }
      }
    }
    return transformedValue;
  }
  getNestedFieldValue(data2, fieldPath) {
    if (!fieldPath.includes(".")) {
      return data2[fieldPath];
    }
    const keys2 = fieldPath.split(".");
    let currentLevel = data2;
    for (const key of keys2) {
      if (!currentLevel || typeof currentLevel !== "object" || !(key in currentLevel)) {
        return void 0;
      }
      currentLevel = currentLevel[key];
    }
    return currentLevel;
  }
  getKey({ partitionName, id: id2, data: data2 }) {
    const partitions = this.getPartitions();
    if (!partitions || !partitions[partitionName]) {
      throw new PartitionError(`Partition '${partitionName}' not found`, {
        resourceName: this.resource.name,
        partitionName,
        operation: "getPartitionKey"
      });
    }
    const partition = partitions[partitionName];
    const partitionSegments = [];
    const sortedFields = Object.entries(partition.fields).sort(([a4], [b4]) => a4.localeCompare(b4));
    for (const [fieldName, rule] of sortedFields) {
      const fieldValue = this.getNestedFieldValue(data2, fieldName);
      const transformedValue = this.applyRule(fieldValue, rule);
      if (transformedValue === void 0 || transformedValue === null) {
        return null;
      }
      partitionSegments.push(`${fieldName}=${transformedValue}`);
    }
    if (partitionSegments.length === 0) {
      return null;
    }
    const finalId = id2 || data2?.id;
    if (!finalId) {
      return null;
    }
    return (0, import_path.join)(`resource=${this.resource.name}`, `partition=${partitionName}`, ...partitionSegments, `id=${finalId}`);
  }
  buildPrefix(partition, partitionDef, partitionValues) {
    const partitionSegments = [];
    const sortedFields = Object.entries(partitionDef.fields).sort(([a4], [b4]) => a4.localeCompare(b4));
    for (const [fieldName, rule] of sortedFields) {
      const value = partitionValues[fieldName];
      if (value !== void 0 && value !== null) {
        const transformedValue = this.applyRule(value, rule);
        partitionSegments.push(`${fieldName}=${transformedValue}`);
      }
    }
    if (partitionSegments.length > 0) {
      return `resource=${this.resource.name}/partition=${partition}/${partitionSegments.join("/")}`;
    }
    return `resource=${this.resource.name}/partition=${partition}`;
  }
  extractValuesFromKey(id2, keys2, sortedFields) {
    const idSegment = `id=${id2}`;
    const keyForId = keys2.find((key) => {
      const segments = key.split("/");
      return segments.some((segment) => segment === idSegment);
    });
    if (!keyForId) {
      throw new PartitionError(`Partition key not found for ID ${id2}`, {
        resourceName: this.resource.name,
        id: id2,
        operation: "extractPartitionValuesFromKey"
      });
    }
    const keyParts = keyForId.split("/");
    const actualPartitionValues = {};
    for (const [fieldName] of sortedFields) {
      const fieldPart = keyParts.find((part) => part.startsWith(`${fieldName}=`));
      if (fieldPart) {
        const value = fieldPart.replace(`${fieldName}=`, "");
        actualPartitionValues[fieldName] = value;
      }
    }
    return actualPartitionValues;
  }
  async createReferences(data2) {
    const partitions = this.getPartitions();
    if (!partitions || Object.keys(partitions).length === 0) {
      return;
    }
    const promises2 = Object.entries(partitions).map(async ([partitionName]) => {
      const partitionKey = this.getKey({ partitionName, id: data2.id, data: data2 });
      if (partitionKey) {
        const partitionMetadata = {
          _v: String(this.resource.version)
        };
        return this.resource.client.putObject({
          key: partitionKey,
          metadata: partitionMetadata,
          body: "",
          contentType: void 0
        });
      }
      return null;
    });
    const results = await Promise.allSettled(promises2);
    const failures = results.filter((r4) => r4.status === "rejected");
    if (failures.length > 0) {
      this.resource.emit("partitionIndexWarning", {
        operation: "create",
        id: data2.id,
        failures: failures.map((f4) => f4.reason)
      });
    }
  }
  async deleteReferences(data2) {
    const partitions = this.getPartitions();
    if (!partitions || Object.keys(partitions).length === 0) {
      return;
    }
    const keysToDelete = [];
    for (const [partitionName] of Object.entries(partitions)) {
      const partitionKey = this.getKey({ partitionName, id: data2.id, data: data2 });
      if (partitionKey) {
        keysToDelete.push(partitionKey);
      }
    }
    if (keysToDelete.length > 0) {
      await tryFn$1(() => this.resource.client.deleteObjects(keysToDelete));
    }
  }
  async updateReferences(data2) {
    const partitions = this.getPartitions();
    if (!partitions || Object.keys(partitions).length === 0) {
      return;
    }
    for (const [partitionName, partition] of Object.entries(partitions)) {
      if (!partition || !partition.fields || typeof partition.fields !== "object") {
        continue;
      }
      const partitionKey = this.getKey({ partitionName, id: data2.id, data: data2 });
      if (partitionKey) {
        const partitionMetadata = {
          _v: String(this.resource.version)
        };
        await tryFn$1(async () => {
          await this.resource.client.putObject({
            key: partitionKey,
            metadata: partitionMetadata,
            body: "",
            contentType: void 0
          });
        });
      }
    }
  }
  async handleReferenceUpdates(oldData, newData) {
    const partitions = this.getPartitions();
    if (!partitions || Object.keys(partitions).length === 0) {
      return;
    }
    const updatePromises = Object.entries(partitions).map(async ([partitionName, partition]) => {
      const [ok, err] = await tryFn$1(() => this.handleReferenceUpdate(partitionName, partition, oldData, newData));
      if (!ok) {
        return { partitionName, error: err };
      }
      return { partitionName, success: true };
    });
    await Promise.allSettled(updatePromises);
    const id2 = newData.id || oldData.id;
    const cleanupPromises = Object.entries(partitions).map(async ([partitionName]) => {
      const prefix = `resource=${this.resource.name}/partition=${partitionName}`;
      const [okKeys, , keys2] = await tryFn$1(() => this.resource.client.getAllKeys({ prefix }));
      if (!okKeys || !keys2) {
        return;
      }
      const validKey = this.getKey({ partitionName, id: id2, data: newData });
      const staleKeys = keys2.filter((key) => key.endsWith(`/id=${id2}`) && key !== validKey);
      if (staleKeys.length > 0) {
        await tryFn$1(() => this.resource.client.deleteObjects(staleKeys));
      }
    });
    await Promise.allSettled(cleanupPromises);
  }
  async handleReferenceUpdate(partitionName, partition, oldData, newData) {
    const id2 = newData.id || oldData.id;
    const oldPartitionKey = this.getKey({ partitionName, id: id2, data: oldData });
    const newPartitionKey = this.getKey({ partitionName, id: id2, data: newData });
    if (oldPartitionKey !== newPartitionKey) {
      if (oldPartitionKey) {
        await tryFn$1(async () => {
          await this.resource.client.deleteObject(oldPartitionKey);
        });
      }
      if (newPartitionKey) {
        await tryFn$1(async () => {
          const partitionMetadata = {
            _v: String(this.resource.version)
          };
          await this.resource.client.putObject({
            key: newPartitionKey,
            metadata: partitionMetadata,
            body: "",
            contentType: void 0
          });
        });
      }
    } else if (newPartitionKey) {
      await tryFn$1(async () => {
        const partitionMetadata = {
          _v: String(this.resource.version)
        };
        await this.resource.client.putObject({
          key: newPartitionKey,
          metadata: partitionMetadata,
          body: "",
          contentType: void 0
        });
      });
    }
  }
  async getFromPartition({ id: id2, partitionName, partitionValues = {} }) {
    validateS3KeySegment(id2, "id");
    for (const [fieldName, value] of Object.entries(partitionValues)) {
      if (value !== void 0 && value !== null) {
        validateS3KeySegment(value, `partitionValues.${fieldName}`);
      }
    }
    const partitions = this.getPartitions();
    if (!partitions || !partitions[partitionName]) {
      throw new PartitionError(`Partition '${partitionName}' not found`, {
        resourceName: this.resource.name,
        partitionName,
        operation: "getFromPartition"
      });
    }
    const partition = partitions[partitionName];
    const partitionSegments = [];
    const sortedFields = Object.entries(partition.fields).sort(([a4], [b4]) => a4.localeCompare(b4));
    for (const [fieldName, rule] of sortedFields) {
      const value = partitionValues[fieldName];
      if (value !== void 0 && value !== null) {
        const transformedValue = this.applyRule(value, rule);
        partitionSegments.push(`${fieldName}=${transformedValue}`);
      }
    }
    if (partitionSegments.length === 0) {
      throw new PartitionError(`No partition values provided for partition '${partitionName}'`, {
        resourceName: this.resource.name,
        partitionName,
        operation: "getFromPartition"
      });
    }
    const partitionKey = (0, import_path.join)(`resource=${this.resource.name}`, `partition=${partitionName}`, ...partitionSegments, `id=${id2}`);
    const [ok] = await tryFn$1(async () => {
      await this.resource.client.headObject(partitionKey);
    });
    if (!ok) {
      throw new ResourceError(`Resource with id '${id2}' not found in partition '${partitionName}'`, {
        resourceName: this.resource.name,
        id: id2,
        partitionName,
        operation: "getFromPartition"
      });
    }
    const data2 = await this.resource.get(id2);
    data2._partition = partitionName;
    data2._partitionValues = partitionValues;
    this.resource._emitStandardized("partition-fetched", data2, data2.id);
    return data2;
  }
};
var ResourceQuery = class {
  resource;
  constructor(resource) {
    this.resource = resource;
  }
  get client() {
    return this.resource.client;
  }
  get partitions() {
    return this.resource.config?.partitions || {};
  }
  async count({ partition = null, partitionValues = {} } = {}) {
    await this.resource.executeHooks("beforeCount", { partition, partitionValues });
    let prefix;
    if (partition && Object.keys(partitionValues).length > 0) {
      const partitionDef = this.partitions[partition];
      if (!partitionDef) {
        throw new PartitionError(`Partition '${partition}' not found`, {
          resourceName: this.resource.name,
          partitionName: partition,
          operation: "count"
        });
      }
      const partitionSegments = [];
      const sortedFields = Object.entries(partitionDef.fields).sort(([a4], [b4]) => a4.localeCompare(b4));
      for (const [fieldName, rule] of sortedFields) {
        const value = partitionValues[fieldName];
        if (value !== void 0 && value !== null) {
          const transformedValue = this.resource.applyPartitionRule(value, rule);
          partitionSegments.push(`${fieldName}=${transformedValue}`);
        }
      }
      if (partitionSegments.length > 0) {
        prefix = `resource=${this.resource.name}/partition=${partition}/${partitionSegments.join("/")}`;
      } else {
        prefix = `resource=${this.resource.name}/partition=${partition}`;
      }
    } else {
      prefix = `resource=${this.resource.name}/data`;
    }
    const count = await this.client.count({ prefix });
    await this.resource.executeHooks("afterCount", { count, partition, partitionValues });
    this.resource._emitStandardized("count", count);
    return count;
  }
  async listIds({ partition = null, partitionValues = {}, limit, offset = 0 } = {}) {
    let prefix;
    if (partition && Object.keys(partitionValues).length > 0) {
      if (!this.partitions[partition]) {
        throw new PartitionError(`Partition '${partition}' not found`, {
          resourceName: this.resource.name,
          partitionName: partition,
          operation: "listIds"
        });
      }
      const partitionDef = this.partitions[partition];
      const partitionSegments = [];
      const sortedFields = Object.entries(partitionDef.fields).sort(([a4], [b4]) => a4.localeCompare(b4));
      for (const [fieldName, rule] of sortedFields) {
        const value = partitionValues[fieldName];
        if (value !== void 0 && value !== null) {
          const transformedValue = this.resource.applyPartitionRule(value, rule);
          partitionSegments.push(`${fieldName}=${transformedValue}`);
        }
      }
      if (partitionSegments.length > 0) {
        prefix = `resource=${this.resource.name}/partition=${partition}/${partitionSegments.join("/")}`;
      } else {
        prefix = `resource=${this.resource.name}/partition=${partition}`;
      }
    } else {
      prefix = `resource=${this.resource.name}/data`;
    }
    const keys2 = await this.client.getKeysPage({
      prefix,
      offset,
      amount: limit || 1e3
    });
    const ids = keys2.map((key) => {
      const parts = key.split("/");
      const idPart = parts.find((part) => part.startsWith("id="));
      return idPart ? idPart.replace("id=", "") : null;
    }).filter((id2) => id2 !== null);
    this.resource._emitStandardized("listed-ids", ids.length);
    return ids;
  }
  async list({ partition = null, partitionValues = {}, limit, offset = 0 } = {}) {
    await this.resource.executeHooks("beforeList", { partition, partitionValues, limit, offset });
    const [ok, err, result] = await tryFn$1(async () => {
      if (!partition) {
        return this.listMain({ limit, offset });
      }
      return this.listPartition({ partition, partitionValues, limit, offset });
    });
    if (!ok) {
      return this.handleListError(err, { partition, partitionValues });
    }
    return this.resource.executeHooks("afterList", result);
  }
  async listMain({ limit, offset = 0 }) {
    const [ok, err, ids] = await tryFn$1(() => this.listIds({ limit, offset }));
    if (!ok || !ids)
      throw err;
    const results = await this.processListResults(ids, "main");
    this.resource._emitStandardized("list", { count: results.length, errors: 0 });
    return results;
  }
  async listPartition({ partition, partitionValues, limit, offset = 0 }) {
    if (!this.partitions[partition]) {
      this.resource._emitStandardized("list", { partition, partitionValues, count: 0, errors: 0 });
      return [];
    }
    const partitionDef = this.partitions[partition];
    const prefix = this.resource.buildPartitionPrefix(partition, partitionDef, partitionValues);
    const [ok, err, keys2] = await tryFn$1(() => this.client.getKeysPage({
      prefix,
      offset,
      amount: limit || 1e3
    }));
    if (!ok || !keys2)
      throw err;
    const filteredIds = this.extractIdsFromKeys(keys2);
    const results = await this.processPartitionResults(filteredIds, partition, partitionDef, keys2);
    this.resource._emitStandardized("list", { partition, partitionValues, count: results.length, errors: 0 });
    return results;
  }
  extractIdsFromKeys(keys2) {
    return keys2.map((key) => {
      const parts = key.split("/");
      const idPart = parts.find((part) => part.startsWith("id="));
      return idPart ? idPart.replace("id=", "") : null;
    }).filter((id2) => id2 !== null);
  }
  async processListResults(ids, context = "main") {
    const operations = ids.map((id2) => async () => {
      const [ok, err, result] = await tryFn$1(() => this.resource.get(id2));
      if (ok && result) {
        return result;
      }
      return this.handleResourceError(err, id2, context);
    });
    const { results } = await this.resource._executeBatchHelper(operations, {
      onItemError: (error2, index) => {
        this.resource.emit("error", error2, ids[index]);
        this.resource.observers.map((x4) => x4.emit("error", this.resource.name, error2, ids[index]));
      }
    });
    this.resource._emitStandardized("list", { count: results.length, errors: 0 });
    return results.filter((r4) => r4 !== null);
  }
  async processPartitionResults(ids, partition, partitionDef, keys2) {
    const sortedFields = Object.entries(partitionDef.fields).sort(([a4], [b4]) => a4.localeCompare(b4));
    const operations = ids.map((id2) => async () => {
      const [ok, err, result] = await tryFn$1(async () => {
        const actualPartitionValues = this.resource.extractPartitionValuesFromKey(id2, keys2, sortedFields);
        const data2 = await this.resource.get(id2);
        data2._partition = partition;
        data2._partitionValues = actualPartitionValues;
        return data2;
      });
      if (ok && result)
        return result;
      return this.handleResourceError(err, id2, "partition");
    });
    const { results } = await this.resource._executeBatchHelper(operations, {
      onItemError: (error2, index) => {
        this.resource.emit("error", error2, ids[index]);
        this.resource.observers.map((x4) => x4.emit("error", this.resource.name, error2, ids[index]));
      }
    });
    return results.filter((item) => item !== null);
  }
  handleResourceError(error2, id2, context) {
    if (error2.message.includes("Cipher job failed") || error2.message.includes("OperationError")) {
      return {
        id: id2,
        _decryptionFailed: true,
        _error: error2.message,
        ...context === "partition" && { _partition: context }
      };
    }
    throw error2;
  }
  handleListError(error2, { partition, partitionValues }) {
    if (error2.message.includes("Partition '") && error2.message.includes("' not found")) {
      this.resource._emitStandardized("list", { partition, partitionValues, count: 0, errors: 1 });
      return [];
    }
    this.resource._emitStandardized("list", { partition, partitionValues, count: 0, errors: 1 });
    return [];
  }
  async getMany(ids) {
    await this.resource.executeHooks("beforeGetMany", { ids });
    const operations = ids.map((id2) => async () => {
      const [ok, err, data2] = await tryFn$1(() => this.resource.get(id2));
      if (ok && data2)
        return data2;
      const error2 = err;
      if (error2.message.includes("Cipher job failed") || error2.message.includes("OperationError")) {
        return {
          id: id2,
          _decryptionFailed: true,
          _error: error2.message
        };
      }
      throw error2;
    });
    const { results } = await this.resource._executeBatchHelper(operations, {
      onItemError: (error2, index) => {
        this.resource.emit("error", error2, ids[index]);
        this.resource.observers.map((x4) => x4.emit("error", this.resource.name, error2, ids[index]));
        return {
          id: ids[index],
          _error: error2.message,
          _decryptionFailed: error2.message.includes("Cipher job failed") || error2.message.includes("OperationError")
        };
      }
    });
    const finalResults = await this.resource.executeHooks("afterGetMany", results.filter((r4) => r4 !== null));
    this.resource._emitStandardized("fetched-many", ids.length);
    return finalResults;
  }
  async getAll() {
    const [ok, err, ids] = await tryFn$1(() => this.listIds());
    if (!ok || !ids)
      throw err;
    const results = [];
    for (const id2 of ids) {
      const [ok2, , item] = await tryFn$1(() => this.resource.get(id2));
      if (ok2 && item) {
        results.push(item);
      }
    }
    return results;
  }
  async page({ offset = 0, size = 100, partition = null, partitionValues = {}, skipCount = false } = {}) {
    const effectiveSize = size > 0 ? size : 100;
    let totalItems = null;
    let totalPages = null;
    if (!skipCount) {
      totalItems = await this.count({ partition, partitionValues });
      totalPages = Math.ceil(totalItems / effectiveSize);
    }
    const page = Math.floor(offset / effectiveSize);
    const items = await this.list({ partition, partitionValues, limit: effectiveSize, offset });
    const pageResult = {
      items,
      totalItems,
      page,
      pageSize: effectiveSize,
      totalPages,
      hasMore: items.length === effectiveSize && offset + effectiveSize < (totalItems || Infinity),
      _debug: {
        requestedSize: size,
        requestedOffset: offset,
        actualItemsReturned: items.length,
        skipCount,
        hasTotalItems: totalItems !== null
      }
    };
    this.resource._emitStandardized("paginated", pageResult);
    return pageResult;
  }
  async query(filter2 = {}, { limit = 100, offset = 0, partition = null, partitionValues = {} } = {}) {
    await this.resource.executeHooks("beforeQuery", { filter: filter2, limit, offset, partition, partitionValues });
    if (Object.keys(filter2).length === 0) {
      return await this.list({ partition, partitionValues, limit, offset });
    }
    const results = [];
    let currentOffset = offset;
    const batchSize = Math.min(limit, 50);
    while (results.length < limit) {
      const batch = await this.list({
        partition,
        partitionValues,
        limit: batchSize,
        offset: currentOffset
      });
      if (batch.length === 0) {
        break;
      }
      const filteredBatch = batch.filter((doc) => {
        return Object.entries(filter2).every(([key, value]) => {
          return doc[key] === value;
        });
      });
      results.push(...filteredBatch);
      currentOffset += batchSize;
      if (batch.length < batchSize) {
        break;
      }
    }
    const finalResults = results.slice(0, limit);
    return await this.resource.executeHooks("afterQuery", finalResults);
  }
};
var ResourceContent = class {
  resource;
  constructor(resource) {
    this.resource = resource;
  }
  get client() {
    return this.resource.client;
  }
  async setContent({ id: id2, buffer, contentType = "application/octet-stream" }) {
    const [ok, err, currentData] = await tryFn$1(() => this.resource.get(id2));
    if (!ok || !currentData) {
      throw new ResourceError(`Resource with id '${id2}' not found`, {
        resourceName: this.resource.name,
        id: id2,
        operation: "setContent"
      });
    }
    const bufferLength = typeof buffer === "string" ? buffer.length : buffer.length;
    const updatedData = {
      ...currentData,
      _hasContent: true,
      _contentLength: bufferLength,
      _mimeType: contentType
    };
    const mappedMetadata = await this.resource.schema.mapper(updatedData);
    const [ok2, err2] = await tryFn$1(() => this.client.putObject({
      key: this.resource.getResourceKey(id2),
      metadata: mappedMetadata,
      body: buffer,
      contentType
    }));
    if (!ok2)
      throw err2;
    this.resource._emitStandardized("content-set", { id: id2, contentType, contentLength: bufferLength }, id2);
    return updatedData;
  }
  async content(id2) {
    const key = this.resource.getResourceKey(id2);
    const [ok, err, response2] = await tryFn$1(() => this.client.getObject(key));
    if (!ok) {
      const error2 = err;
      if (error2.name === "NoSuchKey" || error2.code === "NoSuchKey" || error2.Code === "NoSuchKey" || error2.statusCode === 404) {
        return {
          buffer: null,
          contentType: null
        };
      }
      throw err;
    }
    const s3Response = response2;
    const buffer = Buffer.from(await s3Response.Body.transformToByteArray());
    const contentType = s3Response.ContentType || null;
    this.resource._emitStandardized("content-fetched", { id: id2, contentLength: buffer.length, contentType }, id2);
    return {
      buffer,
      contentType
    };
  }
  async hasContent(id2) {
    const key = this.resource.getResourceKey(id2);
    const [ok, , response2] = await tryFn$1(() => this.client.headObject(key));
    if (!ok)
      return false;
    const s3Response = response2;
    return (s3Response.ContentLength || 0) > 0;
  }
  async deleteContent(id2) {
    const key = this.resource.getResourceKey(id2);
    const [ok, err, existingObject] = await tryFn$1(() => this.client.headObject(key));
    if (!ok)
      throw err;
    const s3Response = existingObject;
    const existingMetadata = s3Response.Metadata || {};
    const [ok2, err2] = await tryFn$1(() => this.client.putObject({
      key,
      body: "",
      metadata: existingMetadata
    }));
    if (!ok2)
      throw err2;
    this.resource._emitStandardized("content-deleted", id2, id2);
  }
};
var ResourceStreams = class {
  resource;
  constructor(resource) {
    this.resource = resource;
  }
  readable() {
    const stream = new ResourceReader({ resource: this.resource });
    return stream.build();
  }
  writable() {
    const stream = new ResourceWriter({ resource: this.resource });
    return stream.build();
  }
};
var S3_METADATA_LIMIT_BYTES = 2047;
async function handleInsert$4({ resource, data: data2, mappedData }) {
  const totalSize = calculateTotalSize(mappedData);
  const effectiveLimit = calculateEffectiveLimit({
    s3Limit: S3_METADATA_LIMIT_BYTES,
    systemConfig: {
      version: resource.version,
      timestamps: resource.config.timestamps,
      id: data2.id
    }
  });
  if (totalSize > effectiveLimit) {
    throw new MetadataLimitError("Metadata size exceeds 2KB limit on insert", {
      totalSize,
      effectiveLimit,
      absoluteLimit: S3_METADATA_LIMIT_BYTES,
      excess: totalSize - effectiveLimit,
      resourceName: resource.name,
      operation: "insert"
    });
  }
  return { mappedData, body: "" };
}
async function handleUpdate$4({ resource, id: id2, mappedData }) {
  const totalSize = calculateTotalSize(mappedData);
  const effectiveLimit = calculateEffectiveLimit({
    s3Limit: S3_METADATA_LIMIT_BYTES,
    systemConfig: {
      version: resource.version,
      timestamps: resource.config.timestamps,
      id: id2
    }
  });
  if (totalSize > effectiveLimit) {
    throw new MetadataLimitError("Metadata size exceeds 2KB limit on update", {
      totalSize,
      effectiveLimit,
      absoluteLimit: S3_METADATA_LIMIT_BYTES,
      excess: totalSize - effectiveLimit,
      resourceName: resource.name,
      operation: "update",
      id: id2
    });
  }
  return { mappedData, body: JSON.stringify(mappedData) };
}
async function handleUpsert$4({ resource, id: id2, mappedData }) {
  const totalSize = calculateTotalSize(mappedData);
  const effectiveLimit = calculateEffectiveLimit({
    s3Limit: S3_METADATA_LIMIT_BYTES,
    systemConfig: {
      version: resource.version,
      timestamps: resource.config.timestamps,
      id: id2
    }
  });
  if (totalSize > effectiveLimit) {
    throw new MetadataLimitError("Metadata size exceeds 2KB limit on upsert", {
      totalSize,
      effectiveLimit,
      absoluteLimit: S3_METADATA_LIMIT_BYTES,
      excess: totalSize - effectiveLimit,
      resourceName: resource.name,
      operation: "upsert",
      id: id2
    });
  }
  return { mappedData, body: "" };
}
async function handleGet$4({ metadata, body: body2 }) {
  return { metadata, body: body2 };
}
var enforceLimits = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  S3_METADATA_LIMIT_BYTES,
  handleGet: handleGet$4,
  handleInsert: handleInsert$4,
  handleUpdate: handleUpdate$4,
  handleUpsert: handleUpsert$4
});
async function handleInsert$3({ resource, data: data2, mappedData, originalData }) {
  const totalSize = calculateTotalSize(mappedData);
  const effectiveLimit = calculateEffectiveLimit({
    s3Limit: S3_METADATA_LIMIT_BYTES,
    systemConfig: {
      version: resource.version,
      timestamps: resource.config.timestamps,
      id: data2.id
    }
  });
  if (totalSize > effectiveLimit) {
    resource.emit("exceedsLimit", {
      operation: "insert",
      totalSize,
      limit: 2047,
      excess: totalSize - 2047,
      data: originalData || data2
    });
    const metadataOnly = { _v: mappedData._v };
    if (resource.schema?.pluginMap && Object.keys(resource.schema.pluginMap).length > 0) {
      metadataOnly._pluginMap = JSON.stringify(resource.schema.pluginMap);
    }
    return { mappedData: metadataOnly, body: JSON.stringify(mappedData) };
  }
  return { mappedData, body: "" };
}
async function handleUpdate$3({ resource, id: id2, data: data2, mappedData, originalData }) {
  const totalSize = calculateTotalSize(mappedData);
  const effectiveLimit = calculateEffectiveLimit({
    s3Limit: S3_METADATA_LIMIT_BYTES,
    systemConfig: {
      version: resource.version,
      timestamps: resource.config.timestamps,
      id: id2
    }
  });
  if (totalSize > effectiveLimit) {
    resource.emit("exceedsLimit", {
      operation: "update",
      id: id2,
      totalSize,
      limit: 2047,
      excess: totalSize - 2047,
      data: originalData || data2
    });
  }
  return { mappedData, body: JSON.stringify(data2) };
}
async function handleUpsert$3({ resource, id: id2, data: data2, mappedData }) {
  const totalSize = calculateTotalSize(mappedData);
  const effectiveLimit = calculateEffectiveLimit({
    s3Limit: S3_METADATA_LIMIT_BYTES,
    systemConfig: {
      version: resource.version,
      timestamps: resource.config.timestamps,
      id: id2
    }
  });
  if (totalSize > effectiveLimit) {
    resource.emit("exceedsLimit", {
      operation: "upsert",
      id: id2,
      totalSize,
      limit: 2047,
      excess: totalSize - 2047,
      data: data2
    });
  }
  return { mappedData, body: JSON.stringify(data2) };
}
async function handleGet$3({ metadata, body: body2 }) {
  if (body2 && body2.trim() !== "") {
    const [ok, , result] = await tryFn$1(() => {
      const bodyData = JSON.parse(body2);
      return {
        metadata: {
          ...bodyData,
          ...metadata
        },
        body: body2
      };
    });
    if (ok) {
      return result;
    }
  }
  return { metadata, body: body2 };
}
var userManaged = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  handleGet: handleGet$3,
  handleInsert: handleInsert$3,
  handleUpdate: handleUpdate$3,
  handleUpsert: handleUpsert$3
});
var TRUNCATED_FLAG = "$truncated";
var TRUNCATED_FLAG_VALUE = "true";
var TRUNCATED_FLAG_BYTES = calculateUTF8Bytes(TRUNCATED_FLAG) + calculateUTF8Bytes(TRUNCATED_FLAG_VALUE);
function truncateString(str, maxBytes) {
  const encoder = new TextEncoder();
  let bytes = encoder.encode(str);
  if (bytes.length <= maxBytes) {
    return str;
  }
  let length = str.length;
  while (length > 0) {
    const truncated = str.substring(0, length);
    bytes = encoder.encode(truncated);
    if (bytes.length <= maxBytes) {
      return truncated;
    }
    length--;
  }
  return "";
}
function truncateValue(value, maxBytes) {
  if (typeof value === "string") {
    return truncateString(value, maxBytes);
  } else if (typeof value === "object" && value !== null) {
    const jsonStr = JSON.stringify(value);
    return truncateString(jsonStr, maxBytes);
  } else {
    const stringValue = String(value);
    return truncateString(stringValue, maxBytes);
  }
}
async function handleInsert$2({ resource, data: data2, mappedData }) {
  const effectiveLimit = calculateEffectiveLimit({
    s3Limit: S3_METADATA_LIMIT_BYTES,
    systemConfig: {
      version: resource.version,
      timestamps: resource.config.timestamps,
      id: data2.id
    }
  });
  const attributeSizes = calculateAttributeSizes(mappedData);
  const sortedFields = Object.entries(attributeSizes).sort(([, a4], [, b4]) => a4 - b4);
  const resultFields = {};
  let currentSize = 0;
  let truncated = false;
  if (mappedData._v) {
    resultFields._v = mappedData._v;
    currentSize += attributeSizes._v;
  }
  for (const [fieldName, size] of sortedFields) {
    if (fieldName === "_v")
      continue;
    const fieldValue = mappedData[fieldName];
    const spaceNeeded = size + (truncated ? 0 : TRUNCATED_FLAG_BYTES);
    if (currentSize + spaceNeeded <= effectiveLimit) {
      resultFields[fieldName] = fieldValue;
      currentSize += size;
    } else {
      const availableSpace = effectiveLimit - currentSize - (truncated ? 0 : TRUNCATED_FLAG_BYTES);
      if (availableSpace > 0) {
        const truncatedValue = truncateValue(fieldValue, availableSpace);
        resultFields[fieldName] = truncatedValue;
        truncated = true;
        currentSize += calculateUTF8Bytes(truncatedValue);
      } else {
        resultFields[fieldName] = "";
        truncated = true;
      }
      break;
    }
  }
  let finalSize = calculateTotalSize(resultFields) + (truncated ? TRUNCATED_FLAG_BYTES : 0);
  while (finalSize > effectiveLimit) {
    const fieldNames = Object.keys(resultFields).filter((f4) => f4 !== "_v" && f4 !== "$truncated");
    if (fieldNames.length === 0) {
      break;
    }
    const lastField = fieldNames[fieldNames.length - 1];
    resultFields[lastField] = "";
    finalSize = calculateTotalSize(resultFields) + TRUNCATED_FLAG_BYTES;
    truncated = true;
  }
  if (truncated) {
    resultFields[TRUNCATED_FLAG] = TRUNCATED_FLAG_VALUE;
  }
  return { mappedData: resultFields, body: "" };
}
async function handleUpdate$2({ resource, data: data2, mappedData, originalData }) {
  return handleInsert$2({ resource, data: data2, mappedData });
}
async function handleUpsert$2({ resource, data: data2, mappedData }) {
  return handleInsert$2({ resource, data: data2, mappedData });
}
async function handleGet$2({ metadata, body: body2 }) {
  return { metadata, body: body2 };
}
var dataTruncate = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  handleGet: handleGet$2,
  handleInsert: handleInsert$2,
  handleUpdate: handleUpdate$2,
  handleUpsert: handleUpsert$2
});
var OVERFLOW_FLAG = "$overflow";
var OVERFLOW_FLAG_VALUE = "true";
var OVERFLOW_FLAG_BYTES = calculateUTF8Bytes(OVERFLOW_FLAG) + calculateUTF8Bytes(OVERFLOW_FLAG_VALUE);
async function handleInsert$1({ resource, data: data2, mappedData }) {
  const effectiveLimit = calculateEffectiveLimit({
    s3Limit: S3_METADATA_LIMIT_BYTES,
    systemConfig: {
      version: resource.version,
      timestamps: resource.config.timestamps,
      id: data2.id
    }
  });
  const attributeSizes = calculateAttributeSizes(mappedData);
  const sortedFields = Object.entries(attributeSizes).sort(([, a4], [, b4]) => a4 - b4);
  const metadataFields = {};
  const bodyFields = {};
  let currentSize = 0;
  let willOverflow = false;
  if (mappedData._v) {
    metadataFields._v = mappedData._v;
    currentSize += attributeSizes._v;
  }
  if (resource.schema?.pluginMap && Object.keys(resource.schema.pluginMap).length > 0) {
    const pluginMapStr = JSON.stringify(resource.schema.pluginMap);
    const pluginMapSize = calculateUTF8Bytes("_pluginMap") + calculateUTF8Bytes(pluginMapStr);
    metadataFields._pluginMap = pluginMapStr;
    currentSize += pluginMapSize;
  }
  let reservedLimit = effectiveLimit;
  for (const [fieldName, size] of sortedFields) {
    if (fieldName === "_v")
      continue;
    if (!willOverflow && currentSize + size > effectiveLimit) {
      reservedLimit -= OVERFLOW_FLAG_BYTES;
      willOverflow = true;
    }
    if (!willOverflow && currentSize + size <= reservedLimit) {
      metadataFields[fieldName] = mappedData[fieldName];
      currentSize += size;
    } else {
      bodyFields[fieldName] = mappedData[fieldName];
      willOverflow = true;
    }
  }
  if (willOverflow) {
    metadataFields[OVERFLOW_FLAG] = OVERFLOW_FLAG_VALUE;
  }
  const hasOverflow = Object.keys(bodyFields).length > 0;
  const body2 = hasOverflow ? JSON.stringify(bodyFields) : "";
  return { mappedData: metadataFields, body: body2 };
}
async function handleUpdate$1({ resource, data: data2, mappedData }) {
  return handleInsert$1({ resource, data: data2, mappedData });
}
async function handleUpsert$1({ resource, data: data2, mappedData }) {
  return handleInsert$1({ resource, data: data2, mappedData });
}
async function handleGet$1({ metadata, body: body2 }) {
  let bodyData = {};
  if (body2 && body2.trim() !== "") {
    const [ok, , parsed] = tryFnSync(() => JSON.parse(body2));
    if (ok) {
      bodyData = parsed;
    }
  }
  const mergedData = {
    ...bodyData,
    ...metadata
  };
  delete mergedData.$overflow;
  return { metadata: mergedData, body: body2 };
}
var bodyOverflow = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  handleGet: handleGet$1,
  handleInsert: handleInsert$1,
  handleUpdate: handleUpdate$1,
  handleUpsert: handleUpsert$1
});
async function handleInsert({ resource, mappedData }) {
  const metadataOnly = {
    "_v": mappedData._v || String(resource.version)
  };
  metadataOnly._map = JSON.stringify(resource.schema?.map || {});
  if (resource.schema?.pluginMap && Object.keys(resource.schema.pluginMap).length > 0) {
    metadataOnly._pluginMap = JSON.stringify(resource.schema.pluginMap);
  }
  const body2 = JSON.stringify(mappedData);
  return { mappedData: metadataOnly, body: body2 };
}
async function handleUpdate({ resource, mappedData }) {
  const metadataOnly = {
    "_v": mappedData._v || String(resource.version)
  };
  metadataOnly._map = JSON.stringify(resource.schema?.map || {});
  if (resource.schema?.pluginMap && Object.keys(resource.schema.pluginMap).length > 0) {
    metadataOnly._pluginMap = JSON.stringify(resource.schema.pluginMap);
  }
  const body2 = JSON.stringify(mappedData);
  return { mappedData: metadataOnly, body: body2 };
}
async function handleUpsert({ resource, mappedData }) {
  return handleInsert({ resource, mappedData });
}
async function handleGet({ metadata, body: body2 }) {
  let bodyData = {};
  if (body2 && body2.trim() !== "") {
    const [ok, , parsed] = tryFnSync(() => JSON.parse(body2));
    if (ok) {
      bodyData = parsed;
    }
  }
  const mergedData = {
    ...bodyData,
    ...metadata
  };
  return { metadata: mergedData, body: body2 };
}
var bodyOnly = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  handleGet,
  handleInsert,
  handleUpdate,
  handleUpsert
});
var behaviors = {
  "user-managed": userManaged,
  "enforce-limits": enforceLimits,
  "truncate-data": dataTruncate,
  "body-overflow": bodyOverflow,
  "body-only": bodyOnly
};
function getBehavior(behaviorName) {
  const behavior = behaviors[behaviorName];
  if (!behavior) {
    throw new BehaviorError(`Unknown behavior: ${behaviorName}`, {
      behavior: behaviorName,
      availableBehaviors: Object.keys(behaviors),
      operation: "getBehavior"
    });
  }
  return behavior;
}
var AVAILABLE_BEHAVIORS = Object.keys(behaviors);
var DEFAULT_BEHAVIOR = "user-managed";
function isNotFoundError(error2) {
  if (!error2)
    return false;
  const err = error2;
  return err.name === "NoSuchKey" || err.name === "NotFound" || err.code === "NoSuchKey" || err.code === "NotFound" || err.Code === "NoSuchKey" || err.Code === "NotFound" || err.statusCode === 404 || err.$metadata?.httpStatusCode === 404 || typeof err.message === "string" && err.message.includes("NoSuchKey");
}
var DANGEROUS_KEYS = ["__proto__", "constructor", "prototype"];
function isDangerousKey(key) {
  if (DANGEROUS_KEYS.includes(key)) {
    return true;
  }
  if (key.includes(".")) {
    return key.split(".").some((part) => DANGEROUS_KEYS.includes(part));
  }
  return false;
}
function sanitizeDeep(obj) {
  if (obj === null || typeof obj !== "object") {
    return obj;
  }
  if (Array.isArray(obj)) {
    return obj.map((item) => sanitizeDeep(item));
  }
  const result = {};
  for (const [key, value] of Object.entries(obj)) {
    if (!isDangerousKey(key)) {
      result[key] = sanitizeDeep(value);
    }
  }
  return result;
}
var ResourcePersistence = class {
  resource;
  constructor(resource) {
    this.resource = resource;
  }
  get client() {
    return this.resource.client;
  }
  get schema() {
    return this.resource.schema;
  }
  get validator() {
    return this.resource.validator;
  }
  get config() {
    return this.resource.config;
  }
  get name() {
    return this.resource.name;
  }
  get version() {
    return this.resource.version;
  }
  get behavior() {
    return this.resource.behavior;
  }
  get hooks() {
    return this.resource.hooks;
  }
  get logger() {
    return this.resource.logger;
  }
  get idGenerator() {
    return this.resource.idGenerator;
  }
  get versioningEnabled() {
    return this.resource.versioningEnabled;
  }
  get observers() {
    return this.resource.observers;
  }
  async insert({ id: id$1, ...attributes }) {
    this.logger.trace({ id: id$1, attributeKeys: Object.keys(attributes) }, "insert called");
    const providedId = id$1 !== void 0 && id$1 !== null && String(id$1).trim() !== "";
    if (this.config.timestamps) {
      attributes.createdAt = (/* @__PURE__ */ new Date()).toISOString();
      attributes.updatedAt = (/* @__PURE__ */ new Date()).toISOString();
    }
    const attributesWithDefaults = this.validator.applyDefaults(attributes);
    const completeData = sanitizeDeep(id$1 !== void 0 ? { id: id$1, ...attributesWithDefaults } : { ...attributesWithDefaults });
    const preProcessedData = sanitizeDeep(await this.resource.executeHooks("beforeInsert", completeData));
    const extraProps = Object.keys(preProcessedData).filter((k4) => !(k4 in completeData) || preProcessedData[k4] !== completeData[k4]);
    const extraData = {};
    for (const k4 of extraProps)
      extraData[k4] = preProcessedData[k4];
    const shouldValidateId = preProcessedData.id !== void 0 && preProcessedData.id !== null;
    const { errors: errors2, isValid, data: validated } = await this.resource.validate(preProcessedData, { includeId: shouldValidateId });
    if (!isValid) {
      const errorMsg = errors2 && errors2.length && errors2[0]?.message ? errors2[0].message : "Insert failed";
      throw new InvalidResourceItem({
        bucket: this.client.config.bucket,
        resourceName: this.name,
        attributes: preProcessedData,
        validation: errors2,
        message: errorMsg
      });
    }
    const { id: validatedId, ...validatedAttributes } = validated;
    Object.assign(validatedAttributes, extraData);
    let finalId = validatedId || preProcessedData.id || id$1;
    if (!finalId) {
      finalId = await Promise.resolve(this.idGenerator(preProcessedData));
      if (!finalId || String(finalId).trim() === "") {
        const { idGenerator: idGenerator2 } = await Promise.resolve().then(function() {
          return id;
        });
        finalId = idGenerator2();
      }
    }
    const mappedData = await this.schema.mapper(validatedAttributes);
    mappedData._v = String(this.version);
    const behaviorImpl = getBehavior(this.behavior);
    const { mappedData: processedMetadata, body: body2 } = await behaviorImpl.handleInsert({
      resource: this.resource,
      data: validatedAttributes,
      mappedData,
      originalData: completeData
    });
    const finalMetadata = processedMetadata;
    if (!finalId || String(finalId).trim() === "") {
      throw new InvalidResourceItem({
        bucket: this.client.config.bucket,
        resourceName: this.name,
        attributes: preProcessedData,
        validation: [{ message: "Generated ID is invalid", field: "id" }],
        message: "Generated ID is invalid"
      });
    }
    const shouldCheckExists = providedId || shouldValidateId || validatedId !== void 0;
    if (shouldCheckExists) {
      const alreadyExists = await this.exists(finalId);
      if (alreadyExists) {
        throw new InvalidResourceItem({
          bucket: this.client.config.bucket,
          resourceName: this.name,
          attributes: preProcessedData,
          validation: [{ message: `Resource with id '${finalId}' already exists`, field: "id" }],
          message: `Resource with id '${finalId}' already exists`
        });
      }
    }
    const key = this.resource.getResourceKey(finalId);
    let contentType = void 0;
    if (body2 && body2 !== "") {
      const [okParse] = await tryFn$1(() => Promise.resolve(JSON.parse(body2)));
      if (okParse)
        contentType = "application/json";
    }
    if (this.behavior === "body-only" && (!body2 || body2 === "")) {
      throw new ResourceError("Body required for body-only behavior", {
        resourceName: this.name,
        operation: "insert",
        id: finalId,
        statusCode: 400,
        retriable: false,
        suggestion: 'Include a request body when using behavior "body-only" or switch to "body-overflow".'
      });
    }
    const [okPut, errPut] = await tryFn$1(() => this.client.putObject({
      key,
      body: body2,
      contentType,
      metadata: finalMetadata
    }));
    if (!okPut) {
      const msg = errPut && errPut.message ? errPut.message : "";
      if (msg.includes("metadata headers exceed") || msg.includes("Insert failed")) {
        const totalSize = calculateTotalSize(finalMetadata);
        const effectiveLimit = calculateEffectiveLimit({
          s3Limit: 2047,
          systemConfig: {
            version: String(this.version),
            timestamps: this.config.timestamps,
            id: finalId
          }
        });
        const excess = totalSize - effectiveLimit;
        throw new ResourceError("metadata headers exceed", {
          resourceName: this.name,
          operation: "insert",
          id: finalId,
          totalSize,
          effectiveLimit,
          excess,
          suggestion: "Reduce metadata size or number of fields."
        });
      }
      throw errPut;
    }
    const insertedObject = await this.get(finalId);
    if (this.config.partitions && Object.keys(this.config.partitions).length > 0) {
      if (this.config.strictPartitions) {
        await this.resource.createPartitionReferences(insertedObject);
      } else if (this.config.asyncPartitions) {
        setImmediate(() => {
          this.resource.createPartitionReferences(insertedObject).catch((err) => {
            this.resource.emit("partitionIndexError", {
              operation: "insert",
              id: finalId,
              error: err,
              message: err.message
            });
          });
        });
      } else {
        const [ok, err] = await tryFn$1(() => this.resource.createPartitionReferences(insertedObject));
        if (!ok) {
          this.resource.emit("partitionIndexError", {
            operation: "insert",
            id: finalId,
            error: err,
            message: err.message
          });
        }
      }
      const nonPartitionHooks = this.hooks.afterInsert.filter((hook) => !hook.toString().includes("createPartitionReferences"));
      let finalResult = insertedObject;
      for (const hook of nonPartitionHooks) {
        finalResult = await hook(finalResult);
      }
      this.resource._emitStandardized("inserted", finalResult, finalResult?.id || insertedObject?.id);
      return finalResult;
    } else {
      const finalResult = await this.resource.executeHooks("afterInsert", insertedObject);
      this.resource._emitStandardized("inserted", finalResult, finalResult?.id || insertedObject?.id);
      return finalResult;
    }
  }
  async get(id2) {
    if (isObject_default(id2)) {
      throw new ValidationError2("Resource id must be a string", {
        field: "id",
        statusCode: 400,
        retriable: false,
        suggestion: 'Pass the resource id as a string value (e.g. "user-123").'
      });
    }
    if (isEmpty_default(id2)) {
      throw new ValidationError2("Resource id cannot be empty", {
        field: "id",
        statusCode: 400,
        retriable: false,
        suggestion: "Provide a non-empty id when calling resource methods."
      });
    }
    await this.resource.executeHooks("beforeGet", { id: id2 });
    const key = this.resource.getResourceKey(id2);
    const [ok, err, request2] = await tryFn$1(() => this.client.getObject(key));
    if (!ok || !request2) {
      throw mapAwsError(err, {
        bucket: this.client.config.bucket,
        key,
        resourceName: this.name,
        operation: "get",
        id: id2
      });
    }
    const objectVersionRaw = request2.Metadata?._v || this.version;
    const objectVersion = typeof objectVersionRaw === "string" && objectVersionRaw.startsWith("v") ? objectVersionRaw.slice(1) : objectVersionRaw;
    const schema = await this.resource.getSchemaForVersion(objectVersion);
    let metadata = await schema.unmapper(request2.Metadata || {});
    const behaviorImpl = getBehavior(this.behavior);
    let body2 = "";
    if (request2.ContentLength && request2.ContentLength > 0) {
      const [okBody, , fullObject] = await tryFn$1(() => this.client.getObject(key));
      if (okBody && fullObject?.Body) {
        const bodyBytes = await fullObject.Body.transformToByteArray();
        body2 = Buffer.from(bodyBytes).toString("utf-8");
      }
    }
    const { metadata: processedMetadata } = await behaviorImpl.handleGet({
      resource: this.resource,
      metadata,
      body: body2
    });
    let data2 = await this.resource.composeFullObjectFromWrite({
      id: id2,
      metadata: processedMetadata,
      body: body2,
      behavior: this.behavior
    });
    data2._contentLength = request2.ContentLength;
    data2._lastModified = request2.LastModified;
    data2._hasContent = (request2.ContentLength || 0) > 0;
    data2._mimeType = request2.ContentType || null;
    data2._etag = request2.ETag;
    data2._v = objectVersion;
    if (request2.VersionId)
      data2._versionId = request2.VersionId;
    if (request2.Expiration)
      data2._expiresAt = request2.Expiration;
    data2._definitionHash = this.resource.getDefinitionHash();
    if (objectVersion !== this.version) {
      data2 = await this.resource.applyVersionMapping(data2, objectVersion, this.version);
    }
    data2 = await this.resource.executeHooks("afterGet", data2);
    this.resource._emitStandardized("fetched", data2, data2.id);
    return data2;
  }
  async getOrNull(id2) {
    const [ok, err, data2] = await tryFn$1(() => this.get(id2));
    if (!ok && err && isNotFoundError(err)) {
      return null;
    }
    if (!ok || !data2)
      throw err;
    return data2;
  }
  async getOrThrow(id2) {
    const [ok, err, data2] = await tryFn$1(() => this.get(id2));
    if (!ok && err && isNotFoundError(err)) {
      throw new ResourceError(`Resource '${this.name}' with id '${id2}' not found`, {
        resourceName: this.name,
        operation: "getOrThrow",
        id: id2,
        code: "RESOURCE_NOT_FOUND"
      });
    }
    if (!ok || !data2)
      throw err;
    return data2;
  }
  async exists(id2) {
    await this.resource.executeHooks("beforeExists", { id: id2 });
    const key = this.resource.getResourceKey(id2);
    const [ok, err] = await tryFn$1(() => this.client.headObject(key));
    if (!ok && err) {
      if (!isNotFoundError(err)) {
        throw err;
      }
    }
    await this.resource.executeHooks("afterExists", { id: id2, exists: ok });
    return ok;
  }
  async delete(id2) {
    if (isEmpty_default(id2)) {
      throw new ValidationError2("Resource id cannot be empty", {
        field: "id",
        statusCode: 400,
        retriable: false,
        suggestion: "Provide the target id when calling delete()."
      });
    }
    let objectData;
    let deleteError = null;
    const [ok, err, data2] = await tryFn$1(() => this.get(id2));
    if (ok && data2) {
      objectData = data2;
    } else {
      objectData = { id: id2 };
      deleteError = err;
    }
    await this.resource.executeHooks("beforeDelete", objectData);
    const key = this.resource.getResourceKey(id2);
    const [ok2, err2, response2] = await tryFn$1(() => this.client.deleteObject(key));
    if (this.config.partitions && Object.keys(this.config.partitions).length > 0 && objectData) {
      if (this.config.strictPartitions) {
        await this.resource.deletePartitionReferences(objectData);
      } else if (this.config.asyncPartitions) {
        setImmediate(() => {
          this.resource.deletePartitionReferences(objectData).catch((err3) => {
            this.resource.emit("partitionIndexError", {
              operation: "delete",
              id: id2,
              error: err3,
              message: err3.message
            });
          });
        });
      } else {
        const [okDel, errDel] = await tryFn$1(() => this.resource.deletePartitionReferences(objectData));
        if (!okDel) {
          this.resource.emit("partitionIndexError", {
            operation: "delete",
            id: id2,
            error: errDel,
            message: errDel.message
          });
        }
      }
      const nonPartitionHooks = this.hooks.afterDelete.filter((hook) => !hook.toString().includes("deletePartitionReferences"));
      let afterDeleteData = objectData;
      for (const hook of nonPartitionHooks) {
        afterDeleteData = await hook(afterDeleteData);
      }
    } else {
      await this.resource.executeHooks("afterDelete", objectData);
    }
    this.resource._emitStandardized("deleted", {
      ...objectData,
      $before: { ...objectData },
      $after: null
    }, id2);
    if (deleteError) {
      throw mapAwsError(deleteError, {
        bucket: this.client.config.bucket,
        key,
        resourceName: this.name,
        operation: "delete",
        id: id2
      });
    }
    if (!ok2)
      throw mapAwsError(err2, {
        key,
        resourceName: this.name,
        operation: "delete",
        id: id2
      });
    return response2;
  }
  async upsert({ id: id2, ...attributes }) {
    if (!id2) {
      throw new ValidationError2("Resource id is required for upsert", {
        field: "id",
        statusCode: 400,
        retriable: false,
        suggestion: "Provide an id when calling upsert()."
      });
    }
    const exists = await this.exists(id2);
    if (exists) {
      return this.update(id2, attributes);
    }
    return this.insert({ id: id2, ...attributes });
  }
  async insertMany(objects) {
    const operations = objects.map((attributes) => async () => {
      return await this.insert(attributes);
    });
    const { results } = await this._executeBatchHelper(operations, {
      onItemError: (error2, index) => {
        this.resource.emit("error", error2, objects[index]);
        this.observers.map((x4) => x4.emit("error", this.name, error2, objects[index]));
      }
    });
    this.resource._emitStandardized("inserted-many", objects.length);
    return results.filter((r4) => r4 !== null);
  }
  async deleteMany(ids) {
    const operations = ids.map((id2) => async () => {
      return await this.delete(id2);
    });
    const { results, errors: errors2 } = await this._executeBatchHelper(operations, {
      onItemError: (error2, index) => {
        this.resource.emit("error", error2, ids[index]);
        this.observers.map((x4) => x4.emit("error", this.name, error2, ids[index]));
      }
    });
    this.resource._emitStandardized("deleted-many", ids.length);
    return { deleted: results.filter((r4) => r4 !== null).length, errors: errors2.length };
  }
  async update(id2, attributes) {
    if (isEmpty_default(id2)) {
      throw new ValidationError2("Resource id cannot be empty", {
        field: "id",
        statusCode: 400,
        retriable: false,
        suggestion: "Provide the target id when calling update()."
      });
    }
    const exists = await this.exists(id2);
    if (!exists) {
      throw new ResourceError(`Resource with id '${id2}' does not exist`, {
        resourceName: this.name,
        id: id2,
        statusCode: 404,
        retriable: false,
        suggestion: "Ensure the record exists or create it before attempting an update."
      });
    }
    const originalData = await this.get(id2);
    let mergedData = { ...originalData };
    for (const [key2, value] of Object.entries(attributes)) {
      if (key2.includes(".")) {
        const parts = key2.split(".");
        let ref = mergedData;
        for (let i4 = 0; i4 < parts.length - 1; i4++) {
          const part = parts[i4];
          if (typeof ref[part] !== "object" || ref[part] === null) {
            ref[part] = {};
          } else if (i4 === 0) {
            ref[part] = { ...ref[part] };
          }
          ref = ref[part];
        }
        const finalKey = parts[parts.length - 1];
        ref[finalKey] = typeof value === "object" && value !== null ? Array.isArray(value) ? [...value] : { ...value } : value;
      } else if (typeof value === "object" && value !== null && !Array.isArray(value)) {
        mergedData[key2] = { ...mergedData[key2] || {}, ...value };
      } else {
        mergedData[key2] = Array.isArray(value) ? [...value] : value;
      }
    }
    if (this.config.timestamps) {
      const now = (/* @__PURE__ */ new Date()).toISOString();
      mergedData.updatedAt = now;
      if (!mergedData.metadata)
        mergedData.metadata = {};
      else
        mergedData.metadata = { ...mergedData.metadata };
      mergedData.metadata.updatedAt = now;
    }
    mergedData = sanitizeDeep(mergedData);
    const preProcessedData = sanitizeDeep(await this.resource.executeHooks("beforeUpdate", mergedData));
    const completeData = { ...originalData, ...preProcessedData, id: id2 };
    const { isValid, errors: errors2, data: data2 } = await this.resource.validate(completeData, { includeId: true });
    if (!isValid) {
      throw new InvalidResourceItem({
        bucket: this.client.config.bucket,
        resourceName: this.name,
        attributes: preProcessedData,
        validation: errors2,
        message: "validation: " + (errors2 && errors2.length ? JSON.stringify(errors2) : "unknown")
      });
    }
    const earlyBehaviorImpl = getBehavior(this.behavior);
    const tempMappedData = await this.schema.mapper({ ...originalData, ...preProcessedData });
    tempMappedData._v = String(this.version);
    await earlyBehaviorImpl.handleUpdate({
      resource: this.resource,
      id: id2,
      data: { ...originalData, ...preProcessedData },
      mappedData: tempMappedData,
      originalData: { ...attributes, id: id2 }
    });
    const { id: validatedId, ...validatedAttributes } = data2;
    const oldData = { ...originalData, id: id2 };
    const newData = { ...validatedAttributes, id: id2 };
    await this.resource.handlePartitionReferenceUpdates(oldData, newData);
    const mappedData = await this.schema.mapper(validatedAttributes);
    mappedData._v = String(this.version);
    const behaviorImpl = getBehavior(this.behavior);
    const { mappedData: processedMetadata, body: body2 } = await behaviorImpl.handleUpdate({
      resource: this.resource,
      id: id2,
      data: validatedAttributes,
      mappedData,
      originalData: { ...attributes, id: id2 }
    });
    const finalMetadata = processedMetadata;
    const key = this.resource.getResourceKey(id2);
    let existingContentType = void 0;
    let finalBody = body2;
    if (body2 === "" && this.behavior !== "body-overflow") {
      const [ok2, , existingObject] = await tryFn$1(() => this.client.getObject(key));
      if (ok2 && existingObject && existingObject.ContentLength && existingObject.ContentLength > 0 && existingObject.Body) {
        const existingBodyBuffer = Buffer.from(await existingObject.Body.transformToByteArray());
        const existingBodyString = existingBodyBuffer.toString();
        const [okParse] = await tryFn$1(() => Promise.resolve(JSON.parse(existingBodyString)));
        if (!okParse) {
          finalBody = existingBodyBuffer;
          existingContentType = existingObject.ContentType;
        }
      }
    }
    let finalContentType = existingContentType;
    if (finalBody && finalBody !== "" && !finalContentType) {
      const [okParse] = await tryFn$1(() => Promise.resolve(JSON.parse(finalBody)));
      if (okParse)
        finalContentType = "application/json";
    }
    const [ok, err] = await tryFn$1(() => this.client.putObject({
      key,
      body: finalBody,
      contentType: finalContentType,
      metadata: finalMetadata
    }));
    if (!ok && err && err.message && err.message.includes("metadata headers exceed")) {
      const totalSize = calculateTotalSize(finalMetadata);
      const effectiveLimit = calculateEffectiveLimit({
        s3Limit: 2047,
        systemConfig: {
          version: String(this.version),
          timestamps: this.config.timestamps,
          id: id2
        }
      });
      const excess = totalSize - effectiveLimit;
      this.resource.emit("exceedsLimit", {
        operation: "update",
        totalSize,
        limit: 2047,
        effectiveLimit,
        excess,
        data: validatedAttributes
      });
      throw new ResourceError("metadata headers exceed", {
        resourceName: this.name,
        operation: "update",
        id: id2,
        totalSize,
        effectiveLimit,
        excess,
        suggestion: "Reduce metadata size or number of fields."
      });
    } else if (!ok) {
      throw mapAwsError(err, {
        bucket: this.client.config.bucket,
        key,
        resourceName: this.name,
        operation: "update",
        id: id2
      });
    }
    if (this.versioningEnabled && originalData._v !== this.version) {
      const [okHistory, errHistory] = await tryFn$1(() => this.resource.createHistoricalVersion(id2, originalData));
      if (!okHistory) {
        this.resource.emit("historyError", {
          operation: "update",
          id: id2,
          error: errHistory,
          message: errHistory.message
        });
      }
    }
    const updatedData = await this.resource.composeFullObjectFromWrite({
      id: id2,
      metadata: finalMetadata,
      body: finalBody,
      behavior: this.behavior
    });
    if (this.config.partitions && Object.keys(this.config.partitions).length > 0) {
      if (this.config.strictPartitions) {
        await this.resource.handlePartitionReferenceUpdates(originalData, updatedData);
      } else if (this.config.asyncPartitions) {
        setImmediate(() => {
          this.resource.handlePartitionReferenceUpdates(originalData, updatedData).catch((err2) => {
            this.resource.emit("partitionIndexError", {
              operation: "update",
              id: id2,
              error: err2,
              message: err2.message
            });
          });
        });
      } else {
        const [ok2, err2] = await tryFn$1(() => this.resource.handlePartitionReferenceUpdates(originalData, updatedData));
        if (!ok2) {
          this.resource.emit("partitionIndexError", {
            operation: "update",
            id: id2,
            error: err2,
            message: err2.message
          });
        }
      }
      const nonPartitionHooks = this.hooks.afterUpdate.filter((hook) => !hook.toString().includes("handlePartitionReferenceUpdates"));
      let finalResult = updatedData;
      for (const hook of nonPartitionHooks) {
        finalResult = await hook(finalResult);
      }
      this.resource._emitStandardized("updated", {
        ...updatedData,
        $before: { ...originalData },
        $after: { ...finalResult }
      }, updatedData.id);
      return finalResult;
    } else {
      const finalResult = await this.resource.executeHooks("afterUpdate", updatedData);
      this.resource._emitStandardized("updated", {
        ...updatedData,
        $before: { ...originalData },
        $after: { ...finalResult }
      }, updatedData.id);
      return finalResult;
    }
  }
  async _executeBatchHelper(operations, options = {}) {
    if (this.client._executeBatch) {
      return await this.client._executeBatch(operations, options);
    }
    const settled = await Promise.allSettled(operations.map((op2) => op2()));
    const results = settled.map((s4, index) => {
      if (s4.status === "fulfilled")
        return s4.value;
      if (options.onItemError)
        options.onItemError(s4.reason, index);
      return null;
    });
    const errors2 = settled.map((s4, index) => s4.status === "rejected" ? { error: s4.reason, index } : null).filter((e4) => e4 !== null);
    return { results, errors: errors2 };
  }
  async patch(id2, fields, options = {}) {
    if (isEmpty_default(id2)) {
      throw new ValidationError2("Resource id cannot be empty", {
        field: "id",
        statusCode: 400,
        retriable: false,
        suggestion: "Provide the target id when calling patch()."
      });
    }
    if (!fields || typeof fields !== "object") {
      throw new ValidationError2("fields must be a non-empty object", {
        field: "fields",
        statusCode: 400,
        retriable: false,
        suggestion: 'Pass a plain object with the fields to update (e.g. { status: "active" }).'
      });
    }
    await this.resource.executeHooks("beforePatch", { id: id2, fields, options });
    const behavior = this.behavior;
    const hasNestedFields = Object.keys(fields).some((key) => key.includes("."));
    let result;
    if ((behavior === "enforce-limits" || behavior === "truncate-data") && !hasNestedFields) {
      result = await this._patchViaCopyObject(id2, fields, options);
    } else {
      result = await this.update(id2, fields);
    }
    const finalResult = await this.resource.executeHooks("afterPatch", result);
    return finalResult;
  }
  async _patchViaCopyObject(id2, fields, options = {}) {
    const key = this.resource.getResourceKey(id2);
    const headResponse = await this.client.headObject(key);
    const currentMetadata = headResponse.Metadata || {};
    let currentData = await this.schema.unmapper(currentMetadata);
    if (!currentData.id) {
      currentData.id = id2;
    }
    let mergedData = { ...currentData };
    for (const [fieldKey, value] of Object.entries(fields)) {
      if (typeof value === "object" && value !== null && !Array.isArray(value)) {
        mergedData[fieldKey] = { ...mergedData[fieldKey] || {}, ...value };
      } else {
        mergedData[fieldKey] = Array.isArray(value) ? [...value] : value;
      }
    }
    if (this.config.timestamps) {
      mergedData.updatedAt = (/* @__PURE__ */ new Date()).toISOString();
    }
    mergedData = sanitizeDeep(mergedData);
    const { isValid, errors: errors2 } = await this.validator.validate(mergedData);
    if (!isValid) {
      throw new ValidationError2("Validation failed during patch", {
        validation: errors2
      });
    }
    const newMetadata = await this.schema.mapper(mergedData);
    newMetadata._v = String(this.version);
    await this.client.copyObject({
      from: key,
      to: key,
      metadataDirective: "REPLACE",
      metadata: newMetadata
    });
    if (this.config.partitions && Object.keys(this.config.partitions).length > 0) {
      const oldData = { ...currentData, id: id2 };
      const newData = { ...mergedData, id: id2 };
      if (this.config.strictPartitions) {
        await this.resource.handlePartitionReferenceUpdates(oldData, newData);
      } else if (this.config.asyncPartitions) {
        setImmediate(() => {
          this.resource.handlePartitionReferenceUpdates(oldData, newData).catch((err) => {
            this.resource.emit("partitionIndexError", {
              operation: "patch",
              id: id2,
              error: err
            });
          });
        });
      } else {
        await this.resource.handlePartitionReferenceUpdates(oldData, newData);
      }
    }
    return mergedData;
  }
  async replace(id2, fullData, options = {}) {
    if (isEmpty_default(id2)) {
      throw new ValidationError2("Resource id cannot be empty", {
        field: "id",
        statusCode: 400,
        retriable: false,
        suggestion: "Provide the target id when calling replace()."
      });
    }
    if (!fullData || typeof fullData !== "object") {
      throw new ValidationError2("fullData must be a non-empty object", {
        field: "fullData",
        statusCode: 400,
        retriable: false,
        suggestion: "Pass a plain object containing the full resource payload to replace()."
      });
    }
    await this.resource.executeHooks("beforeReplace", { id: id2, fullData, options });
    const dataClone = { ...fullData };
    const attributesWithDefaults = this.validator.applyDefaults(dataClone);
    if (this.config.timestamps) {
      if (!attributesWithDefaults.createdAt) {
        attributesWithDefaults.createdAt = (/* @__PURE__ */ new Date()).toISOString();
      }
      attributesWithDefaults.updatedAt = (/* @__PURE__ */ new Date()).toISOString();
    }
    const completeData = sanitizeDeep({ id: id2, ...attributesWithDefaults });
    const { errors: errors2, isValid, data: validated } = await this.resource.validate(completeData, { includeId: true });
    if (!isValid) {
      const errorMsg = errors2 && errors2.length && errors2[0]?.message ? errors2[0].message : "Replace failed";
      throw new InvalidResourceItem({
        bucket: this.client.config.bucket,
        resourceName: this.name,
        attributes: completeData,
        validation: errors2,
        message: errorMsg
      });
    }
    const { id: validatedId, ...validatedAttributes } = validated;
    const mappedMetadata = await this.schema.mapper(validatedAttributes);
    mappedMetadata._v = String(this.version);
    const behaviorImpl = getBehavior(this.behavior);
    const { mappedData: finalMetadata, body: body2 } = await behaviorImpl.handleInsert({
      resource: this.resource,
      data: validatedAttributes,
      mappedData: mappedMetadata,
      originalData: completeData
    });
    const key = this.resource.getResourceKey(id2);
    let contentType = void 0;
    if (body2 && body2 !== "") {
      const [okParse] = await tryFn$1(() => Promise.resolve(JSON.parse(body2)));
      if (okParse)
        contentType = "application/json";
    }
    if (this.behavior === "body-only" && (!body2 || body2 === "")) {
      throw new ResourceError("Body required for body-only behavior", {
        resourceName: this.name,
        operation: "replace",
        id: id2,
        statusCode: 400,
        retriable: false,
        suggestion: 'Include a request body when using behavior "body-only" or switch to "body-overflow".'
      });
    }
    const [okPut, errPut] = await tryFn$1(() => this.client.putObject({
      key,
      body: body2,
      contentType,
      metadata: finalMetadata
    }));
    if (!okPut) {
      const msg = errPut && errPut.message ? errPut.message : "";
      if (msg.includes("metadata headers exceed") || msg.includes("Replace failed")) {
        const totalSize = calculateTotalSize(finalMetadata);
        const effectiveLimit = calculateEffectiveLimit({
          s3Limit: 2047,
          systemConfig: {
            version: String(this.version),
            timestamps: this.config.timestamps,
            id: id2
          }
        });
        const excess = totalSize - effectiveLimit;
        errPut.totalSize = totalSize;
        errPut.limit = 2047;
        errPut.effectiveLimit = effectiveLimit;
        errPut.excess = excess;
        throw new ResourceError("metadata headers exceed", { resourceName: this.name, operation: "replace", id: id2, totalSize, effectiveLimit, excess, suggestion: "Reduce metadata size or number of fields." });
      }
      throw errPut;
    }
    const replacedObject = { id: id2, ...validatedAttributes };
    if (this.config.partitions && Object.keys(this.config.partitions).length > 0) {
      if (this.config.strictPartitions) {
        await this.resource.handlePartitionReferenceUpdates({}, replacedObject);
      } else if (this.config.asyncPartitions) {
        setImmediate(() => {
          this.resource.handlePartitionReferenceUpdates({}, replacedObject).catch((err) => {
            this.resource.emit("partitionIndexError", {
              operation: "replace",
              id: id2,
              error: err
            });
          });
        });
      } else {
        await this.resource.handlePartitionReferenceUpdates({}, replacedObject);
      }
    }
    const finalResult = await this.resource.executeHooks("afterReplace", replacedObject);
    return finalResult;
  }
  async updateConditional(id2, attributes, options) {
    if (isEmpty_default(id2)) {
      throw new ValidationError2("Resource id cannot be empty", {
        field: "id",
        statusCode: 400,
        retriable: false,
        suggestion: "Provide the target id when calling updateConditional()."
      });
    }
    const { ifMatch } = options;
    if (!ifMatch) {
      throw new ValidationError2("updateConditional requires ifMatch option with ETag value", {
        field: "ifMatch",
        statusCode: 428,
        retriable: false,
        suggestion: "Pass the current object ETag in options.ifMatch to enable conditional updates."
      });
    }
    const exists = await this.exists(id2);
    if (!exists) {
      return {
        success: false,
        error: `Resource with id '${id2}' does not exist`
      };
    }
    const originalData = await this.get(id2);
    let mergedData = { ...originalData };
    for (const [key2, value] of Object.entries(attributes)) {
      if (key2.includes(".")) {
        const parts = key2.split(".");
        let ref = mergedData;
        for (let i4 = 0; i4 < parts.length - 1; i4++) {
          const part = parts[i4];
          if (typeof ref[part] !== "object" || ref[part] === null) {
            ref[part] = {};
          } else if (i4 === 0) {
            ref[part] = { ...ref[part] };
          }
          ref = ref[part];
        }
        const finalKey = parts[parts.length - 1];
        ref[finalKey] = typeof value === "object" && value !== null ? Array.isArray(value) ? [...value] : { ...value } : value;
      } else if (typeof value === "object" && value !== null && !Array.isArray(value)) {
        mergedData[key2] = { ...mergedData[key2] || {}, ...value };
      } else {
        mergedData[key2] = Array.isArray(value) ? [...value] : value;
      }
    }
    if (this.config.timestamps) {
      const now = (/* @__PURE__ */ new Date()).toISOString();
      mergedData.updatedAt = now;
      if (!mergedData.metadata)
        mergedData.metadata = {};
      else
        mergedData.metadata = { ...mergedData.metadata };
      mergedData.metadata.updatedAt = now;
    }
    mergedData = sanitizeDeep(mergedData);
    const preProcessedData = sanitizeDeep(await this.resource.executeHooks("beforeUpdate", mergedData));
    const completeData = { ...originalData, ...preProcessedData, id: id2 };
    const { isValid, errors: errors2, data: data2 } = await this.resource.validate(completeData, { includeId: true });
    if (!isValid) {
      return {
        success: false,
        error: "Validation failed: " + (errors2 && errors2.length ? JSON.stringify(errors2) : "unknown"),
        validationErrors: errors2
      };
    }
    const { id: validatedId, ...validatedAttributes } = data2;
    const mappedData = await this.schema.mapper(validatedAttributes);
    mappedData._v = String(this.version);
    const behaviorImpl = getBehavior(this.behavior);
    const { mappedData: processedMetadata, body: body2 } = await behaviorImpl.handleUpdate({
      resource: this.resource,
      id: id2,
      data: validatedAttributes,
      mappedData,
      originalData: { ...attributes, id: id2 }
    });
    const key = this.resource.getResourceKey(id2);
    let existingContentType = void 0;
    let finalBody = body2;
    if (body2 === "" && this.behavior !== "body-overflow") {
      const [okGet, , existingObject] = await tryFn$1(() => this.client.getObject(key));
      if (okGet && existingObject && existingObject.ContentLength && existingObject.ContentLength > 0 && existingObject.Body) {
        const existingBodyBuffer = Buffer.from(await existingObject.Body.transformToByteArray());
        const existingBodyString = existingBodyBuffer.toString();
        const [okParse] = await tryFn$1(() => Promise.resolve(JSON.parse(existingBodyString)));
        if (!okParse) {
          finalBody = existingBodyBuffer;
          existingContentType = existingObject.ContentType;
        }
      }
    }
    let finalContentType = existingContentType;
    if (finalBody && finalBody !== "" && !finalContentType) {
      const [okParse] = await tryFn$1(() => Promise.resolve(JSON.parse(finalBody)));
      if (okParse)
        finalContentType = "application/json";
    }
    const [ok, err, response2] = await tryFn$1(() => this.client.putObject({
      key,
      body: finalBody,
      contentType: finalContentType,
      metadata: processedMetadata,
      ifMatch
    }));
    if (!ok) {
      if (err.name === "PreconditionFailed" || err.$metadata?.httpStatusCode === 412) {
        return {
          success: false,
          error: "ETag mismatch - object was modified by another process"
        };
      }
      return {
        success: false,
        error: err.message || "Update failed"
      };
    }
    if (this.versioningEnabled && originalData._v !== this.version) {
      const [okHistory, errHistory] = await tryFn$1(() => this.resource.createHistoricalVersion(id2, originalData));
      if (!okHistory) {
        this.resource.emit("historyError", {
          operation: "updateConditional",
          id: id2,
          error: errHistory,
          message: errHistory.message
        });
      }
    }
    const updatedData = await this.resource.composeFullObjectFromWrite({
      id: id2,
      metadata: processedMetadata,
      body: finalBody,
      behavior: this.behavior
    });
    const oldData = { ...originalData, id: id2 };
    const newData = { ...validatedAttributes, id: id2 };
    if (this.config.partitions && Object.keys(this.config.partitions).length > 0) {
      if (this.config.strictPartitions) {
        await this.resource.handlePartitionReferenceUpdates(oldData, newData);
      } else if (this.config.asyncPartitions) {
        setImmediate(() => {
          this.resource.handlePartitionReferenceUpdates(oldData, newData).catch((err2) => {
            this.resource.emit("partitionIndexError", {
              operation: "updateConditional",
              id: id2,
              error: err2,
              message: err2.message
            });
          });
        });
      } else {
        const [okPartition, errPartition] = await tryFn$1(() => this.resource.handlePartitionReferenceUpdates(oldData, newData));
        if (!okPartition) {
          this.resource.emit("partitionIndexError", {
            operation: "updateConditional",
            id: id2,
            error: errPartition,
            message: errPartition.message
          });
        }
      }
      const nonPartitionHooks = this.hooks.afterUpdate.filter((hook) => !hook.toString().includes("handlePartitionReferenceUpdates"));
      let finalResult = updatedData;
      for (const hook of nonPartitionHooks) {
        finalResult = await hook(finalResult);
      }
      this.resource._emitStandardized("updated", {
        ...updatedData,
        $before: { ...originalData },
        $after: { ...finalResult }
      }, updatedData.id);
      return {
        success: true,
        data: finalResult,
        etag: response2?.ETag
      };
    } else {
      await this.resource.handlePartitionReferenceUpdates(oldData, newData);
      const finalResult = await this.resource.executeHooks("afterUpdate", updatedData);
      this.resource._emitStandardized("updated", {
        ...updatedData,
        $before: { ...originalData },
        $after: { ...finalResult }
      }, updatedData.id);
      return {
        success: true,
        data: finalResult,
        etag: response2?.ETag
      };
    }
  }
  async deleteAll() {
    if (this.config.paranoid !== false) {
      throw new ResourceError("deleteAll() is a dangerous operation and requires paranoid: false option.", {
        resourceName: this.name,
        operation: "deleteAll",
        paranoid: this.config.paranoid,
        suggestion: "Set paranoid: false to allow deleteAll."
      });
    }
    const prefix = `resource=${this.name}/data`;
    const deletedCount = await this.client.deleteAll({ prefix });
    this.resource._emitStandardized("deleted-all", {
      version: this.version,
      prefix,
      deletedCount
    });
    return { deletedCount, version: this.version };
  }
  async deleteAllData() {
    if (this.config.paranoid !== false) {
      throw new ResourceError("deleteAllData() is a dangerous operation and requires paranoid: false option.", {
        resourceName: this.name,
        operation: "deleteAllData",
        paranoid: this.config.paranoid,
        suggestion: "Set paranoid: false to allow deleteAllData."
      });
    }
    const prefix = `resource=${this.name}`;
    const deletedCount = await this.client.deleteAll({ prefix });
    this.resource._emitStandardized("deleted-all-data", {
      resource: this.name,
      prefix,
      deletedCount
    });
    return { deletedCount, resource: this.name };
  }
};
function validateResourceConfig(config) {
  const errors2 = [];
  if (!config.name) {
    errors2.push("Resource 'name' is required");
  } else if (typeof config.name !== "string") {
    errors2.push("Resource 'name' must be a string");
  } else if (config.name.trim() === "") {
    errors2.push("Resource 'name' cannot be empty");
  } else if (!isValidS3KeySegment(config.name)) {
    errors2.push(`Resource 'name' must be URL-friendly (no /, \\, =, or %). Got: '${config.name}'`);
  }
  if (!config.client) {
    errors2.push("S3 'client' is required");
  }
  if (!config.attributes) {
    errors2.push("Resource 'attributes' are required");
  } else if (typeof config.attributes !== "object" || Array.isArray(config.attributes)) {
    errors2.push("Resource 'attributes' must be an object");
  } else if (Object.keys(config.attributes).length === 0) {
    errors2.push("Resource 'attributes' cannot be empty");
  }
  if (config.version !== void 0 && typeof config.version !== "string") {
    errors2.push("Resource 'version' must be a string");
  }
  if (config.behavior !== void 0 && typeof config.behavior !== "string") {
    errors2.push("Resource 'behavior' must be a string");
  }
  if (config.passphrase !== void 0 && typeof config.passphrase !== "string") {
    errors2.push("Resource 'passphrase' must be a string");
  }
  if (config.observers !== void 0 && !Array.isArray(config.observers)) {
    errors2.push("Resource 'observers' must be an array");
  }
  const booleanFields = ["cache", "autoDecrypt", "timestamps", "paranoid", "allNestedObjectsOptional"];
  for (const field of booleanFields) {
    if (config[field] !== void 0 && typeof config[field] !== "boolean") {
      errors2.push(`Resource '${field}' must be a boolean`);
    }
  }
  if (config.idGenerator !== void 0) {
    const isValidFunction = typeof config.idGenerator === "function";
    const isValidNumber = typeof config.idGenerator === "number";
    const isValidIncremental = typeof config.idGenerator === "string" && (config.idGenerator === "incremental" || config.idGenerator.startsWith("incremental:"));
    const isValidIncrementalObject = typeof config.idGenerator === "object" && config.idGenerator !== null && config.idGenerator.type === "incremental";
    if (!isValidFunction && !isValidNumber && !isValidIncremental && !isValidIncrementalObject) {
      errors2.push("Resource 'idGenerator' must be a function, number (size), 'incremental' string, or incremental config object");
    } else if (isValidNumber && config.idGenerator <= 0) {
      errors2.push("Resource 'idGenerator' size must be greater than 0");
    }
  }
  if (config.idSize !== void 0) {
    if (typeof config.idSize !== "number" || !Number.isInteger(config.idSize)) {
      errors2.push("Resource 'idSize' must be an integer");
    } else if (config.idSize <= 0) {
      errors2.push("Resource 'idSize' must be greater than 0");
    }
  }
  if (config.partitions !== void 0) {
    if (typeof config.partitions !== "object" || Array.isArray(config.partitions)) {
      errors2.push("Resource 'partitions' must be an object");
    } else {
      for (const [partitionName, partitionDef] of Object.entries(config.partitions)) {
        if (!isValidS3KeySegment(partitionName)) {
          errors2.push(`Partition name '${partitionName}' must be URL-friendly (no /, \\, =, or %)`);
        } else if (typeof partitionDef !== "object" || Array.isArray(partitionDef)) {
          errors2.push(`Partition '${partitionName}' must be an object`);
        } else if (!partitionDef.fields) {
          errors2.push(`Partition '${partitionName}' must have a 'fields' property`);
        } else if (typeof partitionDef.fields !== "object" || Array.isArray(partitionDef.fields)) {
          errors2.push(`Partition '${partitionName}.fields' must be an object`);
        } else {
          for (const [fieldName, fieldType] of Object.entries(partitionDef.fields)) {
            if (!isValidS3KeySegment(fieldName)) {
              errors2.push(`Partition field '${fieldName}' must be URL-friendly (no /, \\, =, or %)`);
            } else if (typeof fieldType !== "string") {
              errors2.push(`Partition '${partitionName}.fields.${fieldName}' must be a string`);
            }
          }
        }
      }
    }
  }
  if (config.hooks !== void 0) {
    if (typeof config.hooks !== "object" || Array.isArray(config.hooks)) {
      errors2.push("Resource 'hooks' must be an object");
    } else {
      const validHookEvents = [
        "beforeInsert",
        "afterInsert",
        "beforeUpdate",
        "afterUpdate",
        "beforeDelete",
        "afterDelete",
        "beforeGet",
        "afterGet",
        "beforeList",
        "afterList",
        "beforeQuery",
        "afterQuery",
        "beforeExists",
        "afterExists",
        "beforeCount",
        "afterCount",
        "beforePatch",
        "afterPatch",
        "beforeReplace",
        "afterReplace",
        "beforeGetMany",
        "afterGetMany",
        "beforeDeleteMany",
        "afterDeleteMany"
      ];
      for (const [event, hooksArr] of Object.entries(config.hooks)) {
        if (!validHookEvents.includes(event)) {
          errors2.push(`Invalid hook event '${event}'. Valid events: ${validHookEvents.join(", ")}`);
        } else if (!Array.isArray(hooksArr)) {
          errors2.push(`Resource 'hooks.${event}' must be an array`);
        }
      }
    }
  }
  if (config.events !== void 0) {
    if (typeof config.events !== "object" || Array.isArray(config.events)) {
      errors2.push("Resource 'events' must be an object");
    } else {
      for (const [eventName, listeners] of Object.entries(config.events)) {
        if (Array.isArray(listeners)) {
          for (let i4 = 0; i4 < listeners.length; i4++) {
            const listener = listeners[i4];
            if (typeof listener !== "function") {
              errors2.push(`Resource 'events.${eventName}[${i4}]' must be a function`);
            }
          }
        } else if (typeof listeners !== "function") {
          errors2.push(`Resource 'events.${eventName}' must be a function or array of functions`);
        }
      }
    }
  }
  return {
    isValid: errors2.length === 0,
    errors: errors2
  };
}
var Resource = class extends AsyncEventEmitter {
  name;
  client;
  version;
  logLevel;
  logger;
  behavior;
  _resourceAsyncEvents;
  observers;
  passphrase;
  bcryptRounds;
  versioningEnabled;
  strictValidation;
  asyncEvents;
  idGenerator;
  idSize;
  idGeneratorType;
  config;
  validator;
  schema;
  $schema;
  hooks;
  attributes;
  guard;
  eventsDisabled;
  database;
  map;
  _schemaRegistry;
  _pluginSchemaRegistry;
  _lazySchema;
  _schemaCompiled;
  _pendingSchemaConfig;
  _instanceId;
  _idGenerator;
  _hooksModule;
  _partitions;
  _eventsModule;
  _guards;
  _middleware;
  _query;
  _content;
  _streams;
  _persistence;
  constructor(config = {}) {
    super();
    this._instanceId = idGenerator(7);
    const validation = validateResourceConfig(config);
    if (!validation.isValid) {
      const errorDetails = validation.errors.map((err) => `  \u2022 ${err}`).join("\n");
      throw new ResourceError(`Invalid Resource ${config.name || "[unnamed]"} configuration:
${errorDetails}`, {
        resourceName: config.name,
        validation: validation.errors
      });
    }
    const { name, client: client2, version = "1", attributes = {}, behavior = DEFAULT_BEHAVIOR, passphrase = "secret", bcryptRounds = 10, observers = [], cache: cache5 = false, autoEncrypt = true, autoDecrypt = true, timestamps = false, partitions = {}, paranoid = true, allNestedObjectsOptional = true, hooks = {}, idGenerator: customIdGenerator, idSize = 22, versioningEnabled = false, strictValidation = true, events: events2 = {}, asyncEvents = true, asyncPartitions = true, strictPartitions = false, createdBy = "user", guard, schemaRegistry, pluginSchemaRegistry, lazySchema = false } = config;
    this.name = name;
    this.client = client2;
    this.version = version;
    this.logLevel = config.logLevel || config.client?.logLevel || config.database?.logger.level || "info";
    if (config.database && config.database.getChildLogger) {
      this.logger = config.database.getChildLogger(`Resource:${name}`, { resource: name });
    } else if (config.database && config.database.logger) {
      this.logger = config.database.logger.child({ resource: name });
    } else {
      this.logger = createLogger({ name: `Resource:${name}`, level: this.logLevel });
    }
    this.behavior = behavior;
    this.observers = observers;
    this.passphrase = passphrase ?? "secret";
    this.bcryptRounds = bcryptRounds;
    this.versioningEnabled = versioningEnabled;
    this.strictValidation = strictValidation;
    this.setAsyncMode(asyncEvents);
    this._resourceAsyncEvents = asyncEvents;
    this.asyncEvents = asyncEvents;
    this._idGenerator = new ResourceIdGenerator(this, {
      idGenerator: customIdGenerator,
      idSize
    });
    this.idGenerator = this._idGenerator.getGenerator();
    this.idSize = this._idGenerator.idSize;
    this.idGeneratorType = this._idGenerator.getType(customIdGenerator, this.idSize);
    Object.defineProperty(this, "_incrementalConfig", {
      get: () => this._idGenerator._incrementalConfig,
      enumerable: false,
      configurable: false
    });
    const normalizedPartitions = this._normalizePartitionsInput(partitions, attributes);
    this.config = {
      cache: cache5,
      hooks,
      paranoid,
      timestamps,
      partitions: normalizedPartitions,
      autoEncrypt,
      autoDecrypt,
      allNestedObjectsOptional,
      asyncEvents: this.asyncEvents,
      asyncPartitions,
      strictPartitions,
      createdBy
    };
    this._lazySchema = lazySchema;
    this._schemaCompiled = false;
    this._pendingSchemaConfig = null;
    const parsedVersion = parseInt(version.replace(/v/i, ""), 10) || 1;
    this._schemaRegistry = schemaRegistry;
    this._pluginSchemaRegistry = pluginSchemaRegistry;
    if (lazySchema) {
      this._pendingSchemaConfig = {
        attributes,
        passphrase: this.passphrase,
        bcryptRounds: this.bcryptRounds,
        version: parsedVersion,
        allNestedObjectsOptional,
        autoEncrypt,
        autoDecrypt,
        strictValidation
      };
      this.validator = null;
      this.schema = null;
      this.logger.debug({ resource: this.name }, `[LAZY_SCHEMA] Deferred schema/validator compilation`);
    } else {
      this.validator = new ResourceValidator({
        attributes,
        strictValidation,
        allNestedObjectsOptional,
        passphrase: this.passphrase,
        bcryptRounds: this.bcryptRounds,
        autoEncrypt,
        autoDecrypt
      });
      this.schema = new Schema2({
        name,
        attributes,
        passphrase,
        bcryptRounds,
        version: parsedVersion,
        options: {
          allNestedObjectsOptional,
          autoEncrypt,
          autoDecrypt
        },
        schemaRegistry: this._schemaRegistry,
        pluginSchemaRegistry: this._pluginSchemaRegistry
      });
      this._schemaRegistry = this.schema.getSchemaRegistry() || this._schemaRegistry;
      this._pluginSchemaRegistry = this.schema.getPluginSchemaRegistry() || this._pluginSchemaRegistry;
      this._schemaCompiled = true;
    }
    const { database: _db, observers: _obs, client: _cli, ...cloneableConfig } = config;
    this.$schema = { ...cloneableConfig };
    this.$schema._createdAt = Date.now();
    this.$schema._updatedAt = Date.now();
    Object.freeze(this.$schema);
    this._hooksModule = new ResourceHooks(this, {});
    this.hooks = this._hooksModule.getHooks();
    this.attributes = attributes || {};
    this._partitions = new ResourcePartitions(this, { strictValidation });
    this.map = config.map;
    this.applyConfiguration({ map: this.map });
    if (hooks) {
      for (const [event, hooksArr] of Object.entries(hooks)) {
        if (Array.isArray(hooksArr)) {
          for (const fn of hooksArr) {
            this._hooksModule.addHook(event, fn);
          }
        }
      }
    }
    this._eventsModule = new ResourceEvents(this, {
      disableEvents: config.disableEvents,
      disableResourceEvents: config.disableResourceEvents,
      events: events2
    });
    this.eventsDisabled = this._eventsModule.isDisabled();
    this._guards = new ResourceGuards(this, { guard });
    this.guard = this._guards.getGuard();
    this._middleware = new ResourceMiddleware(this);
    this._middleware.init();
    this._query = new ResourceQuery(this);
    this._content = new ResourceContent(this);
    this._streams = new ResourceStreams(this);
    this._persistence = new ResourcePersistence(this);
    this._initIncrementalIdGenerator();
  }
  _normalizePartitionsInput(partitions, attributes) {
    if (!Array.isArray(partitions)) {
      return partitions || {};
    }
    const normalized = {};
    for (const fieldName of partitions) {
      if (typeof fieldName !== "string") {
        throw new PartitionError("Invalid partition field type", {
          fieldName,
          receivedType: typeof fieldName,
          retriable: false,
          suggestion: 'Use string field names when declaring partitions (e.g. ["status", "region"]).'
        });
      }
      if (!attributes || !attributes[fieldName]) {
        throw new PartitionError(`Partition field '${fieldName}' not found in attributes`, {
          fieldName,
          availableFields: attributes ? Object.keys(attributes) : [],
          retriable: false,
          suggestion: "Ensure the partition field exists in the resource attributes definition."
        });
      }
      const partitionName = `by${fieldName.charAt(0).toUpperCase()}${fieldName.slice(1)}`;
      const fieldDef = attributes[fieldName];
      let fieldType = "string";
      if (typeof fieldDef === "string") {
        fieldType = fieldDef.split("|")[0].trim();
      } else if (typeof fieldDef === "object" && fieldDef !== null && fieldDef.type) {
        fieldType = fieldDef.type;
      }
      normalized[partitionName] = {
        fields: {
          [fieldName]: fieldType
        }
      };
    }
    return normalized;
  }
  configureIdGenerator(customIdGenerator, idSize) {
    const tempGenerator = new ResourceIdGenerator(this, { idGenerator: customIdGenerator, idSize });
    return tempGenerator.getGenerator();
  }
  _initIncrementalIdGenerator() {
    this._idGenerator.initIncremental();
    this.idGenerator = this._idGenerator.getGenerator();
  }
  _ensureSchemaCompiled() {
    if (this._schemaCompiled)
      return;
    if (!this._pendingSchemaConfig) {
      throw new ResourceError(`Resource '${this.name}' has lazy schema enabled but no pending config`, { resourceName: this.name });
    }
    const startTime = Date.now();
    const cfg = this._pendingSchemaConfig;
    this.validator = new ResourceValidator({
      attributes: cfg.attributes,
      strictValidation: cfg.strictValidation,
      allNestedObjectsOptional: cfg.allNestedObjectsOptional,
      passphrase: cfg.passphrase,
      bcryptRounds: cfg.bcryptRounds,
      autoEncrypt: cfg.autoEncrypt,
      autoDecrypt: cfg.autoDecrypt
    });
    this.schema = new Schema2({
      name: this.name,
      attributes: cfg.attributes,
      passphrase: cfg.passphrase,
      bcryptRounds: cfg.bcryptRounds,
      version: cfg.version,
      options: {
        allNestedObjectsOptional: cfg.allNestedObjectsOptional,
        autoEncrypt: cfg.autoEncrypt,
        autoDecrypt: cfg.autoDecrypt
      },
      schemaRegistry: this._schemaRegistry,
      pluginSchemaRegistry: this._pluginSchemaRegistry
    });
    this._schemaRegistry = this.schema.getSchemaRegistry() || this._schemaRegistry;
    this._pluginSchemaRegistry = this.schema.getPluginSchemaRegistry() || this._pluginSchemaRegistry;
    this._schemaCompiled = true;
    this._pendingSchemaConfig = null;
    const elapsed = Date.now() - startTime;
    this.logger.debug({ resource: this.name, elapsedMs: elapsed }, `[LAZY_SCHEMA] Compiled on first use (${elapsed}ms)`);
  }
  prewarmSchema() {
    if (this._schemaCompiled)
      return;
    this._ensureSchemaCompiled();
    this.logger.debug({ resource: this.name }, `[LAZY_SCHEMA] Pre-warmed schema`);
  }
  isSchemaCompiled() {
    return this._schemaCompiled;
  }
  hasAsyncIdGenerator() {
    return this._idGenerator.isAsync();
  }
  getIdGeneratorType(customIdGenerator, idSize) {
    return this._idGenerator.getType(customIdGenerator, idSize);
  }
  export() {
    let exported;
    if (this._lazySchema && !this._schemaCompiled && this._pendingSchemaConfig) {
      exported = {
        name: this.name,
        attributes: this._pendingSchemaConfig.attributes,
        version: this._pendingSchemaConfig.version
      };
    } else {
      this._ensureSchemaCompiled();
      exported = this.schema.export();
    }
    exported.behavior = this.behavior;
    exported.timestamps = this.config.timestamps;
    exported.partitions = this.config.partitions || {};
    exported.paranoid = this.config.paranoid;
    exported.allNestedObjectsOptional = this.config.allNestedObjectsOptional;
    exported.autoDecrypt = this.config.autoDecrypt;
    exported.cache = this.config.cache;
    exported.hooks = this.hooks;
    exported.map = this.map;
    return exported;
  }
  applyConfiguration({ map: map2 } = {}) {
    if (!this._lazySchema) {
      this._ensureSchemaCompiled();
    }
    if (this.config.timestamps) {
      if (!this.attributes.createdAt) {
        this.attributes.createdAt = "string|optional";
      }
      if (!this.attributes.updatedAt) {
        this.attributes.updatedAt = "string|optional";
      }
      if (!this.config.partitions) {
        this.config.partitions = {};
      }
      if (!this.config.partitions.byCreatedDate) {
        this.config.partitions.byCreatedDate = {
          fields: {
            createdAt: "date|maxlength:10"
          }
        };
      }
      if (!this.config.partitions.byUpdatedDate) {
        this.config.partitions.byUpdatedDate = {
          fields: {
            updatedAt: "date|maxlength:10"
          }
        };
      }
    }
    this.setupPartitionHooks();
    if (this.versioningEnabled) {
      if (!this.config.partitions.byVersion) {
        this.config.partitions.byVersion = {
          fields: {
            _v: "string"
          }
        };
      }
    }
    if (!this._lazySchema) {
      const parsedVersion = parseInt(this.version.replace(/v/i, ""), 10) || 1;
      this.schema = new Schema2({
        name: this.name,
        attributes: this.attributes,
        passphrase: this.passphrase,
        bcryptRounds: this.bcryptRounds,
        version: parsedVersion,
        options: {
          autoEncrypt: this.config.autoEncrypt,
          autoDecrypt: this.config.autoDecrypt,
          allNestedObjectsOptional: this.config.allNestedObjectsOptional
        },
        map: map2 || this.map,
        schemaRegistry: this._schemaRegistry,
        pluginSchemaRegistry: this._pluginSchemaRegistry
      });
      this._schemaRegistry = this.schema.getSchemaRegistry() || this._schemaRegistry;
      this._pluginSchemaRegistry = this.schema.getPluginSchemaRegistry() || this._pluginSchemaRegistry;
      if (this.validator) {
        this.validator.updateSchema(this.attributes);
      }
    }
    this.validatePartitions();
  }
  updateAttributes(newAttributes) {
    const oldAttributes = this.attributes;
    this.attributes = newAttributes;
    this.applyConfiguration();
    return { oldAttributes, newAttributes };
  }
  addPluginAttribute(name, definition, pluginName) {
    if (!pluginName) {
      throw new ResourceError("Plugin name is required when adding plugin attributes", { resource: this.name, attribute: name });
    }
    const existingDef = this.schema.getAttributeDefinition(name);
    if (existingDef && (!existingDef.__plugin__ || existingDef.__plugin__ !== pluginName)) {
      throw new ResourceError(`Attribute '${name}' already exists and is not from plugin '${pluginName}'`, { resource: this.name, attribute: name, plugin: pluginName });
    }
    let defObject = definition;
    if (typeof definition === "object" && definition !== null) {
      defObject = { ...definition };
    }
    if (typeof defObject === "object" && defObject !== null) {
      defObject.__plugin__ = pluginName;
      defObject.__pluginCreated__ = Date.now();
    }
    this.schema.attributes[name] = defObject;
    this.attributes[name] = defObject;
    if (typeof defObject === "string") {
      if (!this.schema._pluginAttributeMetadata) {
        this.schema._pluginAttributeMetadata = {};
      }
      this.schema._pluginAttributeMetadata[name] = {
        __plugin__: pluginName,
        __pluginCreated__: Date.now()
      };
    }
    this.schema.regeneratePluginMapping();
    if (this.schema.options?.generateAutoHooks) {
      this.schema.generateAutoHooks();
    }
    const processedAttributes = this.schema.preprocessAttributesForValidation(this.schema.attributes);
    this.schema.validator = new ValidatorManager({ autoEncrypt: false }).compile(merge_default({ $$async: true, $$strict: false }, processedAttributes));
    if (this.database) {
      this.database.emit("plugin-attribute-added", {
        resource: this.name,
        attribute: name,
        plugin: pluginName,
        definition: defObject
      });
    }
  }
  removePluginAttribute(name, pluginName = null) {
    const attrDef = this.schema.getAttributeDefinition(name);
    const metadata = this.schema._pluginAttributeMetadata?.[name];
    const isPluginAttr = typeof attrDef === "object" && attrDef?.__plugin__ || metadata;
    if (!attrDef || !isPluginAttr) {
      return false;
    }
    const actualPlugin = attrDef?.__plugin__ || metadata?.__plugin__;
    if (pluginName && actualPlugin !== pluginName) {
      throw new ResourceError(`Attribute '${name}' belongs to plugin '${actualPlugin}', not '${pluginName}'`, { resource: this.name, attribute: name, actualPlugin, requestedPlugin: pluginName });
    }
    delete this.schema.attributes[name];
    delete this.attributes[name];
    if (this.schema._pluginAttributeMetadata?.[name]) {
      delete this.schema._pluginAttributeMetadata[name];
    }
    this.schema.regeneratePluginMapping();
    if (this.database) {
      this.database.emit("plugin-attribute-removed", {
        resource: this.name,
        attribute: name,
        plugin: actualPlugin
      });
    }
    return true;
  }
  addHook(event, fn) {
    this._hooksModule.addHook(event, fn);
  }
  async executeHooks(event, data2) {
    return this._hooksModule.executeHooks(event, data2);
  }
  _bindHook(fn) {
    return this._hooksModule._bindHook(fn);
  }
  setupPartitionHooks() {
    this._partitions.setupHooks(this._hooksModule);
  }
  async validate(data2, options = {}) {
    this._ensureSchemaCompiled();
    return this.validator.validate(data2, options);
  }
  validatePartitions() {
    this._partitions.validate();
  }
  fieldExistsInAttributes(fieldName) {
    return this._partitions.fieldExistsInAttributes(fieldName);
  }
  findOrphanedPartitions() {
    return this._partitions.findOrphaned();
  }
  removeOrphanedPartitions({ dryRun = false } = {}) {
    return this._partitions.removeOrphaned({ dryRun });
  }
  applyPartitionRule(value, rule) {
    return this._partitions.applyRule(value, rule);
  }
  getResourceKey(id2) {
    validateS3KeySegment(id2, "id");
    const key = (0, import_path.join)("resource=" + this.name, "data", `id=${id2}`);
    return key;
  }
  getPartitionKey({ partitionName, id: id2, data: data2 }) {
    return this._partitions.getKey({ partitionName, id: id2, data: data2 });
  }
  getNestedFieldValue(data2, fieldPath) {
    return this._partitions.getNestedFieldValue(data2, fieldPath);
  }
  calculateContentLength(body2) {
    if (!body2)
      return 0;
    if (Buffer.isBuffer(body2))
      return body2.length;
    if (typeof body2 === "string")
      return Buffer.byteLength(body2, "utf8");
    if (typeof body2 === "object")
      return Buffer.byteLength(JSON.stringify(body2), "utf8");
    return Buffer.byteLength(String(body2), "utf8");
  }
  _emitStandardized(event, payload2, id2 = null) {
    this._eventsModule.emitStandardized(event, payload2, id2);
  }
  _ensureEventsWired() {
    this._eventsModule.ensureWired();
  }
  on(eventName, listener) {
    this._eventsModule.on(eventName, listener);
    return this;
  }
  addListener(eventName, listener) {
    return this.on(eventName, listener);
  }
  once(eventName, listener) {
    this._eventsModule.once(eventName, listener);
    return this;
  }
  emit(eventName, ...args) {
    return this._eventsModule.emit(eventName, ...args);
  }
  async insert({ id: id2, ...attributes }) {
    this._ensureSchemaCompiled();
    return this._persistence.insert({ id: id2, ...attributes });
  }
  async get(id2) {
    this._ensureSchemaCompiled();
    return this._persistence.get(id2);
  }
  async getOrNull(id2) {
    this._ensureSchemaCompiled();
    return this._persistence.getOrNull(id2);
  }
  async getOrThrow(id2) {
    this._ensureSchemaCompiled();
    return this._persistence.getOrThrow(id2);
  }
  async exists(id2) {
    return this._persistence.exists(id2);
  }
  async update(id2, attributes) {
    this._ensureSchemaCompiled();
    return this._persistence.update(id2, attributes);
  }
  async patch(id2, fields, options = {}) {
    this._ensureSchemaCompiled();
    return this._persistence.patch(id2, fields, options);
  }
  async _patchViaCopyObject(id2, fields, options = {}) {
    this._ensureSchemaCompiled();
    return this._persistence._patchViaCopyObject(id2, fields, options);
  }
  async replace(id2, fullData, options = {}) {
    this._ensureSchemaCompiled();
    return this._persistence.replace(id2, fullData, options);
  }
  async updateConditional(id2, attributes, options = {}) {
    this._ensureSchemaCompiled();
    return this._persistence.updateConditional(id2, attributes, options);
  }
  async delete(id2) {
    this._ensureSchemaCompiled();
    return this._persistence.delete(id2);
  }
  async upsert({ id: id2, ...attributes }) {
    this._ensureSchemaCompiled();
    return this._persistence.upsert({ id: id2, ...attributes });
  }
  async count({ partition = null, partitionValues = {} } = {}) {
    return this._query.count({ partition, partitionValues });
  }
  async insertMany(objects) {
    this._ensureSchemaCompiled();
    return this._persistence.insertMany(objects);
  }
  async _executeBatchHelper(operations, options = {}) {
    this._ensureSchemaCompiled();
    return this._persistence._executeBatchHelper(operations, options);
  }
  async deleteMany(ids) {
    this._ensureSchemaCompiled();
    return this._persistence.deleteMany(ids);
  }
  async deleteAll() {
    this._ensureSchemaCompiled();
    return this._persistence.deleteAll();
  }
  async deleteAllData() {
    this._ensureSchemaCompiled();
    return this._persistence.deleteAllData();
  }
  async listIds({ partition = null, partitionValues = {}, limit, offset = 0 } = {}) {
    return this._query.listIds({ partition, partitionValues, limit, offset });
  }
  async list({ partition = null, partitionValues = {}, limit, offset = 0 } = {}) {
    this._ensureSchemaCompiled();
    return this._query.list({ partition, partitionValues, limit, offset });
  }
  async listMain({ limit, offset = 0 }) {
    this._ensureSchemaCompiled();
    return this._query.listMain({ limit, offset });
  }
  async listPartition({ partition, partitionValues, limit, offset = 0 }) {
    this._ensureSchemaCompiled();
    return this._query.listPartition({ partition, partitionValues, limit, offset });
  }
  buildPartitionPrefix(partition, partitionDef, partitionValues) {
    return this._partitions.buildPrefix(partition, partitionDef, partitionValues);
  }
  extractIdsFromKeys(keys2) {
    return this._query.extractIdsFromKeys(keys2);
  }
  async processListResults(ids, context = "main") {
    return this._query.processListResults(ids, context);
  }
  async processPartitionResults(ids, partition, partitionDef, keys2) {
    return this._query.processPartitionResults(ids, partition, partitionDef, keys2);
  }
  extractPartitionValuesFromKey(id2, keys2, sortedFields) {
    return this._partitions.extractValuesFromKey(id2, keys2, sortedFields);
  }
  handleResourceError(error2, id2, context) {
    return this._query.handleResourceError(error2, id2, context);
  }
  handleListError(error2, { partition, partitionValues }) {
    return this._query.handleListError(error2, { partition, partitionValues });
  }
  async getMany(ids) {
    this._ensureSchemaCompiled();
    return this._query.getMany(ids);
  }
  async getAll() {
    this._ensureSchemaCompiled();
    return this._query.getAll();
  }
  async page({ offset = 0, size = 100, partition = null, partitionValues = {}, skipCount = false } = {}) {
    this._ensureSchemaCompiled();
    const result = await this._query.page({ offset, size, partition, partitionValues, skipCount });
    return result;
  }
  readable() {
    return this._streams.readable();
  }
  writable() {
    return this._streams.writable();
  }
  async setContent({ id: id2, buffer, contentType = "application/octet-stream" }) {
    return this._content.setContent({ id: id2, buffer, contentType });
  }
  async content(id2) {
    return this._content.content(id2);
  }
  async hasContent(id2) {
    return this._content.hasContent(id2);
  }
  async deleteContent(id2) {
    return this._content.deleteContent(id2);
  }
  getDefinitionHash() {
    const definition = {
      attributes: this.attributes,
      behavior: this.behavior
    };
    const stableString = (0, import_json_stable_stringify.default)(definition);
    return `sha256:${(0, import_crypto.createHash)("sha256").update(stableString).digest("hex")}`;
  }
  extractVersionFromKey(key) {
    const parts = key.split("/");
    const versionPart = parts.find((part) => part.startsWith("v="));
    return versionPart ? versionPart.replace("v=", "") : null;
  }
  async getSchemaForVersion(version) {
    this._ensureSchemaCompiled();
    return this.schema;
  }
  async createPartitionReferences(data2) {
    return this._partitions.createReferences(data2);
  }
  async deletePartitionReferences(data2) {
    return this._partitions.deleteReferences(data2);
  }
  async query(filter2 = {}, { limit = 100, offset = 0, partition = null, partitionValues = {} } = {}) {
    this._ensureSchemaCompiled();
    return this._query.query(filter2, { limit, offset, partition, partitionValues });
  }
  async handlePartitionReferenceUpdates(oldData, newData) {
    return this._partitions.handleReferenceUpdates(oldData, newData);
  }
  async handlePartitionReferenceUpdate(partitionName, partition, oldData, newData) {
    return this._partitions.handleReferenceUpdate(partitionName, partition, oldData, newData);
  }
  async updatePartitionReferences(data2) {
    return this._partitions.updateReferences(data2);
  }
  async getFromPartition({ id: id2, partitionName, partitionValues = {} }) {
    return this._partitions.getFromPartition({ id: id2, partitionName, partitionValues });
  }
  async createHistoricalVersion(id2, data2) {
    this._ensureSchemaCompiled();
    const historicalKey = (0, import_path.join)(`resource=${this.name}`, `historical`, `id=${id2}`);
    const historicalData = {
      ...data2,
      _v: data2._v || this.version,
      _historicalTimestamp: (/* @__PURE__ */ new Date()).toISOString()
    };
    const mappedData = await this.schema.mapper(historicalData);
    const behaviorImpl = getBehavior(this.behavior);
    const { mappedData: processedMetadata, body: body2 } = await behaviorImpl.handleInsert({
      resource: this,
      data: historicalData,
      mappedData
    });
    const finalMetadata = {
      ...processedMetadata,
      _v: data2._v || this.version,
      _historicalTimestamp: historicalData._historicalTimestamp
    };
    let contentType = void 0;
    if (body2 && body2 !== "") {
      const [okParse] = await tryFn$1(() => Promise.resolve(JSON.parse(body2)));
      if (okParse)
        contentType = "application/json";
    }
    await this.client.putObject({
      key: historicalKey,
      metadata: finalMetadata,
      body: body2,
      contentType
    });
  }
  async applyVersionMapping(data2, fromVersion, toVersion) {
    if (fromVersion === toVersion) {
      return data2;
    }
    const mappedData = {
      ...data2,
      _v: toVersion,
      _originalVersion: fromVersion,
      _versionMapped: true
    };
    return mappedData;
  }
  async composeFullObjectFromWrite({ id: id2, metadata, body: body2, behavior }) {
    this._ensureSchemaCompiled();
    const behaviorFlags = {};
    if (metadata && metadata["$truncated"] === "true") {
      behaviorFlags.$truncated = "true";
    }
    if (metadata && metadata["$overflow"] === "true") {
      behaviorFlags.$overflow = "true";
    }
    let unmappedMetadata = {};
    const [ok, , unmapped] = await tryFn$1(() => this.schema.unmapper(metadata));
    unmappedMetadata = ok ? unmapped : metadata;
    const filterInternalFields = (obj) => {
      if (!obj || typeof obj !== "object")
        return obj;
      const filtered2 = {};
      const pluginAttrNames = this.schema._pluginAttributes ? Object.values(this.schema._pluginAttributes).flat() : [];
      for (const [key, value] of Object.entries(obj)) {
        if (!key.startsWith("_") || key === "_geohash" || key.startsWith("_geohash_zoom") || pluginAttrNames.includes(key)) {
          filtered2[key] = value;
        }
      }
      return filtered2;
    };
    const fixValue = (v4) => {
      if (typeof v4 === "object" && v4 !== null) {
        return v4;
      }
      if (typeof v4 === "string") {
        if (v4 === "[object Object]")
          return {};
        if (v4.startsWith("{") || v4.startsWith("[")) {
          const [ok2, , parsed] = tryFnSync(() => JSON.parse(v4));
          return ok2 ? parsed : v4;
        }
        return v4;
      }
      return v4;
    };
    if (behavior === "body-overflow") {
      const hasOverflow = metadata && metadata["$overflow"] === "true";
      let bodyData = {};
      if (hasOverflow && body2) {
        const [okBody, , parsedBody] = await tryFn$1(() => Promise.resolve(JSON.parse(body2)));
        if (okBody) {
          let pluginMapFromMeta = null;
          if (metadata && metadata._pluginmap) {
            const [okPluginMap, , parsedPluginMap] = await tryFn$1(() => Promise.resolve(typeof metadata._pluginmap === "string" ? JSON.parse(metadata._pluginmap) : metadata._pluginmap));
            pluginMapFromMeta = okPluginMap ? parsedPluginMap : null;
          }
          const [okUnmap, , unmappedBody] = await tryFn$1(() => this.schema.unmapper(parsedBody, void 0, pluginMapFromMeta));
          bodyData = okUnmap ? unmappedBody : {};
        }
      }
      const merged = { ...unmappedMetadata, ...bodyData, id: id2 };
      Object.keys(merged).forEach((k4) => {
        merged[k4] = fixValue(merged[k4]);
      });
      const result2 = filterInternalFields(merged);
      if (hasOverflow) {
        result2.$overflow = "true";
      }
      return result2;
    }
    if (behavior === "body-only") {
      const [okBody, , parsedBody] = await tryFn$1(() => Promise.resolve(body2 ? JSON.parse(body2) : {}));
      let mapFromMeta = this.schema.map;
      let pluginMapFromMeta = null;
      if (metadata && metadata._map) {
        const [okMap, , parsedMap] = await tryFn$1(() => Promise.resolve(typeof metadata._map === "string" ? JSON.parse(metadata._map) : metadata._map));
        mapFromMeta = okMap ? parsedMap : this.schema.map;
      }
      if (metadata && metadata._pluginmap) {
        const [okPluginMap, , parsedPluginMap] = await tryFn$1(() => Promise.resolve(typeof metadata._pluginmap === "string" ? JSON.parse(metadata._pluginmap) : metadata._pluginmap));
        pluginMapFromMeta = okPluginMap ? parsedPluginMap : null;
      }
      const [okUnmap, , unmappedBody] = await tryFn$1(() => this.schema.unmapper(parsedBody, mapFromMeta, pluginMapFromMeta));
      const result2 = okUnmap ? { ...unmappedBody, id: id2 } : { id: id2 };
      Object.keys(result2).forEach((k4) => {
        result2[k4] = fixValue(result2[k4]);
      });
      return result2;
    }
    if (behavior === "user-managed" && body2 && body2.trim() !== "") {
      const [okBody, , parsedBody] = await tryFn$1(() => Promise.resolve(JSON.parse(body2)));
      if (okBody) {
        let pluginMapFromMeta = null;
        if (metadata && metadata._pluginmap) {
          const [okPluginMap, , parsedPluginMap] = await tryFn$1(() => Promise.resolve(typeof metadata._pluginmap === "string" ? JSON.parse(metadata._pluginmap) : metadata._pluginmap));
          pluginMapFromMeta = okPluginMap ? parsedPluginMap : null;
        }
        const [okUnmap, , unmappedBodyRaw] = await tryFn$1(async () => this.schema.unmapper(parsedBody, void 0, pluginMapFromMeta));
        const unmappedBody = unmappedBodyRaw;
        const bodyData = okUnmap ? unmappedBody : {};
        const merged = { ...bodyData, ...unmappedMetadata, id: id2 };
        Object.keys(merged).forEach((k4) => {
          merged[k4] = fixValue(merged[k4]);
        });
        return filterInternalFields(merged);
      }
    }
    const result = { ...unmappedMetadata, id: id2 };
    Object.keys(result).forEach((k4) => {
      result[k4] = fixValue(result[k4]);
    });
    const filtered = filterInternalFields(result);
    if (behaviorFlags.$truncated) {
      filtered.$truncated = behaviorFlags.$truncated;
    }
    if (behaviorFlags.$overflow) {
      filtered.$overflow = behaviorFlags.$overflow;
    }
    return filtered;
  }
  _normalizeGuard(guard) {
    const tempGuards = new ResourceGuards(this, { guard });
    return tempGuards.getGuard();
  }
  async executeGuard(operation2, context, resource = null) {
    return this._guards.execute(operation2, context, resource);
  }
  _checkRolesScopes(requiredRolesScopes, user) {
    return this._guards._checkRolesScopes(requiredRolesScopes, user);
  }
  _initMiddleware() {
    if (!this._middleware) {
      this._middleware = new ResourceMiddleware(this);
    }
    this._middleware.init();
  }
  useMiddleware(method, fn) {
    this._middleware.use(method, fn);
  }
  applyDefaults(data2) {
    this._ensureSchemaCompiled();
    return this.validator.applyDefaults(data2);
  }
  async getSequenceValue(fieldName = "id") {
    return this._idGenerator.getSequenceValue(fieldName);
  }
  async resetSequence(fieldName, value) {
    return this._idGenerator.resetSequence(fieldName, value);
  }
  async listSequences() {
    return this._idGenerator.listSequences();
  }
  async reserveIdBatch(count = 100) {
    return this._idGenerator.reserveIdBatch(count);
  }
  getBatchStatus(fieldName = "id") {
    return this._idGenerator.getBatchStatus(fieldName);
  }
  releaseBatch(fieldName = "id") {
    this._idGenerator.releaseBatch(fieldName);
  }
  dispose() {
    if (this.schema) {
      this.schema.dispose();
    }
    this.emit("resource:disposed", { resourceName: this.name });
    this.removeAllListeners();
  }
};
var DatabaseResources = class {
  database;
  metadata;
  coordinators;
  constructor(database, metadata, coordinators) {
    this.database = database;
    this.metadata = metadata;
    this.coordinators = coordinators;
  }
  resourceExists(name) {
    return !!this.database._resourcesMap[name];
  }
  resourceExistsWithSameHash({ name, attributes, behavior = "user-managed", partitions = {} }) {
    const db = this.database;
    if (!db._resourcesMap[name]) {
      return { exists: false, sameHash: false, hash: null };
    }
    const existingResource = db._resourcesMap[name];
    const existingHash = this.metadata.generateDefinitionHash(existingResource.export());
    const mockResource = new Resource({
      name,
      attributes,
      behavior,
      partitions,
      client: db.client,
      version: existingResource.version,
      passphrase: db.passphrase,
      bcryptRounds: db.bcryptRounds,
      versioningEnabled: db.versioningEnabled
    });
    const newHash = this.metadata.generateDefinitionHash(mockResource.export());
    return {
      exists: true,
      sameHash: existingHash === newHash,
      hash: newHash,
      existingHash
    };
  }
  async createResource({ name, attributes, behavior = "user-managed", hooks, middlewares, ...config }) {
    const db = this.database;
    const normalizedPartitions = this._normalizePartitions(config.partitions || [], attributes);
    if (db._resourcesMap[name]) {
      const existingResource = db._resourcesMap[name];
      Object.assign(existingResource.config, {
        cache: db.cache,
        ...config,
        partitions: normalizedPartitions
      });
      if (behavior) {
        existingResource.behavior = behavior;
      }
      existingResource.versioningEnabled = db.versioningEnabled;
      existingResource.updateAttributes(attributes);
      if (hooks) {
        for (const [event, hooksArr] of Object.entries(hooks)) {
          if (Array.isArray(hooksArr) && existingResource.hooks[event]) {
            for (const fn of hooksArr) {
              if (typeof fn === "function") {
                existingResource.hooks[event].push(fn.bind(existingResource));
              }
            }
          }
        }
      }
      if (middlewares) {
        this._applyMiddlewares(existingResource, middlewares);
      }
      const disableEventsFlag = config.disableEvents !== void 0 ? config.disableEvents : db.disableResourceEvents;
      existingResource.eventsDisabled = disableEventsFlag;
      const newHash = this.metadata.generateDefinitionHash(existingResource.export(), existingResource.behavior);
      const existingMetadata2 = db.savedMetadata?.resources?.[name];
      const currentVersion = existingMetadata2?.currentVersion || "v1";
      const existingVersionData = existingMetadata2?.versions?.[currentVersion];
      if (!existingVersionData || existingVersionData.hash !== newHash) {
        await this.metadata.scheduleMetadataUpload();
      }
      db.emit("db:resource-updated", name);
      return existingResource;
    }
    const existingMetadata = db.savedMetadata?.resources?.[name];
    const version = existingMetadata?.currentVersion || "v1";
    const resource = new Resource({
      name,
      client: db.client,
      version: config.version !== void 0 ? config.version : version,
      attributes,
      behavior,
      passphrase: config.passphrase !== void 0 ? config.passphrase : db.passphrase,
      bcryptRounds: config.bcryptRounds !== void 0 ? config.bcryptRounds : db.bcryptRounds,
      observers: [db],
      cache: config.cache !== void 0 ? config.cache : db.cache,
      timestamps: config.timestamps !== void 0 ? config.timestamps : false,
      partitions: normalizedPartitions,
      paranoid: config.paranoid !== void 0 ? config.paranoid : true,
      allNestedObjectsOptional: config.allNestedObjectsOptional !== void 0 ? config.allNestedObjectsOptional : true,
      autoDecrypt: config.autoDecrypt !== void 0 ? config.autoDecrypt : true,
      hooks: hooks || {},
      versioningEnabled: db.versioningEnabled,
      strictValidation: config.strictValidation !== void 0 ? config.strictValidation : db.strictValidation,
      map: config.map,
      idGenerator: config.idGenerator,
      idSize: config.idSize,
      asyncEvents: config.asyncEvents,
      asyncPartitions: config.asyncPartitions !== void 0 ? config.asyncPartitions : true,
      events: config.events || {},
      disableEvents: config.disableEvents !== void 0 ? config.disableEvents : db.disableResourceEvents,
      createdBy: config.createdBy || "user",
      api: config.api,
      description: config.description,
      lazySchema: config.lazySchema
    });
    resource.database = db;
    db._resourcesMap[name] = resource;
    if (middlewares) {
      this._applyMiddlewares(resource, middlewares);
    }
    await this.metadata.scheduleMetadataUpload();
    db.emit("db:resource-created", name);
    db.emit("db:resource:metrics", {
      resource: name,
      ...this.coordinators.collectMemorySnapshot()
    });
    return resource;
  }
  async listResources() {
    return Object.values(this.database.resources).map((r4) => r4.export());
  }
  async getResource(name) {
    if (!this.database._resourcesMap[name]) {
      throw new ResourceNotFound({
        bucket: this.database.client.config?.bucket,
        resourceName: name,
        id: name
      });
    }
    return this.database._resourcesMap[name];
  }
  _normalizePartitions(partitions, attributes) {
    if (!Array.isArray(partitions)) {
      return partitions || {};
    }
    const normalized = {};
    for (const fieldName of partitions) {
      if (typeof fieldName !== "string") {
        throw new SchemaError("Invalid partition field type", {
          fieldName,
          receivedType: typeof fieldName,
          retriable: false,
          suggestion: 'Use string field names when declaring partitions (e.g. ["status", "region"]).'
        });
      }
      if (!attributes[fieldName]) {
        throw new SchemaError(`Partition field '${fieldName}' not found in attributes`, {
          fieldName,
          availableFields: Object.keys(attributes),
          retriable: false,
          suggestion: "Ensure the partition field exists in the resource attributes definition."
        });
      }
      const partitionName = `by${fieldName.charAt(0).toUpperCase()}${fieldName.slice(1)}`;
      const fieldDef = attributes[fieldName];
      let fieldType = "string";
      if (typeof fieldDef === "string") {
        fieldType = fieldDef.split("|")[0].trim();
      } else if (typeof fieldDef === "object" && fieldDef?.type) {
        fieldType = fieldDef.type;
      }
      normalized[partitionName] = {
        fields: {
          [fieldName]: fieldType
        }
      };
    }
    return normalized;
  }
  _applyMiddlewares(resource, middlewares) {
    if (Array.isArray(middlewares)) {
      const methods = resource._middlewareMethods || [
        "get",
        "list",
        "listIds",
        "getAll",
        "count",
        "page",
        "insert",
        "update",
        "delete",
        "deleteMany",
        "exists",
        "getMany",
        "content",
        "hasContent",
        "query",
        "getFromPartition",
        "setContent",
        "deleteContent",
        "replace",
        "patch"
      ];
      for (const method of methods) {
        for (const middleware of middlewares) {
          if (typeof middleware === "function") {
            resource.useMiddleware(method, middleware);
          }
        }
      }
      return;
    }
    if (typeof middlewares === "object" && middlewares !== null) {
      for (const [method, fns] of Object.entries(middlewares)) {
        if (method === "*") {
          const methods = resource._middlewareMethods || [
            "get",
            "list",
            "listIds",
            "getAll",
            "count",
            "page",
            "insert",
            "update",
            "delete",
            "deleteMany",
            "exists",
            "getMany",
            "content",
            "hasContent",
            "query",
            "getFromPartition",
            "setContent",
            "deleteContent",
            "replace",
            "patch"
          ];
          const middlewareArray = Array.isArray(fns) ? fns : [fns];
          for (const targetMethod of methods) {
            for (const middleware of middlewareArray) {
              if (typeof middleware === "function") {
                resource.useMiddleware(targetMethod, middleware);
              }
            }
          }
        } else {
          const middlewareArray = Array.isArray(fns) ? fns : [fns];
          for (const middleware of middlewareArray) {
            if (typeof middleware === "function") {
              resource.useMiddleware(method, middleware);
            }
          }
        }
      }
    }
  }
};
var DatabaseConnection = class {
  database;
  metadata;
  recovery;
  plugins;
  coordinators;
  _exitListenerRegistered;
  _exitListener;
  constructor(database, metadata, recovery, plugins, coordinators) {
    this.database = database;
    this.metadata = metadata;
    this.recovery = recovery;
    this.plugins = plugins;
    this.coordinators = coordinators;
    this._exitListenerRegistered = false;
    this._exitListener = null;
  }
  registerExitListener() {
    if (!this._exitListenerRegistered && typeof process !== "undefined") {
      this._exitListenerRegistered = true;
      this._exitListener = async () => {
        if (this.database.isConnected()) {
          await tryFn$1(() => this.disconnect());
        }
      };
      bumpProcessMaxListeners(1);
      process.on("exit", this._exitListener);
    }
  }
  isConnected() {
    return !!this.database.savedMetadata;
  }
  async connect() {
    const db = this.database;
    db.logger.debug({ databaseId: db.id }, "connecting to database");
    this.registerExitListener();
    await this.plugins.startPlugins();
    let metadata = null;
    let needsHealing = false;
    const healingLog = [];
    if (await db.client.exists("s3db.json")) {
      const [ok] = await tryFn$1(async () => {
        const request2 = await db.client.getObject("s3db.json");
        const rawContent = await streamToString(request2?.Body);
        const [parseOk, , parsedData] = tryFnSync(() => JSON.parse(rawContent));
        if (!parseOk) {
          healingLog.push("JSON parsing failed - attempting recovery");
          needsHealing = true;
          metadata = await this.recovery.attemptJsonRecovery(rawContent, healingLog);
          if (!metadata) {
            await this.recovery.createCorruptedBackup(rawContent);
            healingLog.push("Created backup of corrupted file - starting with blank metadata");
            metadata = this.metadata.blankMetadataStructure();
          }
        } else {
          metadata = parsedData;
        }
        const healedMetadata = await this.recovery.validateAndHealMetadata(metadata, healingLog);
        if (healedMetadata !== metadata) {
          metadata = healedMetadata;
          needsHealing = true;
        }
      });
      if (!ok) {
        healingLog.push(`Critical error reading s3db.json: unknown error`);
        await this.recovery.createCorruptedBackup();
        metadata = this.metadata.blankMetadataStructure();
        needsHealing = true;
      }
    } else {
      metadata = this.metadata.blankMetadataStructure();
      await this.metadata.uploadMetadataFile();
    }
    if (needsHealing) {
      await this.recovery.uploadHealedMetadata(metadata, healingLog);
    }
    db.savedMetadata = metadata;
    const definitionChanges = this.metadata.detectDefinitionChanges(metadata);
    let registryUploadNeeded = false;
    for (const [name, resourceMetadata] of Object.entries(metadata.resources || {})) {
      const currentVersion = resourceMetadata.currentVersion || "v1";
      const versionData = resourceMetadata.versions?.[currentVersion];
      if (versionData) {
        let restoredIdGenerator;
        let restoredIdSize;
        if (versionData.idGenerator !== void 0) {
          if (versionData.idGenerator === "custom_function") {
            restoredIdGenerator = void 0;
            restoredIdSize = versionData.idSize || 22;
          } else if (typeof versionData.idGenerator === "number") {
            restoredIdGenerator = versionData.idGenerator;
            restoredIdSize = versionData.idSize || versionData.idGenerator;
          } else {
            restoredIdSize = versionData.idSize || 22;
          }
        } else {
          restoredIdSize = versionData.idSize || 22;
        }
        db._resourcesMap[name] = new Resource({
          name,
          client: db.client,
          database: db,
          version: currentVersion,
          attributes: versionData.attributes,
          behavior: versionData.behavior || "user-managed",
          passphrase: db.passphrase,
          bcryptRounds: db.bcryptRounds,
          observers: [db],
          cache: db.cache,
          timestamps: versionData.timestamps !== void 0 ? versionData.timestamps : false,
          partitions: resourceMetadata.partitions || versionData.partitions || {},
          paranoid: versionData.paranoid !== void 0 ? versionData.paranoid : true,
          allNestedObjectsOptional: versionData.allNestedObjectsOptional !== void 0 ? versionData.allNestedObjectsOptional : true,
          autoDecrypt: versionData.autoDecrypt !== void 0 ? versionData.autoDecrypt : true,
          asyncEvents: versionData.asyncEvents !== void 0 ? versionData.asyncEvents : true,
          hooks: {},
          versioningEnabled: db.versioningEnabled,
          strictValidation: db.strictValidation,
          map: versionData.map,
          idGenerator: restoredIdGenerator,
          idSize: restoredIdSize,
          schemaRegistry: resourceMetadata.schemaRegistry,
          pluginSchemaRegistry: resourceMetadata.pluginSchemaRegistry
        });
        if (db._resourcesMap[name].schema?.needsRegistryPersistence()) {
          registryUploadNeeded = true;
        }
      }
    }
    if (definitionChanges.length > 0) {
      db.emit("db:resource-definitions-changed", {
        changes: definitionChanges,
        metadata: db.savedMetadata
      });
    }
    if (registryUploadNeeded) {
      await this.metadata.scheduleMetadataUpload();
    }
    db.logger.info({
      databaseId: db.id,
      resourceCount: Object.keys(db.resources).length,
      pluginCount: Object.keys(db.pluginRegistry).length
    }, "database connected");
    db.emit("db:connected", /* @__PURE__ */ new Date());
  }
  async disconnect() {
    const db = this.database;
    db.logger.debug({ databaseId: db.id }, "disconnecting from database");
    await this.metadata.flushMetadata();
    await db.emit("disconnected", /* @__PURE__ */ new Date());
    await tryFn$1(async () => {
      await this.coordinators.stopAll();
      if (db.pluginList && db.pluginList.length > 0) {
        for (const plugin of db.pluginList) {
          if (plugin && typeof plugin.removeAllListeners === "function") {
            plugin.removeAllListeners();
          }
        }
        const stopConcurrency = Math.max(1, Number.isFinite(db.executorPool?.concurrency) ? db.executorPool.concurrency : 5);
        await TasksPool.map(db.pluginList, async (plugin) => {
          await tryFn$1(async () => {
            if (plugin && typeof plugin.stop === "function") {
              await plugin.stop();
            }
          });
        }, { concurrency: stopConcurrency });
      }
      if (db.resources && Object.keys(db.resources).length > 0) {
        for (const [, resource] of Object.entries(db.resources)) {
          await tryFn$1(() => {
            if (resource && typeof resource.dispose === "function") {
              resource.dispose();
            }
            if (resource._pluginWrappers) {
              resource._pluginWrappers.clear();
            }
            if (resource._pluginMiddlewares) {
              resource._pluginMiddlewares = {};
            }
            if (resource.observers && Array.isArray(resource.observers)) {
              resource.observers = [];
            }
          });
        }
        Object.keys(db.resources).forEach((k4) => delete db._resourcesMap[k4]);
      }
      if (db.client) {
        if (typeof db.client.removeAllListeners === "function") {
          db.client.removeAllListeners();
        }
        if (typeof db.client.destroy === "function") {
          db.client.destroy();
        }
      }
      await db.emit("db:disconnected", /* @__PURE__ */ new Date());
      if (typeof db.removeAllListeners === "function") {
        db.removeAllListeners();
      }
      if (this._exitListener && typeof process !== "undefined") {
        process.off("exit", this._exitListener);
        this._exitListener = null;
        this._exitListenerRegistered = false;
        bumpProcessMaxListeners(-1);
      }
      if (db.processManager && typeof db.processManager.removeSignalHandlers === "function") {
        db.processManager.removeSignalHandlers();
      }
      if (db.cronManager && typeof db.cronManager.removeSignalHandlers === "function") {
        db.cronManager.removeSignalHandlers();
        if (typeof db.cronManager.shutdown === "function") {
          await db.cronManager.shutdown();
        }
      }
      db.savedMetadata = null;
      db.plugins = {};
      db.pluginList = [];
    });
  }
};
var Database = class extends SafeEventEmitter {
  id;
  version;
  s3dbVersion;
  resources;
  savedMetadata;
  databaseOptions;
  executorPool;
  taskExecutor;
  pluginList;
  pluginRegistry;
  plugins;
  cache;
  passphrase;
  bcryptRounds;
  versioningEnabled;
  strictValidation;
  strictHooks;
  disableResourceEvents;
  deferMetadataWrites;
  metadataWriteDelay;
  processManager;
  cronManager;
  logLevel;
  logger;
  client;
  connectionString;
  bucket;
  keyPrefix;
  _resourcesMap;
  _parallelism;
  _childLoggerLevels;
  _hooksModule;
  _coordinatorsModule;
  _recoveryModule;
  _metadataModule;
  _pluginsModule;
  _resourcesModule;
  _connectionModule;
  constructor(options) {
    super({
      logLevel: options.logLevel || options.loggerOptions?.level || "info",
      autoCleanup: options.autoCleanup !== false
    });
    this.id = (() => {
      const [ok, , id2] = tryFnSync(() => idGenerator(7));
      return ok && id2 ? id2 : `db-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    })();
    this.version = "1";
    this.s3dbVersion = (() => {
      const [ok, , version] = tryFnSync(() => typeof globalThis["19.3.17"] !== "undefined" && globalThis["19.3.17"] !== "19.3.17" ? globalThis["19.3.17"] : "latest");
      return ok ? version : "latest";
    })();
    this._resourcesMap = {};
    this.resources = new Proxy(this._resourcesMap, {
      get: (target, prop) => {
        if (typeof prop === "symbol" || prop === "constructor" || prop === "toJSON") {
          return target[prop];
        }
        if (target[prop]) {
          return target[prop];
        }
        return void 0;
      },
      ownKeys: (target) => {
        return Object.keys(target);
      },
      getOwnPropertyDescriptor: (target, prop) => {
        return Object.getOwnPropertyDescriptor(target, prop);
      }
    });
    this.savedMetadata = null;
    this.databaseOptions = options;
    const executorPoolConfig = options?.executorPool ?? options?.operationsPool;
    this._parallelism = this._normalizeParallelism(options?.parallelism ?? executorPoolConfig?.concurrency, 10);
    this.logLevel = options.logLevel || options.loggerOptions?.level || "info";
    const loggerOptions = { ...options.loggerOptions || {} };
    if (options.logLevel) {
      loggerOptions.level = options.logLevel;
    }
    if (options.logger) {
      this.logger = options.logger;
      if (options.logLevel) {
        this.logger.level = options.logLevel;
      }
    } else {
      const loggerConfig = getLoggerOptionsFromEnv(loggerOptions);
      this.logger = createLogger({
        name: "Database",
        ...loggerConfig
      });
    }
    this._childLoggerLevels = options.loggerOptions?.childLevels || {};
    if (options?.operationsPool && !options?.executorPool) {
      this.logger.warn('\u26A0\uFE0F  "operationsPool" is deprecated in s3db.js v16.x. Use "executorPool" instead. Migration: https://s3db.js/docs/migration/v16-to-v17');
    }
    this.executorPool = this._normalizeOperationsPool(executorPoolConfig, this._parallelism);
    if (options?.taskExecutorMonitoring) {
      this.executorPool.monitoring = this._deepMerge(this.executorPool.monitoring || {}, options.taskExecutorMonitoring);
    }
    this._parallelism = this.executorPool?.concurrency ?? this._parallelism;
    this.taskExecutor = this.executorPool;
    this.pluginList = options.plugins ?? [];
    this.pluginRegistry = {};
    this.plugins = this.pluginRegistry;
    this.cache = options.cache;
    this.passphrase = options.passphrase ?? "secret";
    this.bcryptRounds = options.bcryptRounds ?? 10;
    this.versioningEnabled = options.versioningEnabled ?? false;
    this.strictValidation = (options.strictValidation ?? true) !== false;
    this.strictHooks = options.strictHooks ?? false;
    this.disableResourceEvents = options.disableResourceEvents === true;
    this.deferMetadataWrites = options.deferMetadataWrites ?? false;
    this.metadataWriteDelay = options.metadataWriteDelay ?? 100;
    const exitOnSignal = (options.exitOnSignal ?? true) !== false;
    this.processManager = options.processManager ?? new ProcessManager({
      logLevel: this.logger.level,
      exitOnSignal
    });
    this.cronManager = options.cronManager ?? new CronManager({
      logLevel: this.logger.level,
      exitOnSignal
    });
    this._initializeClient(options);
    this._hooksModule = new DatabaseHooks(this);
    this._coordinatorsModule = new DatabaseCoordinators(this);
    this._recoveryModule = new DatabaseRecovery(this);
    this._metadataModule = new DatabaseMetadata(this);
    this._pluginsModule = new DatabasePlugins(this, this._coordinatorsModule);
    this._resourcesModule = new DatabaseResources(this, this._metadataModule, this._coordinatorsModule);
    this._connectionModule = new DatabaseConnection(this, this._metadataModule, this._recoveryModule, this._pluginsModule, this._coordinatorsModule);
    this._connectionModule.registerExitListener();
  }
  _initializeClient(options) {
    let connectionString = options.connectionString;
    if (!connectionString && (options.bucket || options.accessKeyId || options.secretAccessKey)) {
      const { bucket, region, accessKeyId, secretAccessKey, endpoint, forcePathStyle } = options;
      if (endpoint) {
        const url = new URL(endpoint);
        if (accessKeyId)
          url.username = encodeURIComponent(accessKeyId);
        if (secretAccessKey)
          url.password = encodeURIComponent(secretAccessKey);
        url.pathname = `/${bucket || "s3db"}`;
        if (forcePathStyle) {
          url.searchParams.set("forcePathStyle", "true");
        }
        connectionString = url.toString();
      } else if (accessKeyId && secretAccessKey) {
        const params = new URLSearchParams();
        params.set("region", region || "us-east-1");
        if (forcePathStyle) {
          params.set("forcePathStyle", "true");
        }
        connectionString = `s3://${encodeURIComponent(accessKeyId)}:${encodeURIComponent(secretAccessKey)}@${bucket || "s3db"}?${params.toString()}`;
      }
    }
    let mergedClientOptions = {};
    let connStr = null;
    if (options.clientOptions) {
      mergedClientOptions = { ...options.clientOptions };
    }
    if (connectionString) {
      try {
        connStr = new ConnectionString(connectionString);
        if (connStr.clientOptions && Object.keys(connStr.clientOptions).length > 0) {
          mergedClientOptions = this._deepMerge(mergedClientOptions, connStr.clientOptions);
        }
      } catch {
      }
    }
    if (!options.client && connectionString) {
      try {
        const url = new URL(connectionString);
        if (url.protocol === "memory:") {
          const bucketHost = url.hostname || "test-bucket";
          const [okBucket, , decodedBucket] = tryFnSync(() => decodeURIComponent(bucketHost));
          const bucket = okBucket ? decodedBucket : bucketHost;
          const rawPrefix = url.pathname ? url.pathname.substring(1) : "";
          const [okPrefix, , decodedPrefix] = tryFnSync(() => decodeURIComponent(rawPrefix));
          const keyPrefix = okPrefix ? decodedPrefix : rawPrefix;
          const memoryOptions = this._applyTaskExecutorMonitoring(this._deepMerge({
            bucket,
            keyPrefix,
            logLevel: this.logger.level
          }, mergedClientOptions));
          this.client = new MemoryClient(memoryOptions);
        } else if (url.protocol === "file:") {
          const filesystemOptions = this._applyTaskExecutorMonitoring(this._deepMerge({
            basePath: connStr?.basePath,
            bucket: connStr?.bucket,
            keyPrefix: connStr?.keyPrefix,
            logLevel: this.logger.level
          }, mergedClientOptions));
          this.client = new FileSystemClient(filesystemOptions);
        } else {
          const s3ClientOptions = this._deepMerge({
            logLevel: this.logger.level,
            logger: this.getChildLogger("S3Client"),
            connectionString
          }, mergedClientOptions);
          s3ClientOptions.executorPool = this._deepMerge(s3ClientOptions.executorPool || {}, this.executorPool);
          this.client = new S3Client(s3ClientOptions);
        }
      } catch {
        const s3ClientOptions = this._deepMerge({
          logLevel: this.logger.level,
          logger: this.getChildLogger("S3Client"),
          connectionString
        }, mergedClientOptions);
        s3ClientOptions.executorPool = this._deepMerge(s3ClientOptions.executorPool || {}, this.executorPool);
        this.client = new S3Client(s3ClientOptions);
      }
    } else if (!options.client) {
      const s3ClientOptions = this._deepMerge({
        logLevel: this.logger.level,
        logger: this.getChildLogger("S3Client")
      }, mergedClientOptions);
      s3ClientOptions.executorPool = this._deepMerge(s3ClientOptions.executorPool || {}, this.executorPool);
      this.client = new S3Client(s3ClientOptions);
    } else {
      this.client = options.client;
    }
    const resolvedConnectionString = connectionString || this._inferConnectionStringFromClient(this.client);
    this.connectionString = resolvedConnectionString;
    if (!this.databaseOptions.connectionString && resolvedConnectionString) {
      this.databaseOptions.connectionString = resolvedConnectionString;
    }
    this.bucket = this.client.bucket || "";
    this.keyPrefix = this.client.keyPrefix || "";
  }
  get parallelism() {
    return this._parallelism ?? 10;
  }
  set parallelism(value) {
    const normalized = this._normalizeParallelism(value, this._parallelism ?? 10);
    this._parallelism = normalized;
    if (this.executorPool) {
      this.executorPool.concurrency = normalized;
    }
  }
  setConcurrency(value) {
    const normalized = this._normalizeParallelism(value, this._parallelism ?? 10);
    this._parallelism = normalized;
    if (this.executorPool) {
      this.executorPool.concurrency = normalized;
    }
  }
  get operationsPool() {
    return this.executorPool;
  }
  get config() {
    return {
      version: this.version,
      s3dbVersion: this.s3dbVersion,
      bucket: this.bucket,
      keyPrefix: this.keyPrefix,
      taskExecutor: this.taskExecutor,
      logLevel: this.logger.level
    };
  }
  getChildLogger(name, bindings = {}) {
    const childLogger = this.logger.child({
      name,
      ...bindings
    });
    const levelOverride = this._childLoggerLevels[name];
    if (levelOverride) {
      childLogger.level = levelOverride;
    }
    return childLogger;
  }
  setChildLevel(name, level) {
    this._childLoggerLevels[name] = level;
  }
  async connect() {
    return this._connectionModule.connect();
  }
  async disconnect() {
    return this._connectionModule.disconnect();
  }
  isConnected() {
    return this._connectionModule.isConnected();
  }
  async startPlugins() {
    return this._pluginsModule.startPlugins();
  }
  async usePlugin(plugin, name = null) {
    return this._pluginsModule.usePlugin(plugin, name);
  }
  async uninstallPlugin(name, options = {}) {
    return this._pluginsModule.uninstallPlugin(name, options);
  }
  async getGlobalCoordinator(namespace, options = {}) {
    return this._coordinatorsModule.getGlobalCoordinator(namespace, options);
  }
  async createResource(config) {
    return this._resourcesModule.createResource(config);
  }
  async listResources() {
    return this._resourcesModule.listResources();
  }
  async getResource(name) {
    return this._resourcesModule.getResource(name);
  }
  resourceExists(name) {
    return this._resourcesModule.resourceExists(name);
  }
  resourceExistsWithSameHash(params) {
    return this._resourcesModule.resourceExistsWithSameHash(params);
  }
  prewarmResources(resourceNames) {
    const warmed = [];
    const skipped = [];
    const alreadyCompiled = [];
    const resources = resourceNames ? resourceNames.map((name) => this._resourcesMap[name]).filter(Boolean) : Object.values(this._resourcesMap);
    for (const resource of resources) {
      if (!resource)
        continue;
      if (resource.isSchemaCompiled()) {
        alreadyCompiled.push(resource.name);
        continue;
      }
      try {
        resource.prewarmSchema();
        warmed.push(resource.name);
      } catch (err) {
        skipped.push(resource.name);
        this.logger.warn({ resource: resource.name, err }, `[PREWARM] Failed to prewarm resource schema`);
      }
    }
    this.logger.debug({ warmed: warmed.length, skipped: skipped.length, alreadyCompiled: alreadyCompiled.length }, `[PREWARM] Resources prewarmed`);
    return { warmed, skipped, alreadyCompiled };
  }
  async uploadMetadataFile() {
    return this._metadataModule.uploadMetadataFile();
  }
  async flushMetadata() {
    return this._metadataModule.flushMetadata();
  }
  blankMetadataStructure() {
    return this._metadataModule.blankMetadataStructure();
  }
  detectDefinitionChanges(savedMetadata) {
    return this._metadataModule.detectDefinitionChanges(savedMetadata);
  }
  generateDefinitionHash(definition, behavior) {
    return this._metadataModule.generateDefinitionHash(definition, behavior);
  }
  getNextVersion(versions = {}) {
    return this._metadataModule.getNextVersion(versions);
  }
  addHook(event, fn) {
    return this._hooksModule.addHook(event, fn);
  }
  removeHook(event, fn) {
    return this._hooksModule.removeHook(event, fn);
  }
  getHooks(event) {
    return this._hooksModule.getHooks(event);
  }
  clearHooks(event) {
    return this._hooksModule.clearHooks(event);
  }
  _deepMerge(target, source) {
    const result = { ...target };
    for (const key in source) {
      if (source[key] !== void 0) {
        if (typeof source[key] === "object" && source[key] !== null && !Array.isArray(source[key])) {
          result[key] = this._deepMerge(result[key] || {}, source[key]);
        } else {
          result[key] = source[key];
        }
      }
    }
    return result;
  }
  _applyTaskExecutorMonitoring(config) {
    if (!this.databaseOptions?.taskExecutorMonitoring) {
      return config;
    }
    const merged = { ...config };
    merged.taskExecutorMonitoring = this._deepMerge(this.databaseOptions.taskExecutorMonitoring, merged.taskExecutorMonitoring || {});
    return merged;
  }
  _normalizeParallelism(value, fallback = 10) {
    if (value === void 0 || value === null || value === "") {
      return fallback;
    }
    if (typeof value === "string") {
      const trimmed = value.trim();
      if (!trimmed) {
        return fallback;
      }
      if (trimmed.toLowerCase() === "auto") {
        return fallback;
      }
      const parsed = Number(trimmed);
      if (Number.isFinite(parsed) && parsed > 0) {
        return Math.floor(parsed);
      }
      return fallback;
    }
    if (typeof value === "number" && Number.isFinite(value) && value > 0) {
      return Math.floor(value);
    }
    return fallback;
  }
  _normalizeOperationsPool(config, defaultConcurrency = 10) {
    if (config === false || config?.enabled === false) {
      return { enabled: false, concurrency: this._normalizeParallelism(void 0, defaultConcurrency) };
    }
    const normalizedConcurrency = this._normalizeParallelism(config?.concurrency, defaultConcurrency);
    return {
      enabled: true,
      concurrency: normalizedConcurrency,
      retries: config?.retries ?? 3,
      retryDelay: config?.retryDelay ?? 1e3,
      timeout: config?.timeout ?? 3e4,
      retryableErrors: config?.retryableErrors ?? [],
      autotune: config?.autotune ?? null,
      monitoring: config?.monitoring ?? { collectMetrics: true }
    };
  }
  _inferConnectionStringFromClient(client2) {
    if (!client2) {
      return void 0;
    }
    if (client2.connectionString) {
      return client2.connectionString;
    }
    if (client2 instanceof MemoryClient) {
      const bucket = encodeURIComponent(client2.bucket || "s3db");
      const encodedPrefix = client2.keyPrefix ? client2.keyPrefix.split("/").filter(Boolean).map((segment) => encodeURIComponent(segment)).join("/") : "";
      const prefixPath = encodedPrefix ? `/${encodedPrefix}` : "";
      return `memory://${bucket}${prefixPath}`;
    }
    if (client2 instanceof FileSystemClient) {
      if (client2.basePath) {
        return `file://${encodeURI(client2.basePath)}`;
      }
    }
    return void 0;
  }
};
var FileStorage = class {
  dir;
  constructor(baseDir = ".recker/cache") {
    this.dir = baseDir;
  }
  getHash(key) {
    return (0, import_node_crypto2.createHash)("md5").update(key).digest("hex");
  }
  getPath(key) {
    return (0, import_node_path.join)(this.dir, `${this.getHash(key)}.json`);
  }
  async ensureDir() {
    if (!(0, import_node_fs.existsSync)(this.dir)) {
      await (0, import_promises.mkdir)(this.dir, { recursive: true });
    }
  }
  async get(key) {
    try {
      const path3 = this.getPath(key);
      if (!(0, import_node_fs.existsSync)(path3))
        return void 0;
      const content = await (0, import_promises.readFile)(path3, "utf-8");
      const data2 = JSON.parse(content);
      return data2;
    } catch (error2) {
      return void 0;
    }
  }
  async set(key, entry, ttl) {
    await this.ensureDir();
    const path3 = this.getPath(key);
    await (0, import_promises.writeFile)(path3, JSON.stringify(entry), "utf-8");
  }
  async delete(key) {
    const path3 = this.getPath(key);
    if ((0, import_node_fs.existsSync)(path3)) {
      await (0, import_promises.unlink)(path3);
    }
  }
  async clear() {
    if ((0, import_node_fs.existsSync)(this.dir)) {
      await (0, import_promises.rm)(this.dir, { recursive: true, force: true });
    }
  }
};
var basicFileStorage = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  FileStorage
});
var RingBuffer = class {
  capacity;
  buffer;
  head = 0;
  _count = 0;
  constructor(capacity) {
    this.capacity = capacity;
    if (capacity < 1) {
      throw new Error("RingBuffer capacity must be at least 1");
    }
    this.buffer = new Array(capacity);
  }
  push(value) {
    this.buffer[this.head] = value;
    this.head = (this.head + 1) % this.capacity;
    if (this._count < this.capacity) {
      this._count++;
    }
  }
  toArray() {
    if (this._count === 0)
      return [];
    const result = [];
    if (this._count < this.capacity) {
      for (let i4 = 0; i4 < this._count; i4++) {
        result.push(this.buffer[i4]);
      }
    } else {
      for (let i4 = 0; i4 < this.capacity; i4++) {
        const idx = (this.head + i4) % this.capacity;
        result.push(this.buffer[idx]);
      }
    }
    return result;
  }
  get count() {
    return this._count;
  }
  get isFull() {
    return this._count === this.capacity;
  }
  clear() {
    this.buffer = new Array(this.capacity);
    this.head = 0;
    this._count = 0;
  }
};
var LatencyBuffer = class extends RingBuffer {
  sortedCache = null;
  sortedCacheVersion = 0;
  currentVersion = 0;
  constructor(capacity = 100) {
    super(capacity);
  }
  push(value) {
    super.push(value);
    this.currentVersion++;
    this.sortedCache = null;
  }
  getSorted() {
    if (this.sortedCache && this.sortedCacheVersion === this.currentVersion) {
      return this.sortedCache;
    }
    this.sortedCache = this.toArray().sort((a4, b4) => a4 - b4);
    this.sortedCacheVersion = this.currentVersion;
    return this.sortedCache;
  }
  percentile(p4) {
    if (p4 < 0 || p4 > 100) {
      throw new Error("Percentile must be between 0 and 100");
    }
    const sorted = this.getSorted();
    if (sorted.length === 0)
      return 0;
    if (p4 === 0)
      return sorted[0];
    if (p4 === 100)
      return sorted[sorted.length - 1];
    const idx = Math.ceil(p4 / 100 * sorted.length) - 1;
    return sorted[Math.max(0, idx)];
  }
  p50() {
    return this.percentile(50);
  }
  p95() {
    return this.percentile(95);
  }
  p99() {
    return this.percentile(99);
  }
  max() {
    const sorted = this.getSorted();
    return sorted.length > 0 ? sorted[sorted.length - 1] : 0;
  }
  min() {
    const sorted = this.getSorted();
    return sorted.length > 0 ? sorted[0] : 0;
  }
  avg() {
    const arr = this.toArray();
    if (arr.length === 0)
      return 0;
    return arr.reduce((sum, val) => sum + val, 0) / arr.length;
  }
  getStats() {
    return {
      count: this.count,
      min: this.min(),
      max: this.max(),
      avg: this.avg(),
      p50: this.p50(),
      p95: this.p95(),
      p99: this.p99()
    };
  }
  clear() {
    super.clear();
    this.sortedCache = null;
    this.currentVersion++;
  }
};
var serviceCounter = 0;
var GlobalCoordinatorService = class extends import_events.EventEmitter {
  namespace;
  database;
  serviceId;
  workerId;
  isRunning;
  isLeader;
  currentLeaderId;
  currentEpoch;
  config;
  heartbeatTimer;
  electionTimer;
  subscribedPlugins;
  metrics;
  _circuitBreaker;
  _contentionState;
  _latencyBuffer;
  _heartbeatStartedAt;
  _heartbeatMutexTimeoutMs;
  _cachedState;
  _stateCacheTime;
  _stateCacheTtl;
  storage;
  _pluginStorage;
  logger;
  constructor({ namespace, database, config = {} }) {
    super();
    if (!namespace) {
      throw new Error("GlobalCoordinatorService: namespace is required");
    }
    if (!database) {
      throw new Error("GlobalCoordinatorService: database is required");
    }
    this.namespace = namespace;
    this.database = database;
    this.serviceId = `global-coordinator-${Date.now()}-${++serviceCounter}`;
    this.workerId = this._generateWorkerId();
    this.isRunning = false;
    this.isLeader = false;
    this.currentLeaderId = null;
    this.currentEpoch = 0;
    this.config = this._normalizeConfig(config);
    this.heartbeatTimer = null;
    this.electionTimer = null;
    this.subscribedPlugins = /* @__PURE__ */ new Map();
    this.metrics = {
      heartbeatCount: 0,
      electionCount: 0,
      electionDurationMs: 0,
      leaderChanges: 0,
      workerRegistrations: 0,
      workerTimeouts: 0,
      startTime: null,
      lastHeartbeatTime: null,
      circuitBreakerTrips: 0,
      circuitBreakerState: "closed",
      contentionEvents: 0,
      epochDriftEvents: 0
    };
    this._contentionState = {
      lastEventTime: 0,
      rateLimitMs: this.config.contentionRateLimitMs
    };
    this._latencyBuffer = new LatencyBuffer(this.config.metricsBufferSize);
    this._circuitBreaker = {
      state: "closed",
      failureCount: 0,
      lastFailureTime: null,
      lastSuccessTime: null,
      openedAt: null,
      failureThreshold: config.circuitBreaker?.failureThreshold ?? 5,
      resetTimeout: config.circuitBreaker?.resetTimeout ?? 3e4,
      halfOpenMaxAttempts: config.circuitBreaker?.halfOpenMaxAttempts ?? 1
    };
    this.storage = null;
    this._pluginStorage = null;
    this._heartbeatStartedAt = 0;
    this._heartbeatMutexTimeoutMs = (this.config.heartbeatInterval + this.config.heartbeatJitter) * 2;
    this._cachedState = null;
    this._stateCacheTime = 0;
    this._stateCacheTtl = this.config.stateCacheTtl;
    this.logger = database.getChildLogger(`GlobalCoordinator:${namespace}`);
  }
  async start() {
    if (this.isRunning) {
      this._log("Service already running");
      return;
    }
    try {
      this.storage = this._getStorage();
      await this._initializeMetadata();
      this.isRunning = true;
      this.metrics.startTime = Date.now();
      this._log("Service started");
      this._startLoop();
    } catch (err) {
      this.isRunning = false;
      this._logError("Failed to start service", err);
      throw err;
    }
  }
  async _startLoop() {
    try {
      const jitterMs = Math.random() * this.config.heartbeatJitter;
      await this._sleep(jitterMs);
      if (this.isRunning) {
        await this._heartbeatCycle();
        this._scheduleHeartbeat();
      }
    } catch (err) {
      this._logError("Error in background loop start", err);
      if (this.isRunning) {
        setTimeout(() => this._startLoop(), 5e3);
      }
    }
  }
  async stop() {
    if (!this.isRunning)
      return;
    try {
      this.isRunning = false;
      this.isLeader = false;
      this.currentLeaderId = null;
      if (this.heartbeatTimer) {
        clearTimeout(this.heartbeatTimer);
        this.heartbeatTimer = null;
      }
      if (this.electionTimer) {
        clearTimeout(this.electionTimer);
        this.electionTimer = null;
      }
      await this._unregisterWorker();
      this.subscribedPlugins.clear();
      this._log("Service stopped");
    } catch (err) {
      this._logError("Error stopping service", err);
    }
  }
  async subscribePlugin(pluginName, plugin) {
    const subStart = Date.now();
    this.logger.debug({ namespace: this.namespace, pluginName }, `[SUBSCRIBE] START`);
    if (!pluginName || !plugin) {
      throw new Error("GlobalCoordinatorService: pluginName and plugin required");
    }
    this.subscribedPlugins.set(pluginName, plugin);
    this._log(`Plugin subscribed: ${pluginName}`);
    if (this.isRunning && this.storage) {
      this.logger.debug({ namespace: this.namespace, pluginName }, `[SUBSCRIBE] triggering background heartbeat`);
      this._heartbeatCycle().catch((err) => {
        this._logError("Background heartbeat after plugin subscription failed", err);
      });
    }
    const totalMs = Date.now() - subStart;
    this.logger.debug({ namespace: this.namespace, pluginName, totalMs }, `[SUBSCRIBE] complete`);
  }
  unsubscribePlugin(pluginName) {
    this.subscribedPlugins.delete(pluginName);
    this._log(`Plugin unsubscribed: ${pluginName}`);
  }
  async isLeaderCheck(workerId) {
    if (!workerId)
      return false;
    return this.currentLeaderId === workerId && this.isLeader;
  }
  async getLeader() {
    if (!this.isRunning)
      return null;
    return this.currentLeaderId;
  }
  async getEpoch() {
    if (!this.isRunning)
      return 0;
    return this.currentEpoch;
  }
  async getActiveWorkers() {
    if (!this.storage)
      return [];
    return await this.storage.listActiveWorkers(this._getWorkersPrefix(), this.config.workerTimeout);
  }
  getMetrics() {
    return {
      ...this.metrics,
      latency: this._latencyBuffer.getStats(),
      metricsWindowSize: this._latencyBuffer.count
    };
  }
  incrementEpochDriftEvents() {
    this.metrics.epochDriftEvents++;
  }
  async _heartbeatCycle() {
    if (!this.isRunning || !this.storage)
      return;
    const now = Date.now();
    const mutexExpired = this._heartbeatStartedAt > 0 && now - this._heartbeatStartedAt > this._heartbeatMutexTimeoutMs;
    if (this._heartbeatStartedAt > 0 && !mutexExpired) {
      this.logger.debug({ namespace: this.namespace, elapsedMs: now - this._heartbeatStartedAt }, `[HEARTBEAT] SKIPPED - already in progress`);
      return;
    }
    if (mutexExpired) {
      this.logger.warn({ namespace: this.namespace, elapsedMs: now - this._heartbeatStartedAt }, `[HEARTBEAT] Previous heartbeat timed out, forcing mutex release`);
    }
    if (!this._circuitBreakerAllows()) {
      this.logger.debug({ namespace: this.namespace }, `[HEARTBEAT] SKIPPED - circuit breaker open`);
      return;
    }
    this._heartbeatStartedAt = now;
    try {
      const startMs = Date.now();
      this.logger.debug({ namespace: this.namespace }, `[HEARTBEAT] START`);
      const regStart = Date.now();
      await this._registerWorker();
      this.logger.debug({ namespace: this.namespace, ms: Date.now() - regStart }, `[HEARTBEAT] _registerWorker complete`);
      const stateStart = Date.now();
      const state2 = await this._getState();
      this.logger.debug({ namespace: this.namespace, ms: Date.now() - stateStart, hasState: !!state2 }, `[HEARTBEAT] _getState complete`);
      const previousLeaderId = this.currentLeaderId;
      const now2 = Date.now();
      let newLeaderId = state2?.leaderId ?? null;
      let newEpoch = state2?.epoch ?? this.currentEpoch ?? 0;
      let needsNewElection = !state2 || state2.leaseEnd && now2 >= state2.leaseEnd;
      if (!needsNewElection && state2?.leaderId) {
        const isLeaderCoordinator = state2.leaderId.startsWith("gcs-");
        if (isLeaderCoordinator) {
          const workerIds = await this.storage.listActiveWorkerIds(this._getWorkersPrefix(), this.config.workerTimeout);
          const hasPluginWorkers = workerIds.some((id2) => !id2.startsWith("gcs-"));
          if (hasPluginWorkers) {
            this._log("Plugin workers available, forcing re-election");
            needsNewElection = true;
          }
        }
      }
      if (needsNewElection) {
        this.logger.debug({ namespace: this.namespace }, `[HEARTBEAT] needs election, calling _conductElection`);
        const electionStart = Date.now();
        const electionResult = await this._conductElection(newEpoch);
        this.logger.debug({ namespace: this.namespace, ms: Date.now() - electionStart, leader: electionResult?.leaderId }, `[HEARTBEAT] _conductElection complete`);
        newLeaderId = electionResult?.leaderId || null;
        newEpoch = electionResult?.epoch ?? newEpoch + 1;
        this.metrics.electionCount++;
      }
      this.currentLeaderId = newLeaderId;
      this.currentEpoch = newEpoch || 1;
      this.isLeader = newLeaderId === this.workerId;
      this.metrics.heartbeatCount++;
      this.metrics.lastHeartbeatTime = Date.now();
      if (previousLeaderId !== newLeaderId) {
        this.metrics.leaderChanges++;
        this.logger.debug({ namespace: this.namespace, from: previousLeaderId, to: newLeaderId }, `[HEARTBEAT] leader changed, notifying plugins`);
        this._notifyLeaderChange(previousLeaderId, newLeaderId);
      }
      const durationMs = Date.now() - startMs;
      this.metrics.electionDurationMs = durationMs;
      this._latencyBuffer.push(durationMs);
      this._circuitBreakerSuccess();
      this._checkContention(durationMs);
      if (durationMs > 100) {
        this.logger.warn({ namespace: this.namespace, durationMs }, `[PERF] SLOW HEARTBEAT detected`);
      } else {
        this.logger.debug({ namespace: this.namespace, durationMs }, `[HEARTBEAT] complete`);
      }
    } catch (err) {
      this._circuitBreakerFailure();
      this._logError("Heartbeat cycle failed", err);
    } finally {
      this._heartbeatStartedAt = 0;
    }
  }
  _checkContention(durationMs) {
    if (!this.config.contentionEnabled)
      return;
    const ratio = durationMs / this.config.heartbeatInterval;
    if (ratio > this.config.contentionThreshold) {
      this.metrics.contentionEvents++;
      const now = Date.now();
      if (now - this._contentionState.lastEventTime > this._contentionState.rateLimitMs) {
        this._contentionState.lastEventTime = now;
        const event = {
          namespace: this.namespace,
          duration: durationMs,
          expected: this.config.heartbeatInterval,
          ratio,
          threshold: this.config.contentionThreshold,
          timestamp: now
        };
        this.emit("contention:detected", event);
        this.logger.warn({
          namespace: this.namespace,
          durationMs,
          expectedMs: this.config.heartbeatInterval,
          ratio: ratio.toFixed(2),
          threshold: this.config.contentionThreshold
        }, `Contention detected: heartbeat took ${ratio.toFixed(1)}x longer than expected`);
      }
    }
  }
  async _conductElection(previousEpoch = 0) {
    try {
      this.logger.debug({ namespace: this.namespace }, `[ELECTION] START`);
      const listStart = Date.now();
      const workerIds = await this.storage.listActiveWorkerIds(this._getWorkersPrefix(), this.config.workerTimeout);
      this.logger.debug({ namespace: this.namespace, ms: Date.now() - listStart, count: workerIds?.length }, `[ELECTION] listActiveWorkerIds complete`);
      const pluginWorkerIds = workerIds.filter((id2) => !id2.startsWith("gcs-"));
      this.logger.debug({ namespace: this.namespace, pluginWorkers: pluginWorkerIds?.length, allWorkers: workerIds?.length }, `[ELECTION] filtered workers`);
      const candidateIds = pluginWorkerIds.length > 0 ? pluginWorkerIds : workerIds;
      if (candidateIds.length === 0) {
        this.logger.debug({ namespace: this.namespace }, `[ELECTION] no workers available`);
        this._log("No workers available for election");
        return { leaderId: null, epoch: previousEpoch };
      }
      const elected = candidateIds[0] ?? null;
      const now = Date.now();
      const leaseEnd = now + this.config.leaseTimeout;
      const epoch = previousEpoch + 1;
      const newState = {
        leaderId: elected,
        leaderPod: elected ? this._getWorkerPod(elected) : void 0,
        epoch,
        leaseStart: now,
        leaseEnd,
        electedBy: this.workerId,
        electedAt: now
      };
      this._log(`Attempting to elect leader: ${elected}`);
      const [ok, err] = await tryFn$1(() => this.storage.set(this._getStateKey(), newState, {
        ttl: Math.ceil(this.config.leaseTimeout / 1e3) + 60,
        behavior: "body-only"
      }));
      if (!ok) {
        this._logError("Failed to store new leader state", err);
        return { leaderId: null, epoch: previousEpoch };
      }
      this._invalidateStateCache();
      this._log(`Leader elected: ${elected}`);
      return { leaderId: elected, epoch };
    } catch (err) {
      this._logError("Election failed", err);
      return { leaderId: null, epoch: previousEpoch };
    }
  }
  async _registerWorker() {
    if (!this.storage)
      return;
    const regStart = Date.now();
    this.logger.debug({ namespace: this.namespace, subscribedCount: this.subscribedPlugins.size }, `[REGISTER_WORKER] START`);
    const registeredIds = /* @__PURE__ */ new Set();
    const registrations = [];
    let deduped = 0;
    registrations.push(this._registerWorkerEntry(this.workerId));
    registeredIds.add(this.workerId);
    for (const [pluginName, plugin] of this.subscribedPlugins.entries()) {
      if (plugin && plugin.workerId) {
        if (registeredIds.has(plugin.workerId)) {
          this.logger.debug({ namespace: this.namespace, pluginName, workerId: plugin.workerId.substring(0, 30) }, `[REGISTER_WORKER] deduped workerId`);
          deduped++;
          continue;
        }
        registrations.push(this._registerWorkerEntry(plugin.workerId, pluginName));
        registeredIds.add(plugin.workerId);
      }
    }
    await Promise.all(registrations);
    const totalMs = Date.now() - regStart;
    if (totalMs > 50) {
      this.logger.warn({ namespace: this.namespace, totalMs, uniqueWorkers: registrations.length, deduped }, `[PERF] SLOW _registerWorker`);
    } else {
      this.logger.debug({ namespace: this.namespace, totalMs, uniqueWorkers: registrations.length, deduped }, `[REGISTER_WORKER] complete`);
    }
  }
  async _registerWorkerEntry(workerId, pluginName = null) {
    if (!workerId || !this.storage)
      return;
    const [ok, err] = await tryFn$1(() => this.storage.set(this._getWorkerKey(workerId), {
      workerId,
      pluginName: pluginName || "coordinator",
      pod: this._getWorkerPod(workerId),
      lastHeartbeat: Date.now(),
      startTime: this.metrics.startTime,
      namespace: this.namespace
    }, {
      ttl: Math.ceil(this.config.workerTimeout / 1e3),
      behavior: "body-only"
    }));
    if (!ok) {
      this._logError(`Failed to register worker heartbeat for ${workerId}`, err);
    } else {
      this.metrics.workerRegistrations++;
    }
  }
  async _unregisterWorker() {
    if (!this.storage)
      return;
    const unregistrations = [
      this._unregisterWorkerEntry(this.workerId)
    ];
    for (const [, plugin] of this.subscribedPlugins.entries()) {
      if (plugin && plugin.workerId) {
        unregistrations.push(this._unregisterWorkerEntry(plugin.workerId));
      }
    }
    await Promise.all(unregistrations);
  }
  async _unregisterWorkerEntry(workerId) {
    if (!workerId || !this.storage)
      return;
    const [ok, err] = await tryFn$1(() => this.storage.delete(this._getWorkerKey(workerId)));
    if (!ok) {
      this._logError(`Failed to unregister worker ${workerId}`, err);
    }
  }
  async _getState() {
    if (!this.storage)
      return null;
    const now = Date.now();
    if (this._stateCacheTtl > 0 && this._cachedState && now - this._stateCacheTime < this._stateCacheTtl) {
      this.logger.debug({ namespace: this.namespace, cacheAge: now - this._stateCacheTime }, `[STATE_CACHE] HIT`);
      return this._cachedState;
    }
    const [ok, , data2] = await tryFn$1(() => this.storage.get(this._getStateKey()));
    if (!ok) {
      return null;
    }
    if (this._stateCacheTtl > 0) {
      this._cachedState = data2;
      this._stateCacheTime = now;
      this.logger.debug({ namespace: this.namespace }, `[STATE_CACHE] MISS - cached`);
    }
    return data2;
  }
  _invalidateStateCache() {
    this._cachedState = null;
    this._stateCacheTime = 0;
  }
  async _initializeMetadata() {
    if (!this.storage)
      return;
    const [ok, err] = await tryFn$1(() => this.storage.set(this._getMetadataKey(), {
      namespace: this.namespace,
      serviceId: this.serviceId,
      createdAt: Date.now(),
      createdBy: this.workerId,
      plugins: Array.from(this.subscribedPlugins.keys())
    }, {
      ttl: 3600,
      behavior: "body-only"
    }));
    if (!ok) {
      this._logError("Failed to initialize metadata", err);
    }
  }
  _notifyLeaderChange(previousLeaderId, newLeaderId) {
    const event = {
      namespace: this.namespace,
      previousLeader: previousLeaderId,
      newLeader: newLeaderId,
      epoch: this.currentEpoch,
      timestamp: Date.now()
    };
    this._log(`Leader changed: ${previousLeaderId || "none"} \u2192 ${newLeaderId}`, `(epoch: ${this.currentEpoch})`);
    this.emit("leader:changed", event);
    for (const [pluginName, plugin] of this.subscribedPlugins) {
      this._notifyPlugin(pluginName, plugin, "leader:changed", event);
    }
  }
  _notifyPlugin(pluginName, plugin, eventType, data2) {
    try {
      if (eventType === "leader:changed") {
        const isLeader = data2.newLeader === this.workerId;
        if (plugin.onGlobalLeaderChange) {
          plugin.onGlobalLeaderChange(isLeader, data2);
        }
      }
    } catch (err) {
      this._logError(`Plugin notification failed (${pluginName}):`, err);
    }
  }
  _scheduleHeartbeat() {
    if (!this.isRunning)
      return;
    if (this.heartbeatTimer) {
      clearTimeout(this.heartbeatTimer);
    }
    const jitterMs = Math.random() * this.config.heartbeatJitter;
    const delayMs = this.config.heartbeatInterval + jitterMs;
    this.heartbeatTimer = setTimeout(async () => {
      await this._heartbeatCycle();
      this._scheduleHeartbeat();
    }, delayMs);
  }
  _getStorage() {
    if (!this.database || !this.database.client) {
      throw new Error("GlobalCoordinatorService: database client not available");
    }
    if (!this._pluginStorage) {
      this._pluginStorage = new CoordinatorPluginStorage(this.database.client, "coordinator");
    }
    return this._pluginStorage;
  }
  _getStateKey() {
    return this.storage.getPluginKey(null, `namespace=${this.namespace}`, "state.json");
  }
  _getWorkersPrefix() {
    return this.storage.getPluginKey(null, `namespace=${this.namespace}`, "workers") + "/";
  }
  _getWorkerKey(workerId) {
    return this.storage.getPluginKey(null, `namespace=${this.namespace}`, "workers", `worker=${workerId}.json`);
  }
  _getMetadataKey() {
    return this.storage.getPluginKey(null, `namespace=${this.namespace}`, "metadata.json");
  }
  _circuitBreakerAllows() {
    const cb = this._circuitBreaker;
    const now = Date.now();
    if (cb.state === "closed") {
      return true;
    }
    if (cb.state === "open") {
      if (cb.openedAt && now - cb.openedAt >= cb.resetTimeout) {
        cb.state = "half-open";
        this.metrics.circuitBreakerState = "half-open";
        this._log("Circuit breaker transitioning to half-open");
        return true;
      }
      return false;
    }
    return true;
  }
  _circuitBreakerSuccess() {
    const cb = this._circuitBreaker;
    if (cb.state === "half-open") {
      cb.state = "closed";
      cb.failureCount = 0;
      this.metrics.circuitBreakerState = "closed";
      this._log("Circuit breaker closed after successful recovery");
    } else if (cb.state === "closed") {
      cb.failureCount = 0;
    }
    cb.lastSuccessTime = Date.now();
  }
  _circuitBreakerFailure() {
    const cb = this._circuitBreaker;
    const now = Date.now();
    cb.failureCount++;
    cb.lastFailureTime = now;
    if (cb.state === "half-open") {
      cb.state = "open";
      cb.openedAt = now;
      this.metrics.circuitBreakerState = "open";
      this.metrics.circuitBreakerTrips++;
      this._log("Circuit breaker reopened after half-open failure");
      this.emit("circuitBreaker:open", { namespace: this.namespace, failureCount: cb.failureCount });
    } else if (cb.state === "closed" && cb.failureCount >= cb.failureThreshold) {
      cb.state = "open";
      cb.openedAt = now;
      this.metrics.circuitBreakerState = "open";
      this.metrics.circuitBreakerTrips++;
      this._log(`Circuit breaker opened after ${cb.failureCount} failures`);
      this.emit("circuitBreaker:open", { namespace: this.namespace, failureCount: cb.failureCount });
    }
  }
  getCircuitBreakerStatus() {
    const cb = this._circuitBreaker;
    return {
      state: cb.state,
      failureCount: cb.failureCount,
      failureThreshold: cb.failureThreshold,
      resetTimeout: cb.resetTimeout,
      lastFailureTime: cb.lastFailureTime,
      lastSuccessTime: cb.lastSuccessTime,
      openedAt: cb.openedAt,
      trips: this.metrics.circuitBreakerTrips
    };
  }
  _getWorkerPod(_workerId) {
    if (typeof process !== "undefined" && process.env) {
      return process.env.HOSTNAME || process.env.NODE_NAME || "unknown";
    }
    return "unknown";
  }
  _normalizeConfig(config) {
    return {
      heartbeatInterval: Math.max(1e3, config.heartbeatInterval || 5e3),
      heartbeatJitter: Math.max(0, config.heartbeatJitter || 1e3),
      leaseTimeout: Math.max(5e3, config.leaseTimeout || 15e3),
      workerTimeout: Math.max(5e3, config.workerTimeout || 2e4),
      diagnosticsEnabled: Boolean(config.diagnosticsEnabled ?? false),
      contentionEnabled: config.contention?.enabled ?? true,
      contentionThreshold: config.contention?.threshold ?? 2,
      contentionRateLimitMs: config.contention?.rateLimitMs ?? 3e4,
      metricsBufferSize: Math.max(10, config.metricsBufferSize ?? 100),
      stateCacheTtl: Math.max(0, config.stateCacheTtl ?? 2e3)
    };
  }
  _sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
  _log(...args) {
    if (this.config.diagnosticsEnabled) {
      this.logger.debug(args[0], ...args.slice(1));
    }
  }
  _logError(msg, err) {
    if (this.config.diagnosticsEnabled) {
      this.logger.error({ error: err?.message || String(err) }, msg);
    }
  }
  _generateWorkerId() {
    const env = typeof process !== "undefined" ? process.env : {};
    if (env.POD_NAME) {
      return `gcs-${env.POD_NAME}-${++serviceCounter}`;
    }
    if (env.HOSTNAME) {
      return `gcs-${env.HOSTNAME}-${++serviceCounter}`;
    }
    if (this.database && this.database.id) {
      return `gcs-${this.database.id}-${++serviceCounter}`;
    }
    return `gcs-${this.namespace}-${Date.now()}-${Math.random().toString(36).slice(2, 9)}-${++serviceCounter}`;
  }
};
var CoordinatorPluginStorage = class extends PluginStorage {
  constructor(client2, pluginSlug = "coordinator") {
    super(client2, pluginSlug);
  }
  async list(prefix = "", options = {}) {
    const { limit } = options;
    const fullPrefix = prefix || "";
    const [ok, err, result] = await tryFn$1(() => this.client.listObjects({ prefix: fullPrefix, maxKeys: limit }));
    if (!ok) {
      throw err;
    }
    const keys2 = result.Contents?.map((item) => item.Key) || [];
    return this._removeKeyPrefix(keys2);
  }
  async listWithPrefix(prefix = "", options = {}) {
    const keys2 = await this.list(prefix, options);
    if (!keys2 || keys2.length === 0) {
      return [];
    }
    const results = await this.batchGet(keys2);
    return results.filter((item) => item.ok && item.data != null).map((item) => item.data);
  }
  async _getActiveKeys(prefix, timeoutMs) {
    const fullPrefix = prefix || "";
    const [ok, , result] = await tryFn$1(() => this.client.listObjects({ prefix: fullPrefix }));
    if (!ok || !result.Contents) {
      return [];
    }
    const now = Date.now();
    const activeKeys = [];
    const staleKeys = [];
    for (const obj of result.Contents) {
      const lastModified = obj.LastModified ? new Date(obj.LastModified).getTime() : 0;
      const age = now - lastModified;
      if (age < timeoutMs + 5e3) {
        activeKeys.push(obj.Key);
      } else {
        staleKeys.push(obj.Key);
      }
    }
    if (staleKeys.length > 0) {
      this._deleteStaleWorkers(staleKeys).catch(() => {
      });
    }
    return activeKeys;
  }
  async listActiveWorkers(prefix, timeoutMs) {
    const activeKeys = await this._getActiveKeys(prefix, timeoutMs);
    const keysToFetch = this._removeKeyPrefix(activeKeys);
    if (keysToFetch.length === 0)
      return [];
    const results = await this.batchGet(keysToFetch);
    return results.filter((item) => item.ok && item.data != null).map((item) => item.data).sort((a4, b4) => (a4.workerId || "").localeCompare(b4.workerId || ""));
  }
  async listActiveWorkerIds(prefix, timeoutMs) {
    const activeKeys = await this._getActiveKeys(prefix, timeoutMs);
    const keysToProcess = this._removeKeyPrefix(activeKeys);
    if (keysToProcess.length === 0)
      return [];
    return keysToProcess.map((key) => {
      const parts = key.split("/");
      const filename = parts[parts.length - 1];
      const rawId = filename.replace(".json", "");
      return rawId.startsWith("worker=") ? rawId.slice("worker=".length) : rawId;
    }).filter((id2) => id2).sort((a4, b4) => a4.localeCompare(b4));
  }
  async _deleteStaleWorkers(keys2) {
    const cleanKeys = this._removeKeyPrefix(keys2);
    if (cleanKeys.length > 0) {
      await Promise.all(cleanKeys.map((key) => this.client.deleteObject(key)));
    }
  }
};
var globalCoordinatorService_class = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  CoordinatorPluginStorage,
  GlobalCoordinatorService
});

// src/client.ts
var import_node_os2 = __toESM(require("node:os"), 1);

// src/lib/crypto.ts
var import_node_crypto3 = __toESM(require("node:crypto"), 1);
function hybridEncrypt(data2, publicKeyPem, algorithm = "rsa-4096") {
  const aesKey = import_node_crypto3.default.randomBytes(32);
  const iv = import_node_crypto3.default.randomBytes(12);
  const cipher = import_node_crypto3.default.createCipheriv("aes-256-gcm", aesKey, iv);
  const encryptedData = Buffer.concat([
    cipher.update(data2, "utf8"),
    cipher.final()
  ]);
  const authTag = cipher.getAuthTag();
  let encryptedKey;
  if (algorithm.startsWith("rsa-")) {
    encryptedKey = import_node_crypto3.default.publicEncrypt(
      {
        key: publicKeyPem,
        padding: import_node_crypto3.default.constants.RSA_PKCS1_OAEP_PADDING,
        oaepHash: "sha256"
      },
      aesKey
    );
  } else if (algorithm.startsWith("ec-")) {
    const curve = algorithm === "ec-p256" ? "prime256v1" : "secp384r1";
    const privateKeySize = algorithm === "ec-p256" ? 32 : 48;
    const publicKeySize = algorithm === "ec-p256" ? 65 : 97;
    const ephemeralKeyPair = import_node_crypto3.default.generateKeyPairSync("ec", {
      namedCurve: curve,
      publicKeyEncoding: { type: "spki", format: "pem" },
      privateKeyEncoding: { type: "pkcs8", format: "pem" }
    });
    const ecdh = import_node_crypto3.default.createECDH(curve);
    ecdh.setPrivateKey(
      import_node_crypto3.default.createPrivateKey(ephemeralKeyPair.privateKey).export({ type: "pkcs8", format: "der" }).subarray(-privateKeySize)
      // Extract raw private key (32 for P-256, 48 for P-384)
    );
    const publicKeyObj = import_node_crypto3.default.createPublicKey(publicKeyPem);
    const publicKeyDer = publicKeyObj.export({ type: "spki", format: "der" });
    const sharedSecret = ecdh.computeSecret(publicKeyDer.subarray(-publicKeySize));
    const derivedKeyBuffer = Buffer.from(import_node_crypto3.default.hkdfSync("sha256", sharedSecret, "", "vaulter-ec", 32));
    const xorKey = Buffer.alloc(32);
    for (let i4 = 0; i4 < 32; i4++) {
      xorKey[i4] = aesKey[i4] ^ derivedKeyBuffer[i4];
    }
    const ephemeralPubKeyDer = import_node_crypto3.default.createPublicKey(ephemeralKeyPair.publicKey).export({ type: "spki", format: "der" });
    encryptedKey = Buffer.concat([
      Buffer.from([ephemeralPubKeyDer.length >> 8, ephemeralPubKeyDer.length & 255]),
      ephemeralPubKeyDer,
      xorKey
    ]);
  } else {
    throw new Error(`Unsupported algorithm: ${algorithm}`);
  }
  return {
    v: 1,
    alg: `${algorithm}+aes-256-gcm`,
    key: encryptedKey.toString("base64"),
    iv: iv.toString("base64"),
    data: encryptedData.toString("base64"),
    tag: authTag.toString("base64")
  };
}
function hybridDecrypt(encrypted, privateKeyPem) {
  if (encrypted.v !== 1) {
    throw new Error(`Unsupported encryption version: ${encrypted.v}`);
  }
  const [algorithm] = encrypted.alg.split("+");
  const encryptedKey = Buffer.from(encrypted.key, "base64");
  const iv = Buffer.from(encrypted.iv, "base64");
  const encryptedData = Buffer.from(encrypted.data, "base64");
  const authTag = Buffer.from(encrypted.tag, "base64");
  let aesKey;
  if (algorithm.startsWith("rsa-")) {
    aesKey = import_node_crypto3.default.privateDecrypt(
      {
        key: privateKeyPem,
        padding: import_node_crypto3.default.constants.RSA_PKCS1_OAEP_PADDING,
        oaepHash: "sha256"
      },
      encryptedKey
    );
  } else if (algorithm.startsWith("ec-")) {
    const curve = algorithm === "ec-p256" ? "prime256v1" : "secp384r1";
    const privateKeySize = algorithm === "ec-p256" ? 32 : 48;
    const publicKeySize = algorithm === "ec-p256" ? 65 : 97;
    const ephemeralPubKeyLen = encryptedKey[0] << 8 | encryptedKey[1];
    const ephemeralPubKeyDer = encryptedKey.subarray(2, 2 + ephemeralPubKeyLen);
    const xorKey = encryptedKey.subarray(2 + ephemeralPubKeyLen);
    const privateKeyObj = import_node_crypto3.default.createPrivateKey(privateKeyPem);
    const privateKeyDer = privateKeyObj.export({ type: "pkcs8", format: "der" });
    const ecdh = import_node_crypto3.default.createECDH(curve);
    ecdh.setPrivateKey(privateKeyDer.subarray(-privateKeySize));
    const sharedSecret = ecdh.computeSecret(ephemeralPubKeyDer.subarray(-publicKeySize));
    const derivedKeyBuffer = Buffer.from(import_node_crypto3.default.hkdfSync("sha256", sharedSecret, "", "vaulter-ec", 32));
    aesKey = Buffer.alloc(32);
    for (let i4 = 0; i4 < 32; i4++) {
      aesKey[i4] = xorKey[i4] ^ derivedKeyBuffer[i4];
    }
  } else {
    throw new Error(`Unsupported algorithm: ${algorithm}`);
  }
  const decipher = import_node_crypto3.default.createDecipheriv("aes-256-gcm", aesKey, iv);
  decipher.setAuthTag(authTag);
  const decrypted = Buffer.concat([
    decipher.update(encryptedData),
    decipher.final()
  ]);
  return decrypted.toString("utf8");
}
function isHybridEncrypted(data2) {
  if (typeof data2 !== "object" || data2 === null) return false;
  const obj = data2;
  return obj.v === 1 && typeof obj.alg === "string" && typeof obj.key === "string" && typeof obj.iv === "string" && typeof obj.data === "string" && typeof obj.tag === "string";
}
function serializeEncrypted(data2) {
  return JSON.stringify(data2);
}

// src/client.ts
var DEFAULT_CONNECTION_STRING = `file://${import_node_os2.default.homedir()}/.vaulter/store`;
var DEFAULT_PASSPHRASE = "vaulter-default-dev-key";
function toBase64Url(str) {
  return Buffer.from(str, "utf8").toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}
function generateVarId(project, environment, service, key) {
  const input = `${project}|${environment}|${service || ""}|${key}`;
  return toBase64Url(input);
}
var VaulterClient = class {
  db = null;
  resource = null;
  connectionStrings;
  activeConnectionString = null;
  passphrase;
  initialized = false;
  verbose;
  // Asymmetric encryption properties
  encryptionMode;
  publicKey;
  privateKey;
  asymmetricAlgorithm;
  constructor(options = {}) {
    if (options.connectionStrings && options.connectionStrings.length > 0) {
      this.connectionStrings = options.connectionStrings;
    } else if (options.connectionString) {
      this.connectionStrings = [options.connectionString];
    } else {
      this.connectionStrings = [DEFAULT_CONNECTION_STRING];
    }
    this.passphrase = options.passphrase || DEFAULT_PASSPHRASE;
    this.verbose = options.verbose || false;
    this.encryptionMode = options.encryptionMode || "symmetric";
    this.publicKey = options.publicKey || null;
    this.privateKey = options.privateKey || null;
    this.asymmetricAlgorithm = options.asymmetricAlgorithm || "rsa-4096";
    if (this.encryptionMode === "asymmetric") {
      if (!this.publicKey && !this.privateKey) {
        throw new Error("Asymmetric mode requires at least a public key (for encryption) or private key (for decryption)");
      }
    }
  }
  /**
   * Encrypt a value using the configured encryption mode
   * For symmetric mode, encryption is handled by s3db.js
   * For asymmetric mode, we use hybrid encryption
   */
  encryptValue(value) {
    if (this.encryptionMode === "symmetric") {
      return value;
    }
    if (!this.publicKey) {
      throw new Error("Cannot encrypt: public key not configured");
    }
    const encrypted = hybridEncrypt(value, this.publicKey, this.asymmetricAlgorithm);
    return serializeEncrypted(encrypted);
  }
  /**
   * Decrypt a value using the configured encryption mode
   * For symmetric mode, decryption is handled by s3db.js
   * For asymmetric mode, we use hybrid decryption
   */
  decryptValue(value) {
    if (this.encryptionMode === "symmetric") {
      return value;
    }
    try {
      const parsed = JSON.parse(value);
      if (isHybridEncrypted(parsed)) {
        if (!this.privateKey) {
          throw new Error("Cannot decrypt: private key not configured");
        }
        return hybridDecrypt(parsed, this.privateKey);
      }
    } catch {
    }
    return value;
  }
  /**
   * Check if the client can encrypt (has public key for asymmetric mode)
   */
  canEncrypt() {
    if (this.encryptionMode === "symmetric") {
      return !!this.passphrase;
    }
    return !!this.publicKey;
  }
  /**
   * Check if the client can decrypt (has private key for asymmetric mode)
   */
  canDecrypt() {
    if (this.encryptionMode === "symmetric") {
      return !!this.passphrase;
    }
    return !!this.privateKey;
  }
  /**
   * Initialize the client and connect to the storage backend
   * Tries each URL in order until one succeeds (fallback support)
   */
  async connect() {
    if (this.initialized) return;
    const errors2 = [];
    for (const connectionString of this.connectionStrings) {
      try {
        if (this.verbose) {
          console.error(`[vaulter] Trying backend: ${this.maskCredentials(connectionString)}`);
        }
        this.db = new Database({
          connectionString,
          passphrase: this.passphrase,
          logLevel: this.verbose ? "debug" : "silent"
        });
        await this.db.connect();
        const valueFieldType = this.encryptionMode === "symmetric" ? "secret|required" : "string|required";
        this.resource = await this.db.createResource({
          name: "environment-variables",
          // Deterministic ID generator for O(1) lookups
          // Format: {project}|{environment}|{service}|{key}
          idGenerator: (data2) => generateVarId(data2.project, data2.environment, data2.service, data2.key),
          attributes: {
            key: "string|required",
            value: valueFieldType,
            // Encryption depends on mode
            project: "string|required",
            service: "string|optional",
            environment: "string|required",
            // User-defined environment names (no enum constraint)
            tags: "array|items:string|optional",
            metadata: {
              description: "string|optional",
              owner: "string|optional",
              rotateAfter: "date|optional",
              source: { type: "string", enum: ["manual", "sync", "import"], optional: true }
            }
          },
          // Partitions for O(1) queries
          partitions: {
            byProject: {
              fields: { project: "string" }
            },
            byProjectEnv: {
              fields: { project: "string", environment: "string" }
            },
            byProjectServiceEnv: {
              fields: { project: "string", service: "string", environment: "string" }
            },
            // Cross-project partition for compliance/auditing
            byEnvironment: {
              fields: { environment: "string" }
            }
          },
          behavior: "body-overflow",
          // Works for both symmetric and asymmetric modes
          timestamps: true,
          asyncPartitions: true
          // Faster writes
        });
        this.activeConnectionString = connectionString;
        this.initialized = true;
        if (this.verbose) {
          console.error(`[vaulter] Connected to: ${this.maskCredentials(connectionString)}`);
        }
        return;
      } catch (err) {
        errors2.push({ url: connectionString, error: err });
        if (this.verbose) {
          console.error(`[vaulter] Failed to connect to ${this.maskCredentials(connectionString)}: ${err.message}`);
        }
        if (this.db) {
          try {
            await this.db.disconnect();
          } catch {
          }
          this.db = null;
        }
      }
    }
    const errorMessages = errors2.map((e4) => `  - ${this.maskCredentials(e4.url)}: ${e4.error.message}`).join("\n");
    throw new Error(`Failed to connect to any backend:
${errorMessages}`);
  }
  /**
   * Mask credentials in connection string for logging
   */
  maskCredentials(url) {
    return url.replace(/:([^:@/]+)@/, ":***@");
  }
  /**
   * Ensure client is connected
   */
  ensureConnected() {
    if (!this.initialized || !this.resource) {
      throw new Error("VaulterClient not initialized. Call connect() first.");
    }
  }
  /**
   * Get a single environment variable
   * Uses deterministic ID for O(1) lookup
   */
  async get(key, project, environment, service) {
    this.ensureConnected();
    const id2 = generateVarId(project, environment, service, key);
    const found = await this.resource.getOrNull(id2);
    if (!found) return null;
    return {
      ...found,
      value: this.decryptValue(found.value)
    };
  }
  /**
   * Set an environment variable (create or update)
   * Uses deterministic ID for O(1) upsert
   */
  async set(input) {
    this.ensureConnected();
    const encryptedValue = this.encryptValue(input.value);
    const id2 = generateVarId(input.project, input.environment, input.service, input.key);
    const existing = await this.resource.getOrNull(id2);
    if (existing) {
      const filteredInputMeta = input.metadata ? Object.fromEntries(Object.entries(input.metadata).filter(([, v4]) => v4 !== void 0)) : {};
      const result = await this.resource.update(id2, {
        value: encryptedValue,
        tags: input.tags,
        metadata: {
          ...existing.metadata,
          ...filteredInputMeta,
          source: input.metadata?.source || existing.metadata?.source || "manual"
        }
      });
      return { ...result, value: input.value };
    } else {
      const result = await this.resource.insert({
        id: id2,
        ...input,
        value: encryptedValue,
        metadata: {
          ...input.metadata,
          source: input.metadata?.source || "manual"
        }
      });
      return { ...result, value: input.value };
    }
  }
  /**
   * Delete an environment variable
   * Uses deterministic ID for O(1) deletion
   */
  async delete(key, project, environment, service) {
    this.ensureConnected();
    const id2 = generateVarId(project, environment, service, key);
    try {
      await this.resource.delete(id2);
      return true;
    } catch (err) {
      if (err?.code === "NOT_FOUND" || err?.message?.includes("not found")) {
        return false;
      }
      throw err;
    }
  }
  /**
   * List environment variables
   *
   * Automatically selects the most efficient partition based on provided filters:
   * - project + service + environment  byProjectServiceEnv
   * - project + environment  byProjectEnv
   * - project only  byProject
   * - environment only  byEnvironment (cross-project, for auditing)
   */
  async list(options = {}) {
    this.ensureConnected();
    const { project, service, environment, limit, offset } = options;
    let partition;
    let partitionValues;
    if (project && service && environment) {
      partition = "byProjectServiceEnv";
      partitionValues = { project, service, environment };
    } else if (project && environment) {
      partition = "byProjectEnv";
      partitionValues = { project, environment };
    } else if (project) {
      partition = "byProject";
      partitionValues = { project };
    } else if (environment) {
      partition = "byEnvironment";
      partitionValues = { environment };
    }
    const listOptions = {};
    if (partition && partitionValues) {
      listOptions.partition = partition;
      listOptions.partitionValues = partitionValues;
    }
    if (limit) listOptions.limit = limit;
    if (offset) listOptions.offset = offset;
    const results = await this.resource.list(listOptions);
    return results.map((item) => ({
      ...item,
      value: this.decryptValue(item.value)
    }));
  }
  /**
   * Bulk insert environment variables (legacy - uses sequential set)
   * @deprecated Use setMany for better performance
   */
  async insertMany(inputs) {
    return this.setMany(inputs);
  }
  /**
   * Set multiple environment variables efficiently
   * Uses deterministic IDs for O(1) lookups - fully parallel without list queries
   */
  async setMany(inputs) {
    this.ensureConnected();
    if (inputs.length === 0) return [];
    const results = await Promise.all(inputs.map(async (input) => {
      const id2 = generateVarId(input.project, input.environment, input.service, input.key);
      const encryptedValue = this.encryptValue(input.value);
      const existing = await this.resource.getOrNull(id2);
      if (existing) {
        const filteredInputMeta = input.metadata ? Object.fromEntries(Object.entries(input.metadata).filter(([, v4]) => v4 !== void 0)) : {};
        const result = await this.resource.update(id2, {
          value: encryptedValue,
          tags: input.tags,
          metadata: {
            ...existing.metadata,
            ...filteredInputMeta,
            source: input.metadata?.source || existing.metadata?.source || "manual"
          }
        });
        return { ...result, value: input.value };
      } else {
        const result = await this.resource.insert({
          ...input,
          value: encryptedValue,
          metadata: {
            ...input.metadata,
            source: input.metadata?.source || "manual"
          }
        });
        return { ...result, value: input.value };
      }
    }));
    return results;
  }
  /**
   * Get multiple environment variables efficiently
   * Uses deterministic IDs for O(1) parallel lookups
   */
  async getMany(keys2, project, environment, service) {
    this.ensureConnected();
    const entries = await Promise.all(
      keys2.map(async (key) => {
        const id2 = generateVarId(project, environment, service, key);
        const found = await this.resource.getOrNull(id2);
        if (!found) return [key, null];
        return [key, { ...found, value: this.decryptValue(found.value) }];
      })
    );
    return new Map(entries);
  }
  /**
   * Delete multiple environment variables efficiently
   * Uses deterministic IDs for O(1) parallel deletion - no list query needed
   */
  async deleteManyByKeys(keys2, project, environment, service) {
    this.ensureConnected();
    const ids = keys2.map((key) => generateVarId(project, environment, service, key));
    if (typeof this.resource.deleteMany === "function") {
      const result = await this.resource.deleteMany(ids);
      const deletedIds = new Set(result?.deleted || ids);
      const deleted = [];
      const notFound = [];
      for (let i4 = 0; i4 < keys2.length; i4++) {
        if (deletedIds.has(ids[i4])) {
          deleted.push(keys2[i4]);
        } else {
          notFound.push(keys2[i4]);
        }
      }
      return { deleted, notFound };
    } else {
      const results = await Promise.all(
        keys2.map(async (key, i4) => {
          try {
            await this.resource.delete(ids[i4]);
            return { key, deleted: true };
          } catch (err) {
            if (err?.code === "NOT_FOUND" || err?.message?.includes("not found")) {
              return { key, deleted: false };
            }
            throw err;
          }
        })
      );
      const deleted = results.filter((r4) => r4.deleted).map((r4) => r4.key);
      const notFound = results.filter((r4) => !r4.deleted).map((r4) => r4.key);
      return { deleted, notFound };
    }
  }
  /**
   * Delete all variables for a project/environment
   */
  async deleteAll(project, environment, service) {
    this.ensureConnected();
    const vars = await this.list({ project, environment, service });
    let deleted = 0;
    for (const v4 of vars) {
      await this.resource.delete(v4.id);
      deleted++;
    }
    return deleted;
  }
  /**
   * Export variables to a Record<string, string>
   *
   * When a service is specified, shared variables (__shared__) are automatically
   * included and merged, with service-specific values taking precedence.
   *
   * @param project - Project name
   * @param environment - Environment name
   * @param service - Service name (optional)
   * @param options - Export options
   * @param options.includeShared - Include shared vars when service is specified (default: true)
   */
  async export(project, environment, service, options = {}) {
    const { includeShared = true } = options;
    const result = {};
    if (service && service !== "__shared__" && includeShared) {
      const sharedVars = await this.list({ project, environment, service: "__shared__" });
      for (const v4 of sharedVars) {
        result[v4.key] = v4.value;
      }
    }
    const vars = await this.list({ project, environment, service });
    for (const v4 of vars) {
      result[v4.key] = v4.value;
    }
    return result;
  }
  /**
   * Sync variables from a Record<string, string>
   * Returns sync statistics
   * Optionally deletes remote keys that are missing from input
   */
  async sync(vars, project, environment, service, options = {}) {
    this.ensureConnected();
    const existing = await this.list({ project, environment, service });
    const existingMap = new Map(existing.map((v4) => [v4.key, v4]));
    const deleteMissing = options.deleteMissing ?? false;
    const result = {
      added: [],
      updated: [],
      deleted: [],
      unchanged: [],
      conflicts: []
    };
    for (const [key, value] of Object.entries(vars)) {
      const existingVar = existingMap.get(key);
      if (!existingVar) {
        await this.set({
          key,
          value,
          project,
          environment,
          service,
          metadata: { source: options.source || "sync" }
        });
        result.added.push(key);
      } else if (existingVar.value !== value) {
        await this.set({
          key,
          value,
          project,
          environment,
          service,
          metadata: { source: options.source || "sync" }
        });
        result.updated.push(key);
      } else {
        result.unchanged.push(key);
      }
      existingMap.delete(key);
    }
    if (deleteMissing) {
      for (const [key, existingVar] of existingMap) {
        await this.resource.delete(existingVar.id);
        result.deleted.push(key);
      }
    }
    return result;
  }
  /**
   * Close the connection
   */
  async disconnect() {
    if (this.db) {
      await this.db.disconnect();
      this.db = null;
      this.resource = null;
      this.initialized = false;
    }
  }
  /**
   * Check if client is connected
   */
  isConnected() {
    return this.initialized;
  }
  /**
   * Get the active connection string (the one that succeeded)
   */
  getConnectionString() {
    return this.activeConnectionString || this.connectionStrings[0];
  }
  /**
   * Get all configured connection strings
   */
  getConnectionStrings() {
    return this.connectionStrings;
  }
  /**
   * Get the current encryption mode
   */
  getEncryptionMode() {
    return this.encryptionMode;
  }
  /**
   * Get the asymmetric algorithm (only relevant in asymmetric mode)
   */
  getAsymmetricAlgorithm() {
    return this.asymmetricAlgorithm;
  }
};

// src/action/index.ts
process.env.S3DB_LOG_LEVEL = "silent";
process.env.S3DB_LOG_FORMAT = "json";
function setOutput(name, value) {
  const outputFile = process.env.GITHUB_OUTPUT;
  if (outputFile) {
    import_node_fs2.default.appendFileSync(outputFile, `${name}=${value}
`);
  } else {
    console.log(`::set-output name=${name}::${value}`);
  }
}
function setFailed(message) {
  console.error(`::error::${message}`);
  process.exitCode = 1;
}
function info(message) {
  console.log(message);
}
function warning(message) {
  console.log(`::warning::${message}`);
}
function setSecret(value) {
  console.log(`::add-mask::${value}`);
}
function exportVariable(name, value) {
  const envFile = process.env.GITHUB_ENV;
  if (envFile) {
    if (value.includes("\n")) {
      const delimiter = `ghadelimiter_${Date.now()}`;
      import_node_fs2.default.appendFileSync(envFile, `${name}<<${delimiter}
${value}
${delimiter}
`);
    } else {
      import_node_fs2.default.appendFileSync(envFile, `${name}=${value}
`);
    }
  }
}
async function run() {
  try {
    const inputs = getInputs();
    info(`\u{1F510} Vaulter Action`);
    info(`   Project: ${inputs.project}`);
    info(`   Environment: ${inputs.environment}`);
    if (inputs.service) {
      info(`   Service: ${inputs.service}`);
    }
    info(`   Outputs: ${inputs.outputs.join(", ")}`);
    info("");
    const clientOptions = {
      connectionString: inputs.backend,
      passphrase: inputs.passphrase,
      encryptionMode: inputs.encryptionMode,
      verbose: false
      // Disable verbose logging in action
    };
    if (inputs.encryptionMode === "asymmetric") {
      clientOptions.publicKey = inputs.publicKey;
      clientOptions.privateKey = inputs.privateKey;
      clientOptions.asymmetricAlgorithm = inputs.asymmetricAlgorithm;
    }
    const client2 = new VaulterClient(clientOptions);
    info("\u{1F4E1} Connecting to backend...");
    await client2.connect();
    info("\u2713 Connected");
    info("\u{1F4E5} Fetching variables...");
    const vars = await client2.export(
      inputs.project,
      inputs.environment,
      inputs.service,
      { includeShared: inputs.includeShared }
    );
    const varCount = Object.keys(vars).length;
    info(`\u2713 Found ${varCount} variables`);
    if (varCount === 0) {
      warning("No variables found for the specified project/environment/service");
      setOutput("vars-count", "0");
      setOutput("vars-json", "[]");
      await client2.disconnect();
      return;
    }
    if (inputs.maskValues) {
      for (const value of Object.values(vars)) {
        if (value && value.length > 3) {
          setSecret(value);
        }
      }
    }
    info("");
    info("\u{1F4DD} Generating outputs...");
    const generatedOutputs = {};
    for (const output of inputs.outputs) {
      let filePath;
      let content;
      switch (output) {
        case "env":
          filePath = inputs.envPath;
          content = generateEnvFile(vars);
          generatedOutputs["env-file"] = filePath;
          break;
        case "json":
          filePath = inputs.jsonPath;
          content = generateJsonFile(vars);
          generatedOutputs["json-file"] = filePath;
          break;
        case "k8s-secret":
          filePath = inputs.k8sSecretPath;
          content = generateK8sSecret(vars, {
            name: inputs.k8sSecretName || `${inputs.project}-secrets`,
            namespace: inputs.k8sNamespace,
            environment: inputs.environment
          });
          generatedOutputs["k8s-secret-file"] = filePath;
          break;
        case "k8s-configmap":
          filePath = inputs.k8sConfigMapPath;
          content = generateK8sConfigMap(vars, {
            name: inputs.k8sConfigMapName || `${inputs.project}-config`,
            namespace: inputs.k8sNamespace,
            environment: inputs.environment
          });
          generatedOutputs["k8s-configmap-file"] = filePath;
          break;
        case "helm-values":
          filePath = inputs.helmValuesPath;
          content = generateHelmValues(vars, {
            project: inputs.project,
            environment: inputs.environment,
            service: inputs.service
          });
          generatedOutputs["helm-values-file"] = filePath;
          break;
        case "tfvars":
          filePath = inputs.tfvarsPath;
          content = generateTfVars(vars, {
            project: inputs.project,
            environment: inputs.environment,
            service: inputs.service
          });
          generatedOutputs["tfvars-file"] = filePath;
          break;
        case "shell":
          filePath = inputs.shellPath;
          content = generateShellExport(vars);
          generatedOutputs["shell-file"] = filePath;
          break;
        default:
          warning(`Unknown output type: ${output}`);
          continue;
      }
      const dir = import_node_path2.default.dirname(filePath);
      if (dir && dir !== "." && !import_node_fs2.default.existsSync(dir)) {
        import_node_fs2.default.mkdirSync(dir, { recursive: true });
      }
      import_node_fs2.default.writeFileSync(filePath, content);
      info(`   \u2713 ${output} \u2192 ${filePath}`);
    }
    for (const [name, value] of Object.entries(generatedOutputs)) {
      setOutput(name, value);
    }
    setOutput("vars-count", String(varCount));
    setOutput("vars-json", JSON.stringify(Object.keys(vars)));
    if (inputs.exportToEnv) {
      info("");
      info("\u{1F4E4} Exporting to GITHUB_ENV...");
      for (const [key, value] of Object.entries(vars)) {
        exportVariable(key, value);
      }
      info(`\u2713 Exported ${varCount} variables to GITHUB_ENV`);
    }
    await client2.disconnect();
    info("");
    info("\u2705 Done!");
  } catch (error2) {
    if (error2 instanceof Error) {
      setFailed(error2.message);
    } else {
      setFailed(String(error2));
    }
  }
}
run();
/*! Bundled license information:

lodash-es/lodash.js:
  (**
   * @license
   * Lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="es" -o ./`
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

s3db.js/dist/s3db-lite.es.js:
  (*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> *)
  (*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> *)
  (*! https://mths.be/he v1.2.0 by @mathias | MIT license *)
*/
