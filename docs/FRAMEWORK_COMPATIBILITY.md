# Framework Compatibility Analysis

## The Real Problem

Vaulter is already framework-agnostic because it works with `.env` files.  
**The real problem is:**

1. **Where each framework expects `.env` to be located**
2. **What naming convention each framework uses**
3. **How it integrates with build/dev processes**

---

## Framework Matrix

### Standalone Frameworks

| Framework | Env Location | Naming Convention | Auto-load? | Notes |
|-----------|--------------|-------------------|------------|-------|
| **Next.js** | App root | `.env`, `.env.local`, `.env.development`, `.env.production` | ‚úÖ Built-in | `.env.local` has priority |
| **NestJS** | App root | `.env` | ‚ùå Requires `ConfigModule` | `ConfigModule.forRoot()` |
| **Express** | App root | `.env` | ‚ùå Requires dotenv | `require('dotenv').config()` |
| **Hono** | App root | `.env` | ‚ùå Manual | Depends on runtime |
| **Fastify** | App root | `.env` | ‚ùå Plugin required | `@fastify/env` or dotenv |
| **Remix** | App root | `.env` | ‚úÖ Built-in | Similar to Next.js |
| **Astro** | App root | `.env` | ‚úÖ Built-in | Similar to Next.js |
| **SvelteKit** | App root | `.env` | ‚úÖ Built-in | Through Vite |
| **Nuxt** | App root | `.env` | ‚úÖ Built-in | Through Vite |

### Monorepo Tools

| Tool | Workspace Config | Package Location | Env Strategy |
|------|------------------|------------------|--------------|
| **NX** | `nx.json` | `apps/*`, `libs/*` | Per-app or root |
| **Turborepo** | `turbo.json` | `apps/*`, `packages/*` | Per-app (recommended) |
| **pnpm workspaces** | `pnpm-workspace.yaml` | Flexible | Per-package |
| **Yarn workspaces** | `package.json` | Flexible | Per-package |
| **Lerna** | `lerna.json` | `packages/*` | Per-package |
| **Rush** | `rush.json` | Flexible | Per-project |

---

## Key Insight üéØ

**All these frameworks read `.env` from their own package/app root.**

That means in monorepos, each app has a different `.env` target.

```
monorepo/
‚îú‚îÄ‚îÄ apps/
‚îÇ   ‚îú‚îÄ‚îÄ web/              # Next.js reads .env here
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ .env
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ package.json
‚îÇ   ‚îî‚îÄ‚îÄ api/              # NestJS reads .env here
‚îÇ       ‚îú‚îÄ‚îÄ .env
‚îÇ       ‚îî‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ packages/
‚îÇ   ‚îî‚îÄ‚îÄ shared/
‚îî‚îÄ‚îÄ package.json
```

---

## Possible Strategies

### Strategy 1: Per-App Config (Current)

Each app has its own `.vaulter/config.yaml`:

```
monorepo/
‚îú‚îÄ‚îÄ .vaulter/
‚îÇ   ‚îî‚îÄ‚îÄ config.yaml         # Shared config
‚îú‚îÄ‚îÄ apps/
‚îÇ   ‚îú‚îÄ‚îÄ web/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ .vaulter/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ config.yaml # extends: ../../../.vaulter/config.yaml
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ .env            # generated by vaulter pull
‚îÇ   ‚îî‚îÄ‚îÄ api/
‚îÇ       ‚îú‚îÄ‚îÄ .vaulter/
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ config.yaml
‚îÇ       ‚îî‚îÄ‚îÄ .env
```

**Pros**
- ‚úÖ Each app controls its own vars
- ‚úÖ Works with any framework
- ‚úÖ Supports inheritance via `extends`

**Cons**
- ‚ùå Many config files to maintain
- ‚ùå More operational setup

### Strategy 2: Root-Only + Symlinks

Config only at root and symlinks per app:

```
monorepo/
‚îú‚îÄ‚îÄ .vaulter/
‚îÇ   ‚îú‚îÄ‚îÄ config.yaml
‚îÇ   ‚îî‚îÄ‚îÄ apps/
‚îÇ       ‚îú‚îÄ‚îÄ web.env
‚îÇ       ‚îî‚îÄ‚îÄ api.env
‚îú‚îÄ‚îÄ apps/
‚îÇ   ‚îú‚îÄ‚îÄ web/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ .env -> ../../.vaulter/apps/web.env
‚îÇ   ‚îî‚îÄ‚îÄ api/
‚îÇ       ‚îî‚îÄ‚îÄ .env -> ../../.vaulter/apps/api.env
```

**Pros**
- ‚úÖ Single config location
- ‚úÖ Easy to manage

**Cons**
- ‚ùå Symlinks can fail on Windows
- ‚ùå Git handling of symlinks is limited
- ‚ùå Docker `COPY` does not always follow symlinks

### Strategy 3: Root Config + Output Targets üéØ (RECOMMENDED)

**One root config defines where each app receives its `.env`:**

```yaml
# .vaulter/config.yaml
version: '1'
project: my-monorepo
environments: [dev, stg, prd]

services:
  web:
    type: next           # Optional hint
    output: apps/web      # Where to generate .env
    vars:
      - NEXT_PUBLIC_*
      - API_URL

  api:
    type: nest           # Optional hint
    output: apps/api
    vars:
      - DATABASE_*
      - REDIS_*
      - JWT_*

shared:
  vars:
    - LOG_LEVEL
    - NODE_ENV
```

**Command**
```bash
# Generates .env in apps/web and apps/api
vaulter local pull --all

# Or one output
vaulter local pull -s web
```

**Pros**
- ‚úÖ Single source config
- ‚úÖ Granular filtering per service
- ‚úÖ No symlinks
- ‚úÖ Works cross-platform
- ‚úÖ Framework hints are optional

**Cons**
- ‚ùå Implementation effort required

### Strategy 4: Framework Adapters

Framework-specific adapters with explicit conventions:

```yaml
# .vaulter/config.yaml
services:
  web:
    adapter: nextjs
    output: apps/web
```

`nextjs` adapter behavior:
- Generate `.env.local` instead of `.env`
- Keep public variable prefixing rules (`NEXT_PUBLIC_*`)
- Optionally generate `.env.development` and `.env.production`

**Pros**
- ‚úÖ Convention automation
- ‚úÖ Less manual config

**Cons**
- ‚ùå Adapter maintenance complexity
- ‚ùå Risk of over-engineering

---

## Recommendation: Strategy 3 + Optional Adapters

### Phase 1 (Strategy 3)

1. **Root config with services and outputs**
2. **Shared vars with inheritance**
3. **Glob patterns for variable filtering**
4. **`vaulter local pull --all` generates all outputs**

### Phase 2 (Adapters)

1. **Optional adapter per service**
2. **Built-in adapters:** `nextjs`, `nestjs`, `vite`, `generic`
3. **Custom adapters via config**

---

## Framework Conventions

### Next.js

```yaml
services:
  web:
    adapter: nextjs
    output: apps/web
```

Adapter output:
- `.env.local` (local vars, gitignored)
- `.env.development` (dev defaults)
- `.env.production` (prod defaults)

Automatically:
- Enforce public variable prefix `NEXT_PUBLIC_` when needed
- Warn when sensitive vars may be exposed without prefix

### NestJS

```yaml
services:
  api:
    adapter: nestjs
    output: apps/api
```

Adapter output:
- `.env` only
- Optional `.env.development`, `.env.production`

### Vite-based (SvelteKit, Nuxt, Astro)

```yaml
services:
  app:
    adapter: vite
    output: apps/app
```

Adapter output:
- `.env.local`
- `.env.development`
- `.env.production`

And automatically:
- Prefix public vars with `VITE_` when needed

---

## Build/Dev Integration

### Option A: `vaulter run`

```bash
vaulter run --service web -- pnpm dev
```

### Option B: `vaulter pull` + framework loader

```bash
vaulter local pull --all
pnpm dev
```

### Option C: dotenv-cli wrapper

```bash
dotenv -e <(vaulter export -f env web) -- pnpm dev
```

### Option D: Native integration (future)

```typescript
// next.config.ts
import { loadEnv } from 'vaulter/next'

export default loadEnv({
  service: 'web',
  environment: process.env.NODE_ENV
})
```

---

## Design Decisions

### 1. Where to place `.vaulter/`?

**Options**
- A) Monorepo root only
- B) Monorepo root + per-app
- C) Per app only

**Recommendation:** A (Root only)

**Reason:** Single source of truth, fewer config files, easier maintenance.

### 2. How to identify services?

**Options**
- A) Explicitly list in config
- B) Auto-discover from workspace patterns
- C) Hybrid approach

**Recommendation:** C (Hybrid)

```yaml
services:
  # Explicit
  web:
    output: apps/web

  # Auto-discover (future)
  discover:
    pattern: apps/*
    exclude: [shared, utils]
```

### 3. How to handle shared vars?

**Options**
- A) Duplicate on every service
- B) Shared section with inheritance
- C) Separate file

**Recommendation:** B (Shared section)

```yaml
shared:
  vars: [LOG_LEVEL, NODE_ENV]

services:
  web:
    inherit: shared  # default: true
    vars: [NEXT_PUBLIC_*]
```

### 4. How to handle secrets vs configs?

**Already implemented:** Pattern matching to detect sensitive values.

**Additional:** Allow explicit overrides:

```yaml
services:
  web:
    secrets: [DATABASE_URL]  # Force secret
    configs: [LOG_LEVEL]     # Force config
```

---

## Next Steps

1. [ ] Implement Strategy 3 (root config + output targets)
2. [ ] Add `services` section to config schema
3. [ ] Implement `vaulter local pull --all` generation semantics
4. [ ] Implement `vaulter local pull -s <name>` output targeting
5. [ ] Add glob patterns for filtering vars
6. [ ] (Phase 2) Implement framework adapters

## Open Questions

1. **How to handle vars that need transformation?**
   - Example: `API_URL` -> `NEXT_PUBLIC_API_URL`
   - Adapter, explicit config, or both?
2. **How to handle environment-specific vars?**
   - `DATABASE_URL` differs in dev/stg/prd
   - Already solved via environments, but how to generate multiple `.env` variants?
3. **CI/CD integration?**
   - GitHub Actions secrets
   - Kubernetes secrets
   - Terraform vars
4. **Migration for existing projects**
   - `vaulter scan` -> `vaulter init --from-scan`?
