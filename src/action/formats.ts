/**
 * Vaulter GitHub Action - Output Format Generators
 *
 * Generates output files in various formats for different IaC tools:
 * - env: Standard .env file
 * - json: JSON key-value pairs
 * - k8s-secret: Kubernetes Secret YAML
 * - k8s-configmap: Kubernetes ConfigMap YAML
 * - helm-values: Helm values.yaml
 * - tfvars: Terraform .tfvars
 * - shell: Shell export script
 */

// ─────────────────────────────────────────────────────────────────────────────
// Utility Functions
// ─────────────────────────────────────────────────────────────────────────────

/**
 * Encode string to base64 (for K8s secrets)
 */
function base64Encode(str: string): string {
  return Buffer.from(str, 'utf-8').toString('base64')
}

/**
 * Sanitize name for Kubernetes (lowercase, alphanumeric, dashes)
 */
function sanitizeK8sName(name: string): string {
  return name
    .toLowerCase()
    .replace(/[^a-z0-9-]/g, '-')
    .replace(/--+/g, '-')
    .replace(/^-|-$/g, '')
    .slice(0, 63)
}

/**
 * Escape value for .env file
 */
function escapeEnvValue(value: string): string {
  // If value contains special chars, wrap in quotes
  if (
    value.includes(' ') ||
    value.includes('"') ||
    value.includes("'") ||
    value.includes('#') ||
    value.includes('\n') ||
    value.includes('$') ||
    value.startsWith(' ') ||
    value.endsWith(' ')
  ) {
    // Use double quotes and escape internal quotes and backslashes
    return `"${value.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n')}"`
  }
  return value
}

/**
 * Format value for YAML (with proper quoting)
 */
function formatYamlValue(value: string): string {
  const needsQuote =
    value === '' ||
    value === 'true' ||
    value === 'false' ||
    value === 'null' ||
    value === 'yes' ||
    value === 'no' ||
    value === 'on' ||
    value === 'off' ||
    !isNaN(Number(value)) ||
    value.includes(':') ||
    value.includes('#') ||
    value.includes('\n') ||
    value.includes('"') ||
    value.includes("'") ||
    value.startsWith(' ') ||
    value.endsWith(' ') ||
    value.startsWith('{') ||
    value.startsWith('[') ||
    value.startsWith('*') ||
    value.startsWith('&')

  if (needsQuote) {
    return `"${value.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n')}"`
  }

  return value
}

/**
 * Format value for Terraform HCL
 */
function formatTfValue(value: string): string {
  const escaped = value
    .replace(/\\/g, '\\\\')
    .replace(/"/g, '\\"')
    .replace(/\n/g, '\\n')
    .replace(/\r/g, '\\r')
    .replace(/\t/g, '\\t')

  return `"${escaped}"`
}

/**
 * Escape value for shell (single quotes)
 */
function escapeShellValue(value: string): string {
  // Use single quotes and escape internal single quotes
  return `'${value.replace(/'/g, "'\\''")}'`
}

// ─────────────────────────────────────────────────────────────────────────────
// Format Generators
// ─────────────────────────────────────────────────────────────────────────────

/**
 * Generate .env file content
 */
export function generateEnvFile(vars: Record<string, string>): string {
  const lines = [
    '# Generated by Vaulter GitHub Action',
    `# Generated at: ${new Date().toISOString()}`,
    ''
  ]

  for (const [key, value] of Object.entries(vars)) {
    lines.push(`${key}=${escapeEnvValue(value)}`)
  }

  return lines.join('\n') + '\n'
}

/**
 * Generate JSON file content
 */
export function generateJsonFile(vars: Record<string, string>): string {
  return JSON.stringify(vars, null, 2) + '\n'
}

/**
 * Generate Kubernetes Secret YAML
 */
export function generateK8sSecret(
  vars: Record<string, string>,
  options: {
    name: string
    namespace: string
    environment: string
  }
): string {
  const lines = [
    '# Generated by Vaulter GitHub Action',
    `# Generated at: ${new Date().toISOString()}`,
    '# Apply: kubectl apply -f <file>',
    'apiVersion: v1',
    'kind: Secret',
    'metadata:',
    `  name: ${sanitizeK8sName(options.name)}`,
    `  namespace: ${sanitizeK8sName(options.namespace)}`,
    '  labels:',
    '    app.kubernetes.io/managed-by: vaulter',
    `    app.kubernetes.io/environment: ${options.environment}`,
    'type: Opaque',
    'data:'
  ]

  for (const [key, value] of Object.entries(vars)) {
    lines.push(`  ${key}: ${base64Encode(value)}`)
  }

  return lines.join('\n') + '\n'
}

/**
 * Generate Kubernetes ConfigMap YAML
 */
export function generateK8sConfigMap(
  vars: Record<string, string>,
  options: {
    name: string
    namespace: string
    environment: string
  }
): string {
  const lines = [
    '# Generated by Vaulter GitHub Action',
    `# Generated at: ${new Date().toISOString()}`,
    '# Apply: kubectl apply -f <file>',
    'apiVersion: v1',
    'kind: ConfigMap',
    'metadata:',
    `  name: ${sanitizeK8sName(options.name)}`,
    `  namespace: ${sanitizeK8sName(options.namespace)}`,
    '  labels:',
    '    app.kubernetes.io/managed-by: vaulter',
    `    app.kubernetes.io/environment: ${options.environment}`,
    'data:'
  ]

  for (const [key, value] of Object.entries(vars)) {
    lines.push(`  ${key}: ${formatYamlValue(value)}`)
  }

  return lines.join('\n') + '\n'
}

/**
 * Generate Helm values.yaml
 */
export function generateHelmValues(
  vars: Record<string, string>,
  options: {
    project: string
    environment: string
    service?: string
  }
): string {
  const lines = [
    '# Generated by Vaulter GitHub Action',
    `# Project: ${options.project}`,
    `# Environment: ${options.environment}`,
    options.service ? `# Service: ${options.service}` : null,
    `# Generated at: ${new Date().toISOString()}`,
    '# DO NOT EDIT - changes will be overwritten',
    '',
    '# All environment variables',
    'env:'
  ].filter(Boolean) as string[]

  for (const [key, value] of Object.entries(vars)) {
    lines.push(`  ${key}: ${formatYamlValue(value)}`)
  }

  // Also provide as envFrom-compatible format
  lines.push('')
  lines.push('# As key-value pairs for envFrom')
  lines.push('envVars:')

  for (const [key, value] of Object.entries(vars)) {
    lines.push(`  - name: ${key}`)
    lines.push(`    value: ${formatYamlValue(value)}`)
  }

  return lines.join('\n') + '\n'
}

/**
 * Generate Terraform .tfvars
 */
export function generateTfVars(
  vars: Record<string, string>,
  options: {
    project: string
    environment: string
    service?: string
  }
): string {
  const lines = [
    '# Generated by Vaulter GitHub Action',
    `# Project: ${options.project}`,
    `# Environment: ${options.environment}`,
    options.service ? `# Service: ${options.service}` : null,
    `# Generated at: ${new Date().toISOString()}`,
    '# DO NOT EDIT - changes will be overwritten',
    ''
  ].filter(Boolean) as string[]

  // Individual variables with lowercase names
  for (const [key, value] of Object.entries(vars)) {
    const tfKey = key.toLowerCase()
    lines.push(`${tfKey} = ${formatTfValue(value)}`)
  }

  // All vars as a map (useful for for_each)
  lines.push('')
  lines.push('# All environment variables as a map')
  lines.push('env_vars = {')

  for (const [key, value] of Object.entries(vars)) {
    lines.push(`  "${key}" = ${formatTfValue(value)}`)
  }

  lines.push('}')

  return lines.join('\n') + '\n'
}

/**
 * Generate shell export script
 */
export function generateShellExport(vars: Record<string, string>): string {
  const lines = [
    '#!/bin/bash',
    '# Generated by Vaulter GitHub Action',
    `# Generated at: ${new Date().toISOString()}`,
    '# Usage: source <file> or . <file>',
    ''
  ]

  for (const [key, value] of Object.entries(vars)) {
    lines.push(`export ${key}=${escapeShellValue(value)}`)
  }

  return lines.join('\n') + '\n'
}
