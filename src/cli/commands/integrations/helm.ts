/**
 * MiniEnv CLI - Helm Integration Commands
 *
 * Generate Helm values.yaml
 */

import type { CLIArgs, MiniEnvConfig, Environment } from '../../../types.js'
import { createClientFromConfig } from '../../lib/create-client.js'
import { getSecretPatterns, splitVarsBySecret } from '../../../lib/secret-patterns.js'

interface HelmContext {
  args: CLIArgs
  config: MiniEnvConfig | null
  project: string
  service?: string
  environment: Environment
  verbose: boolean
  jsonOutput: boolean
}

/**
 * Generate Helm values.yaml
 */
export async function runHelmValues(context: HelmContext): Promise<void> {
  const { args, config, project, service, environment, verbose, jsonOutput } = context

  if (!project) {
    console.error('Error: Project not specified')
    process.exit(1)
  }

  if (verbose) {
    console.error(`Generating Helm values for ${project}/${environment}`)
  }

  const client = await createClientFromConfig({ args, config, verbose })

  try {
    await client.connect()

    const vars = await client.export(project, environment, service)

    if (Object.keys(vars).length === 0) {
      console.error('Warning: No variables found')
      return
    }

    if (jsonOutput) {
      console.log(JSON.stringify({
        format: 'helm-values',
        project,
        environment,
        variableCount: Object.keys(vars).length
      }))
    } else {
      const patterns = getSecretPatterns(config)
      const { plain, secrets } = splitVarsBySecret(vars, patterns)

      // Generate Helm values YAML
      const yaml = generateHelmValuesYaml(plain, secrets, {
        project,
        service,
        environment
      })
      console.log(yaml)
    }
  } finally {
    await client.disconnect()
  }
}

/**
 * Generate Helm values YAML string
 *
 * Creates a structure like:
 * env:
 *   PUBLIC_URL: "..."
 *
 * secrets:
 *   DATABASE_URL: "..."
 *   API_KEY: "..."
 */
function generateHelmValuesYaml(
  plainVars: Record<string, string>,
  secretVars: Record<string, string>,
  metadata: { project: string; service?: string; environment: string }
): string {
  const lines: string[] = [
    '# Generated by minienv',
    `# Project: ${metadata.project}`,
    `# Environment: ${metadata.environment}`,
    metadata.service ? `# Service: ${metadata.service}` : null,
    '# DO NOT EDIT - changes will be overwritten',
    '',
    '# Environment variables (plain)',
    'env:'
  ].filter(Boolean) as string[]

  // Add env vars
  for (const [key, value] of Object.entries(plainVars)) {
    lines.push(`  ${key}: ${formatYamlValue(value)}`)
  }

  lines.push('')
  lines.push('# Secrets (matching patterns, for use with secretKeyRef)')
  lines.push('secrets:')

  for (const [key, value] of Object.entries(secretVars)) {
    lines.push(`  ${key}: ${formatYamlValue(value)}`)
  }

  return lines.join('\n')
}

/**
 * Format value for YAML
 */
function formatYamlValue(value: string): string {
  // Check if value needs quoting
  const needsQuote =
    value === '' ||
    value === 'true' ||
    value === 'false' ||
    value === 'null' ||
    value === 'yes' ||
    value === 'no' ||
    !isNaN(Number(value)) ||
    value.includes(':') ||
    value.includes('#') ||
    value.includes('\n') ||
    value.includes('"') ||
    value.includes("'") ||
    value.startsWith(' ') ||
    value.endsWith(' ') ||
    value.startsWith('{') ||
    value.startsWith('[')

  if (needsQuote) {
    // Use double quotes and escape special chars
    return `"${value.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n')}"`
  }

  return value
}
