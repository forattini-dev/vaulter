/**
 * Vaulter CLI - Helm Integration Commands
 *
 * Generate Helm values.yaml
 */

import type { CLIArgs, VaulterConfig, Environment } from '../../../types.js'
import { withClient } from '../../lib/create-client.js'
import { print } from '../../lib/colors.js'
import * as ui from '../../ui.js'

interface HelmContext {
  args: CLIArgs
  config: VaulterConfig | null
  project: string
  service?: string
  environment: Environment
  verbose: boolean
  jsonOutput: boolean
}

/**
 * Generate Helm values.yaml
 */
export async function runHelmValues(context: HelmContext): Promise<void> {
  const { args, config, project, service, environment, verbose, jsonOutput } = context

  if (!project) {
    print.error('Project not specified')
    process.exit(1)
  }

  ui.verbose(`Generating Helm values for ${project}/${environment}`, verbose)

  await withClient({ args, config, project, verbose }, async (client) => {
    // Use list() to get sensitive flag for each var
    const allVars = await client.list({ project, environment, service })

    if (allVars.length === 0) {
      print.warning('No variables found')
      return
    }

    if (jsonOutput) {
      ui.output(JSON.stringify({
        format: 'helm-values',
        project,
        environment,
        variableCount: allVars.length
      }))
    } else {
      // Split by sensitive flag (no pattern inference)
      const plain: Record<string, string> = {}
      const secrets: Record<string, string> = {}

      for (const v of allVars) {
        if (v.sensitive) {
          secrets[v.key] = v.value
        } else {
          plain[v.key] = v.value
        }
      }

      // Generate Helm values YAML
      const yaml = generateHelmValuesYaml(plain, secrets, {
        project,
        service,
        environment
      })
      ui.output(yaml)
    }
  })
}

/**
 * Generate Helm values YAML string
 *
 * Creates a structure like:
 * env:
 *   PUBLIC_URL: "..."
 *
 * secrets:
 *   DATABASE_URL: "..."
 *   API_KEY: "..."
 */
function generateHelmValuesYaml(
  plainVars: Record<string, string>,
  secretVars: Record<string, string>,
  metadata: { project: string; service?: string; environment: string }
): string {
  const lines: string[] = [
    '# Generated by vaulter',
    `# Project: ${metadata.project}`,
    `# Environment: ${metadata.environment}`,
    metadata.service ? `# Service: ${metadata.service}` : null,
    '# DO NOT EDIT - changes will be overwritten',
    '',
    '# Environment variables (plain)',
    'env:'
  ].filter(Boolean) as string[]

  // Add env vars
  for (const [key, value] of Object.entries(plainVars)) {
    lines.push(`  ${key}: ${formatYamlValue(value)}`)
  }

  lines.push('')
  lines.push('# Secrets (matching patterns, for use with secretKeyRef)')
  lines.push('secrets:')

  for (const [key, value] of Object.entries(secretVars)) {
    lines.push(`  ${key}: ${formatYamlValue(value)}`)
  }

  return lines.join('\n')
}

/**
 * Format value for YAML
 */
function formatYamlValue(value: string): string {
  // Check if value needs quoting
  const needsQuote =
    value === '' ||
    value === 'true' ||
    value === 'false' ||
    value === 'null' ||
    value === 'yes' ||
    value === 'no' ||
    !isNaN(Number(value)) ||
    value.includes(':') ||
    value.includes('#') ||
    value.includes('\n') ||
    value.includes('"') ||
    value.includes("'") ||
    value.startsWith(' ') ||
    value.endsWith(' ') ||
    value.startsWith('{') ||
    value.startsWith('[')

  if (needsQuote) {
    // Use double quotes and escape special chars
    return `"${value.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n')}"`
  }

  return value
}
