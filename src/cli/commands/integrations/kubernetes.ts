/**
 * MiniEnv CLI - Kubernetes Integration Commands
 *
 * Generate Kubernetes Secret and ConfigMap YAML
 */

import type { CLIArgs, MiniEnvConfig, Environment } from '../../../types.js'
import { MiniEnvClient } from '../../../client.js'
import { loadEncryptionKey } from '../../../lib/config-loader.js'

interface K8sContext {
  args: CLIArgs
  config: MiniEnvConfig | null
  project: string
  service?: string
  environment: Environment
  verbose: boolean
  jsonOutput: boolean
}

/**
 * Encode value to base64
 */
function base64Encode(value: string): string {
  return Buffer.from(value).toString('base64')
}

/**
 * Sanitize name for Kubernetes (lowercase, alphanumeric, hyphens)
 */
function sanitizeK8sName(name: string): string {
  return name
    .toLowerCase()
    .replace(/[^a-z0-9-]/g, '-')
    .replace(/--+/g, '-')
    .replace(/^-|-$/g, '')
}

/**
 * Generate Kubernetes Secret YAML
 */
export async function runK8sSecret(context: K8sContext): Promise<void> {
  const { args, config, project, service, environment, verbose, jsonOutput } = context

  if (!project) {
    console.error('Error: Project not specified')
    process.exit(1)
  }

  // Determine secret name and namespace
  const namespace = args.namespace || args.n ||
    config?.integrations?.kubernetes?.namespace ||
    `${project}-${environment}`

  const secretName = config?.integrations?.kubernetes?.secret_name ||
    (service ? `${service}-secrets` : `${project}-secrets`)

  if (verbose) {
    console.error(`Generating K8s Secret: ${namespace}/${secretName}`)
  }

  // Build connection string
  const connectionString = args.backend || args.b || config?.backend?.url
  const passphrase = config ? await loadEncryptionKey(config) : undefined

  const client = new MiniEnvClient({
    connectionString: connectionString || undefined,
    passphrase: passphrase || undefined
  })

  try {
    await client.connect()

    const vars = await client.export(project, environment, service)

    if (Object.keys(vars).length === 0) {
      console.error('Warning: No variables found')
      return
    }

    // Generate YAML
    const yaml = generateSecretYaml(
      sanitizeK8sName(secretName),
      sanitizeK8sName(namespace),
      vars,
      {
        project,
        service,
        environment,
        managedBy: 'minienv'
      }
    )

    if (jsonOutput) {
      console.log(JSON.stringify({
        kind: 'Secret',
        name: secretName,
        namespace,
        variableCount: Object.keys(vars).length
      }))
    } else {
      console.log(yaml)
    }
  } finally {
    await client.disconnect()
  }
}

/**
 * Generate Kubernetes ConfigMap YAML
 */
export async function runK8sConfigMap(context: K8sContext): Promise<void> {
  const { args, config, project, service, environment, verbose, jsonOutput } = context

  if (!project) {
    console.error('Error: Project not specified')
    process.exit(1)
  }

  // Determine configmap name and namespace
  const namespace = args.namespace || args.n ||
    config?.integrations?.kubernetes?.namespace ||
    `${project}-${environment}`

  const configMapName = config?.integrations?.kubernetes?.configmap_name ||
    (service ? `${service}-config` : `${project}-config`)

  if (verbose) {
    console.error(`Generating K8s ConfigMap: ${namespace}/${configMapName}`)
  }

  // Build connection string
  const connectionString = args.backend || args.b || config?.backend?.url
  const passphrase = config ? await loadEncryptionKey(config) : undefined

  const client = new MiniEnvClient({
    connectionString: connectionString || undefined,
    passphrase: passphrase || undefined
  })

  try {
    await client.connect()

    const vars = await client.export(project, environment, service)

    if (Object.keys(vars).length === 0) {
      console.error('Warning: No variables found')
      return
    }

    // Generate YAML
    const yaml = generateConfigMapYaml(
      sanitizeK8sName(configMapName),
      sanitizeK8sName(namespace),
      vars,
      {
        project,
        service,
        environment,
        managedBy: 'minienv'
      }
    )

    if (jsonOutput) {
      console.log(JSON.stringify({
        kind: 'ConfigMap',
        name: configMapName,
        namespace,
        variableCount: Object.keys(vars).length
      }))
    } else {
      console.log(yaml)
    }
  } finally {
    await client.disconnect()
  }
}

/**
 * Generate Secret YAML string
 */
function generateSecretYaml(
  name: string,
  namespace: string,
  data: Record<string, string>,
  labels: Record<string, string | undefined>
): string {
  const lines: string[] = [
    '# Generated by minienv',
    '# DO NOT EDIT - changes will be overwritten',
    'apiVersion: v1',
    'kind: Secret',
    'metadata:',
    `  name: ${name}`,
    `  namespace: ${namespace}`,
    '  labels:'
  ]

  // Add labels
  for (const [key, value] of Object.entries(labels)) {
    if (value) {
      lines.push(`    app.kubernetes.io/${key}: "${value}"`)
    }
  }

  lines.push('type: Opaque')
  lines.push('data:')

  // Add base64-encoded data
  for (const [key, value] of Object.entries(data)) {
    lines.push(`  ${key}: ${base64Encode(value)}`)
  }

  return lines.join('\n')
}

/**
 * Generate ConfigMap YAML string
 */
function generateConfigMapYaml(
  name: string,
  namespace: string,
  data: Record<string, string>,
  labels: Record<string, string | undefined>
): string {
  const lines: string[] = [
    '# Generated by minienv',
    '# DO NOT EDIT - changes will be overwritten',
    'apiVersion: v1',
    'kind: ConfigMap',
    'metadata:',
    `  name: ${name}`,
    `  namespace: ${namespace}`,
    '  labels:'
  ]

  // Add labels
  for (const [key, value] of Object.entries(labels)) {
    if (value) {
      lines.push(`    app.kubernetes.io/${key}: "${value}"`)
    }
  }

  lines.push('data:')

  // Add string data (quote values that need it)
  for (const [key, value] of Object.entries(data)) {
    const needsQuote = value.includes(':') ||
      value.includes('#') ||
      value.includes('\n') ||
      value.startsWith(' ') ||
      value.endsWith(' ')

    if (needsQuote) {
      lines.push(`  ${key}: "${value.replace(/"/g, '\\"').replace(/\n/g, '\\n')}"`)
    } else {
      lines.push(`  ${key}: ${value}`)
    }
  }

  return lines.join('\n')
}
