/**
 * Vaulter Domain Types
 *
 * State-centric domain model with explicit Scope, Provenance, and Lifecycle.
 *
 * Key concepts:
 * - Scope: 'shared' | 'service:<name>'
 * - Provenance: who/when/where/what for every mutation
 * - Lifecycle: active → deprecated → orphan
 * - Plan: the diff between local state and backend state
 * - Scorecard: actionable status summary
 */

// ============================================================================
// Core Domain Types
// ============================================================================

/**
 * Explicit scope for variable ownership
 *
 * @example
 * const shared: Scope = { kind: 'shared' }
 * const auth: Scope = { kind: 'service', name: 'svc-auth' }
 */
export type Scope =
  | { kind: 'shared' }
  | { kind: 'service'; name: string }

/**
 * Where and how the variable was last modified
 */
export interface Provenance {
  /** Origin of the mutation */
  source: ProvenanceSource
  /** User or system that made the change */
  actor: string
  /** ISO 8601 timestamp */
  timestamp: string
  /** Operation that was performed */
  operation: ProvenanceOperation
}

export type ProvenanceSource = 'cli' | 'mcp' | 'ci' | 'runtime' | 'migration' | 'import'
export type ProvenanceOperation = 'set' | 'delete' | 'move' | 'rotate' | 'rollback' | 'clone' | 'import'

/**
 * Variable lifecycle state
 *
 * - active: in use, no issues
 * - deprecated: marked for removal (still works, but flagged)
 * - orphan: belongs to a service that no longer exists
 */
export type Lifecycle = 'active' | 'deprecated' | 'orphan'

/**
 * Resolved variable with all domain context.
 *
 * This is the "rich" representation used in the domain layer.
 * The existing EnvVar type continues to be used for storage/client.
 */
export interface ResolvedVariable {
  key: string
  value: string
  environment: string
  scope: Scope
  sensitive: boolean
  lifecycle: Lifecycle
  provenance?: Provenance
  version?: number
  tags?: string[]
}

// ============================================================================
// Scope Helpers
// ============================================================================

/**
 * Create a shared scope
 */
export function sharedScope(): Scope {
  return { kind: 'shared' }
}

/**
 * Create a service scope
 */
export function serviceScope(name: string): Scope {
  return { kind: 'service', name }
}

/**
 * Parse a scope string into a Scope object.
 *
 * Accepted forms:
 * - 'shared' or '__shared__' → { kind: 'shared' }
 * - 'service:svc-auth' → { kind: 'service', name: 'svc-auth' }
 * - 'svc-auth' → { kind: 'service', name: 'svc-auth' }
 */
export function parseScope(raw: string | undefined): Scope | null {
  if (!raw) return null

  const trimmed = raw.trim()
  if (!trimmed) return null

  const lowered = trimmed.toLowerCase()
  if (lowered === 'shared' || lowered === '__shared__') {
    return sharedScope()
  }

  if (lowered.startsWith('service:')) {
    const name = trimmed.slice(8).trim()
    if (!name) return null
    return serviceScope(name)
  }

  // Bare name (no colon prefix) → service
  if (!trimmed.includes(':')) {
    return serviceScope(trimmed)
  }

  return null
}

/**
 * Convert a Scope to the service string used by VaulterClient.
 *
 * - shared → '__shared__'
 * - service:name → name
 */
export function scopeToService(scope: Scope): string {
  if (scope.kind === 'shared') return '__shared__'
  return scope.name
}

/**
 * Convert a service string to a Scope.
 *
 * - '__shared__' or undefined → { kind: 'shared' }
 * - anything else → { kind: 'service', name }
 */
export function serviceToScope(service: string | undefined): Scope {
  if (!service || service === '__shared__') return sharedScope()
  return serviceScope(service)
}

/**
 * Format scope for display
 */
export function formatScope(scope: Scope): string {
  if (scope.kind === 'shared') return 'shared'
  return scope.name
}

/**
 * Check scope equality
 */
export function scopesEqual(a: Scope, b: Scope): boolean {
  if (a.kind !== b.kind) return false
  if (a.kind === 'shared') return true
  return (a as { kind: 'service'; name: string }).name === (b as { kind: 'service'; name: string }).name
}

// ============================================================================
// Plan Types
// ============================================================================

/**
 * A plan is the diff between local state and backend state.
 * Generated by `vaulter plan`, executed by `vaulter apply`.
 */
export interface Plan {
  /** Deterministic ID: project-env-timestamp */
  id: string
  project: string
  environment: string
  /** Scope filter (null = all scopes) */
  scope: Scope | null
  /** Plan lifecycle */
  status: PlanStatus
  /** When the plan was computed */
  generatedAt: string
  /** When the plan was applied (if status === 'applied') */
  appliedAt?: string

  /** Individual changes in this plan */
  changes: PlanChange[]
  /** Aggregated counts */
  summary: PlanSummary
  /** Governance and health scorecard */
  scorecard: Scorecard
}

export type PlanStatus = 'planned' | 'applied' | 'stale' | 'failed'

/**
 * A single change in a plan
 */
export interface PlanChange {
  key: string
  scope: Scope
  action: PlanAction
  sensitive: boolean
  /** Current local value (masked in persisted artifacts) */
  localValue?: string
  /** Current backend value (masked in persisted artifacts) */
  remoteValue?: string
}

export type PlanAction = 'add' | 'update' | 'delete'

/**
 * Aggregated plan summary counts
 */
export interface PlanSummary {
  toAdd: number
  toUpdate: number
  toDelete: number
  unchanged: number
  conflicts: number
}

// ============================================================================
// Scorecard Types
// ============================================================================

/**
 * Scorecard — actionable status summary for an environment.
 * Computed during plan and available in status.
 */
export interface Scorecard {
  /** Total variable count */
  totalVars: number
  /** Count of sensitive=true vars */
  secrets: number
  /** Count of sensitive=false vars */
  configs: number
  /** Per-service status */
  services: ServiceStatus[]
  /** Local vs backend drift */
  drift: DriftStatus
  /** Scope policy check results */
  policy: PolicyStatus
  /** Required vars check */
  required: RequiredStatus
  /** Rotation age check */
  rotation: RotationStatus
  /** Overall health */
  health: ScorecardHealth
  /** Actionable issues */
  issues: ScorecardIssue[]
}

export type ScorecardHealth = 'ok' | 'warning' | 'critical'

/**
 * A single actionable issue in the scorecard
 */
export interface ScorecardIssue {
  severity: 'info' | 'warning' | 'error'
  category: ScorecardCategory
  message: string
  key?: string
  suggestion?: string
}

export type ScorecardCategory = 'drift' | 'policy' | 'required' | 'rotation' | 'orphan' | 'lifecycle'

/**
 * Per-service status in the scorecard
 */
export interface ServiceStatus {
  name: string
  lifecycle: Lifecycle
  varCount: number
  sharedCount: number
  serviceCount: number
}

/**
 * Drift between local state and backend state
 */
export interface DriftStatus {
  /** Vars that exist locally but not in backend */
  localOnly: number
  /** Vars that exist in backend but not locally */
  remoteOnly: number
  /** Vars with different values */
  conflicts: number
  /** True if everything matches */
  synced: boolean
}

/**
 * Scope policy check results
 */
export interface PolicyStatus {
  /** Non-blocking warnings */
  warnings: number
  /** Blocking violations (strict mode) */
  violations: number
  /** Individual issues */
  issues: PolicyIssue[]
}

export interface PolicyIssue {
  key: string
  rule: string
  message: string
}

/**
 * Required vars check
 */
export interface RequiredStatus {
  /** Number of required vars that are present */
  satisfied: number
  /** Required vars that are missing */
  missing: string[]
}

/**
 * Rotation age check
 */
export interface RotationStatus {
  /** Number of vars overdue for rotation */
  overdue: number
  /** Details per overdue key */
  keys: RotationOverdueKey[]
}

export interface RotationOverdueKey {
  key: string
  lastRotated: string
  maxAgeDays: number
}

// ============================================================================
// Write/Move Result Types
// ============================================================================

/**
 * Result of writing a variable to local state
 */
export interface WriteResult {
  success: boolean
  variable: ResolvedVariable
  /** Non-blocking warnings (scope policy, encoding, etc.) */
  warnings: string[]
  /** Whether the write was blocked by strict policy */
  blocked: boolean
  blockReason?: string
}

/**
 * Result of moving a variable between scopes
 */
export interface MoveResult {
  success: boolean
  key: string
  from: Scope
  to: Scope
  warnings: string[]
}

// ============================================================================
// Governance Types
// ============================================================================

/**
 * Combined governance check result
 */
export interface GovernanceResult {
  policy: PolicyStatus
  required: RequiredStatus
  rotation: RotationStatus
  guardrails: ValueGuardrailStatus
  /** Whether any strict violations block the operation */
  blocked: boolean
  /** All warnings from all checks */
  warnings: string[]
  /** Actionable suggestions for fixing issues */
  suggestions: string[]
}

// ============================================================================
// Value Guardrail Types
// ============================================================================

export type ValueGuardrailCode =
  | 'placeholder'
  | 'localhost-in-prd'
  | 'url-no-scheme'
  | 'empty-value'
  | 'whitespace-value'

export interface ValueGuardrailIssue {
  key: string
  code: ValueGuardrailCode
  severity: 'warning' | 'error'
  message: string
  suggestion?: string
}

export interface ValueGuardrailStatus {
  issues: ValueGuardrailIssue[]
  /** true if any issue has severity: error (empty/whitespace) */
  blocked: boolean
}

export function emptyGuardrailStatus(): ValueGuardrailStatus {
  return { issues: [], blocked: false }
}

// ============================================================================
// Inventory Types
// ============================================================================

/**
 * Full cross-environment variable inventory
 */
export interface Inventory {
  services: InventoryService[]
  orphanedVars: OrphanedVariable[]
  /** Vars that exist in some environments but not others */
  missingVars: MissingVariable[]
  /** Which vars exist in which environments */
  coverageMatrix: CoverageEntry[]
}

export interface InventoryService {
  name: string
  lifecycle: Lifecycle
  environments: string[]
  varCount: number
}

/**
 * A variable that belongs to a service that no longer exists
 */
export interface OrphanedVariable {
  key: string
  environment: string
  scope: Scope
  reason: OrphanReason
  suggestion: 'delete' | 'move' | 'investigate'
}

export type OrphanReason = 'service_removed' | 'unused' | 'unknown_service'

/**
 * A variable that exists in some environments but not others
 */
export interface MissingVariable {
  key: string
  scope: Scope
  presentIn: string[]
  missingFrom: string[]
}

/**
 * Coverage entry: tracks a variable across environments
 */
export interface CoverageEntry {
  key: string
  scope: Scope
  environments: Record<string, boolean>
}

// ============================================================================
// Provenance Log Entry (for provenance.jsonl)
// ============================================================================

/**
 * A single entry in the provenance log file.
 * Serialized as one JSON line per entry in provenance.jsonl.
 */
export interface ProvenanceLogEntry {
  key: string
  scope: string        // 'shared' | 'service:<name>'
  op: ProvenanceOperation
  actor: string
  source: ProvenanceSource
  ts: string           // ISO 8601
  environment?: string
  sensitive?: boolean
  /** Previous scope for move operations */
  fromScope?: string
}

/**
 * Serialize a scope to the compact string format used in provenance.jsonl
 */
export function serializeScope(scope: Scope): string {
  if (scope.kind === 'shared') return 'shared'
  return `service:${scope.name}`
}

/**
 * Deserialize a scope string from provenance.jsonl
 */
export function deserializeScope(raw: string): Scope {
  if (raw === 'shared') return sharedScope()
  if (raw.startsWith('service:')) {
    return serviceScope(raw.slice(8))
  }
  // Fallback: treat as service name
  return serviceScope(raw)
}

// ============================================================================
// Empty Factories
// ============================================================================

/**
 * Create an empty scorecard
 */
export function emptyScorecard(): Scorecard {
  return {
    totalVars: 0,
    secrets: 0,
    configs: 0,
    services: [],
    drift: { localOnly: 0, remoteOnly: 0, conflicts: 0, synced: true },
    policy: { warnings: 0, violations: 0, issues: [] },
    required: { satisfied: 0, missing: [] },
    rotation: { overdue: 0, keys: [] },
    health: 'ok',
    issues: []
  }
}

/**
 * Create an empty plan summary
 */
export function emptyPlanSummary(): PlanSummary {
  return { toAdd: 0, toUpdate: 0, toDelete: 0, unchanged: 0, conflicts: 0 }
}

/**
 * Create an empty governance result
 */
export function emptyGovernanceResult(): GovernanceResult {
  return {
    policy: { warnings: 0, violations: 0, issues: [] },
    required: { satisfied: 0, missing: [] },
    rotation: { overdue: 0, keys: [] },
    guardrails: emptyGuardrailStatus(),
    blocked: false,
    warnings: [],
    suggestions: []
  }
}
