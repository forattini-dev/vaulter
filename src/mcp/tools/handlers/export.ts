/**
 * vaulter_export handler â€” consolidated export in multiple formats
 *
 * Formats: k8s-secret, k8s-configmap, helm, terraform, env, shell, json
 */

import fs from 'node:fs'
import type { VaulterClient } from '../../../client.js'
import type { HandlerContext } from '../index.js'
import type { ToolResponse } from '../config.js'
import { textResponse, sanitizeK8sName, base64Encode } from '../config.js'
import { findConfigDir, isSplitMode, getSecretsFilePath, getConfigsFilePath } from '../../../lib/config-loader.js'
import { parseEnvFile } from '../../../lib/env-parser.js'
import type { Environment } from '../../../types.js'

export async function handleExport(
  ctx: HandlerContext,
  client: VaulterClient,
  args: Record<string, unknown>
): Promise<ToolResponse> {
  const format = (args.format as string) || 'shell'

  switch (format) {
    case 'k8s-secret':
      return handleK8sSecret(ctx, client, args)
    case 'k8s-configmap':
      return handleK8sConfigMap(ctx, client, args)
    case 'helm':
      return handleHelm(ctx, client)
    case 'terraform':
      return handleTerraform(ctx, client, args)
    default:
      return handleGenericExport(ctx, client, format)
  }
}

async function handleK8sSecret(
  ctx: HandlerContext,
  client: VaulterClient,
  args: Record<string, unknown>
): Promise<ToolResponse> {
  const namespace = (args.namespace as string) || `${ctx.project}-${ctx.environment}`
  const name = (args.name as string) || (ctx.service ? `${ctx.service}-secrets` : `${ctx.project}-secrets`)

  let secretVars: Record<string, string> = {}

  if (ctx.config && isSplitMode(ctx.config)) {
    const configDir = findConfigDir()
    if (configDir) {
      const secretsPath = getSecretsFilePath(ctx.config, configDir, ctx.environment)
      if (fs.existsSync(secretsPath)) {
        secretVars = parseEnvFile(secretsPath)
      } else {
        return textResponse(`Error: Secrets file not found: ${secretsPath}`)
      }
    } else {
      return textResponse('Error: No .vaulter directory found')
    }
  } else {
    const allVars = await client.list({ project: ctx.project, environment: ctx.environment as Environment, service: ctx.service })
    for (const v of allVars.filter(v => v.sensitive === true)) {
      secretVars[v.key] = v.value
    }
  }

  if (Object.keys(secretVars).length === 0) {
    return textResponse('Warning: No secret variables found (none marked as sensitive)')
  }

  const lines = [
    '# Generated by vaulter MCP',
    'apiVersion: v1',
    'kind: Secret',
    'metadata:',
    `  name: ${sanitizeK8sName(name)}`,
    `  namespace: ${sanitizeK8sName(namespace)}`,
    '  labels:',
    `    app.kubernetes.io/managed-by: vaulter`,
    `    app.kubernetes.io/environment: ${ctx.environment}`,
    'type: Opaque',
    'data:'
  ]

  for (const [key, value] of Object.entries(secretVars)) {
    lines.push(`  ${key}: ${base64Encode(value)}`)
  }

  return textResponse(lines.join('\n'))
}

async function handleK8sConfigMap(
  ctx: HandlerContext,
  client: VaulterClient,
  args: Record<string, unknown>
): Promise<ToolResponse> {
  const namespace = (args.namespace as string) || `${ctx.project}-${ctx.environment}`
  const name = (args.name as string) || (ctx.service ? `${ctx.service}-config` : `${ctx.project}-config`)

  let configVars: Record<string, string> = {}

  if (ctx.config && isSplitMode(ctx.config)) {
    const configDir = findConfigDir()
    if (configDir) {
      const configsPath = getConfigsFilePath(ctx.config, configDir, ctx.environment)
      if (fs.existsSync(configsPath)) {
        configVars = parseEnvFile(configsPath)
      } else {
        return textResponse(`Error: Configs file not found: ${configsPath}`)
      }
    } else {
      return textResponse('Error: No .vaulter directory found')
    }
  } else {
    const allVars = await client.list({ project: ctx.project, environment: ctx.environment as Environment, service: ctx.service })
    for (const v of allVars.filter(v => v.sensitive !== true)) {
      configVars[v.key] = v.value
    }
  }

  if (Object.keys(configVars).length === 0) {
    return textResponse('Warning: No config variables found (all are marked as sensitive)')
  }

  const lines = [
    '# Generated by vaulter MCP',
    'apiVersion: v1',
    'kind: ConfigMap',
    'metadata:',
    `  name: ${sanitizeK8sName(name)}`,
    `  namespace: ${sanitizeK8sName(namespace)}`,
    '  labels:',
    `    app.kubernetes.io/managed-by: vaulter`,
    `    app.kubernetes.io/environment: ${ctx.environment}`,
    'data:'
  ]

  for (const [key, value] of Object.entries(configVars)) {
    const needsQuote = value.includes(':') || value.includes('#') || value.includes('\n')
    if (needsQuote) {
      lines.push(`  ${key}: "${value.replace(/"/g, '\\"').replace(/\n/g, '\\n')}"`)
    } else {
      lines.push(`  ${key}: ${value}`)
    }
  }

  return textResponse(lines.join('\n'))
}

async function handleHelm(ctx: HandlerContext, client: VaulterClient): Promise<ToolResponse> {
  const allVars = await client.list({ project: ctx.project, environment: ctx.environment as Environment, service: ctx.service })

  if (allVars.length === 0) {
    return textResponse('Warning: No variables found')
  }

  const plain: Record<string, string> = {}
  const secrets: Record<string, string> = {}

  for (const v of allVars) {
    if (v.sensitive) {
      secrets[v.key] = v.value
    } else {
      plain[v.key] = v.value
    }
  }

  const lines: string[] = [
    '# Generated by vaulter MCP',
    `# Project: ${ctx.project}`,
    `# Environment: ${ctx.environment}`,
    ctx.service ? `# Service: ${ctx.service}` : null,
    '',
    'env:'
  ].filter(Boolean) as string[]

  for (const [key, value] of Object.entries(plain)) {
    lines.push(`  ${key}: ${formatYamlValue(value)}`)
  }

  lines.push('')
  lines.push('secrets:')

  for (const [key, value] of Object.entries(secrets)) {
    lines.push(`  ${key}: ${formatYamlValue(value)}`)
  }

  return textResponse(lines.join('\n'))
}

async function handleTerraform(
  ctx: HandlerContext,
  client: VaulterClient,
  args: Record<string, unknown>
): Promise<ToolResponse> {
  const tfFormat = (args.tfFormat as string) || 'tfvars'
  const vars = await client.export(ctx.project, ctx.environment as Environment, ctx.service)

  if (Object.keys(vars).length === 0) {
    return textResponse('Warning: No variables found')
  }

  if (tfFormat === 'json') {
    const tfVars: Record<string, string> = {}
    for (const [key, value] of Object.entries(vars)) {
      tfVars[key.toLowerCase()] = value
    }
    return textResponse(JSON.stringify({ ...tfVars, env_vars: vars }, null, 2))
  }

  const lines: string[] = [
    '# Generated by vaulter MCP',
    `# Project: ${ctx.project}`,
    `# Environment: ${ctx.environment}`,
    ''
  ]

  for (const [key, value] of Object.entries(vars)) {
    lines.push(`${key.toLowerCase()} = ${formatTfValue(value)}`)
  }

  lines.push('')
  lines.push('env_vars = {')
  for (const [key, value] of Object.entries(vars)) {
    lines.push(`  "${key}" = ${formatTfValue(value)}`)
  }
  lines.push('}')

  return textResponse(lines.join('\n'))
}

async function handleGenericExport(
  ctx: HandlerContext,
  client: VaulterClient,
  format: string
): Promise<ToolResponse> {
  const includeShared = true
  const vars = await client.export(ctx.project, ctx.environment as Environment, ctx.service, { includeShared })

  let output: string
  switch (format) {
    case 'json':
      output = JSON.stringify(vars, null, 2)
      break
    case 'env':
      output = Object.entries(vars).map(([k, v]) => `${k}=${v}`).join('\n')
      break
    case 'shell':
    default:
      output = Object.entries(vars).map(([k, v]) => `export ${k}="${v.replace(/"/g, '\\"')}"`).join('\n')
  }

  return textResponse(output || '# No variables found')
}

function formatYamlValue(value: string): string {
  const needsQuote =
    value === '' || value === 'true' || value === 'false' || value === 'null' ||
    value === 'yes' || value === 'no' || !isNaN(Number(value)) ||
    value.includes(':') || value.includes('#') || value.includes('\n') ||
    value.includes('"') || value.includes("'") ||
    value.startsWith(' ') || value.endsWith(' ') ||
    value.startsWith('{') || value.startsWith('[')

  if (needsQuote) {
    return `"${value.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n')}"`
  }
  return value
}

function formatTfValue(value: string): string {
  return `"${value.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\t/g, '\\t')}"`
}
