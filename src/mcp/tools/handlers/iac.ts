/**
 * Vaulter MCP Tools - IaC Handlers
 *
 * Handlers for helm_values, tf_vars operations
 */

import { VaulterClient } from '../../../client.js'
import type { VaulterConfig, Environment } from '../../../types.js'
import type { ToolResponse } from '../config.js'

/**
 * Format value for YAML
 */
function formatYamlValue(value: string): string {
  const needsQuote =
    value === '' ||
    value === 'true' ||
    value === 'false' ||
    value === 'null' ||
    value === 'yes' ||
    value === 'no' ||
    !isNaN(Number(value)) ||
    value.includes(':') ||
    value.includes('#') ||
    value.includes('\n') ||
    value.includes('"') ||
    value.includes("'") ||
    value.startsWith(' ') ||
    value.endsWith(' ') ||
    value.startsWith('{') ||
    value.startsWith('[')

  if (needsQuote) {
    return `"${value.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n')}"`
  }

  return value
}

/**
 * Format value for Terraform HCL
 */
function formatTfValue(value: string): string {
  const escaped = value
    .replace(/\\/g, '\\\\')
    .replace(/"/g, '\\"')
    .replace(/\n/g, '\\n')
    .replace(/\r/g, '\\r')
    .replace(/\t/g, '\\t')

  return `"${escaped}"`
}

/**
 * Handle Helm values generation
 */
export async function handleHelmValuesCall(
  client: VaulterClient,
  _config: VaulterConfig | null,
  project: string,
  environment: Environment,
  service: string | undefined,
  _args: Record<string, unknown>
): Promise<ToolResponse> {
  // Use list() to get sensitive flag for each var
  const allVars = await client.list({ project, environment, service })

  if (allVars.length === 0) {
    return { content: [{ type: 'text', text: 'Warning: No variables found' }] }
  }

  // Split by sensitive flag (no pattern inference)
  const plain: Record<string, string> = {}
  const secrets: Record<string, string> = {}

  for (const v of allVars) {
    if (v.sensitive) {
      secrets[v.key] = v.value
    } else {
      plain[v.key] = v.value
    }
  }

  // Generate Helm values YAML
  const lines: string[] = [
    '# Generated by vaulter MCP',
    `# Project: ${project}`,
    `# Environment: ${environment}`,
    service ? `# Service: ${service}` : null,
    '# DO NOT EDIT - changes will be overwritten',
    '',
    '# Environment variables (sensitive=false)',
    'env:'
  ].filter(Boolean) as string[]

  for (const [key, value] of Object.entries(plain)) {
    lines.push(`  ${key}: ${formatYamlValue(value)}`)
  }

  lines.push('')
  lines.push('# Secrets (sensitive=true)')
  lines.push('secrets:')

  for (const [key, value] of Object.entries(secrets)) {
    lines.push(`  ${key}: ${formatYamlValue(value)}`)
  }

  return { content: [{ type: 'text', text: lines.join('\n') }] }
}

/**
 * Handle Terraform vars generation
 */
export async function handleTfVarsCall(
  client: VaulterClient,
  _config: VaulterConfig | null,
  project: string,
  environment: Environment,
  service: string | undefined,
  args: Record<string, unknown>
): Promise<ToolResponse> {
  const format = (args.format as string) || 'tfvars'
  const vars = await client.export(project, environment, service)

  if (Object.keys(vars).length === 0) {
    return { content: [{ type: 'text', text: 'Warning: No variables found' }] }
  }

  if (format === 'json') {
    // Terraform JSON format
    const tfVars: Record<string, string> = {}
    for (const [key, value] of Object.entries(vars)) {
      const tfKey = key.toLowerCase()
      tfVars[tfKey] = value
    }

    const output = {
      ...tfVars,
      env_vars: vars
    }

    return { content: [{ type: 'text', text: JSON.stringify(output, null, 2) }] }
  }

  // Generate .tfvars content
  const lines: string[] = [
    '# Generated by vaulter MCP',
    `# Project: ${project}`,
    `# Environment: ${environment}`,
    service ? `# Service: ${service}` : null,
    '# DO NOT EDIT - changes will be overwritten',
    ''
  ].filter(Boolean) as string[]

  // Individual variables (lowercase names)
  for (const [key, value] of Object.entries(vars)) {
    const tfKey = key.toLowerCase()
    lines.push(`${tfKey} = ${formatTfValue(value)}`)
  }

  // All env vars as a map
  lines.push('')
  lines.push('# All environment variables as a map')
  lines.push('env_vars = {')

  for (const [key, value] of Object.entries(vars)) {
    lines.push(`  "${key}" = ${formatTfValue(value)}`)
  }

  lines.push('}')

  return { content: [{ type: 'text', text: lines.join('\n') }] }
}
