/**
 * Vaulter MCP Tools - Kubernetes Handlers
 *
 * Handlers for k8s_secret, k8s_configmap operations
 */

import fs from 'node:fs'
import { VaulterClient } from '../../../client.js'
import {
  findConfigDir,
  isSplitMode,
  getSecretsFilePath,
  getConfigsFilePath
} from '../../../lib/config-loader.js'
import { parseEnvFile } from '../../../lib/env-parser.js'
import { getSecretPatterns, splitVarsBySecret } from '../../../lib/secret-patterns.js'
import type { VaulterConfig, Environment } from '../../../types.js'
import type { ToolResponse } from '../config.js'
import { sanitizeK8sName, base64Encode } from '../config.js'

export async function handleK8sSecretCall(
  client: VaulterClient,
  config: VaulterConfig | null,
  project: string,
  environment: Environment,
  service: string | undefined,
  args: Record<string, unknown>
): Promise<ToolResponse> {
  const namespace = (args.namespace as string) || `${project}-${environment}`
  const name = (args.name as string) || (service ? `${service}-secrets` : `${project}-secrets`)

  let vars: Record<string, string>

  // Check for split mode - read from local file
  if (config && isSplitMode(config)) {
    const configDir = findConfigDir()
    if (configDir) {
      const secretsPath = getSecretsFilePath(config, configDir, environment)
      if (fs.existsSync(secretsPath)) {
        vars = parseEnvFile(secretsPath)
      } else {
        return { content: [{ type: 'text', text: `Error: Secrets file not found: ${secretsPath}` }] }
      }
    } else {
      return { content: [{ type: 'text', text: 'Error: No .vaulter directory found' }] }
    }
  } else {
    // Fetch from backend
    vars = await client.export(project, environment, service)
  }

  if (Object.keys(vars).length === 0) {
    return { content: [{ type: 'text', text: 'Warning: No variables found' }] }
  }

  // Generate YAML
  const lines = [
    '# Generated by vaulter MCP',
    '# kubectl apply -f - <<< "$(vaulter_k8s_secret)"',
    'apiVersion: v1',
    'kind: Secret',
    'metadata:',
    `  name: ${sanitizeK8sName(name)}`,
    `  namespace: ${sanitizeK8sName(namespace)}`,
    '  labels:',
    `    app.kubernetes.io/managed-by: vaulter`,
    `    app.kubernetes.io/environment: ${environment}`,
    'type: Opaque',
    'data:'
  ]

  for (const [key, value] of Object.entries(vars)) {
    lines.push(`  ${key}: ${base64Encode(value)}`)
  }

  return { content: [{ type: 'text', text: lines.join('\n') }] }
}

export async function handleK8sConfigMapCall(
  client: VaulterClient,
  config: VaulterConfig | null,
  project: string,
  environment: Environment,
  service: string | undefined,
  args: Record<string, unknown>
): Promise<ToolResponse> {
  const namespace = (args.namespace as string) || `${project}-${environment}`
  const name = (args.name as string) || (service ? `${service}-config` : `${project}-config`)

  let vars: Record<string, string>

  // Check for split mode - read from local file
  if (config && isSplitMode(config)) {
    const configDir = findConfigDir()
    if (configDir) {
      const configsPath = getConfigsFilePath(config, configDir, environment)
      if (fs.existsSync(configsPath)) {
        vars = parseEnvFile(configsPath)
      } else {
        return { content: [{ type: 'text', text: `Error: Configs file not found: ${configsPath}` }] }
      }
    } else {
      return { content: [{ type: 'text', text: 'Error: No .vaulter directory found' }] }
    }
  } else {
    // Fetch from backend and filter out secrets
    const allVars = await client.export(project, environment, service)
    const patterns = getSecretPatterns(config)
    const { plain } = splitVarsBySecret(allVars, patterns)
    vars = plain
  }

  if (Object.keys(vars).length === 0) {
    return { content: [{ type: 'text', text: 'Warning: No config variables found (all matched secret patterns)' }] }
  }

  // Generate YAML
  const lines = [
    '# Generated by vaulter MCP',
    '# kubectl apply -f - <<< "$(vaulter_k8s_configmap)"',
    'apiVersion: v1',
    'kind: ConfigMap',
    'metadata:',
    `  name: ${sanitizeK8sName(name)}`,
    `  namespace: ${sanitizeK8sName(namespace)}`,
    '  labels:',
    `    app.kubernetes.io/managed-by: vaulter`,
    `    app.kubernetes.io/environment: ${environment}`,
    'data:'
  ]

  for (const [key, value] of Object.entries(vars)) {
    const needsQuote = value.includes(':') || value.includes('#') || value.includes('\n')
    if (needsQuote) {
      lines.push(`  ${key}: "${value.replace(/"/g, '\\"').replace(/\n/g, '\\n')}"`)
    } else {
      lines.push(`  ${key}: ${value}`)
    }
  }

  return { content: [{ type: 'text', text: lines.join('\n') }] }
}
